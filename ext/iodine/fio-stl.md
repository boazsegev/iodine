# facil.io - C Real-Time Web Application Framework

[facil.io](http://facil.io) focuses on providing solutions for real-time web applications. facil.io includes:

* A fast HTTP/1.1, Websocket and SSE application server.
* A zero-dependency Pub/Sub cluster-enabled message bus API.
* Performant JSON parsing and formatting for easy network communication.
* Dynamic types designed with web applications in mind (Strings, Hashes, Arrays etc').
* Support for custom network protocols for both server and client connections.
* An easy solution to [the C10K problem](http://www.kegel.com/c10k.html).
* Optional connectivity with Redis.

This header library is the **C Server Toolbox Library** (C STL) that makes it all happen.

## The C STL Design Goal

> The [facil.io](http://facil.io) C STL aims to provide C developers with easy-to-use tools to write memory safe and performant programs.

## OS Support

The library in written and tested on POSIX systems. Windows support was added afterwards, leaving the library with a POSIX oriented design.

Please note I cannot continually test the windows support as I avoid the OS... hence, Windows OS support should be considered unstable.

## Server Toolbox Library (STL) Overview

At the core of the [facil.io library](https://facil.io) is its powerful Server Toolbox Library for C (and C++).

The Server Toolbox Library is a "swiss-army-knife" library, that uses MACROS to generate code for different common types, such as Hash Maps, Arrays, Linked Lists, Binary-Safe Strings, etc'.

The [testable](#testing-the-library-fio_test_cstl) header library includes a Server Toolbox Library for the following common types:

* [Binary Safe Dynamic Strings](#dynamic-strings) - defined by `FIO_STR` / `FIO_STR_NAME` / `FIO_STR_SMALL`

* [Dynamic Arrays](#dynamic-arrays) - defined by `FIO_ARRAY_NAME`

* [Hash Maps / Sets](#hash-tables-and-maps) - defined by `FIO_MAP_NAME`

* [Reference counting / Type wrapper](#reference-counting-and-type-wrapping) - defined by `FIO_REF_NAME`

* [Soft / Dynamic Types (FIOBJ)](#fiobj-soft-dynamic-types) - defined by `FIO_FIOBJ`


In addition, the core Server Toolbox Library (STL) includes helpers for common tasks, such as:

* [Atomic operations](#atomic-operations)

* [Pointer Arithmetics](#pointer-arithmetics)

* [Fast String / Number conversion](#string-number-conversion) - defined by `FIO_ATOL`

* [Logging and Assertion (without heap allocation)](#logging-and-assertions) - defined by `FIO_LOG`

* [Binary Safe String Helpers](#binary-safe-core-string-helpers) - defined by `FIO_STR`

* [Time Helpers](#time-helpers) - defined by `FIO_TIME`

* [File Utility Helpers](#file-utility-helpers) - defined by `FIO_FILES`

* [Command Line Interface helpers](#cli-command-line-interface) - defined by `FIO_CLI`

* [Task Queues and Timers](#task-queue) - defined by `FIO_QUEUE`

* [Local Memory Allocation](#local-memory-allocation) - defined by `FIO_MEMORY` / `FIO_MALLOC`

* [An Evented IO Reactor](#io-reactor---an-evented-single-threaded-io-reactor) - defined by `FIO_IO`

* And much more...

-------------------------------------------------------------------------------

## How to Use

Simply copy the `fio-stl` folder to your project (or the combined `fio-stl.h` file).

Then include the file in your project to use the facil.io CSTL library.

The library can be included more than once and produce different results depending on the MACROS predefined before each inclusion.

#### `FIO_INCLUDE_FILE`

The facil.io C STL can be used as either a single header library (`fio-stl.h`) or a multi-header library (`fio-stl/include.h`).

The `FIO_INCLUDE_FILE` macro will remember which approach was first used and will use the same approach for subsequent inclusions.

-------------------------------------------------------------------------------

## Compilation Modes

The Server Toolbox Library types and functions could be compiled as either static or extern ("global"), either limiting their scope to a single C file (compilation unit) or exposing them throughout the program.

### Static Functions by Default

By default, facil.io will generate static functions where possible.

To change this behavior, `FIO_EXTERN` and `FIO_EXTERN_COMPLETE` could be used to generate externally visible code.

#### `FIO_EXTERN`

If defined, the the Server Toolbox Library will generate non-static code.

If `FIO_EXTERN` is defined alone, only function declarations and inline functions will be generated.

If `FIO_EXTERN_COMPLETE` is defined, the function definition (the implementation code) will also be generated.

**Note**: the `FIO_EXTERN` will be **automatically undefined** each time the Server Toolbox Library header is included, **unless** the `FIO_EXTERN` is defined with a **numerical** value other than `1` (a compiler default value in some cases), in which case the `FIO_EXTERN` definition will remain in force until manually removed.

For example, in the header (i.e., `mymem.h`), use:

```c
#define FIO_EXTERN
#define FIO_MALLOC
#include FIO_INCLUDE_FILE
/* FIO_EXTERN automatically undefined in this case */
```

Later, in the implementation file, use:

```c
#define FIO_EXTERN_COMPLETE 2
#include "mymem.h"
#undef FIO_EXTERN_COMPLETE
/* FIO_EXTERN_COMPLETE needed to be manually undefined in this case */
```

#### `FIO_EXTERN_COMPLETE`

When defined, this macro will force full code generation.

**Note**: the `FIO_EXTERN_COMPLETE` will be **automatically undefined** each time the Server Toolbox Library header is included, **unless** the `FIO_EXTERN_COMPLETE` is defined with a **numerical** value other than `1` (a compiler default value in some cases), in which case the `FIO_EXTERN_COMPLETE` definition will remain in force until manually removed.

-------------------------------------------------------------------------------

## Thread Safety

Some modules require thread safety locks, such as the timer module, queue module, memory allocator and socket polling. The facil.io library will default to it's own spin-lock based implementation unless `FIO_USE_THREAD_MUTEX` or `FIO_USE_THREAD_MUTEX_TMP` are defined.

#### `FIO_USE_THREAD_MUTEX` and `FIO_USE_THREAD_MUTEX_TMP`

This default choice can be changed so facil.io uses the OS's native `mutex` type (`pthread_mutex_t` on POSIX systems) by setting the `FIO_USE_THREAD_MUTEX` or `FIO_USE_THREAD_MUTEX_TMP` to true (`1`).

The `FIO_USE_THREAD_MUTEX_TMP` macro will alter the default behavior for only a single `include` statement.

The `FIO_USE_THREAD_MUTEX` macro will alter the default behavior for all future `include` statements.

-------------------------------------------------------------------------------

## Unaligned Memory Access

By default facil.io attempts to automatically detect systems that allow for unaligned memory access and use optimizations that require this feature. This can be changed by setting `FIO_UNALIGNED_ACCESS` to `0`.

#### `FIO_UNALIGNED_ACCESS`

If set to true (`1`) this MACRO will attempt to detect support of unaligned memory access and if support is detected the `FIO_UNALIGNED_MEMORY_ACCESS_ENABLED` will be set to true (`1`).

#### `FIO_UNALIGNED_MEMORY_ACCESS_ENABLED`

If set to true (`1`) this MACRO will indicate that the facil.io library should allow for unaligned memory access, skipping memory alignment requirements in some cases (such as the in the `fio_buf2uXX` function implementation).

-------------------------------------------------------------------------------

## Multi-Module Inclusion Helpers

#### `FIO_CORE`

When `FIO_CORE` is defined, all core modules are included, such as `FIO_STR`, `FIO_ATOL`, and non-typed helpers.

#### `FIO_BASIC`

When `FIO_BASIC` is defined, the `FIOBJ` types, multi threading, and CLI modules are included in addition to the core modules.

#### `FIO_CRYPTO`

When `FIO_CRYPTO` is defined, all hash and cryptographic modules are included.

**Note**: do NOT use these cryptographic unless you have no other choice. Always prefer tested cryptographic libraries such as OpenSSL.

#### `FIO_EVERYTHING`

Adds all the code facil.io C STL has to offer.

Custom types (templates) can't be created without specific instruction, but all functionality that can be included is included.

Note, `FIO_EVERYTHING` functions will always be `static` unless `FIO_EXTERN` was defined for specific functionality or `FIO_EXTERN` was defined in a persistent way (with a numerical value of `2` or greater).


-------------------------------------------------------------------------------

## Testing the Library (`FIO_TEST_ALL`)

To test the library, define the `FIO_TEST_ALL` macro and include the header. A testing function called `fio_test_dynamic_types` will be defined. Call that function in your code to test the library.

#### `FIO_TEST_ALL`

Defined the `fio_test_dynamic_types` and enables as many testing features as possible, such as the `FIO_LEAK_COUNTER`.

-------------------------------------------------------------------------------

## Version and Common Helper Macros

The facil.io C STL (Server Toolbox Library) offers a number of common helper macros that are also used internally. These are automatically included once the `fio-stl.h` is included.

### Version Macros

The facil.io C STL library follows [semantic versioning](https://semver.org) and supports macros that will help detect and validate it's version.

#### `FIO_VERSION_MAJOR`

Translates to the STL's major version number.

MAJOR version upgrades require a code review and possibly significant changes. Even functions with the same name might change their behavior.

#### `FIO_VERSION_MINOR`

Translates to the STL's minor version number.

Please review your code before adopting a MINOR version upgrade.

#### `FIO_VERSION_PATCH`

Translates to the STL's patch version number.

PATCH versions should be adopted as soon as possible (they contain bug fixes).

#### `FIO_VERSION_BUILD`

Translates to the STL's build version **string** (i.e., `"beta.1"`), if any.

#### `FIO_VERSION_STRING`

Translates to the STL's version as a string (i.e., `"0.8.0-beta.1"`).

-------------------------------------------------------------------------------

## OS Detection Macros

#### `FIO_OS_POSIX`

Set to `1` on POSIX systems (Linux, macOS, BSD, etc.), `0` otherwise.

#### `FIO_OS_WIN`

Set to `1` on Windows systems, `0` otherwise.

#### `FIO_HAVE_UNIX_TOOLS`

Set to a non-zero value when Unix-like tools are available. Values:
- `0` - No Unix tools
- `1` - Full POSIX
- `2` - MinGW
- `3` - Cygwin

-------------------------------------------------------------------------------

### Default Memory Allocation

By setting these macros, the memory allocator used by facil.io could be changed from the default allocator (either the custom allocator or, if missing, the system's allocator).

When facil.io's memory allocator is defined (using `FIO_MALLOC`), **these macros will be automatically overwritten to use the custom memory allocator**. To use a different allocator, you may redefine the macros.

#### `FIO_MEM_REALLOC`

```c
#define FIO_MEM_REALLOC(ptr, old_size, new_size, copy_len) realloc((ptr), (new_size))
```

Reallocates memory, copying (at least) `copy_len` if necessary.

If `ptr` is `NULL`, behaves like `malloc`.

If `new_size` is 0, behaves like `free`.

#### `FIO_MEM_FREE`

```c
#define FIO_MEM_FREE(ptr, size) free((ptr))
```

Frees allocated memory.

#### `FIO_MALLOC_TMP_USE_SYSTEM`

When defined, temporarily bypasses the `FIO_MEM_REALLOC` macros and uses the system's `realloc` and `free` functions for newly created types.

#### `FIO_MEMORY_DISABLE`

When `FIO_MEMORY_DISABLE` is defined, all (future) custom memory allocators will route to the system's `malloc`. Set this when compiling to test the effects of all custom memory allocators working together.

-------------------------------------------------------------------------------

## Memory Leak Detection

#### `FIO_LEAK_COUNTER`

Unless defined as zero (`0`), facil.io will count allocations and deallocations for custom memory allocators and reference counted types - allowing memory leaks to be detected with a high degree of certainty.

This may also print some minimal usage information about each allocator when exiting the program (when logging using `FIO_LOG_LEVEL_DEBUG`. 

**Note**: enabling leak detection automatically adds the `FIO_LOG` module (to print errors), the `FIO_ATOMIC` module (for atomic counters) and the `FIO_STATE` module (for more predictable `at_exit` callbacks).

#### `FIO_LEAK_COUNTER_DEF`, `FIO_LEAK_COUNTER_ON_ALLOC` and `FIO_LEAK_COUNTER_ON_FREE`

These macros require `FIO_LEAK_COUNTER` to be true, otherwise they do nothing.

- `FIO_LEAK_COUNTER_DEF(name)` - defines the named memory leak counter / detection functions.

- `FIO_LEAK_COUNTER_ON_ALLOC(name)` - adds an allocation to the named memory leak counter.

- `FIO_LEAK_COUNTER_ON_FREE(name)` - subtracts an allocation from the named memory leak counter and tests if `free` was called more than `malloc` for this named allocation counter.

For example:

```c
typedef struct { int i; } my_type_s;
/* define the allocation counter */
FIO_LEAK_COUNTER_DEF(my_type_s)
/* allocation function */
my_type_s * my_type_new() {
  my_type_s *t = malloc(sizeof(*t));
  if(!t)
    return t;
  /* count allocation */
  FIO_LEAK_COUNTER_ON_ALLOC(my_type_s);
  *t = (my_type_s){0};
  return t;
}
/* deallocation function */
void my_type_free(my_type_s * t) {
  if(!t)
    return;
  /* count deallocation before freeing object - tests excessive calls to free) */
  FIO_LEAK_COUNTER_ON_FREE(my_type_s);
  free(t);
  FIO_LOG_DEBUG("We now have only %zu my_type_s objects left.",
                FIO_LEAK_COUNTER_COUNT(my_type_s));
}
```

**Note**: the `FIO_REF` reference counting module does this automatically when `FIO_LEAK_COUNTER` is defined as true.

#### `FIO_LEAK_COUNTER_COUNT`

```c
#define FIO_LEAK_COUNTER_COUNT(name)
```

Returns the number of unfreed allocations according to the named memory leak detector.

Returned type is `size_t`

-------------------------------------------------------------------------------

## Dedicated Static Memory Allocations

The core module provides a simple way to manage a "good enough" thread safe memory allocations for short term use that never need to be freed (e.g., when the caller cannot be trusted to free the memory).

#### `FIO_STATIC_ALLOC_DEF`

```c
#define FIO_STATIC_ALLOC_DEF(function_name, type_T, size_per_allocation, allocations_per_thread)
```

Defines a simple (almost naive) static memory allocator named `function_name` which accepts a single `size_t` argument `count`.

The defined function returns a `type_T` pointer (`type_T *`) containing `sizeof(type_T) * count * size_per_allocation` in correct memory alignment for the requested type.

```c
static type_T *function_name(size_t count);
```

That memory is statically allocated, allowing it to be returned without ever needing to be freed.

The functions can safely allocate the following number of bytes before the function returns the same memory block to another caller:

    FIO_STATIC_ALLOC_SAFE_CONCURRENCY_MAX * allocations_per_thread *
        sizeof(type_T) * size_per_allocation

Example:

```c
// Step 1: define the allocator:
FIO_STATIC_ALLOC_DEF(numer2hex_allocator, char, 19, 1);

// Step 2: use the allocator
char * ntos16(uint16_t n) {
  char * buf = numer2hex_allocator(1);
  buf[0] = '0'; buf[1] = 'x';
  fio_ltoa16u(buf+2, n, 16);
  buf[18] = 0;
  return buf;
}
```

-------------------------------------------------------------------------------

## Pointer Arithmetics

#### `FIO_PTR_MATH_LMASK`

```c
#define FIO_PTR_MATH_LMASK(T_type, ptr, bits)                                  \
  ((T_type *)(((uintptr_t)(ptr)) & (((uintptr_t)1ULL << (bits)) - 1)))
```

Masks a pointer's left-most bits, returning the right bits (i.e., `0x000000FF`).

#### `FIO_PTR_MATH_RMASK`

```c
#define FIO_PTR_MATH_RMASK(T_type, ptr, bits)                                  \
  ((T_type *)(((uintptr_t)(ptr)) & ((~(uintptr_t)0ULL) << (bits))))
```

Masks a pointer's right-most bits, returning the left bits (i.e., `0xFFFFFF00`).

#### `FIO_PTR_MATH_ADD`

```c
#define FIO_PTR_MATH_ADD(T_type, ptr, offset)                                  \
  ((T_type *)((uintptr_t)(ptr) + (uintptr_t)(offset)))
```

Add offset bytes to pointer's address, updating the pointer's type.

#### `FIO_PTR_MATH_SUB`

```c
#define FIO_PTR_MATH_SUB(T_type, ptr, offset)                                  \
  ((T_type *)((uintptr_t)(ptr) - (uintptr_t)(offset)))
```

Subtract X bytes from pointer's address, updating the pointer's type.

#### `FIO_PTR_FIELD_OFFSET`

```c
#define FIO_PTR_FIELD_OFFSET(T_type, field)                                    \
  ((uintptr_t)((&((T_type *)0xFF00)->field)) - 0xFF00)
```

Calculates the byte offset of a field within a struct type.

**Note**: Uses `0xFF00` as a base address instead of `0` to avoid undefined behavior with address sanitizers and strict aliasing rules.

Example:

```c
typedef struct {
  int a;
  char b;
  double c;
} my_struct_s;

size_t offset = FIO_PTR_FIELD_OFFSET(my_struct_s, c);
// offset now contains the byte offset of field 'c' within my_struct_s
```

#### `FIO_PTR_FROM_FIELD`

```c
#define FIO_PTR_FROM_FIELD(T_type, field, ptr)                                 \
  FIO_PTR_MATH_SUB(T_type, ptr, FIO_PTR_FIELD_OFFSET(T_type, field))
```

Find the root object (of a `struct`) from a pointer to its field's address.

**Note**: Uses `FIO_PTR_FIELD_OFFSET` internally, which uses `0xFF00` as a base address to avoid undefined behavior with address sanitizers.

Example:

```c
typedef struct {
  int id;
  fio_list_node_s node;
  char *name;
} my_item_s;

// Given a pointer to the 'node' field, get the containing struct
fio_list_node_s *node_ptr = /* ... */;
my_item_s *item = FIO_PTR_FROM_FIELD(my_item_s, node, node_ptr);
```

-------------------------------------------------------------------------------

## Pointer Tagging Support

Pointer tagging allows types created using this library to have their pointers "tagged".

This is when creating / managing dynamic types, where some type data could be written to the pointer data itself.

**Note**: pointer tagging can't automatically tag "pointers" to objects placed on the stack.

#### `FIO_PTR_TAG`

```c
#define FIO_PTR_TAG(p) (p)
```

Supports embedded pointer tagging / untagging for the included types.

Should resolve to a tagged pointer value. i.e.: `((uintptr_t)(p) | 1)`

#### `FIO_PTR_UNTAG`

```c
#define FIO_PTR_UNTAG(p) (p)
```

Supports embedded pointer tagging / untagging for the included types.

Should resolve to an untagged pointer value. i.e.: `((uintptr_t)(p) | ~1UL)`

**Note**: `FIO_PTR_UNTAG` might be called more then once or on untagged pointers. For this reason, `FIO_PTR_UNTAG` should always return the valid pointer, even if called on an untagged pointer.

#### `FIO_PTR_TAG_TYPE`

If the FIO_PTR_TAG_TYPE is defined, then functions returning a type's pointer will return a pointer of the specified type instead.


#### `FIO_PTR_TAG_VALIDATE`

```c
#define FIO_PTR_TAG_VALIDATE(ptr) ((ptr) != NULL)
```

If `FIO_PTR_TAG_VALIDATE` is defined, tagging will be verified before executing any code.

`FIO_PTR_TAG_VALIDATE` **must** fail on NULL pointers.

-------------------------------------------------------------------------------

## Naming and Misc. Macros

#### `FIO_IFUNC`

```c
#define FIO_IFUNC static inline __attribute__((unused))
```

Marks a function as `static`, `inline` and possibly unused.

#### `FIO_SFUNC`

```c
#define FIO_SFUNC static __attribute__((unused))
```

Marks a function as `static` and possibly unused.

#### `FIO_MIFN`

```c
#define FIO_MIFN FIO_IFUNC __attribute__((warn_unused_result))
```

Marks a function as `static`, `inline`, possibly unused, and warns if the return value is unused.

#### `FIO_WEAK`

```c
#define FIO_WEAK __attribute__((weak))
```

Marks a function as weak.

#### `FIO_ALIGN`

```c
#define FIO_ALIGN(bytes) __attribute__((aligned(bytes)))
```

Aligns a type or variable to the specified byte boundary.

#### `DEPRECATED`

```c
#define DEPRECATED(reason) __attribute__((deprecated(reason)))
```

Marks a function or type as deprecated with an optional reason string.

#### `FIO_CONSTRUCTOR(fname)`

```c
#define FIO_CONSTRUCTOR(fname) static __attribute__((constructor)) void fname(void)
```

Marks a function as a _constructor_ - **if supported**.

When supported by the compiler (i.e., `gcc` / `clang`), this function will execute when the library is loaded or, if statically linked, before `main` is called.

#### `FIO_DESTRUCTOR(fname)`

```c
#define FIO_DESTRUCTOR(fname) static __attribute__((destructor)) void fname(void)
```

Marks a function as a _destructor_ - **if supported**.

When supported by the compiler (i.e., `gcc` / `clang`), this function will execute when the library is loaded or, if statically linked, after `main` returns.

#### `FIO_LIKELY` / `FIO_UNLIKELY`

```c
#define FIO_LIKELY(cond)   __builtin_expect((cond), 1)
#define FIO_UNLIKELY(cond) __builtin_expect((cond), 0)
```

Branch prediction hints for the compiler. Use `FIO_LIKELY` when a condition is expected to be true most of the time, and `FIO_UNLIKELY` when it's expected to be false.

#### `FIO_NOOP`

```c
#define FIO_NOOP
```

An empty macro, adding white space.

This is useful when a function name is shadowed by a macro (such as when named arguments are used). The additional `FIO_NOOP` macro and white space that follows prevents the named argument macro from being expanded by the preprocessor.

#### `FIO_NOOP_FN`

```c
#define FIO_NOOP_FN(...)
```

An empty macro that does nothing.

This is useful for creating macros that can have optional callbacks (`FIO_NOOP_FN` can be used instead of a callback in these cases).

#### `FIO_NOOP_FN_NAME`

```c
#define FIO_NOOP_FN_NAME (void)
```

A macro for a No-Op function name that casts to void.

#### `FIO_MACRO2STR`

```c
#define FIO_MACRO2STR(macro) FIO_MACRO2STR_STEP2(macro)
```

Converts a macro's content to a string literal.

#### `FIO_NAME`

```c
#define FIO_NAME(prefix, postfix)
```

Used for naming functions and variables resulting in: `prefix_postfix`

This allows macros to be used for naming types and functions.

i.e.:

```c
// the type's name
#define NUM number
// typedef struct { long l; } number_s
typedef struct { long l; } FIO_NAME(NUM, s)

// number_s number_add(number_s a, number_s b)
FIO_NAME(NUM, s) FIO_NAME(NUM, add)(FIO_NAME(NUM, s) a, FIO_NAME(NUM, s) b) {
  a.l += b.l;
  return a;
}
#undef NUM
```

#### `FIO_NAME2`

```c
#define FIO_NAME2(prefix, postfix)
```

Sets naming convention for conversion functions, i.e.: foo2bar

i.e.:

```c
// int64_t a2l(const char * buf)
int64_t FIO_NAME2(a, l)(const char * buf) {
  return fio_atol(&buf);
}
```

#### `FIO_NAME_BL`

```c
#define FIO_NAME_BL(prefix, postfix) 
```

Sets naming convention for boolean functions, i.e.: foo_is_true

#### `FIO_NAME_TEST`

```c
#define FIO_NAME_TEST(prefix, postfix) FIO_NAME(fio___test, FIO_NAME(prefix, postfix))
```

Used internally to name test functions.

#### `FIO_FOR`

```c
#define FIO_FOR(i, count) for (size_t i = 0; i < (count); ++i)
```

Helper for simple `for` loops, where `i` is the variable name to use.

-------------------------------------------------------------------------------

## Compiler Guards and Memory Barriers

#### `FIO_COMPILER_GUARD`

```c
#define FIO_COMPILER_GUARD __asm__ volatile("" ::: "memory")
```

Clobber CPU registers and prevent compiler reordering optimizations.

#### `FIO_COMPILER_GUARD_INSTRUCTION`

```c
#define FIO_COMPILER_GUARD_INSTRUCTION __asm__ volatile("" :::)
```

Prevent compiler instruction reordering without clobbering memory.

-------------------------------------------------------------------------------

## Thread Scheduling Macros

#### `FIO_THREAD_WAIT`

```c
#define FIO_THREAD_WAIT(nano_sec)
```

Calls the system's sleep function with the requested nano-second count.

On POSIX systems, calls `nanosleep`. On Windows, calls `Sleep`.

#### `FIO_THREAD_YIELD`

```c
#define FIO_THREAD_YIELD()
```

Yields the thread, hinting to the processor about a spinlock loop.

Uses CPU-specific instructions (`pause` on x86, `yield` on ARM) when available.

#### `FIO_THREAD_RESCHEDULE`

```c
#define FIO_THREAD_RESCHEDULE() FIO_THREAD_WAIT(4)
```

Reschedules the thread by calling nanosleep for a few nanoseconds.

In practice, the thread will probably sleep for 60ns or more. Seems to be faster than `FIO_THREAD_YIELD`, perhaps it prevents de-prioritization of the thread.

-------------------------------------------------------------------------------

## Assertions

#### `FIO_ASSERT`

```c
#define FIO_ASSERT(cond, ...)
```

Asserts a condition is true, or kills the application using SIGINT.

Prints the error message and errno information before aborting.

#### `FIO_ASSERT_ALLOC`

```c
#define FIO_ASSERT_ALLOC(ptr) FIO_ASSERT((ptr), "memory allocation failed.")
```

Tests for an allocation failure. The behavior can be overridden.

#### `FIO_ASSERT_DEBUG`

```c
#define FIO_ASSERT_DEBUG(cond, ...)
```

If `DEBUG` is defined, raises SIGINT if assertion fails, otherwise NOOP.

#### `FIO_ASSERT_STATIC`

```c
#define FIO_ASSERT_STATIC(cond, msg) _Static_assert((cond), msg)
```

Compile-time assertion. Uses C11 `_Static_assert` when available.

-------------------------------------------------------------------------------

## Memory Copying, Seeking and Setting

The following macros are defined to allow for memory copying primitives of set sizes.

In addition an overridable `FIO_MEMCPY` macro is provided that allows routing any variable sized memory copying to a different routine.

#### `FIO_MEMCPY`

```c
#define FIO_MEMCPY memcpy // or __builtin_memcpy if available
```

This macro makes it easy to override the `memcpy` implementation used by the library.

By default this will be set to either `memcpy` or `__builtin_memcpy` (if available). It can also be set to `fio_memcpy` if need be.

#### `FIO_MEMMOVE`

```c
#define FIO_MEMMOVE memmove // or __builtin_memmove if available
```

This macro makes it easy to override the `memmove` implementation used by the library.

By default this will be set to either `memmove` or `__builtin_memmove` (if available). It can also be set to `fio_memcpy` if need be.

#### `fio_memcpy##`

```c
static void * fio_memcpy0(void *restrict dest, const void *restrict src); /* no-op */
static void * fio_memcpy1(void *restrict dest, const void *restrict src);
static void * fio_memcpy2(void *restrict dest, const void *restrict src);
static void * fio_memcpy3(void *restrict dest, const void *restrict src);
static void * fio_memcpy4(void *restrict dest, const void *restrict src);
static void * fio_memcpy8(void *restrict dest, const void *restrict src);
static void * fio_memcpy16(void *restrict dest, const void *restrict src);
static void * fio_memcpy32(void *restrict dest, const void *restrict src);
static void * fio_memcpy64(void *restrict dest, const void *restrict src);
// ... void * fio_memcpy4096
```

Copies a pre-defined `n` bytes from `src` to `dest` where `n` is a power of 2 between 1 and 4096 (including).

**Note**: Implementation relies heavily on compiler auto-vectorization. Resulting code may run faster or slower than libc, depending on the compiler and available instruction sets / optimizations.

#### `fio_memcpy##x`

```c
static void * fio_memcpy7x(void *restrict dest, const void *restrict src, size_t length);
static void * fio_memcpy15x(void *restrict dest, const void *restrict src, size_t length);
static void * fio_memcpy31x(void *restrict dest, const void *restrict src, size_t length);
static void * fio_memcpy63x(void *restrict dest, const void *restrict src, size_t length);
// ... void * fio_memcpy4095x
```

Copies up to `n-1` bytes from `src` to `dest` where `n` is a power of 2 between 1 and 4096 (including).

This is provided to allow for easy "tail" processing.

**Note**: Implementation relies heavily on compiler auto-vectorization. Resulting code may run faster or slower than libc, depending on the compiler and available instruction sets / optimizations.

#### `fio_memcpy`

```c
void *fio_memcpy(void *dest, const void *src, size_t bytes);
```

A fallback for `memcpy` and `memmove`, copies `bytes` bytes from `src` to `dest`.

Behaves as `memmove`, allowing for copy between overlapping memory buffers. 

On most of `libc` implementations the library call will be faster. On embedded systems, test before deciding.

**Note**: Implementation relies heavily on compiler auto-vectorization. Resulting code may run faster or slower than libc, depending on the compiler and available instruction sets / optimizations.

#### `FIO_MEMSET`

```c
#define FIO_MEMSET memset // or __builtin_memset if available
```

This macro makes it easy to override the `memset` implementation used by the library.

By default this will be set to either `memset` or `__builtin_memset` (if available). It can also be set to `fio_memset` if need be.

#### `fio_memset`

```c
void *fio_memset(void *restrict dest, uint64_t data, size_t bytes);
```

A fallback for `memset`. Sets `bytes` bytes in the `dest` buffer to `data`.

The `data` can be either a single byte - in which case all bytes in `dest` will be set to `data` - or a 64 bit value which will be written repeatedly all over `dest` in local endian format (last copy may be partial).

On most of `libc` implementations the library call will be faster. On embedded systems, test before deciding.

Returns `dest` (the pointer originally received).

**Note**: Implementation relies heavily on compiler auto-vectorization. Resulting code may run faster or slower than `libc`, depending on the compiler and available instruction sets / optimizations.

#### `FIO_MEMCHR`

```c
#define FIO_MEMCHR memchr // or __builtin_memchr if available
```

This macro makes it easy to override the `memchr` implementation used by the library.

By default this will be set to either `memchr` or `__builtin_memchr` (if available). It can also be set to `fio_memchr` if need be.

#### `fio_memchr`

```c
void *fio_memchr(const void *buffer, const char token, size_t len);
```

A fallback for `memchr`, seeking a `token` in the number of `bytes` starting at the address of `mem`.

If `token` is found, returns the address of the token's first appearance. Otherwise returns `NULL`.

On most of `libc` implementations the library call will be faster. Test before deciding.

**Note**: Implementation relies heavily on compiler auto-vectorization. Resulting code may run faster or slower than `libc`, depending on the compiler and available instruction sets / optimizations.

#### `FIO_MEMCMP`

```c
#define FIO_MEMCMP memcmp // or __builtin_memcmp if available
```

This macro makes it easy to override the `memcmp` implementation used by the library.

By default this will be set to either `memcmp` or `__builtin_memcmp` (if available). It can also be set to `fio_memcmp` if need be.

#### `fio_memcmp`

```c
int fio_memcmp(const void *a, const void *b, size_t len);
```

A fallback for `memcmp`, comparing two memory regions by byte values.

Returns 1 if `a > b`, -1 if `a < b` and 0 if `a == b`.

**Note**: Implementation relies heavily on compiler auto-vectorization. Resulting code may run faster or slower than `libc`, depending on the compiler and available instruction sets / optimizations.

#### `FIO_STRLEN`

```c
#define FIO_STRLEN strlen // or __builtin_strlen if available
```

This macro makes it easy to override the `strlen` implementation used by the library.

By default this will be set to either `strlen` or `__builtin_strlen` (if available). It can also be set to `fio_strlen` if need be.

#### `fio_strlen`

```c
size_t fio_strlen(const char *str);
```

A fallback for `strlen`, returning the length of the string.

**Note**: Implementation relies heavily on compiler auto-vectorization. Resulting code may run faster or slower than `libc`, depending on the compiler and available instruction sets / optimizations.

#### `FIO_MEMALT`

If defined, defines all previously undefined memory macros to use facil.io's fallback options.

Note that this will also cause `__builtin_memcpy` to be bypassed for the fixed `fio_memcpy##` functions.

-------------------------------------------------------------------------------

## Security Related Functions

#### `fio_secure_zero`

```c
void fio_secure_zero(void *a_, size_t bytes);
```

Securely zeros memory, preventing compiler optimizations from removing the operation.

Use this to clear sensitive data (passwords, keys, etc.) from memory.

#### `FIO_MEM_STACK_WIPE`

```c
#define FIO_MEM_STACK_WIPE(pages)
```

Wipes stack memory by allocating and zeroing a volatile array of the specified number of pages (each page is 4096 bytes).

-------------------------------------------------------------------------------

## Byte Ordering and Copying - Little Endian vs. Big Endian

To help with byte ordering on different systems, the following macros and functions are defined. Note that there's no built-in support for mixed endian systems.

#### `__BIG_ENDIAN__`

Defined and set to either 1 (on big endian systems) or 0 (little endian systems)

#### `__LITTLE_ENDIAN__`

Defined and set to either 1 (on little endian systems) or 0 (big endian systems)

#### `fio_is_little_endian`, `fio_is_big_endian`

```c
unsigned int fio_is_little_endian(void);
unsigned int fio_is_big_endian(void);
```

These functions perform runtime tests for endianess ... but may be optimized away by the compiler.

#### `fio_bswap`

Returns a number of the indicated type with it's byte representation swapped.

- `fio_bswap16(i)`
- `fio_bswap32(i)`
- `fio_bswap64(i)`
- `fio_bswap128(i)` (only on compilers that support this type)

#### `fio_lton`, `fio_ntol`

On big-endian systems, the following macros a NOOPs. On little-endian systems these macros flip the byte order.

- `fio_lton16(i)`
- `fio_ntol16(i)`
- `fio_lton32(i)`
- `fio_ntol32(i)`
- `fio_lton64(i)`
- `fio_ntol64(i)`
- `fio_lton128(i)`
- `fio_ntol128(i)`

#### `fio_ltole`

Converts a local number to little-endian. On big-endian systems, these macros flip the byte order. On little-endian systems these macros are a NOOP.

- `fio_ltole16(i)`
- `fio_ltole32(i)`
- `fio_ltole64(i)`
- `fio_ltole128(i)`

#### Bit rotation (left / right)

Returns a number with it's bits left rotated (`lrot`) or right rotated (`rrot`) according to the type width specified (i.e., `fio_rrot64` indicates a **r**ight rotation for `uint64_t`).

- `fio_lrot8(i, bits)`
- `fio_rrot8(i, bits)`
- `fio_lrot16(i, bits)`
- `fio_rrot16(i, bits)`
- `fio_lrot32(i, bits)`
- `fio_rrot32(i, bits)`
- `fio_lrot64(i, bits)`
- `fio_rrot64(i, bits)`
- `fio_lrot128(i, bits)`
- `fio_rrot128(i, bits)`

- `FIO_LROT(i, bits)` (MACRO, can be used with any type size)
- `FIO_RROT(i, bits)` (MACRO, can be used with any type size)

#### Bytes to Numbers

Reads a number from an unaligned memory buffer. The number or **bits** read from the buffer is indicated by the name of the function.

**Big Endian**:

- `fio_buf2u16_be(buffer)`
- `fio_buf2u24_be(buffer)`
- `fio_buf2u32_be(buffer)`
- `fio_buf2u64_be(buffer)`
- `fio_buf2u128_be(buffer)`

**Little Endian**:

- `fio_buf2u16_le(buffer)`
- `fio_buf2u24_le(buffer)`
- `fio_buf2u32_le(buffer)`
- `fio_buf2u64_le(buffer)`
- `fio_buf2u128_le(buffer)`

**Native (Unspecified) Byte Order**:

- `fio_buf2u16u(buffer)`
- `fio_buf2u24u(buffer)`
- `fio_buf2u32u(buffer)`
- `fio_buf2u64u(buffer)`
- `fio_buf2u128u(buffer)`

#### Numbers to Bytes (native / reversed / network ordered)

Writes a number to an unaligned memory buffer. The number or bits written to the buffer is indicated by the name of the function.

**Big Endian (default)**:

- `fio_u2buf16_be(buffer, i)`
- `fio_u2buf24_be(buffer, i)`
- `fio_u2buf32_be(buffer, i)`
- `fio_u2buf64_be(buffer, i)`
- `fio_u2buf128_be(buffer, i)`

**Little Endian**:

- `fio_u2buf16_le(buffer, i)`
- `fio_u2buf24_le(buffer, i)`
- `fio_u2buf32_le(buffer, i)`
- `fio_u2buf64_le(buffer, i)`
- `fio_u2buf128_le(buffer, i)`

**Native (Unspecified) Byte Order**:

- `fio_u2buf16u(buffer, i)`
- `fio_u2buf24u(buffer, i)`
- `fio_u2buf32u(buffer, i)`
- `fio_u2buf64u(buffer, i)`
- `fio_u2buf128u(buffer, i)`

#### `fio_xmask`

```c
void fio_xmask(char *buf, size_t len, uint64_t mask);
```

Masks data using a 64 bit mask.

The function may perform significantly better when the buffer's memory is aligned.

#### `fio_xmask_cpy`

```c
void fio_xmask_cpy(char *restrict dest, const char *src, size_t len, uint64_t mask);
```

Masks data using a 64 bit mask while copying from `src` to `dest`.

If `dest == src`, behaves like `fio_xmask`.

-------------------------------------------------------------------------------

## Constant Time Helpers

Performs the operation indicated in constant time.

#### `fio_ct_true`

```c
uintmax_t fio_ct_true(uintmax_t cond);
```

Returns 1 if `cond` is non-zero, 0 otherwise.

#### `fio_ct_false`

```c
uintmax_t fio_ct_false(uintmax_t cond);
```

Returns 1 if `cond` is zero, 0 otherwise.

#### `fio_ct_if_bool`

```c
uintmax_t fio_ct_if_bool(uintmax_t cond, uintmax_t a, uintmax_t b);
```

Returns `a` if `cond == 1`, returns `b` otherwise.

#### `fio_ct_if`

```c
uintmax_t fio_ct_if(uintmax_t cond, uintmax_t a, uintmax_t b);
```

Returns `a` if `cond` is non-zero, returns `b` otherwise.

#### `fio_ct_max`

```c
intmax_t fio_ct_max(intmax_t a, intmax_t b);
```

Returns `a` if `a >= b` (performs a **signed** comparison).

#### `fio_ct_min`

```c
intmax_t fio_ct_min(intmax_t a, intmax_t b);
```

Returns `a` if `a <= b` (performs a **signed** comparison).

#### `fio_ct_abs`

```c
uintmax_t fio_ct_abs(intmax_t i);
```

Returns the absolute value of `i`.

#### `fio_ct_is_eq`

```c
_Bool fio_ct_is_eq(const void *a, const void *b, size_t bytes);
```

Returns 1 if memory regions are equal. Should be resistant to timing attacks.

-------------------------------------------------------------------------------

## Constant-Time Bitwise Selection Functions

These functions perform bitwise selection operations in constant time. They are commonly used in cryptographic algorithms (SHA, AES, etc.) and can also be used for branchless programming.

#### `fio_ct_mux32` / `fio_ct_mux64`

```c
uint32_t fio_ct_mux32(uint32_t x, uint32_t y, uint32_t z);
uint64_t fio_ct_mux64(uint64_t x, uint64_t y, uint64_t z);
```

Bitwise "choose": for each bit, if x is set, return y's bit, else z's bit.

Formula: `z ^ (x & (y ^ z))`

Used in: SHA-1 (Ch), SHA-256 (Ch), SHA-512 (Ch), AES, etc.

#### `fio_ct_maj32` / `fio_ct_maj64`

```c
uint32_t fio_ct_maj32(uint32_t x, uint32_t y, uint32_t z);
uint64_t fio_ct_maj64(uint64_t x, uint64_t y, uint64_t z);
```

Bitwise "majority": for each bit position, return 1 if 2+ inputs have 1.

Formula: `(x & y) | (z & (x | y))`

Used in: SHA-1 (Maj), SHA-256 (Maj), SHA-512 (Maj), etc.

#### `fio_ct_xor3_32` / `fio_ct_xor3_64`

```c
uint32_t fio_ct_xor3_32(uint32_t x, uint32_t y, uint32_t z);
uint64_t fio_ct_xor3_64(uint64_t x, uint64_t y, uint64_t z);
```

Bitwise "parity": XOR of all three inputs (1 if odd number of 1s).

Formula: `x ^ y ^ z`

Used in: SHA-1 (Parity function for rounds 20-39 and 60-79)

-------------------------------------------------------------------------------

## Combined Rotation-XOR Operations

These combine multiple rotations with XOR, which is a common pattern in SHA-2, BLAKE2, and other hash functions.

#### `fio_xor_rrot3_32` / `fio_xor_rrot3_64`

```c
uint32_t fio_xor_rrot3_32(uint32_t x, uint8_t a, uint8_t b, uint8_t c);
uint64_t fio_xor_rrot3_64(uint64_t x, uint8_t a, uint8_t b, uint8_t c);
```

XOR of three right rotations: `ROTR(x,a) ^ ROTR(x,b) ^ ROTR(x,c)`

Common in SHA-256/SHA-512 Sigma functions.

#### `fio_xor_rrot2_shr_32` / `fio_xor_rrot2_shr_64`

```c
uint32_t fio_xor_rrot2_shr_32(uint32_t x, uint8_t a, uint8_t b, uint8_t c);
uint64_t fio_xor_rrot2_shr_64(uint64_t x, uint8_t a, uint8_t b, uint8_t c);
```

XOR of two right rotations and a right shift: `ROTR(x,a) ^ ROTR(x,b) ^ SHR(x,c)`

Common in SHA-256/SHA-512 sigma (lowercase) functions for message schedule.

-------------------------------------------------------------------------------

## Inspecting Byte / Bit Data

**Note**: the 128 bit helpers are only available with systems / compilers that support 128 bit types.

**Note**: for mutable shared data, please consider using the atomic operations.

### Bitmap helpers

#### `fio_bit_get`

```c
uint8_t fio_bit_get(void *map, size_t bit);
```

Gets the state of a bit in a bitmap.

#### `fio_bit_set`

```c
void fio_bit_set(void *map, size_t bit);
```

Sets a bit in a bitmap (sets to 1). **Non-atomic**, not thread-safe.

#### `fio_bit_unset`

```c
void fio_bit_unset(void *map, size_t bit);
```

Unsets a bit in a bitmap (sets to 0). **Non-atomic**, not thread-safe.

#### `fio_bit_flip`

```c
void fio_bit_flip(void *map, size_t bit);
```

Flips a bit in a bitmap (sets to 0 if 1, sets to 1 if 0). **Non-atomic**, not thread-safe.

### Bit Isolation and Indexing

#### `fio_bits_lsb`

```c
uint64_t fio_bits_lsb(uint64_t i);
```

Isolates the least significant (lowest) bit.

#### `fio_bits_msb`

```c
uint64_t fio_bits_msb(uint64_t i);
```

Isolates the most significant (highest) bit.

#### `fio_bits_lsb_index`

```c
size_t fio_bits_lsb_index(uint64_t i);
```

Returns the index of the least significant (lowest) bit. Returns `(size_t)-1` if `i` is 0.

#### `fio_bits_msb_index`

```c
size_t fio_bits_msb_index(uint64_t i);
```

Returns the index of the most significant (highest) bit. Returns `(size_t)-1` if `i` is 0.

#### `fio_lsb_index_unsafe`

```c
size_t fio_lsb_index_unsafe(uint64_t i);
```

Returns the index of the least significant (lowest) bit. Undefined behavior if `i` is 0.

#### `fio_msb_index_unsafe`

```c
size_t fio_msb_index_unsafe(uint64_t i);
```

Returns the index of the most significant (highest) bit. Undefined behavior if `i` is 0.

### Popcount and Hamming Distance

#### `fio_popcount`

```c
int fio_popcount(uint64_t n);
```

Returns the number of set bits in the number `n`.

#### `fio_hemming_dist`

```c
#define fio_hemming_dist(n1, n2) fio_popcount(((uint64_t)(n1) ^ (uint64_t)(n2)))
```

Returns the Hamming Distance between the number `n1` and the number `n2`.

Hamming Distance is the number of bits that need to be "flipped" in order for both numbers to be equal.

### Byte Detection in Vectors

#### `fio_has_full_byte32`

```c
uint32_t fio_has_full_byte32(uint32_t row);
```

Detects a byte where all the bits are set (`255`) within a 4 byte vector.

#### `fio_has_zero_byte32`

```c
uint32_t fio_has_zero_byte32(uint32_t row);
```

Detects a byte where no bits are set (0) within a 4 byte vector.

#### `fio_has_byte32`

```c
uint32_t fio_has_byte32(uint32_t row, uint8_t byte);
```

Detects if `byte` exists within a 4 byte vector.

#### `fio_has_full_byte64`

```c
uint64_t fio_has_full_byte64(uint64_t row);
```

Detects a byte where all the bits are set (`255`) within an 8 byte vector.

#### `fio_has_zero_byte64`

```c
uint64_t fio_has_zero_byte64(uint64_t row);
```

Detects a byte where no bits are set (byte == 0) within an 8 byte vector.

#### `fio_has_zero_byte_alt64`

```c
uint64_t fio_has_zero_byte_alt64(uint64_t row);
```

Alternative version of `fio_has_zero_byte64`. Should NOT be used to build a bitmap, but may be used to detect the first occurrence.

#### `fio_has_byte64`

```c
uint64_t fio_has_byte64(uint64_t row, uint8_t byte);
```

Detects if `byte` exists within an 8 byte vector.

#### `fio_has_byte2bitmap`

```c
uint64_t fio_has_byte2bitmap(uint64_t result);
```

Converts a `fio_has_byteX` result to a bitmap.

#### `fio_has_full_byte128`

```c
__uint128_t fio_has_full_byte128(__uint128_t row);
```

Detects a byte where all the bits are set (`255`) within a 16 byte vector.

#### `fio_has_zero_byte128`

```c
__uint128_t fio_has_zero_byte128(__uint128_t row);
```

Detects a byte where no bits are set (0) within a 16 byte vector.

#### `fio_has_byte128`

```c
__uint128_t fio_has_byte128(__uint128_t row, uint8_t byte);
```

Detects if `byte` exists within a 16 byte vector.

-------------------------------------------------------------------------------

## Multi-Precision Math Building Blocks

The following simple operations can be used to build your own multi-precision implementation.

The following, somewhat naive, multi-precision math implementation focuses on constant time. It assumes an array of local endian 64bit numbers ordered within the array in little endian (word `0` contains the least significant bits and word `n-1` contains the most significant bits).


#### `fio_math_addc64`

```c
uint64_t fio_math_addc64(uint64_t a,
                         uint64_t b,
                         uint64_t carry_in,
                         uint64_t *carry_out);
```

Add with carry.

#### `fio_math_add`

```c
bool fio_math_add(uint64_t *dest,
                  const uint64_t *a,
                  const uint64_t *b,
                  const size_t len);
```

Multi-precision ADD for `len` 64 bit words a + b. Returns the carry.

This assumes all the pointers point to memory blocks that are the same-length `len` (use zero padding for uneven word lengths).

This assume LSW (Least Significant Word) ordering.

#### `fio_math_subc64`

```c
uint64_t fio_math_subc64(uint64_t a,
                         uint64_t b,
                         uint64_t carry_in,
                         uint64_t *carry_out);
```

Subtract with carry.

#### `fio_math_sub`

```c
uint64_t fio_math_sub(uint64_t *dest,
                      const uint64_t *a,
                      const uint64_t *b,
                      const size_t len);
```

Multi-precision SUB for `len` 64 bit words a + b. Returns the borrow.

This assumes all the pointers point to memory blocks that are the same-length `len` (use zero padding for uneven word lengths).

This assume LSW (Least Significant Word) ordering.

#### `fio_math_mulc64`
```c
uint64_t fio_math_mulc64(uint64_t a, uint64_t b, uint64_t *carry_out);
```

Multiply with carry out.


#### `fio_math_mul`

```c
void fio_math_mul(uint64_t *restrict dest,
                  const uint64_t *a,
                  const uint64_t *b,
                  const size_t len);
```

Multi-precision MUL for `len` 64 bit words.

`dest` must be `len * 2` long to hold the result.

`a` and `b` must be 64 bit word arrays of equal `len`.

This assume LSW (Least Significant Word) ordering.

#### `fio_math_mod_mul64`

```c
uint64_t fio_math_mod_mul64(uint64_t a, uint64_t b, uint64_t mod);
```

Perform modular multiplication for numbers with up to 64 bits.

#### `fio_math_mod_expo64`

```c
uint64_t fio_math_mod_expo64(uint64_t base, uint64_t exp, uint64_t mod);
```

Perform modular exponentiation for numbers with up to 64 bits.

-------------------------------------------------------------------------------

## 64 bit Prime Helpers

### Detecting primes

Sometimes it is important to know if a number is a prime. the facil.io CSTL provides helpers for detecting if a 64 bit number is likely to be a prime.

#### `fio_math_is_uprime`

```c
bool fio_math_is_uprime(uint64_t n);
```

Tests if an unsigned 64 bit number is (probably) a prime. For numbers up to 1023 this is deterministic.

#### `fio_math_is_iprime`

```c
bool fio_math_is_iprime(int64_t n);
```

Tests if the absolute value of a signed 64 bit number is (probably) a prime. For numbers up to 1023 this is deterministic.

### Constants

The importance of primes for some aspects of programming is difficult to exaggerate. For this reason, facil.io provides the following helper MACROS that represent somewhat randomly pre-selected primes out of a prime pool that fit the requirements (about half of the bits set).

Each group of macros contains 32 primes (indexed from `0` to `31`), where the post-fix of the macro correlates to its index.

#### `FIO_U8_HASH_PRIME0` ... `FIO_U8_HASH_PRIME31`

These set of macros, with post-fixes from `0` to `31`, represent a prime number that would fit inside a `uint8_t` type and has between 3 and 5 bits set (out of 8).

#### `FIO_U16_HASH_PRIME0` ... `FIO_U16_HASH_PRIME31`

These set of macros, with post-fixes from `0` to `31`, represent a prime number that would fit inside a `uint16_t` type and has only half of its bits set.

#### `FIO_U32_HASH_PRIME0` ... `FIO_U32_HASH_PRIME31`

These set of macros, with post-fixes from `0` to `31`, represent a prime number that would fit inside a `uint32_t` type and has only half of its bits set.

#### `FIO_U64_HASH_PRIME0` ... `FIO_U64_HASH_PRIME31`

These set of macros, with post-fixes from `0` to `31`, represent a prime number that would fit inside a `uint64_t` type and has only half of its bits set.

-------------------------------------------------------------------------------

## Native Numeral Vector Operation

These are operations defined on native C types, written with the hope that the compiler will replace these somewhat naive implementations with SIMD instructions where possible.

These operate on common, power of 2, collections of numbers

#### Vectorized Mathematical Operations (`fio_u##x#_OP`)

Add, Multiply, Subtract and more using any of the following (or similarly named):

```c
void fio_u8x4_add(uint8_t * dest, uint8_t * a, uint8_t *b);
void fio_u8x8_add(uint8_t * dest, uint8_t * a, uint8_t *b);
void fio_u8x16_add(uint8_t * dest, uint8_t * a, uint8_t *b);
void fio_u8x32_add(uint8_t * dest, uint8_t * a, uint8_t *b);
void fio_u8x64_add(uint8_t * dest, uint8_t * a, uint8_t *b);
void fio_u8x128_add(uint8_t * dest, uint8_t * a, uint8_t *b);
void fio_u8x256_add(uint8_t * dest, uint8_t * a, uint8_t *b);

void fio_u16x2_add(uint16_t * dest, uint16_t * a, uint16_t *b);
void fio_u16x4_add(uint16_t * dest, uint16_t * a, uint16_t *b);
// ... etc.

void fio_u32x2_add(uint32_t * dest, uint32_t * a, uint32_t *b);
// ... etc.

void fio_u64x2_add(uint64_t * dest, uint64_t * a, uint64_t *b);
// ... etc.
```

The following operations are supported: `add`, `sub`, `mul`, `and`, `or`, `xor`.

#### Vectorized Mathematical Summing (`fio_u##x#_reduce_OP`)

Sum vectors up using Add, Or, XOR, and more using any of the following (or similarly named):

```c
uint8_t fio_u8x4_reduce_add(uint8_t * v);
uint8_t fio_u8x8_reduce_add(uint8_t * v);
// ... etc.

uint16_t fio_u16x2_reduce_add(uint16_t * v);
// ... etc.

uint32_t fio_u32x2_reduce_add(uint32_t * v);
// ... etc.

uint64_t fio_u64x2_reduce_add(uint64_t * v);
// ... etc.
```

The following summation operations are supported: `max`, `min`, `add`, `mul`, `and`, `or`, `xor`.

#### Reshuffling (`fio_u##x#_reshuffle`)

Reorders the words inside the vector.

```c
#define fio_u8x4_reshuffle(v, ...)     fio_u8x4_reshuffle(v,     (uint8_t[4]){__VA_ARGS__})
#define fio_u8x8_reshuffle(v, ...)     fio_u8x8_reshuffle(v,     (uint8_t[8]){__VA_ARGS__})
// ... etc.
```

-------------------------------------------------------------------------------

## Atomic Operations (Core)

If the `FIO_ATOMIC` macro is defined than the following macros will be defined.

In general, when a function returns a value, it is always the previous value - unless the function name ends with `fetch` or `load`.

#### `fio_atomic_load(dest, p_obj)`

Atomically loads and returns the value stored in the object pointed to by `p_obj`.

#### `fio_atomic_exchange(p_obj, value)`

Atomically sets the object pointer to by `p_obj` to `value`, returning the
previous value.

#### `fio_atomic_add(p_obj, value)`

A MACRO / function that performs `add` atomically.

Returns the previous value.

#### `fio_atomic_sub(p_obj, value)`

A MACRO / function that performs `sub` atomically.

Returns the previous value.

#### `fio_atomic_and(p_obj, value)`

A MACRO / function that performs `and` atomically.

Returns the previous value.

#### `fio_atomic_xor(p_obj, value)`

A MACRO / function that performs `xor` atomically.

Returns the previous value.

#### `fio_atomic_or(p_obj, value)`

A MACRO / function that performs `or` atomically.

Returns the previous value.

#### `fio_atomic_nand(p_obj, value)`

A MACRO / function that performs `nand` atomically.

Returns the previous value.

#### `fio_atomic_add_fetch(p_obj, value)`

A MACRO / function that performs `add` atomically.

Returns the new value.

#### `fio_atomic_sub_fetch(p_obj, value)`

A MACRO / function that performs `sub` atomically.

Returns the new value.

#### `fio_atomic_and_fetch(p_obj, value)`

A MACRO / function that performs `and` atomically.

Returns the new value.

#### `fio_atomic_xor_fetch(p_obj, value)`

A MACRO / function that performs `xor` atomically.

Returns the new value.

#### `fio_atomic_or_fetch(p_obj, value)`

A MACRO / function that performs `or` atomically.

Returns the new value.

#### `fio_atomic_nand_fetch(p_obj, value)`

A MACRO / function that performs `nand` atomically.

Returns the new value.

#### `fio_atomic_compare_exchange_p(p_obj, p_expected, p_desired)`

A MACRO / function that performs a system specific `fio_atomic_compare_exchange` using pointers.

The behavior of this instruction is compiler / CPU architecture specific, where `p_expected` **SHOULD** be overwritten with the latest value of `p_obj`, but **MAY NOT**, depending on system and compiler implementations.

Returns 1 for successful exchange or 0 for failure.

#### Atomic Bitmap helpers

- `fio_atomic_bit_get(void *map, size_t bit)` - Gets the state of a bit atomically.

- `fio_atomic_bit_set(void *map, size_t bit)` - Sets a bit atomically (an **atomic** operation, thread-safe).

- `fio_atomic_bit_unset(void *map, size_t bit)` - Unsets a bit atomically (an **atomic** operation, thread-safe).

- `fio_atomic_bit_flip(void *map, size_t bit)` - Flips a bit atomically (an **atomic** operation, thread-safe).

-------------------------------------------------------------------------------

## a SpinLock style MultiLock

Atomic operations lend themselves easily to implementing spinlocks, so the facil.io STL includes one.

Spinlocks are effective for very short critical sections or when a a failure to acquire a lock allows the program to redirect itself to other pending tasks. 

However, in general, spinlocks should be avoided when a task might take a longer time to complete or when the program might need to wait for a high contention lock to become available.

#### `fio_lock_i`

A spinlock type based on a volatile unsigned char.

**Note**: the spinlock contains one main / default lock (`sub == 0`) and 7 sub-locks (`sub >= 1 && sub <= 7`), which could be managed:

- Separately / Jointly: using the `fio_trylock_group`, `fio_lock_group` and `fio_unlock_group` functions.
- Collectively: using the `fio_trylock_full`, `fio_lock_full` and `fio_unlock_full` functions.

#### `fio_lock(fio_lock_i *)`

Busy waits for the default lock (sub-lock `0`) to become available.

#### `fio_trylock(fio_lock_i *)`

Attempts to acquire the default lock (sub-lock `0`). Returns 0 on success and 1 on failure.

#### `fio_unlock(fio_lock_i *)`

Unlocks the default lock (sub-lock `0`), no matter which thread owns the lock.

#### `fio_is_locked(fio_lock_i *)`

Returns 1 if the (main) lock is engaged. Otherwise returns 0.

#### `uint8_t fio_trylock_group(fio_lock_i *lock, const uint8_t group)`

Tries to lock a group of sub-locks.

Combine a number of sub-locks using OR (`|`) and the FIO_LOCK_SUBLOCK(i)
macro. i.e.:

```c
if(fio_trylock_group(&lock,
                     FIO_LOCK_SUBLOCK(1) |
                     FIO_LOCK_SUBLOCK(2)) == 0) {
  // act in lock and then release the SAME lock with:
  fio_unlock_group(&lock, FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(2));
}
```

Returns 0 on success and 1 on failure.

#### `void fio_lock_group(fio_lock_i *lock, uint8_t group)`

Busy waits for a group lock to become available - not recommended.

See `fio_trylock_group` for details.

#### `void fio_unlock_group(fio_lock_i *lock, uint8_t group)`

Unlocks a sub-lock group, no matter which thread owns which sub-lock.

#### `fio_is_group_locked(fio_lock_i *, uint8_t group)`

Returns 1 if the specified group-lock is engaged. Otherwise returns 0.

#### `fio_trylock_full(fio_lock_i *lock)`

Tries to lock all sub-locks. Returns 0 on success and 1 on failure.

#### `fio_lock_full(fio_lock_i *lock)`

Busy waits for all sub lock to become available - not recommended.

#### `fio_unlock_full(fio_lock_i *lock)`

Unlocks all sub locks, no matter which thread owns which lock.

-------------------------------------------------------------------------------

## Linked Lists

The facil.io C STL provides a doubly-linked list implementation using macros. These are intrusive linked lists, meaning the list node is embedded within your data structure.

#### `fio_list_node_s`

```c
typedef struct fio_list_node_s {
  struct fio_list_node_s *next;
  struct fio_list_node_s *prev;
} fio_list_node_s;
```

A linked list arch-type. This struct should be embedded in your data structures to enable linked list functionality.

#### `FIO_LIST_NODE` / `FIO_LIST_HEAD`

```c
#define FIO_LIST_NODE fio_list_node_s
#define FIO_LIST_HEAD fio_list_node_s
```

Type aliases for linked list nodes and heads. Both are the same type - the distinction is semantic (a "head" is a sentinel node that marks the beginning/end of the list).

#### `FIO_LIST_INIT`

```c
#define FIO_LIST_INIT(obj) (fio_list_node_s) { .next = &(obj), .prev = &(obj) }
```

Initializes a `FIO_LIST_HEAD` object to an empty list state (pointing to itself).

Example:

```c
FIO_LIST_HEAD my_list = FIO_LIST_INIT(my_list);
```

#### `FIO_LIST_PUSH`

```c
#define FIO_LIST_PUSH(head, n)
```

UNSAFE macro for pushing a node to the end of a list (before the head).

**Parameters:**
- `head` - pointer to the list head (`fio_list_node_s *`)
- `n` - pointer to the node to push (`fio_list_node_s *`)

Example:

```c
typedef struct {
  int value;
  fio_list_node_s node;
} my_item_s;

FIO_LIST_HEAD list = FIO_LIST_INIT(list);
my_item_s item = {.value = 42};
FIO_LIST_PUSH(&list, &item.node);
```

#### `FIO_LIST_POP`

```c
#define FIO_LIST_POP(type, node_name, dest_ptr, head)
```

UNSAFE macro for popping a node from the front of a list.

**Parameters:**
- `type` - the type of the containing struct
- `node_name` - the name of the `fio_list_node_s` field within the struct
- `dest_ptr` - a pointer variable that will receive the popped item
- `head` - pointer to the list head (`fio_list_node_s *`)

Example:

```c
my_item_s *popped;
FIO_LIST_POP(my_item_s, node, popped, &list);
// popped now points to the first item (or the head if list was empty)
```

#### `FIO_LIST_REMOVE`

```c
#define FIO_LIST_REMOVE(n)
```

UNSAFE macro for removing a node from a list. Does not reset the node's pointers.

**Parameters:**
- `n` - pointer to the node to remove (`fio_list_node_s *`)

#### `FIO_LIST_REMOVE_RESET`

```c
#define FIO_LIST_REMOVE_RESET(n)
```

UNSAFE macro for removing a node from a list and resetting its pointers to point to itself.

**Parameters:**
- `n` - pointer to the node to remove (`fio_list_node_s *`)

#### `FIO_LIST_IS_EMPTY`

```c
#define FIO_LIST_IS_EMPTY(head) \
  ((!(head)) || ((!(head)->next) | ((head)->next == (head))))
```

UNSAFE macro for testing if a list is empty.

**Parameters:**
- `head` - pointer to the list head (`fio_list_node_s *`)

**Returns:** non-zero if the list is empty, zero otherwise.

#### `FIO_LIST_EACH`

```c
#define FIO_LIST_EACH(type, node_name, head, pos)
```

Loops through every node in the linked list except the head, from first to last.

**Parameters:**
- `type` - the type of the containing struct
- `node_name` - the name of the `fio_list_node_s` field within the struct
- `head` - pointer to the list head (`fio_list_node_s *`)
- `pos` - the variable name to use for the current item pointer

**Note**: Safe to use when removing the current node during iteration.

Example:

```c
typedef struct {
  int value;
  fio_list_node_s node;
} my_item_s;

FIO_LIST_HEAD list = FIO_LIST_INIT(list);
// ... add items to list ...

FIO_LIST_EACH(my_item_s, node, &list, item) {
  printf("Value: %d\n", item->value);
  // Safe to remove current item:
  // FIO_LIST_REMOVE(&item->node);
}
```

#### `FIO_LIST_EACH_REVERSED`

```c
#define FIO_LIST_EACH_REVERSED(type, node_name, head, pos)
```

Loops through every node in the linked list in reverse order (from last to first), except the head.

**Parameters:**
- `type` - the type of the containing struct
- `node_name` - the name of the `fio_list_node_s` field within the struct
- `head` - pointer to the list head (`fio_list_node_s *`)
- `pos` - the variable name to use for the current item pointer

**Note**: Safe to use when removing the current node during iteration.

Example:

```c
FIO_LIST_EACH_REVERSED(my_item_s, node, &list, item) {
  printf("Value (reversed): %d\n", item->value);
}
```

-------------------------------------------------------------------------------

## Indexed Linked Lists

Indexed Linked Lists can be used to create a linked list that uses indices relative to some root pointer (usually the root of an array) instead of absolute pointers. This:

1. Allows easy reallocation of the list without requiring pointer updates.
2. Could be used for memory optimization if the array limits are known.

The "head" index is usually validated by reserving the value of `-1` to indicate an empty list.

#### `fio_index32_node_s` / `fio_index16_node_s` / `fio_index8_node_s`

```c
typedef struct fio_index32_node_s { uint32_t next; uint32_t prev; } fio_index32_node_s;
typedef struct fio_index16_node_s { uint16_t next; uint16_t prev; } fio_index16_node_s;
typedef struct fio_index8_node_s { uint8_t next; uint8_t prev; } fio_index8_node_s;
```

Indexed linked list node types for different index sizes (32-bit, 16-bit, and 8-bit indices).

#### `FIO_INDEXED_LIST32_NODE` / `FIO_INDEXED_LIST16_NODE` / `FIO_INDEXED_LIST8_NODE`

```c
#define FIO_INDEXED_LIST32_NODE fio_index32_node_s
#define FIO_INDEXED_LIST32_HEAD uint32_t
#define FIO_INDEXED_LIST16_NODE fio_index16_node_s
#define FIO_INDEXED_LIST16_HEAD uint16_t
#define FIO_INDEXED_LIST8_NODE fio_index8_node_s
#define FIO_INDEXED_LIST8_HEAD uint8_t
```

Type aliases for indexed linked list nodes and heads.

#### `FIO_INDEXED_LIST_PUSH`

```c
#define FIO_INDEXED_LIST_PUSH(root, node_name, head, i)
```

UNSAFE macro for pushing a node to the end of an indexed list (before the head).

**Parameters:**
- `root` - pointer to the array of structs containing the indexed list nodes
- `node_name` - the name of the indexed list node field within the struct
- `head` - the index of the list head
- `i` - the index of the node to push

#### `FIO_INDEXED_LIST_UNSHIFT`

```c
#define FIO_INDEXED_LIST_UNSHIFT(root, node_name, head, i)
```

UNSAFE macro for adding a node to the beginning of an indexed list (updates head).

**Parameters:**
- `root` - pointer to the array of structs containing the indexed list nodes
- `node_name` - the name of the indexed list node field within the struct
- `head` - the index of the list head (will be updated to `i`)
- `i` - the index of the node to add

#### `FIO_INDEXED_LIST_REMOVE`

```c
#define FIO_INDEXED_LIST_REMOVE(root, node_name, i)
```

UNSAFE macro for removing a node from an indexed list.

**Parameters:**
- `root` - pointer to the array of structs containing the indexed list nodes
- `node_name` - the name of the indexed list node field within the struct
- `i` - the index of the node to remove

#### `FIO_INDEXED_LIST_REMOVE_RESET`

```c
#define FIO_INDEXED_LIST_REMOVE_RESET(root, node_name, i)
```

UNSAFE macro for removing a node from an indexed list and resetting its indices to point to itself.

**Parameters:**
- `root` - pointer to the array of structs containing the indexed list nodes
- `node_name` - the name of the indexed list node field within the struct
- `i` - the index of the node to remove

#### `FIO_INDEXED_LIST_EACH`

```c
#define FIO_INDEXED_LIST_EACH(root, node_name, head, pos)
```

Loops through every index in the indexed list, assuming `head` is valid.

**Parameters:**
- `root` - pointer to the array of structs containing the indexed list nodes
- `node_name` - the name of the indexed list node field within the struct
- `head` - the index of the list head
- `pos` - the variable name to use for the current index

#### `FIO_INDEXED_LIST_EACH_REVERSED`

```c
#define FIO_INDEXED_LIST_EACH_REVERSED(root, node_name, head, pos)
```

Loops through every index in the indexed list in reverse order, assuming `head` is valid.

**Parameters:**
- `root` - pointer to the array of structs containing the indexed list nodes
- `node_name` - the name of the indexed list node field within the struct
- `head` - the index of the list head
- `pos` - the variable name to use for the current index

-------------------------------------------------------------------------------

## Numeral / Vector Helper Types

The following union types hold (little endian) arrays of unsigned 64 bit numbers that are accessible also as byte arrays or smaller numeral types:

- `fio_u128`
- `fio_u256`
- `fio_u512`
- `fio_u1024`
- `fio_u2048`
- `fio_u4096`

#### `fio_u128`

```c
typedef union {
  size_t uz[16 / sizeof(size_t)];
  uint64_t u64[2];
  uint32_t u32[4];
  uint16_t u16[8];
  uint8_t u8[16];
  int64_t i64[2];
  int32_t i32[4];
  // ... plus vector types if supported
} fio_u128 FIO_ALIGN(16);
```

An unsigned 128 bit union type.

#### `fio_u256`

An unsigned 256 bit union type. Same structure as `fio_u128` but with larger arrays.

#### `fio_u512`

An unsigned 512 bit union type.

### Numeral / Vector Helper Type Initialization

Fast and easy macros are provided for these numeral helper initialization, initializing any provided X bit words in least-significant-word ordering and initializing any remaining higher words with zero.

#### `fio_u128_init8` / `fio_u128_init16` / `fio_u128_init32` / `fio_u128_init64` ...

```c
#define fio_u128_init8(...)  ((fio_u128){.u8 = {__VA_ARGS__}})
#define fio_u128_init16(...) ((fio_u128){.u16 = {__VA_ARGS__}})
#define fio_u128_init32(...) ((fio_u128){.u32 = {__VA_ARGS__}})
#define fio_u128_init64(...) ((fio_u128){.u64 = {__VA_ARGS__}})
// ... similar for fio_u256, fio_u512, etc.
```

### Numeral / Vector Helper Type Load / Store

These numerals can be stored and loaded from memory using big endian / little endian formatting:

#### `fio_u128_load`, `fio_u256_load` ...

- `fio_u128 fio_u128_load(const void *buf)` - load in native ordering.
- `void fio_u128_store(void *buf, const fio_u128 a)` - store in native ordering.
- `fio_u128 fio_u128_load_le16(const void *buf)` - load in little endian ordering using 16 bit words.
- `fio_u128 fio_u128_load_be16(const void *buf)` - load in big endian ordering using 16 bit words.
- `fio_u128 fio_u128_bswap16(const void *buf)` - load in and byte-swap using 16 bit words.
- ... similar for 32 and 64 bit words, and for larger types.

### Numeral / Vector Helper Type Operation

Common mathematical operations are provided for the Vector Helper Types.

#### `fio_u128_add16`, `fio_u256_sub32`, `fio_u512_mul64` ...

These functions follow the naming scheme of `fio_u##TOTAL_BITS##_##OP##WORD_BITS`, where `TOTAL_BITS` is the total number of bits, `OP` is the name of the operation (`add`, `sub`, `mul`, etc') and `WORD_BITS` is the number of bits in each vector "word".

Supported operations (`OP`) are: `add`, `sub`, `mul`, `and`, `or`, `xor`.

#### Multi-Precision `fio_u128_add`, `fio_u256_sub`, `fio_u512_mul` ...

These functions provide Multi-Precision operations for the Numeral / Vector Helper Types.

- `bool fio_u128_add(fio_u128 *t, fio_u128 *a, fio_u128 *b)` - performs ADD (`t=a+b`), returning the carry bit.
- `bool fio_u256_sub(fio_u256 *t, fio_u256 *a, fio_u256 *b)` - performs SUB (`t=a-b`), returning the borrow bit.
- `void fio_u512_mul(fio_u512 *t, fio_u256 *a, fio_u256 *b)` - performs MUL (`t=a*b`) operation.

-------------------------------------------------------------------------------

## Core Randomness

The core module provides macros for generating semi-deterministic Pseudo-Random Number Generator functions.

#### `fio_cycle_counter`

```c
uint64_t fio_cycle_counter(void);
```

Returns the CPU cycle counter. Uses `rdtsc` on x86, `cntvct_el0` on ARM64, or returns 0 on unsupported platforms.

#### `FIO_DEFINE_RANDOM128_FN`

```c
#define FIO_DEFINE_RANDOM128_FN(extern, name, reseed_log, seed_offset)
```

Defines a semi-deterministic Pseudo-Random 128 bit Number Generator function.

The following functions will be defined:

```c
extern fio_u128 name##128(void); // returns 128 bits
extern uint64_t name##64(void);  // returns 64 bits (simply half of the 128 bit result)
extern void name##_bytes(void *buffer, size_t len); // fills a buffer
extern void name##_reset(void); // resets the state of the PRNG
extern void name##_reseed(void); // reseeds the PRNG using time and jitter
extern void name##_on_fork(void *is_null); // reseeds the PRNG (for fork safety)
```

If `reseed_log` is non-zero and less than 64, the PNGR is no longer deterministic, as it will automatically re-seeds itself every `1 << reseed_log` iterations using a loop measuring both time and CPU 'jitter'.

If `extern` is `static` or `FIO_SFUNC`, a `static` function will be defined.

-------------------------------------------------------------------------------

## Core Binary Strings and Buffer Helpers

Some informational types and helpers are always defined (similarly to the [Linked Lists Macros](#linked-lists-macros)). These include:

#### `fio_str_info_s`

Some functions use the `fio_str_info_s` type to either collect or return string related information. This helper type is defined as:

```c
typedef struct fio_str_info_s {
  size_t len;  /* The string's length, if any. */
  char *buf;   /* The string's buffer (pointer to first byte) or NULL on error. */
  size_t capa; /* The buffer's capacity. Zero (0) indicates the buffer is read-only. */
} fio_str_info_s;
```

Note that it is often the case that the data in the string object could be binary, where NUL is a valid character, so using C string functions isn't advised.

Also, note that `capa` might be `0` or otherwise less than `len`. This would indicate the data might be non-mutable (overwriting the string might break things).


#### `fio_buf_info_s`

```c
typedef struct fio_buf_info_s {
  size_t len; /* The buffer's length, if any. */
  char *buf;  /* The buffer's address (may be NULL if no buffer). */
} fio_buf_info_s;
```

An information type for reporting/storing buffer data (no `capa`). Note that the buffer may contain binary data and is **not** likely to be NUL terminated.

#### `FIO_STR_INFO0`

```c
#define FIO_STR_INFO0 ((fio_str_info_s){0})
```

A NULL fio_str_info_s.

#### `FIO_STR_INFO_IS_EQ`

```c
#define FIO_STR_INFO_IS_EQ(s1, s2)
```

This helper MACRO compares two `fio_str_info_s` / `fio_buf_info_s` objects for content equality.

#### `FIO_BUF_INFO_IS_EQ`

```c
#define FIO_BUF_INFO_IS_EQ(s1, s2) FIO_STR_INFO_IS_EQ((s1), (s2))
```

This helper MACRO compares two `fio_buf_info_s` objects for content equality.

#### `FIO_STR_INFO1`

```c
#define FIO_STR_INFO1(str)                                                     \
  ((fio_str_info_s){.len = FIO_STRLEN((str)), .buf = (str)})
```

Converts a C String into a `fio_str_info_s`.

#### `FIO_STR_INFO2`

```c
#define FIO_STR_INFO2(str, length)                                             \
  ((fio_str_info_s){.len = (length), .buf = (str)})
```

Converts a String with a known length into a `fio_str_info_s`.

#### `FIO_STR_INFO3`

```c
#define FIO_STR_INFO3(str, length, capacity)                                   \
  ((fio_str_info_s){.len = (length), .buf = (str), .capa = (capacity)})
```

Converts a String with a known length and capacity into a `fio_str_info_s`.

#### `FIO_BUF_INFO0`

```c
#define FIO_BUF_INFO0 ((fio_buf_info_s){0})
```

A NULL fio_buf_info_s.

#### `FIO_BUF_INFO1`

```c
#define FIO_BUF_INFO1(str)                                                     \
  ((fio_buf_info_s){.len = ((str) ? FIO_STRLEN((str)) : 0), .buf = (str)})
```

Converts a C String into a `fio_buf_info_s`.

#### `FIO_BUF_INFO2`

```c
#define FIO_BUF_INFO2(str, length)                                             \
  ((fio_buf_info_s){.len = (length), .buf = (str)})
```

Converts a String with a known length into a `fio_buf_info_s`.

#### `FIO_BUF2STR_INFO`

```c
#define FIO_BUF2STR_INFO(buf_info)                                             \
  ((fio_str_info_s){.len = (buf_info).len, .buf = (buf_info).buf})
```

Converts a `fio_buf_info_s` into a `fio_str_info_s`.

#### `FIO_STR2BUF_INFO`

```c
#define FIO_STR2BUF_INFO(str_info)                                             \
  ((fio_buf_info_s){.len = (str_info).len, .buf = (str_info).buf})
```

Converts a `fio_str_info_s` into a `fio_buf_info_s`.

#### `FIO_STR_INFO_TMP_VAR(name, capacity)`

```c
#define FIO_STR_INFO_TMP_VAR(name, capacity)                                   \
  char fio___stack_mem___##name[(capacity) + 1];                               \
  fio___stack_mem___##name[0] = 0; /* guard */                                 \
  fio_str_info_s name = (fio_str_info_s) {                                     \
    .buf = fio___stack_mem___##name, .capa = (capacity)                        \
  }
```

Creates a stack fio_str_info_s variable `name` with `capacity` bytes (including 1 extra byte for a `NUL` guard).

#### `FIO_STR_INFO_TMP_IS_REALLOCATED`

```c
#define FIO_STR_INFO_TMP_IS_REALLOCATED(name) (fio___stack_mem___##name != name.buf)
```

Tests to see if memory reallocation happened for a `FIO_STR_INFO_TMP_VAR`.

-------------------------------------------------------------------------------

### Core UTF-8 Support

Note, these functions are for single UTF-8 character / code-point handling, they don't check for memory bounds (may overflow) and aren't considered safe.

However, they could be used for writing safe a UTF-8 implementation if used with care. Assuming your strings end with a little padding or a NUL character, these should be safe to use (when writing, check available buffer before writing a possibly multi-byte UTF-8 char.

#### `fio_utf8_code_len`

```c
unsigned fio_utf8_code_len(uint32_t u);
```

Returns the number of bytes required to UTF-8 encoded a code point `u`.

#### `fio_utf8_char_len_unsafe`

```c
unsigned fio_utf8_char_len_unsafe(uint8_t c);
```

Returns 1-4 (UTF-8 char length), 8 (middle of a char) or 0 (invalid).

Use only to re-collect lost length information after a successful `fio_utf8_write` or `fio_utf8_char_len` call.

#### `fio_utf8_char_len`

```c
unsigned fio_utf8_char_len(const void *str);
```

Returns the number of valid UTF-8 bytes used by first char at `str`.

If `str` doesn't point to a valid UTF-8 encoded code-point, returns 0.

**Note**: This function also tests all the following bytes that are part of the same UTF-8 character.


#### `fio_utf8_write`

```c
unsigned fio_utf8_write(void *dest, uint32_t u);
```

Writes code point to `dest` using UFT-8. Returns number of bytes written.

Possible use pattern will be:

```c
dest += fio_utf8_write(dest, u);
```


#### `fio_utf8_read`

```c
uint32_t fio_utf8_read(char **str);
```

Decodes the first UTF-8 char at `str` and returns its code point value.

Advances the pointer at `str` by the number of bytes consumed (read).

#### `fio_utf8_peek`

```c
uint32_t fio_utf8_peek(const char *str);
```

Decodes the first UTF-8 char at `str` and returns its code point value.

Unlike `fio_utf8_read`, the pointer does not change.

-------------------------------------------------------------------------------
## Doubly Linked Lists

```c
#include "fio-stl.h"
```

Doubly Linked Lists are an incredibly common and useful data structure. The facil.io C STL provides macros and types for managing both pointer-based linked lists and indexed linked lists.

These macros are always defined by the CSTL core and can be used without defining any additional macros.

### Linked Lists Performance

Memory overhead (on 64bit machines) is 16 bytes per node (or 8 bytes on 32 bit machines) for the `next` and `prev` pointers.

Linked Lists use pointers in order to provide fast add/remove operations with O(1) speeds. This O(1) operation ignores the object allocation time and suffers from poor memory locality, but it's still very fast.

However, Linked Lists suffer from slow seek/find and iteration operations.

Seek/find has a worst case scenario O(n) cost and iteration suffers from a high likelihood of CPU cache misses, resulting in degraded performance.

-------------------------------------------------------------------------------

### Linked List Types

#### `FIO_LIST_NODE` / `FIO_LIST_HEAD`

```c
/** A linked list node type */
#define FIO_LIST_NODE fio_list_node_s
/** A linked list head type */
#define FIO_LIST_HEAD fio_list_node_s

/** A linked list arch-type */
typedef struct fio_list_node_s {
  struct fio_list_node_s *next;
  struct fio_list_node_s *prev;
} fio_list_node_s;
```

These are the basic core types for a linked list node used by the Linked List macros.

`FIO_LIST_NODE` and `FIO_LIST_HEAD` are both aliases for `fio_list_node_s`. The distinction is semantic - use `FIO_LIST_HEAD` for the list's head/root and `FIO_LIST_NODE` for nodes embedded in your data structures.

Example:

```c
typedef struct {
  FIO_LIST_NODE node;
  char *data;
} my_list_s;

FIO_LIST_HEAD my_list = FIO_LIST_INIT(my_list);
```

-------------------------------------------------------------------------------

### Linked List Macros

#### `FIO_LIST_INIT`

```c
#define FIO_LIST_INIT(obj) (fio_list_node_s){ .next = &(obj), .prev = &(obj) }
```

Initializes a linked list head so it points to itself (indicating an empty list).

Example:

```c
FIO_LIST_HEAD my_list = FIO_LIST_INIT(my_list);
```

#### `FIO_LIST_PUSH`

```c
#define FIO_LIST_PUSH(head, n)                                                 \
  do {                                                                         \
    (n)->prev = (head)->prev;                                                  \
    (n)->next = (head);                                                        \
    (head)->prev->next = (n);                                                  \
    (head)->prev = (n);                                                        \
  } while (0)
```

UNSAFE macro for pushing a node to the end of a list (before the head).

**Parameters:**
- `head` - pointer to the list head (`FIO_LIST_HEAD *`)
- `n` - pointer to the node to push (`FIO_LIST_NODE *`)

**Note**: this macro does not test that the list / data was initialized before reading / writing to the memory pointed to by the list / node.

#### `FIO_LIST_POP`

```c
#define FIO_LIST_POP(type, node_name, dest_ptr, head)                          \
  do {                                                                         \
    (dest_ptr) = FIO_PTR_FROM_FIELD(type, node_name, ((head)->next));          \
    FIO_LIST_REMOVE(&(dest_ptr)->node_name);                                   \
  } while (0)
```

UNSAFE macro for popping a node from the beginning of a list.

**Parameters:**
- `type` - the underlying `struct` type of the list member
- `node_name` - the field name in `type` that is the `FIO_LIST_NODE` linking type
- `dest_ptr` - the pointer that will receive the popped list member
- `head` - pointer to the list head

**Note**: this macro does not test that the list / data was initialized before reading / writing to the memory pointed to by the list / node.

**Note**: using this macro with an empty list will produce **undefined behavior**.

Example:

```c
typedef struct {
  FIO_LIST_NODE node;
  int value;
} item_s;

FIO_LIST_HEAD list = FIO_LIST_INIT(list);
// ... add items to list ...

item_s *popped;
FIO_LIST_POP(item_s, node, popped, &list);
// popped now points to the first item, which has been removed from the list
```

#### `FIO_LIST_REMOVE`

```c
#define FIO_LIST_REMOVE(n)                                                     \
  do {                                                                         \
    (n)->prev->next = (n)->next;                                               \
    (n)->next->prev = (n)->prev;                                               \
  } while (0)
```

UNSAFE macro for removing a node from a list.

**Parameters:**
- `n` - pointer to the node to remove (`FIO_LIST_NODE *`)

**Note**: this macro does not test that the list / data was initialized before reading / writing to the memory pointed to by the list / node.

**Note**: after removal, the node's `next` and `prev` pointers still point to their old neighbors. Use `FIO_LIST_REMOVE_RESET` if you need the node to be self-referential after removal.

#### `FIO_LIST_REMOVE_RESET`

```c
#define FIO_LIST_REMOVE_RESET(n)                                               \
  do {                                                                         \
    (n)->prev->next = (n)->next;                                               \
    (n)->next->prev = (n)->prev;                                               \
    (n)->next = (n)->prev = (n);                                               \
  } while (0)
```

UNSAFE macro for removing a node from a list and resetting its pointers to point to itself.

**Parameters:**
- `n` - pointer to the node to remove (`FIO_LIST_NODE *`)

**Note**: this macro does not test that the list / data was initialized before reading / writing to the memory pointed to by the list / node.

#### `FIO_LIST_EACH`

```c
#define FIO_LIST_EACH(type, node_name, head, pos)                              \
  for (type *pos = FIO_PTR_FROM_FIELD(type, node_name, (head)->next),          \
            *next____p_ls_##pos =                                              \
                FIO_PTR_FROM_FIELD(type, node_name, (head)->next->next);       \
       pos != FIO_PTR_FROM_FIELD(type, node_name, (head));                     \
       (pos = next____p_ls_##pos),                                             \
            (next____p_ls_##pos =                                              \
                 FIO_PTR_FROM_FIELD(type,                                      \
                                    node_name,                                 \
                                    next____p_ls_##pos->node_name.next)))
```

Loops through every node in the linked list except the head.

This macro allows `pos` to point to the type that the linked list contains (rather than a pointer to the node type).

**Parameters:**
- `type` - the underlying `struct` type of the list members
- `node_name` - the field name in `type` that is the `FIO_LIST_NODE`
- `head` - pointer to the list head
- `pos` - the variable name to use for the current position in the loop

**Note**: it is safe to remove the current node (`pos`) during iteration.

Example:

```c
typedef struct {
  FIO_LIST_NODE node;
  void *data;
} ptr_list_s;

FIO_LIST_HEAD my_ptr_list = FIO_LIST_INIT(my_ptr_list);

// ... add items to list ...

FIO_LIST_EACH(ptr_list_s, node, &my_ptr_list, pos) {
  do_something_with(pos->data);
}
```

#### `FIO_LIST_EACH_REVERSED`

```c
#define FIO_LIST_EACH_REVERSED(type, node_name, head, pos)                     \
  for (type *pos = FIO_PTR_FROM_FIELD(type, node_name, (head)->prev),          \
            *next____p_ls_##pos =                                              \
                FIO_PTR_FROM_FIELD(type, node_name, (head)->next->prev);       \
       pos != FIO_PTR_FROM_FIELD(type, node_name, (head));                     \
       (pos = next____p_ls_##pos),                                             \
            (next____p_ls_##pos =                                              \
                 FIO_PTR_FROM_FIELD(type,                                      \
                                    node_name,                                 \
                                    next____p_ls_##pos->node_name.prev)))
```

Loops through every node in the linked list in reverse order (from tail to head).

**Parameters:**
- `type` - the underlying `struct` type of the list members
- `node_name` - the field name in `type` that is the `FIO_LIST_NODE`
- `head` - pointer to the list head
- `pos` - the variable name to use for the current position in the loop

**Note**: it is safe to remove the current node (`pos`) during iteration.

#### `FIO_LIST_IS_EMPTY`

```c
#define FIO_LIST_IS_EMPTY(head)                                                \
  ((!(head)) || ((!(head)->next) | ((head)->next == (head))))
```

Macro for testing if a list is empty.

**Parameters:**
- `head` - pointer to the list head

**Returns:** non-zero (true) if the list is empty or `head` is NULL, zero (false) otherwise.

-------------------------------------------------------------------------------

### Indexed Linked Lists

Indexed linked lists are often used to either save memory or make it easier to reallocate the memory used for the whole list. This is performed by storing index offsets instead of full pointers, allowing the offsets to use smaller type sizes.

For example, an Indexed Linked List might be added to objects in a cache array in order to implement a "least recently used" eviction policy. If the cache holds less than 65,536 members, then a 16 bit index is all that's required, reducing the list's overhead from 2 pointers (16 bytes on 64 bit systems) to a 4 byte overhead per cache member.

The "head" index is usually validated by reserving the value of `-1` (or the maximum value for the type) to indicate an empty list.

-------------------------------------------------------------------------------

### Indexed Linked List Types

#### `FIO_INDEXED_LIST32_NODE` / `FIO_INDEXED_LIST32_HEAD`

```c
/** A 32 bit indexed linked list node type */
typedef struct fio_index32_node_s {
  uint32_t next;
  uint32_t prev;
} fio_index32_node_s;

#define FIO_INDEXED_LIST32_NODE fio_index32_node_s
#define FIO_INDEXED_LIST32_HEAD uint32_t
```

A 32 bit indexed linked list node type, supporting up to 4,294,967,295 elements.

#### `FIO_INDEXED_LIST16_NODE` / `FIO_INDEXED_LIST16_HEAD`

```c
/** A 16 bit indexed linked list node type */
typedef struct fio_index16_node_s {
  uint16_t next;
  uint16_t prev;
} fio_index16_node_s;

#define FIO_INDEXED_LIST16_NODE fio_index16_node_s
#define FIO_INDEXED_LIST16_HEAD uint16_t
```

A 16 bit indexed linked list node type, supporting up to 65,535 elements.

#### `FIO_INDEXED_LIST8_NODE` / `FIO_INDEXED_LIST8_HEAD`

```c
/** An 8 bit indexed linked list node type */
typedef struct fio_index8_node_s {
  uint8_t next;
  uint8_t prev;
} fio_index8_node_s;

#define FIO_INDEXED_LIST8_NODE fio_index8_node_s
#define FIO_INDEXED_LIST8_HEAD uint8_t
```

An 8 bit indexed linked list node type, supporting up to 255 elements.

-------------------------------------------------------------------------------

### Indexed Linked List Macros

#### `FIO_INDEXED_LIST_PUSH`

```c
#define FIO_INDEXED_LIST_PUSH(root, node_name, head, i)                        \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[n__].node_name.prev = (root)[(head)].node_name.prev;                \
    (root)[n__].node_name.next = (head);                                       \
    (root)[(root)[(head)].node_name.prev].node_name.next = (n__);              \
    (root)[(head)].node_name.prev = (n__);                                     \
  } while (0)
```

UNSAFE macro for pushing a node to the end of an indexed list (before the head).

**Parameters:**
- `root` - pointer to the array containing the list elements
- `node_name` - the field name in the element type that is the indexed list node
- `head` - the index of the list head
- `i` - the index of the element to push

#### `FIO_INDEXED_LIST_UNSHIFT`

```c
#define FIO_INDEXED_LIST_UNSHIFT(root, node_name, head, i)                     \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[n__].node_name.next = (root)[(head)].node_name.next;                \
    (root)[n__].node_name.prev = (head);                                       \
    (root)[(root)[(head)].node_name.next].node_name.prev = (n__);              \
    (root)[(head)].node_name.next = (n__);                                     \
    (head) = (n__);                                                            \
  } while (0)
```

UNSAFE macro for adding a node to the beginning of an indexed list (making it the new head).

**Parameters:**
- `root` - pointer to the array containing the list elements
- `node_name` - the field name in the element type that is the indexed list node
- `head` - the index of the list head (will be updated to the new head)
- `i` - the index of the element to add

#### `FIO_INDEXED_LIST_REMOVE`

```c
#define FIO_INDEXED_LIST_REMOVE(root, node_name, i)                            \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[(root)[n__].node_name.prev].node_name.next =                        \
        (root)[n__].node_name.next;                                            \
    (root)[(root)[n__].node_name.next].node_name.prev =                        \
        (root)[n__].node_name.prev;                                            \
  } while (0)
```

UNSAFE macro for removing a node from an indexed list.

**Parameters:**
- `root` - pointer to the array containing the list elements
- `node_name` - the field name in the element type that is the indexed list node
- `i` - the index of the element to remove

#### `FIO_INDEXED_LIST_REMOVE_RESET`

```c
#define FIO_INDEXED_LIST_REMOVE_RESET(root, node_name, i)                      \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[(root)[n__].node_name.prev].node_name.next =                        \
        (root)[n__].node_name.next;                                            \
    (root)[(root)[n__].node_name.next].node_name.prev =                        \
        (root)[n__].node_name.prev;                                            \
    (root)[n__].node_name.next = (root)[n__].node_name.prev = (n__);           \
  } while (0)
```

UNSAFE macro for removing a node from an indexed list and resetting its links to point to itself.

**Parameters:**
- `root` - pointer to the array containing the list elements
- `node_name` - the field name in the element type that is the indexed list node
- `i` - the index of the element to remove

#### `FIO_INDEXED_LIST_EACH`

```c
#define FIO_INDEXED_LIST_EACH(root, node_name, head, pos)                      \
  for (size_t pos = (head),                                                    \
              stooper___hd = (head),                                           \
              stopper___ils___ = 0,                                            \
              pos##___nxt = (root)[(head)].node_name.next;                     \
       !stopper___ils___;                                                      \
       (stopper___ils___ = ((pos = pos##___nxt) == stooper___hd)),             \
              pos##___nxt = (root)[pos].node_name.next)
```

Loops through every index in the indexed list, **assuming `head` is valid**.

**Parameters:**
- `root` - pointer to the array containing the list elements
- `node_name` - the field name in the element type that is the indexed list node
- `head` - the index of the list head
- `pos` - the variable name to use for the current index in the loop

**Note**: it is safe to remove the current element during iteration.

Example:

```c
typedef struct {
  FIO_INDEXED_LIST32_NODE node;
  int value;
} indexed_item_s;

indexed_item_s items[100];
uint32_t head = 0;

// Initialize head to point to itself
items[0].node.next = items[0].node.prev = 0;

// ... add items to list ...

FIO_INDEXED_LIST_EACH(items, node, head, pos) {
  printf("Item at index %zu has value %d\n", pos, items[pos].value);
}
```

#### `FIO_INDEXED_LIST_EACH_REVERSED`

```c
#define FIO_INDEXED_LIST_EACH_REVERSED(root, node_name, head, pos)             \
  for (size_t pos = ((root)[(head)].node_name.prev),                           \
              pos##___nxt =                                                    \
                  ((root)[((root)[(head)].node_name.prev)].node_name.prev),    \
              stooper___hd = (head),                                           \
              stopper___ils___ = 0;                                            \
       !stopper___ils___;                                                      \
       ((stopper___ils___ = (pos == stooper___hd)),                            \
        (pos = pos##___nxt),                                                   \
        (pos##___nxt = (root)[pos##___nxt].node_name.prev)))
```

Loops through every index in the indexed list in reverse order, **assuming `head` is valid**.

**Parameters:**
- `root` - pointer to the array containing the list elements
- `node_name` - the field name in the element type that is the indexed list node
- `head` - the index of the list head
- `pos` - the variable name to use for the current index in the loop

**Note**: it is safe to remove the current element during iteration.

-------------------------------------------------------------------------------
## Logging and Assertions

```c
#define FIO_LOG
#include "fio-stl.h"
```

The logging module provides heap-allocation-free logging macros and assertion utilities. When `FIO_LOG` is defined, the `FIO_LOG2STDERR` function and related logging macros become functional (otherwise they are no-ops).

**Note:** `FIO_LOG` uses `libc` functions (`memcpy`, `vsnprintf`, `fwrite`) and cannot be used for authoring apps without `libc` unless these functions are implemented separately and shadowed by macros before the module is included.

**Note:** in **all** logging macros, `msg` **must** be a string literal (`const char *`).

### Logging Levels

The following logging level constants are always defined:

```c
#define FIO_LOG_LEVEL_NONE    0  /* No logging */
#define FIO_LOG_LEVEL_FATAL   1  /* Log fatal errors */
#define FIO_LOG_LEVEL_ERROR   2  /* Log errors and fatal errors */
#define FIO_LOG_LEVEL_WARNING 3  /* Log warnings, errors and fatal errors */
#define FIO_LOG_LEVEL_INFO    4  /* Log info, warnings, errors and fatal errors */
#define FIO_LOG_LEVEL_DEBUG   5  /* Log everything, including debug messages */
```

### Configuration Macros

#### `FIO_LOG_LENGTH_LIMIT`

```c
#define FIO_LOG_LENGTH_LIMIT 1024
```

Defines the maximum length of a log message. Messages exceeding this limit will be truncated. The default value is `1024`. It's recommended that this value be greater than 128.

#### `FIO_LOG_LEVEL_DEFAULT`

```c
#ifndef FIO_LOG_LEVEL_DEFAULT
#if DEBUG
#define FIO_LOG_LEVEL_DEFAULT FIO_LOG_LEVEL_DEBUG
#else
#define FIO_LOG_LEVEL_DEFAULT FIO_LOG_LEVEL_INFO
#endif
#endif
```

Sets the initial logging level. By default, the level is `FIO_LOG_LEVEL_INFO` (4) for normal compilation and `FIO_LOG_LEVEL_DEBUG` (5) when `DEBUG` is defined.

### Logging Level Control

#### `FIO_LOG_LEVEL_GET`

```c
#define FIO_LOG_LEVEL_GET() ((fio___log_level()))
```

Returns the current application-wide logging level as an integer.

#### `FIO_LOG_LEVEL_SET`

```c
#define FIO_LOG_LEVEL_SET(new_level) fio___log_level_set(new_level)
```

Sets the application-wide logging level to `new_level`. Returns the new level.

Example:

```c
FIO_LOG_LEVEL_SET(FIO_LOG_LEVEL_WARNING); // Only log warnings and above
int level = FIO_LOG_LEVEL_GET();          // Returns 3
```

### Core Logging Functions

#### `FIO_LOG2STDERR`

```c
void FIO_LOG2STDERR(const char *format, ...);
```

A `printf`-style function that logs a message to `stderr` without allocating heap memory for the string (unlike `fprintf` which might).

Messages exceeding `FIO_LOG_LENGTH_LIMIT` will be truncated with a warning.

**Note:** this function is defined as a static function, allowing it to be overridden by defining your own version before including the module.

#### `FIO_LOG_WRITE`

```c
#define FIO_LOG_WRITE(...) FIO_LOG2STDERR("(" FIO__FILE__ ":" FIO_MACRO2STR(__LINE__) "): " __VA_ARGS__)
```

Routes to `FIO_LOG2STDERR` after prefixing the message with the file name and line number where the log statement occurs.

### Logging Macros

All logging macros check the current log level before printing. If the log level is below the macro's threshold, the message is not printed.

#### `FIO_LOG_FATAL`

```c
#define FIO_LOG_FATAL(...) /* logs if level >= FIO_LOG_LEVEL_FATAL */
```

Logs a fatal error message **if** the log level is equal to or above `FIO_LOG_LEVEL_FATAL` (1).

Output is prefixed with `FATAL:` in bold inverse text.

#### `FIO_LOG_ERROR`

```c
#define FIO_LOG_ERROR(...) /* logs if level >= FIO_LOG_LEVEL_ERROR */
```

Logs an error message **if** the log level is equal to or above `FIO_LOG_LEVEL_ERROR` (2).

Output is prefixed with `ERROR:` in bold text.

#### `FIO_LOG_SECURITY`

```c
#define FIO_LOG_SECURITY(...) /* logs if level >= FIO_LOG_LEVEL_ERROR */
```

Logs a security-related message **if** the log level is equal to or above `FIO_LOG_LEVEL_ERROR` (2).

Output is prefixed with `SECURITY:` in bold text.

#### `FIO_LOG_WARNING`

```c
#define FIO_LOG_WARNING(...) /* logs if level >= FIO_LOG_LEVEL_WARNING */
```

Logs a warning message **if** the log level is equal to or above `FIO_LOG_LEVEL_WARNING` (3).

Output is prefixed with `WARNING:` in dim text.

#### `FIO_LOG_INFO`

```c
#define FIO_LOG_INFO(...) /* logs if level >= FIO_LOG_LEVEL_INFO */
```

Logs an informational message **if** the log level is equal to or above `FIO_LOG_LEVEL_INFO` (4).

Output is prefixed with `INFO:`.

#### `FIO_LOG_DEBUG`

```c
#define FIO_LOG_DEBUG(...) /* logs if level >= FIO_LOG_LEVEL_DEBUG */
```

Logs a debug message **if** the log level is equal to or above `FIO_LOG_LEVEL_DEBUG` (5).

Output is prefixed with `DEBUG:` followed by the file name and line number.

#### `FIO_LOG_DEBUG2`

```c
#define FIO_LOG_DEBUG2(...) /* logs if level >= FIO_LOG_LEVEL_DEBUG */
```

Same as `FIO_LOG_DEBUG` but without the file name and line number prefix.

Output is prefixed with `DEBUG:` only.

### Debug-Only Logging Macros

These macros only produce output when `DEBUG` is defined at compile time. Otherwise, they are no-ops with zero runtime overhead.

#### `FIO_LOG_DDEBUG`

```c
#define FIO_LOG_DDEBUG(...) /* FIO_LOG_DEBUG if DEBUG defined, else no-op */
```

Same as `FIO_LOG_DEBUG` when `DEBUG` is defined. Otherwise a no-op.

#### `FIO_LOG_DDEBUG2`

```c
#define FIO_LOG_DDEBUG2(...) /* FIO_LOG_DEBUG2 if DEBUG defined, else no-op */
```

Same as `FIO_LOG_DEBUG2` when `DEBUG` is defined. Otherwise a no-op.

#### `FIO_LOG_DERROR`

```c
#define FIO_LOG_DERROR(...) /* FIO_LOG_ERROR if DEBUG defined, else no-op */
```

Same as `FIO_LOG_ERROR` when `DEBUG` is defined. Otherwise a no-op.

#### `FIO_LOG_DSECURITY`

```c
#define FIO_LOG_DSECURITY(...) /* FIO_LOG_SECURITY if DEBUG defined, else no-op */
```

Same as `FIO_LOG_SECURITY` when `DEBUG` is defined. Otherwise a no-op.

#### `FIO_LOG_DWARNING`

```c
#define FIO_LOG_DWARNING(...) /* FIO_LOG_WARNING if DEBUG defined, else no-op */
```

Same as `FIO_LOG_WARNING` when `DEBUG` is defined. Otherwise a no-op.

#### `FIO_LOG_DINFO`

```c
#define FIO_LOG_DINFO(...) /* FIO_LOG_INFO if DEBUG defined, else no-op */
```

Same as `FIO_LOG_INFO` when `DEBUG` is defined. Otherwise a no-op.

### Assertion Macros

#### `FIO_ASSERT`

```c
#define FIO_ASSERT(cond, ...)
```

Reports an error unless `cond` is true. If the assertion fails:

1. Prints the message using `FIO_LOG_FATAL`
2. Prints the current `errno` value and its string description
3. Raises `SIGINT` (when `DEBUG` is defined) to allow debuggers to pause execution
4. Calls `abort()` to terminate the program

Example:

```c
void *ptr = malloc(size);
FIO_ASSERT(ptr, "memory allocation of %zu bytes failed", size);
```

#### `FIO_ASSERT_ALLOC`

```c
#define FIO_ASSERT_ALLOC(ptr) FIO_ASSERT((ptr), "memory allocation failed.")
```

A convenience macro for testing allocation failures. Equivalent to `FIO_ASSERT(ptr, "memory allocation failed.")`.

Example:

```c
void *ptr = malloc(size);
FIO_ASSERT_ALLOC(ptr);
```

#### `FIO_ASSERT_DEBUG`

```c
#define FIO_ASSERT_DEBUG(cond, ...)
```

Ignored unless `DEBUG` is defined.

When `DEBUG` is defined, reports an error unless `cond` is true. If the assertion fails:

1. Prints the message using `FIO_LOG_FATAL` with file name and line number
2. Prints the current `errno` value and its string description
3. Raises `SIGINT` to allow debuggers to catch the failure
4. Calls `exit(-1)` to terminate the program

**Note:** unlike `FIO_ASSERT`, this macro calls `exit(-1)` instead of `abort()`, and only raises `SIGINT` when `DEBUG` is defined.

#### `FIO_ASSERT_STATIC`

```c
#define FIO_ASSERT_STATIC(cond, msg)
```

Performs a static assertion test at compile time. If `cond` is false, compilation fails with the message `msg`.

**Note:** `cond` **must** be a constant expression and `msg` cannot contain format specifiers.

Example:

```c
FIO_ASSERT_STATIC(sizeof(int) >= 4, "int must be at least 32 bits");
```

### Example Usage

```c
#define FIO_LOG
#include "fio-stl.h"

int main(void) {
  // Set logging level
  FIO_LOG_LEVEL_SET(FIO_LOG_LEVEL_WARNING);
  
  // These will not print (below warning level)
  FIO_LOG_INFO("This info message won't appear");
  FIO_LOG_DEBUG("This debug message won't appear");
  
  // These will print
  FIO_LOG_WARNING("number invalid: %d", 42);
  FIO_LOG_ERROR("something went wrong");
  
  // Direct logging (always prints, ignores level)
  FIO_LOG2STDERR("Direct message to stderr");
  
  // Assertions
  void *ptr = malloc(100);
  FIO_ASSERT_ALLOC(ptr);
  
  int value = 5;
  FIO_ASSERT(value > 0, "value must be positive, got %d", value);
  
  free(ptr);
  return 0;
}
```

-------------------------------------------------------------------------------
## SIMD Types and Vector Operations

The facil.io C STL provides a comprehensive set of aligned union types, SIMD-aware vector operations, and multi-precision math primitives. These are always available as part of the core library -- no `#define` or `#include` is needed beyond the initial inclusion of the STL.

**Note**: the [Hex Read/Write](#hex-readwrite) functions are an exception -- they require `#define FIO_ATOL` before inclusion.

The library abstracts over three SIMD backends:

1. **ARM NEON** -- uses `uint64x2_t`, `uint32x4_t`, `uint16x8_t`, `uint8x16_t` intrinsics (128-bit vectors).
2. **GCC/Clang `vector_size`** -- uses compiler vector extensions for full-width vectors.
3. **Scalar fallback** -- uses plain C arrays, relying on compiler auto-vectorization.

The same source code compiles to efficient SIMD on all platforms. The backend is selected automatically at compile time based on available intrinsics and compiler features.

### SIMD Backend Selection

The SIMD backend is selected automatically at compile time. The library detects available intrinsics and chooses the best option:

| Platform | Detection condition | Effect |
|----------|-------------------|--------|
| ARM NEON + crypto | `__ARM_FEATURE_CRYPTO` and `__ARM_NEON` defined | Includes `arm_neon.h` and `arm_acle.h` |
| ARMv8.2-A SHA3 | `__ARM_FEATURE_SHA3` defined | Enables EOR3/RAX1/BCAX instructions |
| x86_64 | `__x86_64` and `immintrin.h` available | Includes `immintrin.h` |
| x86 SHA-NI | `__SHA__` defined | Enables SHA-NI instructions |

All intrinsic detection is guarded by `!defined(DEBUG) && !defined(NO_INTRIN)` -- intrinsics are disabled in debug builds and when `NO_INTRIN` is defined.

### SIMD Loop Helper

#### `FIO_FOR_UNROLL`

```c
#define FIO_FOR_UNROLL(iterations, size_of_loop, i, action)
```

An unrolled `for` loop macro that splits iteration into a remainder loop followed by fixed-stride batches (256 bytes / `size_of_loop` iterations per batch). This structure enables compiler auto-vectorization by presenting predictable, aligned loop bodies.

**Parameters:**
- `iterations` - total number of iterations to perform
- `size_of_loop` - number of bytes consumed by each `action` (used to compute batch size)
- `i` - the loop index variable name (accessible within `action`)
- `action` - an expression or statement to execute each iteration (may reference `i`)

Example:

```c
/* Zero out an array of 1000 uint32_t values with auto-vectorization hints */
uint32_t arr[1000];
FIO_FOR_UNROLL(1000, sizeof(uint32_t), i, arr[i] = 0);
```

**Note**: the remainder loop handles `iterations % (256 / size_of_loop)` elements first, then the main loop processes full 256-byte batches. This ensures correct behavior for any iteration count.

### Aligned Union Types (`fio_uXXX`)

The library defines six aligned union types for SIMD and multi-precision math: `fio_u128`, `fio_u256`, `fio_u512`, `fio_u1024`, `fio_u2048`, and `fio_u4096`.

Each type is a `union` containing multiple views of the same memory:

#### `fio_u128`

```c
typedef union fio_u128 {
  /* Unsigned integers */
  size_t   uz[16 / sizeof(size_t)];  /* native word array, system-dependent length */
  uint64_t u64[2];
  uint32_t u32[4];
  uint16_t u16[8];
  uint8_t  u8[16];
  /* Signed integers */
  ssize_t  iz[16 / sizeof(ssize_t)]; /* signed native word array */
  int64_t  i64[2];
  int32_t  i32[4];
  int16_t  i16[8];
  int8_t   i8[16];
  /* Floating point */
  float    f[16 / sizeof(float)];
  double   d[16 / sizeof(double)];
  long double ld[16 / sizeof(long double)];
  /* SIMD vector members - platform dependent */
  /* ARM NEON:    uint64x2_t x64[1]; uint32x4_t x32[1]; ... */
  /* GCC vector:  uint64_t __attribute__((vector_size(16))) x64[1]; ... */
  /* Scalar:      uint64_t x64[2]; uint32_t x32[4]; ... */
#if defined(__SIZEOF_INT128__)
  __uint128_t alignment_for_u128_[1]; /* forces 128-bit alignment on supported compilers */
#endif
} fio_u128 FIO_ALIGN(16);
```

**Note**: on compilers that support `__uint128_t` (detected via `__SIZEOF_INT128__`), an additional `__uint128_t alignment_for_u128_[1]` member is included to guarantee proper 128-bit alignment of the union.

#### `fio_u256`

```c
typedef union fio_u256 {
  fio_u128 u128[2];
  /* ... all unsigned, signed, float, and SIMD members for 256 bits ... */
#if defined(__SIZEOF_INT256__)
  __uint256_t alignment_for_u256_[1]; /* forces 256-bit alignment on supported compilers */
#endif
} fio_u256 FIO_ALIGN(32);
```

**Note**: on compilers that support `__uint256_t` (detected via `__SIZEOF_INT256__`), an additional alignment member is included. In practice, very few compilers define this type.

#### `fio_u512`

```c
typedef union fio_u512 {
  fio_u128 u128[4];
  fio_u256 u256[2];
  /* ... all data and SIMD members for 512 bits ... */
} fio_u512 FIO_ALIGN(64);
```

#### `fio_u1024`

```c
typedef union fio_u1024 {
  fio_u128 u128[8];
  fio_u256 u256[4];
  fio_u512 u512[2];
  /* ... all data and SIMD members for 1024 bits ... */
} fio_u1024 FIO_ALIGN(64);
```

#### `fio_u2048`

```c
typedef union fio_u2048 {
  fio_u128 u128[16];
  fio_u256 u256[8];
  fio_u512 u512[4];
  fio_u1024 u1024[2];
  /* ... all data and SIMD members for 2048 bits ... */
} fio_u2048 FIO_ALIGN(64);
```

#### `fio_u4096`

```c
typedef union fio_u4096 {
  fio_u128 u128[32];
  fio_u256 u256[16];
  fio_u512 u512[8];
  fio_u1024 u1024[4];
  fio_u2048 u2048[2];
  /* ... all data and SIMD members for 4096 bits ... */
} fio_u4096 FIO_ALIGN(64);
```

#### Data Member Array Lengths

Each union contains the following data member arrays. The array length depends on the total bit width:

| Member | Type | 128 | 256 | 512 | 1024 | 2048 | 4096 |
|--------|------|-----|-----|-----|------|------|------|
| `uz[]` / `iz[]` | `size_t` / `ssize_t` | 2* | 4* | 8* | 16* | 32* | 64* |
| `u64[]` / `i64[]` | `uint64_t` / `int64_t` | 2 | 4 | 8 | 16 | 32 | 64 |
| `u32[]` / `i32[]` | `uint32_t` / `int32_t` | 4 | 8 | 16 | 32 | 64 | 128 |
| `u16[]` / `i16[]` | `uint16_t` / `int16_t` | 8 | 16 | 32 | 64 | 128 | 256 |
| `u8[]` / `i8[]` | `uint8_t` / `int8_t` | 16 | 32 | 64 | 128 | 256 | 512 |
| `f[]` | `float` | 4 | 8 | 16 | 32 | 64 | 128 |
| `d[]` | `double` | 2 | 4 | 8 | 16 | 32 | 64 |
| `ld[]` | `long double` | * | * | * | * | * | * |

\* `uz[]`/`iz[]` and `ld[]` lengths are system-dependent (`sizeof(size_t)` and `sizeof(long double)` vary by platform).

#### SIMD Vector Members

The `x64[]`, `x32[]`, `x16[]`, `x8[]` members provide platform-specific SIMD vector access:

| Platform | `x64` type | `x32` type | `x16` type | `x8` type | Array length |
|----------|-----------|-----------|-----------|----------|-------------|
| ARM NEON | `uint64x2_t` | `uint32x4_t` | `uint16x8_t` | `uint8x16_t` | `bits / 128` |
| GCC `vector_size` | full-width vector | full-width vector | full-width vector | full-width vector | `1` |
| Scalar fallback | `uint64_t` | `uint32_t` | `uint16_t` | `uint8_t` | `bits / 64`, `bits / 32`, etc. |

#### Nesting

Larger types nest smaller ones for convenient sub-vector access:

| Type | Nested members |
|------|---------------|
| `fio_u256` | `u128[2]` |
| `fio_u512` | `u128[4]`, `u256[2]` |
| `fio_u1024` | `u128[8]`, `u256[4]`, `u512[2]` |
| `fio_u2048` | `u128[16]`, `u256[8]`, `u512[4]`, `u1024[2]` |
| `fio_u4096` | `u128[32]`, `u256[16]`, `u512[8]`, `u1024[4]`, `u2048[2]` |

#### Alignment

| Type | Alignment |
|------|-----------|
| `fio_u128` | 16 bytes |
| `fio_u256` | 32 bytes |
| `fio_u512` | 64 bytes |
| `fio_u1024` | 64 bytes |
| `fio_u2048` | 64 bytes |
| `fio_u4096` | 64 bytes |

### Init Macros

Each `fio_uXXX` type has four initialization macros that initialize via the corresponding unsigned integer array member:

```c
#define fio_uXXX_init8(...)  ((fio_uXXX){.u8 = {__VA_ARGS__}})
#define fio_uXXX_init16(...) ((fio_uXXX){.u16 = {__VA_ARGS__}})
#define fio_uXXX_init32(...) ((fio_uXXX){.u32 = {__VA_ARGS__}})
#define fio_uXXX_init64(...) ((fio_uXXX){.u64 = {__VA_ARGS__}})
```

Example:

```c
/* Initialize a 256-bit value with four 64-bit words */
fio_u256 val = fio_u256_init64(0x0123456789ABCDEF,
                                0xFEDCBA9876543210,
                                0x1111111111111111,
                                0x2222222222222222);

/* Initialize a 128-bit value with 16 bytes */
fio_u128 key = fio_u128_init8(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
```

**Complete list of init macros:**

| 128-bit | 256-bit | 512-bit | 1024-bit | 2048-bit | 4096-bit |
|---------|---------|---------|----------|----------|----------|
| `fio_u128_init8` | `fio_u256_init8` | `fio_u512_init8` | `fio_u1024_init8` | `fio_u2048_init8` | `fio_u4096_init8` |
| `fio_u128_init16` | `fio_u256_init16` | `fio_u512_init16` | `fio_u1024_init16` | `fio_u2048_init16` | `fio_u4096_init16` |
| `fio_u128_init32` | `fio_u256_init32` | `fio_u512_init32` | `fio_u1024_init32` | `fio_u2048_init32` | `fio_u4096_init32` |
| `fio_u128_init64` | `fio_u256_init64` | `fio_u512_init64` | `fio_u1024_init64` | `fio_u2048_init64` | `fio_u4096_init64` |

### Load / Store / Endian Operations

For each `fio_uXXX` type (128, 256, 512, 1024, 2048, 4096), the library generates 11 functions for loading from memory, storing to memory, and byte-swapping with endian conversion.

#### Representative Signatures

```c
/* Load from memory in local (native) endian order */
fio_uXXX fio_uXXX_load(const void *buf);

/* Store to memory in local (native) endian order */
void fio_uXXX_store(void *buf, const fio_uXXX a);

/* Load, converting 16/32/64-bit words from little-endian */
fio_uXXX fio_uXXX_load_le16(const void *buf);
fio_uXXX fio_uXXX_load_le32(const void *buf);
fio_uXXX fio_uXXX_load_le64(const void *buf);

/* Load, converting 16/32/64-bit words from big-endian */
fio_uXXX fio_uXXX_load_be16(const void *buf);
fio_uXXX fio_uXXX_load_be32(const void *buf);
fio_uXXX fio_uXXX_load_be64(const void *buf);

/* Byte-swap each 16/32/64-bit word in place */
fio_uXXX fio_uXXX_bswap16(fio_uXXX a);
fio_uXXX fio_uXXX_bswap32(fio_uXXX a);
fio_uXXX fio_uXXX_bswap64(fio_uXXX a);
```

Example:

```c
/* Load 256 bits from a buffer, treating each 64-bit word as big-endian */
uint8_t wire_data[32] = { /* ... network data ... */ };
fio_u256 val = fio_u256_load_be64(wire_data);

/* Store back to a buffer in local endian */
uint8_t local_buf[32];
fio_u256_store(local_buf, val);
```

#### Complete Function List

| Function pattern | 128 | 256 | 512 | 1024 | 2048 | 4096 |
|-----------------|-----|-----|-----|------|------|------|
| `fio_uXXX_load` | `fio_u128_load` | `fio_u256_load` | `fio_u512_load` | `fio_u1024_load` | `fio_u2048_load` | `fio_u4096_load` |
| `fio_uXXX_store` | `fio_u128_store` | `fio_u256_store` | `fio_u512_store` | `fio_u1024_store` | `fio_u2048_store` | `fio_u4096_store` |
| `fio_uXXX_load_le16` | `fio_u128_load_le16` | `fio_u256_load_le16` | `fio_u512_load_le16` | `fio_u1024_load_le16` | `fio_u2048_load_le16` | `fio_u4096_load_le16` |
| `fio_uXXX_load_le32` | `fio_u128_load_le32` | `fio_u256_load_le32` | `fio_u512_load_le32` | `fio_u1024_load_le32` | `fio_u2048_load_le32` | `fio_u4096_load_le32` |
| `fio_uXXX_load_le64` | `fio_u128_load_le64` | `fio_u256_load_le64` | `fio_u512_load_le64` | `fio_u1024_load_le64` | `fio_u2048_load_le64` | `fio_u4096_load_le64` |
| `fio_uXXX_load_be16` | `fio_u128_load_be16` | `fio_u256_load_be16` | `fio_u512_load_be16` | `fio_u1024_load_be16` | `fio_u2048_load_be16` | `fio_u4096_load_be16` |
| `fio_uXXX_load_be32` | `fio_u128_load_be32` | `fio_u256_load_be32` | `fio_u512_load_be32` | `fio_u1024_load_be32` | `fio_u2048_load_be32` | `fio_u4096_load_be32` |
| `fio_uXXX_load_be64` | `fio_u128_load_be64` | `fio_u256_load_be64` | `fio_u512_load_be64` | `fio_u1024_load_be64` | `fio_u2048_load_be64` | `fio_u4096_load_be64` |
| `fio_uXXX_bswap16` | `fio_u128_bswap16` | `fio_u256_bswap16` | `fio_u512_bswap16` | `fio_u1024_bswap16` | `fio_u2048_bswap16` | `fio_u4096_bswap16` |
| `fio_uXXX_bswap32` | `fio_u128_bswap32` | `fio_u256_bswap32` | `fio_u512_bswap32` | `fio_u1024_bswap32` | `fio_u2048_bswap32` | `fio_u4096_bswap32` |
| `fio_uXXX_bswap64` | `fio_u128_bswap64` | `fio_u256_bswap64` | `fio_u512_bswap64` | `fio_u1024_bswap64` | `fio_u2048_bswap64` | `fio_u4096_bswap64` |

That is 11 functions x 6 sizes = **66 functions** total.

### Low-Level Vector Helper Macros

These macros form the building blocks for all higher-level `fio_uXXX` vector operations. `FIO_MATH_UXXX_OP`, `COP`, `SOP`, and `TOP` operate on the `.xN[]` SIMD vector members (benefiting from hardware SIMD when available). `FIO_MATH_UXXX_REDUCE` and `FIO_MATH_UXXX_SUFFLE` operate on the `.uN[]` unsigned integer array members instead.

#### `FIO_MATH_UXXX_OP`

```c
#define FIO_MATH_UXXX_OP(t, a, b, bits, op)
```

Lane-wise binary operation: `t.xN[i] = a.xN[i] op b.xN[i]` for each lane `i`.

- `t` - target `fio_uXXX` value (modified in place)
- `a`, `b` - source `fio_uXXX` values
- `bits` - selects the union member (64 for `.x64`, 32 for `.x32`, etc.)
- `op` - C binary operator (`+`, `-`, `*`, `&`, `|`, `^`)

#### `FIO_MATH_UXXX_COP`

```c
#define FIO_MATH_UXXX_COP(t, a, b, bits, op)
```

Lane-wise operation with a scalar constant: `t.xN[i] = a.xN[i] op b` for each lane `i`.

- `b` - a scalar constant (not a `fio_uXXX` value)
- All other parameters are the same as `FIO_MATH_UXXX_OP`.

#### `FIO_MATH_UXXX_SOP`

```c
#define FIO_MATH_UXXX_SOP(t, a, bits, op)
```

Lane-wise unary operation: `t.xN[i] = op a.xN[i]` for each lane `i`.

- `op` - C unary operator (e.g., `~` for bitwise NOT)

#### `FIO_MATH_UXXX_TOP`

```c
#define FIO_MATH_UXXX_TOP(t, a, b, c, bits, expr)
```

Lane-wise ternary operation: `t.xN[i] = expr(a.xN[i], b.xN[i], c.xN[i])` for each lane `i`.

- `expr` - a function-like macro taking three arguments (e.g., a macro expanding to `(z) ^ ((x) & ((y) ^ (z)))` for mux/choose)

#### `FIO_MATH_UXXX_REDUCE`

```c
#define FIO_MATH_UXXX_REDUCE(t, a, bits, op)
```

Horizontal reduction across all lanes: `t = a.uN[0] op a.uN[1] op ... op a.uN[last]`.

- `t` - scalar result variable
- Uses `.uN[]` (unsigned integer array), not `.xN[]` (vector array)

#### `FIO_MATH_UXXX_SUFFLE`

```c
#define FIO_MATH_UXXX_SUFFLE(var, bits, ...)
```

Reorders lanes by index array: `var.uN[i] = var.uN[index[i]]` for each lane `i`. Uses the `.u##bits[]` unsigned integer array member (not the `.x##bits[]` vector member).

- `var` - the `fio_uXXX` value to shuffle (modified in place)
- `bits` - selects the word width for shuffling (accesses `.u##bits[]`)
- `...` - comma-separated index values

**Note**: the macro name is intentionally misspelled as "SUFFLE" (not "SHUFFLE"). When searching the codebase for shuffle operations, look for `SUFFLE`.

**Note**: for `FIO_MATH_UXXX_OP`, `COP`, `SOP`, and `TOP`, the `bits` parameter selects the `.x##bits[]` vector union member, **NOT** the element size. The loop count is `sizeof(t.xN) / sizeof(t.xN[0])`, which varies by platform: 1 for GCC `vector_size`, `bits/128` for NEON, `bits/64` (or `bits/32`, etc.) for scalar fallback. For `REDUCE` and `SUFFLE`, the `bits` parameter selects the `.u##bits[]` scalar array member instead.

### Lane-Wise Operations (Pointer-Based)

These functions perform lane-wise binary operations on `fio_uXXX` types through pointers. They are generated for all 6 sizes (128, 256, 512, 1024, 2048, 4096), 4 word widths (8, 16, 32, 64), and 6 operations.

#### Signature Pattern

```c
void fio_uXXX_opN(fio_uXXX *target, const fio_uXXX *a, const fio_uXXX *b);
```

Where `op` is one of `add`, `sub`, `mul`, `and`, `or`, `xor` and `N` is one of `8`, `16`, `32`, `64`.

#### Operations

| Operation | Operator | Description |
|-----------|----------|-------------|
| `add` | `+` | Lane-wise addition |
| `sub` | `-` | Lane-wise subtraction |
| `mul` | `*` | Lane-wise multiplication |
| `and` | `&` | Lane-wise bitwise AND |
| `or` | `\|` | Lane-wise bitwise OR |
| `xor` | `^` | Lane-wise bitwise XOR |

#### Complete Function List (6 ops x 4 widths x 6 sizes = 144 functions)

| Pattern | Word widths | Sizes |
|---------|-------------|-------|
| `fio_uXXX_addN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_subN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_mulN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_andN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_orN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_xorN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |

For example: `fio_u256_add32`, `fio_u512_xor64`, `fio_u1024_mul8`, etc.

#### Untyped (64-bit Lane) Pointer-Based Operations

Additionally, untyped convenience functions operate on 64-bit lanes without a width suffix:

```c
void fio_uXXX_and(fio_uXXX *target, const fio_uXXX *a, const fio_uXXX *b);
void fio_uXXX_or(fio_uXXX *target, const fio_uXXX *a, const fio_uXXX *b);
void fio_uXXX_xor(fio_uXXX *target, const fio_uXXX *a, const fio_uXXX *b);
```

Available for all 6 sizes: 3 ops x 6 sizes = **18 functions**.

### Constant Operations (Pointer-Based)

These functions perform lane-wise operations between a `fio_uXXX` vector and a scalar constant.

#### Signature Pattern

```c
void fio_uXXX_copN(fio_uXXX *target, const fio_uXXX *a, uintN_t b);
```

Where `cop` is one of `cadd`, `csub`, `cmul`, `cand`, `cor`, `cxor` and `N` is one of `8`, `16`, `32`, `64`.

#### Complete Function List (6 ops x 4 widths x 6 sizes = 144 functions)

| Pattern | Word widths | Sizes |
|---------|-------------|-------|
| `fio_uXXX_caddN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_csubN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_cmulN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_candN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_corN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_cxorN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |

For example: `fio_u256_cadd32(&target, &a, 42)`, `fio_u512_cxor64(&target, &a, 0xFF)`.

### Reduce Operations (Pointer-Based)

These functions perform horizontal reduction across all lanes of a `fio_uXXX` type, returning a single scalar value.

#### Signature Pattern

```c
uintN_t fio_uXXX_reduce_opN(const fio_uXXX *a);
```

Where `op` is one of `add`, `sub`, `mul`, `and`, `or`, `xor` and `N` is one of `8`, `16`, `32`, `64`.

#### Complete Function List (6 ops x 4 widths x 6 sizes = 144 functions)

| Pattern | Word widths | Sizes |
|---------|-------------|-------|
| `fio_uXXX_reduce_addN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_reduce_subN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_reduce_mulN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_reduce_andN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_reduce_orN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_reduce_xorN` | 8, 16, 32, 64 | 128, 256, 512, 1024, 2048, 4096 |

For example: `uint64_t sum = fio_u256_reduce_add64(&val)`.

### Value-Returning SIMD Operations

These functions return `fio_uXXX` by value (not through pointers). They use the `.x64` vector member for maximum SIMD width.

#### Signature Pattern

```c
fio_uXXX fio_uXXX_xorv(fio_uXXX a, fio_uXXX b);   /* XOR */
fio_uXXX fio_uXXX_andv(fio_uXXX a, fio_uXXX b);   /* AND */
fio_uXXX fio_uXXX_orv(fio_uXXX a, fio_uXXX b);    /* OR */
fio_uXXX fio_uXXX_addv64(fio_uXXX a, fio_uXXX b); /* ADD (64-bit lanes) */
```

#### Complete Function List (4 ops x 6 sizes = 24 functions)

| Operation | 128 | 256 | 512 | 1024 | 2048 | 4096 |
|-----------|-----|-----|-----|------|------|------|
| XOR | `fio_u128_xorv` | `fio_u256_xorv` | `fio_u512_xorv` | `fio_u1024_xorv` | `fio_u2048_xorv` | `fio_u4096_xorv` |
| AND | `fio_u128_andv` | `fio_u256_andv` | `fio_u512_andv` | `fio_u1024_andv` | `fio_u2048_andv` | `fio_u4096_andv` |
| OR | `fio_u128_orv` | `fio_u256_orv` | `fio_u512_orv` | `fio_u1024_orv` | `fio_u2048_orv` | `fio_u4096_orv` |
| ADD (64-bit) | `fio_u128_addv64` | `fio_u256_addv64` | `fio_u512_addv64` | `fio_u1024_addv64` | `fio_u2048_addv64` | `fio_u4096_addv64` |

**Note**: the `v` suffix distinguishes these value-returning functions from the pointer-based variants. The return value carries the `warn_unused_result` attribute (`FIO_MIFN`).

Example:

```c
fio_u256 a = fio_u256_init64(1, 2, 3, 4);
fio_u256 b = fio_u256_init64(5, 6, 7, 8);
fio_u256 result = fio_u256_xorv(a, b);
/* result.u64[0] == 1^5, result.u64[1] == 2^6, ... */
```

### Comparison and Utility (Pointer-Based)

For each size XXX (128, 256, 512, 1024, 2048, 4096):

#### `fio_uXXX_is_eq`

```c
bool fio_uXXX_is_eq(const fio_uXXX *a, const fio_uXXX *b);
```

Returns `true` if `a` and `b` are equal (all bits identical). Implemented as XOR + OR reduction -- constant time.

#### `fio_uXXX_inv`

```c
void fio_uXXX_inv(fio_uXXX *target, const fio_uXXX *a);
```

Bitwise NOT (inversion): `target = ~a`. Operates on 64-bit lanes.

#### `fio_uXXX_ct_swap_if`

```c
void fio_uXXX_ct_swap_if(bool cond, fio_uXXX *restrict a, fio_uXXX *restrict b);
```

Constant-time conditional swap. If `cond` is true, swaps the contents of `a` and `b`. If `cond` is false, `a` and `b` are unchanged. Uses XOR-mask technique to avoid branching.

**Note**: this is safe for use in cryptographic code where branch timing must not leak information.

#### Complete Function List (3 ops x 6 sizes = 18 functions)

| Operation | 128 | 256 | 512 | 1024 | 2048 | 4096 |
|-----------|-----|-----|-----|------|------|------|
| Equality | `fio_u128_is_eq` | `fio_u256_is_eq` | `fio_u512_is_eq` | `fio_u1024_is_eq` | `fio_u2048_is_eq` | `fio_u4096_is_eq` |
| Invert | `fio_u128_inv` | `fio_u256_inv` | `fio_u512_inv` | `fio_u1024_inv` | `fio_u2048_inv` | `fio_u4096_inv` |
| CT Swap | `fio_u128_ct_swap_if` | `fio_u256_ct_swap_if` | `fio_u512_ct_swap_if` | `fio_u1024_ct_swap_if` | `fio_u2048_ct_swap_if` | `fio_u4096_ct_swap_if` |

### Ternary Operations

These functions perform lane-wise ternary bitwise operations commonly used in cryptographic hash functions (SHA-1, SHA-2, etc.).

#### Formulas

| Operation | Formula | Cryptographic name |
|-----------|---------|-------------------|
| **mux** (choose) | `z ^ (x & (y ^ z))` | Ch (SHA-1/2) |
| **maj** (majority) | `(x & y) \| (z & (x \| y))` | Maj (SHA-1/2) |
| **3xor** (parity) | `x ^ y ^ z` | Parity (SHA-1) |

#### Signature Patterns

For each operation, three variants exist: 32-bit lanes, 64-bit lanes, and untyped (64-bit):

```c
/* 32-bit lane variant */
void fio_uXXX_mux32(fio_uXXX *t, const fio_uXXX *a, const fio_uXXX *b, const fio_uXXX *c);
/* 64-bit lane variant */
void fio_uXXX_mux64(fio_uXXX *t, const fio_uXXX *a, const fio_uXXX *b, const fio_uXXX *c);
/* Untyped (64-bit lane) variant */
void fio_uXXX_mux(fio_uXXX *t, const fio_uXXX *a, const fio_uXXX *b, const fio_uXXX *c);
```

#### Complete Function List (3 ops x 3 variants x 6 sizes = 54 functions)

| Operation | Variants | Sizes |
|-----------|----------|-------|
| `fio_uXXX_mux32`, `fio_uXXX_mux64`, `fio_uXXX_mux` | 32-bit, 64-bit, untyped | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_maj32`, `fio_uXXX_maj64`, `fio_uXXX_maj` | 32-bit, 64-bit, untyped | 128, 256, 512, 1024, 2048, 4096 |
| `fio_uXXX_3xor32`, `fio_uXXX_3xor64`, `fio_uXXX_3xor` | 32-bit, 64-bit, untyped | 128, 256, 512, 1024, 2048, 4096 |

### Multi-Precision Math

These functions provide arbitrary-precision integer arithmetic on `fio_uXXX` types. All operations assume LSW (Least Significant Word) ordering within the `.u64[]` array.

**Note**: `fio_uXXX_add`, `fio_uXXX_sub`, and `fio_uXXX_cmp` use `FIO_MIFN` (static inline, warn-unused-result). `fio_uXXX_mul` and `fio_uXXX_montgomery_mul` use `FIO_SFUNC` (static, **non-inline**), unlike the lane-wise operations which use `FIO_IFUNC` (always-inline). This means multiply and Montgomery multiply are compiled as regular function calls, which affects code generation and may prevent inlining in hot loops.

#### Addition and Subtraction

```c
uint64_t fio_uXXX_add(fio_uXXX *result, const fio_uXXX *a, const fio_uXXX *b);
uint64_t fio_uXXX_sub(fio_uXXX *result, const fio_uXXX *a, const fio_uXXX *b);
```

Performs multi-precision addition or subtraction. Returns the carry (for `add`) or borrow (for `sub`) as 1 or 0.

#### Comparison

```c
int fio_uXXX_cmp(const fio_uXXX *a, const fio_uXXX *b);
```

Returns `-1` if `a < b`, `0` if `a == b`, or `1` if `a > b`. Constant-time implementation.

#### Complete Add/Sub/Cmp List (3 ops x 6 sizes = 18 functions)

| Operation | 128 | 256 | 512 | 1024 | 2048 | 4096 |
|-----------|-----|-----|-----|------|------|------|
| Add | `fio_u128_add` | `fio_u256_add` | `fio_u512_add` | `fio_u1024_add` | `fio_u2048_add` | `fio_u4096_add` |
| Sub | `fio_u128_sub` | `fio_u256_sub` | `fio_u512_sub` | `fio_u1024_sub` | `fio_u2048_sub` | `fio_u4096_sub` |
| Cmp | `fio_u128_cmp` | `fio_u256_cmp` | `fio_u512_cmp` | `fio_u1024_cmp` | `fio_u2048_cmp` | `fio_u4096_cmp` |

#### Widening Multiply

```c
void fio_uXXX_mul(fio_uYYY *result, const fio_uXXX *a, const fio_uXXX *b);
```

Multiplies two `fio_uXXX` values and stores the full double-width result in a `fio_uYYY` (where `YYY = 2 * XXX`).

Available for sizes 128 through 2048 (5 functions):

| Function | Input type | Result type |
|----------|-----------|-------------|
| `fio_u128_mul` | `fio_u128` | `fio_u256` |
| `fio_u256_mul` | `fio_u256` | `fio_u512` |
| `fio_u512_mul` | `fio_u512` | `fio_u1024` |
| `fio_u1024_mul` | `fio_u1024` | `fio_u2048` |
| `fio_u2048_mul` | `fio_u2048` | `fio_u4096` |

**Note**: `fio_u4096_mul` is not available because there is no `fio_u8192` type to hold the result.

#### Montgomery Multiplication

```c
void fio_uXXX_montgomery_mul(fio_uXXX *result,
                              const fio_uXXX *a,
                              const fio_uXXX *b,
                              const fio_uXXX *N,
                              const fio_uXXX *N_dash);
```

Performs Montgomery modular multiplication: `result = (a * b * R^-1) mod N`, where `R = 2^bits` and `N_dash` is the Montgomery constant `N' = -N^-1 mod R`.

Available for the same sizes as widening multiply (5 functions):

| Function | Size |
|----------|------|
| `fio_u128_montgomery_mul` | 128-bit |
| `fio_u256_montgomery_mul` | 256-bit |
| `fio_u512_montgomery_mul` | 512-bit |
| `fio_u1024_montgomery_mul` | 1024-bit |
| `fio_u2048_montgomery_mul` | 2048-bit |

Example:

```c
/* Multi-precision addition with carry detection */
fio_u256 a = fio_u256_init64(0xFFFFFFFFFFFFFFFF, 0, 0, 0);
fio_u256 b = fio_u256_init64(1, 0, 0, 0);
fio_u256 result;
uint64_t carry = fio_u256_add(&result, &a, &b);
/* result.u64[0] == 0, result.u64[1] == 1, carry == 0 */

/* Widening multiply: 128-bit x 128-bit -> 256-bit */
fio_u128 x = fio_u128_init64(0x123456789ABCDEF0, 0);
fio_u128 y = fio_u128_init64(0xFEDCBA9876543210, 0);
fio_u256 product;
fio_u128_mul(&product, &x, &y);
```

### Native Numeral Vector Operations (Array-Based)

These operations work on plain C arrays of native types (not `fio_uXXX` unions). They are written with the hope that the compiler will replace the naive implementations with SIMD instructions where possible.

#### Integer Types and Lengths

| Type prefix | C type | Available lengths |
|-------------|--------|-------------------|
| `u8` | `uint8_t` | 4, 8, 16, 32, 64, 128, 256 |
| `u16` | `uint16_t` | 2, 4, 8, 16, 32, 64, 128 |
| `u32` | `uint32_t` | 2, 4, 8, 16, 32, 64 |
| `u64` | `uint64_t` | 2, 4, 8, 16, 32 |

#### Float Types and Lengths

| Type prefix | C type | Available lengths |
|-------------|--------|-------------------|
| `float` | `float` | 2, 4, 8, 16, 32, 64 |
| `dbl` | `double` | 2, 4, 8, 16, 32 |

#### Integer Operations

For each integer type/length combination, the following operations are available:

**Binary operations** (signature: `void fio_{type}x{len}_{op}({type} *dest, {type} *a, {type} *b)`):

| Operation | Operator | Description |
|-----------|----------|-------------|
| `add` | `+` | Element-wise addition |
| `sub` | `-` | Element-wise subtraction |
| `mul` | `*` | Element-wise multiplication |
| `and` | `&` | Element-wise bitwise AND |
| `or` | `\|` | Element-wise bitwise OR |
| `xor` | `^` | Element-wise bitwise XOR |

**Reduce operations** (signature: `{type} fio_{type}x{len}_reduce_{op}({type} *v)`):

| Operation | Description |
|-----------|-------------|
| `reduce_add` | Sum of all elements |
| `reduce_sub` | Sequential subtraction of all elements |
| `reduce_mul` | Product of all elements |
| `reduce_and` | Bitwise AND of all elements |
| `reduce_or` | Bitwise OR of all elements |
| `reduce_xor` | Bitwise XOR of all elements |
| `reduce_max` | Maximum element |
| `reduce_min` | Minimum element |

**Reshuffle** (macro: `fio_{type}x{len}_reshuffle(v, ...)`):

Reorders elements by index. The variadic arguments specify the source index for each destination position.

#### Float Operations

Float types have a reduced operation set:

**Binary operations**: `add`, `mul`

**Reduce operations**: `reduce_add`, `reduce_mul`, `reduce_max`, `reduce_min`

**Reshuffle**: `reshuffle`

**Note**: float types do NOT support `sub`, `and`, `or`, `xor`, `reduce_sub`, `reduce_and`, `reduce_or`, `reduce_xor`.

#### Naming Convention

All functions follow the pattern `fio_{type}x{len}_{op}(...)`.

Examples:

```c
uint32_t a[4] = {1, 2, 3, 4};
uint32_t b[4] = {5, 6, 7, 8};
uint32_t dest[4];

/* Element-wise addition */
fio_u32x4_add(dest, a, b);
/* dest = {6, 8, 10, 12} */

/* Horizontal sum */
uint32_t sum = fio_u32x4_reduce_add(a);
/* sum = 10 */

/* Reshuffle: reverse order */
fio_u32x4_reshuffle(a, 3, 2, 1, 0);
/* a = {4, 3, 2, 1} */
```

#### Reshuffle Macros

The reshuffle functions are shadowed by macros that convert variadic arguments into the required index array:

```c
#define fio_u8x4_reshuffle(v, ...)     fio_u8x4_reshuffle(v,     (uint8_t[4]){__VA_ARGS__})
#define fio_u16x4_reshuffle(v, ...)    fio_u16x4_reshuffle(v,    (uint8_t[4]){__VA_ARGS__})
#define fio_u32x4_reshuffle(v, ...)    fio_u32x4_reshuffle(v,    (uint8_t[4]){__VA_ARGS__})
/* ... etc. for all type/length combinations */
```

Complete list of reshuffle macros:

| Type | Lengths |
|------|---------|
| `fio_u8xN_reshuffle` | 4, 8, 16, 32, 64, 128, 256 |
| `fio_u16xN_reshuffle` | 2, 4, 8, 16, 32, 64, 128 |
| `fio_u32xN_reshuffle` | 2, 4, 8, 16, 32, 64 |
| `fio_u64xN_reshuffle` | 2, 4, 8, 16, 32 |
| `fio_floatxN_reshuffle` | 2, 4, 8, 16, 32, 64 |
| `fio_dblxN_reshuffle` | 2, 4, 8, 16, 32 |

### FIO_VEC_* Macros

Generic vector operation macros that work with any array type. These use `FIO_FOR_UNROLL` internally for auto-vectorization.

#### Building Block Macros

#### `FIO_VEC_SIMPLE_OP`

```c
#define FIO_VEC_SIMPLE_OP(result, a, b, len, op)
```

Performs `result[i] = a[i] op b[i]` for `len` elements using `FIO_FOR_UNROLL`.

#### `FIO_VEC_SCALAR_OP`

```c
#define FIO_VEC_SCALAR_OP(result, v, sclr, len, op)
```

Performs `result[i] = v[i] op sclr` for `len` elements using `FIO_FOR_UNROLL`.

#### `FIO_VEC_REDUCE_OP`

```c
#define FIO_VEC_REDUCE_OP(result, vec, len, op)
```

Performs `result = result op vec[i]` for `len` elements using `FIO_FOR_UNROLL`.

**Note**: `result` should be initialized before calling (e.g., to 0 for addition, 1 for multiplication).

#### High-Level Vector Macros

#### `FIO_VEC_ADD`

```c
#define FIO_VEC_ADD(result, a, b, len)
```

Adds two vectors element-wise: `result[i] = a[i] + b[i]`.

#### `FIO_VEC_SUB`

```c
#define FIO_VEC_SUB(result, a, b, len)
```

Subtracts two vectors element-wise: `result[i] = a[i] - b[i]`.

#### `FIO_VEC_MUL`

```c
#define FIO_VEC_MUL(result, a, b, len)
```

Multiplies two vectors element-wise: `result[i] = a[i] * b[i]`.

#### `FIO_VEC_DOT`

```c
#define FIO_VEC_DOT(result, a, b, len)
```

Computes the dot product: `result += a[0]*b[0] + a[1]*b[1] + ... + a[len-1]*b[len-1]`.

**Note**: `result` should be initialized to 0 before calling.

#### `FIO_VEC_SCALAR_ADD`

```c
#define FIO_VEC_SCALAR_ADD(result, vec, scalar, vlen)
```

Adds a scalar to each element: `result[i] = vec[i] + scalar`.

#### `FIO_VEC_SCALAR_SUB`

```c
#define FIO_VEC_SCALAR_SUB(result, vec, scalar, vlen)
```

Subtracts a scalar from each element: `result[i] = vec[i] - scalar`.

#### `FIO_VEC_SCALAR_MUL`

```c
#define FIO_VEC_SCALAR_MUL(result, vec, scalar, vlen)
```

Multiplies each element by a scalar: `result[i] = vec[i] * scalar`.

#### `FIO_VEC_REDUCE_ADD`

```c
#define FIO_VEC_REDUCE_ADD(result, vec, vlen)
```

Sums all elements: `result = result + vec[0] + vec[1] + ...`.

#### `FIO_VEC_REDUCE_SUB`

```c
#define FIO_VEC_REDUCE_SUB(result, vec, vlen)
```

Subtracts all elements: `result = result - vec[0] - vec[1] - ...`.

#### `FIO_VEC_REDUCE_MUL`

```c
#define FIO_VEC_REDUCE_MUL(result, vec, vlen)
```

Multiplies all elements: `result = result * vec[0] * vec[1] * ...`.

Example:

```c
float a[8] = {1, 2, 3, 4, 5, 6, 7, 8};
float b[8] = {8, 7, 6, 5, 4, 3, 2, 1};
float result[8];
float dot = 0;

/* Element-wise addition */
FIO_VEC_ADD(result, a, b, 8);

/* Dot product */
FIO_VEC_DOT(dot, a, b, 8);
/* dot = 1*8 + 2*7 + 3*6 + 4*5 + 5*4 + 6*3 + 7*2 + 8*1 = 120 */

/* Scale vector by 2.0 */
FIO_VEC_SCALAR_MUL(result, a, 2.0f, 8);
```

### Hex Read/Write

These functions convert between `fio_uXXX` types and hexadecimal string representations. They require `FIO_ATOL` to be defined before inclusion.

```c
#define FIO_ATOL
#include "fio-stl/include.h"
```

#### `fio_uXXX_hex_read`

```c
fio_uXXX fio_uXXX_hex_read(char **pstr);
```

Reads a hexadecimal numeral string and returns the parsed value as a `fio_uXXX`. Advances `*pstr` past the consumed hex characters.

#### `fio_uXXX_hex_write`

```c
size_t fio_uXXX_hex_write(char *dest, const fio_uXXX *u);
```

Writes the `fio_uXXX` value as a hexadecimal string to `dest`. Returns the number of characters written. Prints out the underlying 64-bit array representation.

**Note**: `dest` must have enough space for the full hex representation (XXX/4 hex digits plus potential prefix).

**Note**: this function is primarily intended for **debugging** purposes (the source describes it as "Prints out the underlying 64 bit array (for debugging)").

#### Complete Function List (2 ops x 6 sizes = 12 functions)

| Size | Read | Write |
|------|------|-------|
| 128 | `fio_u128_hex_read` | `fio_u128_hex_write` |
| 256 | `fio_u256_hex_read` | `fio_u256_hex_write` |
| 512 | `fio_u512_hex_read` | `fio_u512_hex_write` |
| 1024 | `fio_u1024_hex_read` | `fio_u1024_hex_write` |
| 2048 | `fio_u2048_hex_read` | `fio_u2048_hex_write` |
| 4096 | `fio_u4096_hex_read` | `fio_u4096_hex_write` |

### SIMD Backend Abstraction

The `fio_uXXX` types and their operations provide a portable SIMD abstraction. The same application code compiles to efficient platform-specific instructions without `#ifdef` guards.

#### How It Works

The `.xN[]` union members (`.x64`, `.x32`, `.x16`, `.x8`) are defined differently depending on the platform:

**ARM NEON** (when NEON + crypto intrinsics are available):
```c
uint64x2_t x64[bits / 128];  /* array of 128-bit NEON vectors */
uint32x4_t x32[bits / 128];
uint16x8_t x16[bits / 128];
uint8x16_t x8[bits / 128];
```

**GCC/Clang `vector_size`** (`__has_attribute(vector_size)`):
```c
uint64_t __attribute__((vector_size(bits / 8))) x64[1];  /* single full-width vector */
uint32_t __attribute__((vector_size(bits / 8))) x32[1];
uint16_t __attribute__((vector_size(bits / 8))) x16[1];
uint8_t  __attribute__((vector_size(bits / 8))) x8[1];
```

**Scalar fallback**:
```c
uint64_t x64[bits / 64];  /* plain arrays */
uint32_t x32[bits / 32];
uint16_t x16[bits / 16];
uint8_t  x8[bits / 8];
```

The `FIO_MATH_UXXX_OP` macro (and friends) iterate over `sizeof(t.xN) / sizeof(t.xN[0])` elements. This yields:

| Platform | Loop iterations for `fio_u256` with `.x64` |
|----------|---------------------------------------------|
| GCC `vector_size` | **1** (single 256-bit vector operation) |
| ARM NEON | **2** (two 128-bit NEON operations) |
| Scalar | **4** (four 64-bit scalar operations) |

This means the same `FIO_MATH_UXXX_OP(r, a, b, 64, ^)` call compiles to a single vector XOR on GCC, two `veorq_u64` on NEON, or four scalar XORs on the fallback -- all from the same source code.

### Examples

#### Initializing and Using `fio_u256`

```c
#include "fio-stl/include.h"

void example_init(void) {
  /* Initialize from 64-bit words (LSW first) */
  fio_u256 a = fio_u256_init64(0x0011223344556677,
                                0x8899AABBCCDDEEFF,
                                0x0000000000000001,
                                0x0000000000000000);

  /* Access individual elements */
  printf("First 64-bit word: 0x%016llx\n", (unsigned long long)a.u64[0]);
  printf("First byte: 0x%02x\n", a.u8[0]);

  /* Access as 128-bit halves */
  fio_u128 low_half = a.u128[0];
  fio_u128 high_half = a.u128[1];
}
```

#### Loading/Storing with Endian Conversion

```c
void example_endian(void) {
  /* Simulate receiving big-endian data from network */
  uint8_t network_data[32];
  /* ... fill from network ... */

  /* Load, converting each 64-bit word from big-endian to local */
  fio_u256 val = fio_u256_load_be64(network_data);

  /* Process in local endian... */
  fio_u256 mask = fio_u256_init64(0xFF, 0xFF, 0xFF, 0xFF);
  fio_u256 masked;
  fio_u256_and(&masked, &val, &mask);

  /* Store back to buffer in local endian */
  uint8_t local_buf[32];
  fio_u256_store(local_buf, masked);
}
```

#### Lane-Wise Operations and Multi-Precision Math

```c
void example_operations(void) {
  fio_u256 a = fio_u256_init64(0xFFFFFFFFFFFFFFFF, 0, 0, 0);
  fio_u256 b = fio_u256_init64(1, 0, 0, 0);
  fio_u256 result;

  /* Multi-precision addition (propagates carry across 64-bit words) */
  uint64_t carry = fio_u256_add(&result, &a, &b);
  /* result.u64 = {0, 1, 0, 0}, carry = 0 */

  /* Lane-wise XOR (no carry propagation, operates per-lane) */
  fio_u256 x = fio_u256_init64(0xAA, 0xBB, 0xCC, 0xDD);
  fio_u256 y = fio_u256_init64(0xFF, 0xFF, 0xFF, 0xFF);
  fio_u256_xor64(&result, &x, &y);
  /* result.u64 = {0x55, 0x44, 0x33, 0x22} */

  /* Value-returning XOR (same operation, different calling convention) */
  fio_u256 r = fio_u256_xorv(x, y);

  /* Comparison */
  if (fio_u256_is_eq(&result, &r)) {
    printf("Results are equal\n");
  }

  /* Constant-time conditional swap */
  bool should_swap = (fio_u256_cmp(&x, &y) > 0);
  fio_u256_ct_swap_if(should_swap, &x, &y);
  /* Now x <= y (constant-time, no branch) */
}
```

------------------------------------------------------------
## String / Number Conversion

```c
#define FIO_ATOL
#include "fio-stl.h"
```

If the `FIO_ATOL` macro is defined, the following functions will be defined for converting between strings and numbers.

**Note**: all functions that write to a buffer also write a `NUL` terminator byte.

### Configuration Macros

#### `FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER`

```c
#define FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER 1
```

When set to `1` (default), allows underscores (`_`) to be used as digit separators when parsing numbers. For example, `1_000_000` would be parsed as `1000000`.

Set to `0` to disable this feature.

### Universal Number Parsing

#### `fio_aton_s`

```c
typedef struct {
  union {
    int64_t i;
    double f;
    uint64_t u;
  };
  int is_float;
  int err;
} fio_aton_s;
```

Result type for `fio_aton`. Contains the parsed number value and metadata about the parsing result.

**Members:**
- `i` - The parsed value as a signed 64-bit integer
- `f` - The parsed value as a double-precision float
- `u` - The parsed value as an unsigned 64-bit integer
- `is_float` - Non-zero if the parsed value is a floating-point number
- `err` - Non-zero if a parsing or overflow error occurred

#### `fio_aton`

```c
fio_aton_s fio_aton(char **pstr);
```

Converts a string to a number - either an integer or a float (double).

- Skips white space at the beginning of the string
- Auto detects binary and hex formats when prefix is provided (`0x` / `0b`)
- Auto detects octal when number starts with zero
- Auto detects the strings `"inf"`, `"infinity"` and `"nan"` as float values
- The number's format and type are returned in the return type
- If a numerical overflow or format error occurred, the `.err` flag is set

**Note**: rounding errors may occur, as this is not an exact `strtod` match.

### Signed Number / String Conversion

The most common use of number to string conversion (and string to number) relates to converting signed numbers.

However, consider using unsigned conversion where possible.

#### `fio_atol10`

```c
int64_t fio_atol10(char **pstr);
```

Reads a signed base 10 formatted number.

#### `fio_atol`

```c
int64_t fio_atol(char **pstr);
```

A helper function that converts between String data to a signed int64_t.

Numbers are assumed to be in base 10. Octal (`0###`), Hex (`0x##`/`x##`) and binary (`0b##`/ `b##`) are recognized as well. For binary Most Significant Bit must come first.

The most significant difference between this function and `strtol` (aside of API design), is the added support for binary representations.

#### `fio_ltoa`

```c
size_t fio_ltoa(char *dest, int64_t num, uint8_t base);
```

A helper function that writes a signed int64_t to a `NUL` terminated string.

If `dest` is `NULL`, returns the number of bytes that would have been written.

No overflow guard is provided, make sure there's at least 68 bytes available (for base 2).

Offers special support for base 2 (binary), base 8 (octal), base 10 and base 16 (hex) where prefixes are automatically added if required (i.e., `"0x"` for hex, `"0b"` for base 2, and `"0"` for octal).

Supports any base up to base 36 (using 0-9,A-Z).

An unsupported base will log an error and print zero.

Returns the number of bytes actually written (excluding the NUL terminator).

#### `fio_atof`

```c
double fio_atof(char **pstr);
```

A helper function that converts between String data to a signed double.

Currently wraps `strtod` with some special case handling.

#### `fio_ftoa`

```c
size_t fio_ftoa(char *dest, double num, uint8_t base);
```

A helper function that converts between a double to a string.

Currently wraps `snprintf` with some special case handling.

No overflow guard is provided, make sure there's at least 130 bytes available (for base 2).

Supports base 2, base 10 and base 16. An unsupported base will silently default to base 10. Prefixes aren't added (i.e., no `"0x"` or `"0b"` at the beginning of the string).

Returns the number of bytes actually written (excluding the NUL terminator).

#### `fio_ltoa10`

```c
void fio_ltoa10(char *dest, int64_t i, size_t digits);
```

Writes a signed number to `dest` using `digits` bytes (+ `NUL`). See also [`fio_digits10`](#fio_digits10).

### Unsigned Number / String Conversion

#### `fio_ltoa10u`

```c
void fio_ltoa10u(char *dest, uint64_t i, size_t digits);
```

Writes an unsigned number to `dest` using `digits` bytes (+ `NUL`).

#### `fio_ltoa8u`

```c
void fio_ltoa8u(char *dest, uint64_t i, size_t digits);
```

Writes an unsigned number to `dest` using `digits` bytes (+ `NUL`) in octal format (base 8).

#### `fio_ltoa16u`

```c
void fio_ltoa16u(char *dest, uint64_t i, size_t digits);
```

Writes an unsigned number to `dest` using `digits` bytes (+ `NUL`) in hex format (base 16).

**Note**: for hex based numerals facil.io assumes that `digits` are always even (2, 4, 6, 8, 10, 12, 14, 16).

#### `fio_ltoa_bin`

```c
void fio_ltoa_bin(char *dest, uint64_t i, size_t digits);
```

Writes an unsigned number to `dest` using `digits` bytes (+ `NUL`) in binary format (base 2).

#### `fio_ltoa_xbase`

```c
void fio_ltoa_xbase(char *dest, uint64_t i, size_t digits, size_t base);
```

Writes an unsigned number to `dest` using `digits` bytes (+ `NUL`) in `base` format (up to base 36 inclusive).

#### `fio_atol8u`

```c
uint64_t fio_atol8u(char **pstr);
```

Reads an unsigned base 8 formatted number.

#### `fio_atol10u`

```c
uint64_t fio_atol10u(char **pstr);
```

Reads an unsigned base 10 formatted number.

#### `fio_atol16u`

```c
uint64_t fio_atol16u(char **pstr);
```

Reads an unsigned hex formatted number (possibly prefixed with `"0x"`).

#### `fio_atol_bin`

```c
uint64_t fio_atol_bin(char **pstr);
```

Reads an unsigned binary formatted number (possibly prefixed with `"0b"`).

#### `fio_atol_xbase`

```c
uint64_t fio_atol_xbase(char **pstr, size_t base);
```

Read an unsigned number in any base up to base 36.

### Number / String Conversion Helpers

#### `fio_c2i`

```c
uint8_t fio_c2i(unsigned char c);
```

Maps characters to alphanumerical value, where numbers have their natural values (`0-9`) and `A-Z` (or `a-z`) map to the values `10-35`.

Out of bound values return 255.

This allows calculations for up to base 36.

#### `fio_i2c`

```c
uint8_t fio_i2c(unsigned char i);
```

Maps numeral values to alphanumerical characters, where numbers have their natural values (`0-9`) and `A-Z` are the values `10-35`.

Accepts values up to 63. Returns zero for values over 35. Out of bound values produce undefined behavior.

This allows printing of numerals for up to base 36.

#### `fio_u2i_limit`

```c
int64_t fio_u2i_limit(uint64_t val, size_t to_negative);
```

Converts an unsigned `val` to a signed `val`, limiting the value to provide overflow protection and limiting it to either a negative or a positive value.

#### `fio_digits10`

```c
size_t fio_digits10(int64_t i);
```

Returns the number of digits of the **signed** number when using base 10. The result includes the possible sign (`-`) digit.

This function can be used before allocating memory in order to predict the amount of memory required by a String representation of the number.

#### `fio_digits10u`

```c
size_t fio_digits10u(uint64_t i);
```

Returns the number of digits of the **unsigned** number when using base 10.

This function can be used before allocating memory in order to predict the amount of memory required by a String representation of the number.

#### `fio_digits8u`

```c
size_t fio_digits8u(uint64_t i);
```

Returns the number of digits of the **unsigned** number when using base 8.

This function can be used before allocating memory in order to predict the amount of memory required by a String representation of the number.

#### `fio_digits16u`

```c
size_t fio_digits16u(uint64_t i);
```

Returns the number of digits in base 16 for an **unsigned** number.

Base 16 digits are always computed in pairs (byte sized chunks). Possible values are 2, 4, 6, 8, 10, 12, 14 and 16.

This function can be used before allocating memory in order to predict the amount of memory required by a String representation of the number.

**Note**: facil.io always assumes all base 16 numeral representations are printed as they are represented in memory.

#### `fio_digits_bin`

```c
size_t fio_digits_bin(uint64_t i);
```

Returns the number of digits of the **unsigned** number when using base 2.

This function can be used before allocating memory in order to predict the amount of memory required by a String representation of the number.

#### `fio_digits_xbase`

```c
size_t fio_digits_xbase(uint64_t i, size_t base);
```

Returns the number of digits of the **unsigned** number when using base `base`.

This function can be used before allocating memory in order to predict the amount of memory required by a String representation of the number.

### IEEE 754 Floating Point Helpers

#### `fio_i2d`

```c
double fio_i2d(int64_t mant, int64_t exponent_in_base_2);
```

Converts a 64 bit signed integer mantissa and a base-2 exponent to an IEEE 754 formatted double.

#### `fio_u2d`

```c
double fio_u2d(uint64_t mant, int64_t exponent_in_base_2);
```

Converts a 64 bit unsigned integer mantissa and a base-2 exponent to an IEEE 754 formatted double.

### Big Number Conversion

These functions provide hex string conversion for large unsigned integer types.

#### `fio_u128_hex_read`

```c
fio_u128 fio_u128_hex_read(char **pstr);
```

Reads a hex numeral string and initializes a 128-bit unsigned integer.

#### `fio_u256_hex_read`

```c
fio_u256 fio_u256_hex_read(char **pstr);
```

Reads a hex numeral string and initializes a 256-bit unsigned integer.

#### `fio_u512_hex_read`

```c
fio_u512 fio_u512_hex_read(char **pstr);
```

Reads a hex numeral string and initializes a 512-bit unsigned integer.

#### `fio_u1024_hex_read`

```c
fio_u1024 fio_u1024_hex_read(char **pstr);
```

Reads a hex numeral string and initializes a 1024-bit unsigned integer.

#### `fio_u2048_hex_read`

```c
fio_u2048 fio_u2048_hex_read(char **pstr);
```

Reads a hex numeral string and initializes a 2048-bit unsigned integer.

#### `fio_u4096_hex_read`

```c
fio_u4096 fio_u4096_hex_read(char **pstr);
```

Reads a hex numeral string and initializes a 4096-bit unsigned integer.

#### `fio_u128_hex_write`

```c
size_t fio_u128_hex_write(char *dest, const fio_u128 *u);
```

Writes a 128-bit unsigned integer to `dest` as a hex string.

Returns the number of bytes written (excluding the NUL terminator).

#### `fio_u256_hex_write`

```c
size_t fio_u256_hex_write(char *dest, const fio_u256 *u);
```

Writes a 256-bit unsigned integer to `dest` as a hex string.

Returns the number of bytes written (excluding the NUL terminator).

#### `fio_u512_hex_write`

```c
size_t fio_u512_hex_write(char *dest, const fio_u512 *u);
```

Writes a 512-bit unsigned integer to `dest` as a hex string.

Returns the number of bytes written (excluding the NUL terminator).

#### `fio_u1024_hex_write`

```c
size_t fio_u1024_hex_write(char *dest, const fio_u1024 *u);
```

Writes a 1024-bit unsigned integer to `dest` as a hex string.

Returns the number of bytes written (excluding the NUL terminator).

#### `fio_u2048_hex_write`

```c
size_t fio_u2048_hex_write(char *dest, const fio_u2048 *u);
```

Writes a 2048-bit unsigned integer to `dest` as a hex string.

Returns the number of bytes written (excluding the NUL terminator).

#### `fio_u4096_hex_write`

```c
size_t fio_u4096_hex_write(char *dest, const fio_u4096 *u);
```

Writes a 4096-bit unsigned integer to `dest` as a hex string.

Returns the number of bytes written (excluding the NUL terminator).

-------------------------------------------------------------------------------
## Glob Matching

```c
#define FIO_GLOB_MATCH
#include "fio-stl.h"
```

By defining the macro `FIO_GLOB_MATCH`, the following glob pattern matching function is defined. This provides a binary glob matching helper useful for filtering strings against wildcard patterns.

#### `fio_glob_match`

```c
uint8_t fio_glob_match(fio_str_info_s pattern, fio_str_info_s string);
```

A **binary** glob matching helper that tests if `string` matches the glob `pattern`.

**Parameters:**

- `pattern` - the glob pattern to match against
- `string` - the string to test

**Returns:** `1` on a match, `0` otherwise.

**Note**: this function operates on raw bytes and does **not** support UTF-8 multi-byte characters for single-character matching (`?` and `[...]`).

### Supported Patterns

The following glob patterns are recognized:

#### Wildcard `*`

Matches any string, including an empty string.

```c
/* The following patterns will match against the string "String": */
fio_glob_match(FIO_STR_INFO1("*"), FIO_STR_INFO1("String"));        /* matches */
fio_glob_match(FIO_STR_INFO1("*String*"), FIO_STR_INFO1("String")); /* matches */
fio_glob_match(FIO_STR_INFO1("S*ing"), FIO_STR_INFO1("String"));    /* matches */
```

#### Single Character `?`

Matches any single **byte** (does NOT support UTF-8 characters).

```c
/* The following patterns will match against the string "String": */
fio_glob_match(FIO_STR_INFO1("?tring"), FIO_STR_INFO1("String")); /* matches */
fio_glob_match(FIO_STR_INFO1("Strin?"), FIO_STR_INFO1("String")); /* matches */
fio_glob_match(FIO_STR_INFO1("St?ing"), FIO_STR_INFO1("String")); /* matches */
```

#### Negated Character Class `[!...]` or `[^...]`

Matches any **byte** that is **not** within the brackets (does **not** support UTF-8 characters).

Byte ranges are supported using `-` (e.g., `[!0-9]` matches any non-digit).

Use the backslash (`\`) to escape the special `]`, `-` and `\` characters when they are part of the list.

```c
/* The following patterns will match against the string "String": */
fio_glob_match(FIO_STR_INFO1("[!a-z]tring"), FIO_STR_INFO1("String")); /* matches */
fio_glob_match(FIO_STR_INFO1("[^a-z]tring"), FIO_STR_INFO1("String")); /* matches */
fio_glob_match(FIO_STR_INFO1("[^F]tring"), FIO_STR_INFO1("String"));   /* matches */
```

#### Character Class `[...]`

Matches any **byte** that **is** within the brackets (does **not** support UTF-8 characters).

Byte ranges are supported using `-` (e.g., `[a-z]` matches any lowercase letter).

Use the backslash (`\`) to escape the special `]`, `-` and `\` characters when they are part of the list.

```c
/* The following patterns will match against the string "String": */
fio_glob_match(FIO_STR_INFO1("[A-Z]tring"), FIO_STR_INFO1("String")); /* matches */
fio_glob_match(FIO_STR_INFO1("[sS]tring"), FIO_STR_INFO1("String"));  /* matches */
```

#### Escape Character `\`

The backslash can be used to escape special characters (`*`, `?`, `[`, `\`) so they are matched literally.

```c
/* Match a literal asterisk */
fio_glob_match(FIO_STR_INFO1("file\\*"), FIO_STR_INFO1("file*")); /* matches */
```

### Example

```c
#define FIO_GLOB_MATCH
#define FIO_STR
#include "fio-stl.h"

int main(void) {
  fio_str_info_s pattern = FIO_STR_INFO1("*.txt");
  fio_str_info_s filename = FIO_STR_INFO1("document.txt");

  if (fio_glob_match(pattern, filename)) {
    printf("File matches pattern!\n");
  } else {
    printf("No match.\n");
  }

  /* More examples */
  fio_glob_match(FIO_STR_INFO1("test_*"), FIO_STR_INFO1("test_file"));   /* 1 */
  fio_glob_match(FIO_STR_INFO1("data[0-9]"), FIO_STR_INFO1("data5"));    /* 1 */
  fio_glob_match(FIO_STR_INFO1("log_????"), FIO_STR_INFO1("log_2024"));  /* 1 */
  fio_glob_match(FIO_STR_INFO1("[A-Z]*"), FIO_STR_INFO1("Hello"));       /* 1 */
  fio_glob_match(FIO_STR_INFO1("[!0-9]*"), FIO_STR_INFO1("abc"));        /* 1 */

  return 0;
}
```

-------------------------------------------------------------------------------
## iMap - Index Mapped Array (Hash Map - Array Combo)

```c
#define FIO_IMAP_CORE
#include "fio-stl.h"
```

The iMap module provides an indexed array data structure that combines the benefits of both arrays and hash maps. It maintains insertion order while providing fast O(1) lookups through an index map.

This is primarily **used internally** by other facil.io modules to minimize dependencies and avoid nested inclusions. For most use cases, it is recommended to use the `FIO_MAP_NAME` macro instead.

**Key Features:**
- Maintains insertion order for iteration
- Fast hash-based lookups
- Combines array storage with hash map indexing
- Suitable when both ordered iteration and random access are needed

**Note**: there is no automatic memory management when objects are removed or the iMap is destroyed. You must handle cleanup of stored objects manually.

-------------------------------------------------------------------------------

### Configuration Macros

#### `FIO_TYPEDEF_IMAP_REALLOC`

```c
#define FIO_TYPEDEF_IMAP_REALLOC FIO_MEM_REALLOC
```

Defines the reallocation function used by iMap. Defaults to `FIO_MEM_REALLOC`.

#### `FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE`

```c
#define FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE FIO_MEM_REALLOC_IS_SAFE
```

Indicates whether the reallocation function zeros out new memory. Defaults to `FIO_MEM_REALLOC_IS_SAFE`.

#### `FIO_TYPEDEF_IMAP_FREE`

```c
#define FIO_TYPEDEF_IMAP_FREE FIO_MEM_FREE
```

Defines the deallocation function used by iMap. Defaults to `FIO_MEM_FREE`.

-------------------------------------------------------------------------------

### Helper Macros

#### `FIO_IMAP_ALWAYS_VALID`

```c
#define FIO_IMAP_ALWAYS_VALID(o) (1)
```

A helper macro for simple iMap array types where all objects are considered valid.

#### `FIO_IMAP_ALWAYS_CMP_TRUE`

```c
#define FIO_IMAP_ALWAYS_CMP_TRUE(a, b) (1)
```

A helper macro for simple iMap array types where all comparisons return true.

#### `FIO_IMAP_ALWAYS_CMP_FALSE`

```c
#define FIO_IMAP_ALWAYS_CMP_FALSE(a, b) (0)
```

A helper macro for simple iMap array types where all comparisons return false.

#### `FIO_IMAP_SIMPLE_CMP`

```c
#define FIO_IMAP_SIMPLE_CMP(a, b) ((a)[0] == (b)[0])
```

A helper macro for simple iMap array types that compares the first element of two objects.

#### `FIO_IMAP_EACH`

```c
#define FIO_IMAP_EACH(array_name, map_ptr, i)                                  \
  for (size_t i = 0; i < (map_ptr)->w; ++i)                                    \
    if (!FIO_NAME(array_name, is_valid)((map_ptr)->ary + i))                   \
      continue;                                                                \
    else
```

Iterates over all valid elements in the iMap array.

Example:

```c
FIO_IMAP_EACH(my_array, &my_map, i) {
  printf("Element at index %zu: %d\n", i, my_map.ary[i].value);
}
```

-------------------------------------------------------------------------------

### Type Definition Macro

#### `FIO_TYPEDEF_IMAP_ARRAY`

```c
#define FIO_TYPEDEF_IMAP_ARRAY(array_name,                                     \
                               array_type,                                     \
                               imap_type,                                      \
                               hash_fn,                                        \
                               cmp_fn,                                         \
                               is_valid_fn)
```

This macro defines the type and functions needed for an indexed array.

An indexed array is a simple ordered array whose objects are indexed using an almost-hash map, allowing for easy seeking while also enjoying the advantages provided by the array structure.

The index map uses one `imap_type` (e.g., `uint64_t`) to store both the index in the array and any leftover hash data. The first half of the bits are tested during random access, and the remaining bits are used during comparison.

**Reserved Values:**
- `0` - indicates a free slot
- `~0` (all bits set) - indicates a freed item (a slot that was previously used)

**Parameters:**
- `array_name` - the prefix for all generated type and function names
- `array_type` - the type of elements stored in the array
- `imap_type` - the unsigned integer type for the index map (e.g., `uint32_t`, `uint64_t`)
- `hash_fn(ptr)` - a function/macro that computes a hash from a pointer to an element
- `cmp_fn(a_ptr, b_ptr)` - a function/macro that compares two elements by pointer
- `is_valid_fn(ptr)` - a function/macro that returns non-zero if the element is valid

**Note**: `hash_fn`, `cmp_fn`, and `is_valid_fn` all accept **pointers** to elements and must dereference them to access the content.

-------------------------------------------------------------------------------

### Generated Types

#### `array_name_s`

```c
typedef struct {
  array_type *ary;    /* Pointer to the array of elements */
  imap_type count;    /* Number of valid elements in the array */
  imap_type w;        /* Write position (next available index) */
  uint32_t capa_bits; /* Log2 of the capacity */
} array_name_s;
```

The main container type for the indexed array.

**Members:**
- `ary` - pointer to the array of stored elements
- `count` - the number of valid (non-removed) elements
- `w` - the write position, indicating the next available slot
- `capa_bits` - the capacity expressed as a power of 2 (actual capacity is `1 << capa_bits`)

#### `array_name_seeker_s`

```c
typedef struct {
  imap_type pos;     /* Position in the array */
  imap_type ipos;    /* Position in the index map */
  imap_type set_val; /* Value to set in the index map */
} array_name_seeker_s;
```

A seeker type returned by `array_name_seek` that contains position information.

**Members:**
- `pos` - the position of the element in the array (or `w` if not found)
- `ipos` - the position in the index map
- `set_val` - the value to write to the index map when inserting

-------------------------------------------------------------------------------

### Generated Functions

#### `array_name_is_valid`

```c
int array_name_is_valid(array_type *pobj);
```

Returns non-zero if the object pointed to by `pobj` is valid.

This is a wrapper around the `is_valid_fn` provided to `FIO_TYPEDEF_IMAP_ARRAY`.

#### `array_name_capa`

```c
size_t array_name_capa(array_name_s *a);
```

Returns the theoretical storage capacity for the indexed array.

The capacity is calculated as `1 << a->capa_bits`.

#### `array_name_imap`

```c
imap_type *array_name_imap(array_name_s *a);
```

Returns a pointer to the index map.

The index map is stored immediately after the array data in memory.

#### `array_name_destroy`

```c
void array_name_destroy(array_name_s *a);
```

Deallocates all dynamic memory associated with the indexed array.

**Note**: this does not call destructors on stored elements. You must clean up element resources before calling this function.

#### `array_name_seek`

```c
array_name_seeker_s array_name_seek(array_name_s *a, array_type *pobj);
```

Finds an object in the array or determines its future position.

**Parameters:**
- `a` - pointer to the indexed array
- `pobj` - pointer to the object to search for

**Returns:** a seeker struct containing:
- `pos` - the array index of the found element, or `a->w` if not found
- `ipos` - the index map position, or `~0` if no suitable slot was found
- `set_val` - the value to write to the index map when inserting

#### `array_name_reserve`

```c
int array_name_reserve(array_name_s *a, imap_type min);
```

Reserves a minimum storage capacity for the indexed array.

**Parameters:**
- `a` - pointer to the indexed array
- `min` - the minimum capacity to reserve

**Returns:** `0` on success, `-1` on failure.

#### `array_name_rehash`

```c
int array_name_rehash(array_name_s *a);
```

Rebuilds the index map from the current array contents.

Use this function after sorting the array or after any operation that changes element positions without updating the index map.

**Returns:** `0` on success, `-1` on failure.

#### `array_name_set`

```c
array_type *array_name_set(array_name_s *a, array_type obj, int overwrite);
```

Writes or overwrites data in the array.

**Parameters:**
- `a` - pointer to the indexed array
- `obj` - the object to insert
- `overwrite` - if non-zero, overwrites existing data; otherwise returns existing element

**Returns:** a pointer to the element in the array, or `NULL` on failure.

#### `array_name_get`

```c
array_type *array_name_get(array_name_s *a, array_type obj);
```

Finds an object in the array using the index map.

**Parameters:**
- `a` - pointer to the indexed array
- `obj` - an object with the key/hash to search for

**Returns:** a pointer to the found element, or `NULL` if not found.

#### `array_name_remove`

```c
int array_name_remove(array_name_s *a, array_type obj);
```

Removes an object from the array and zeros out its memory.

**Parameters:**
- `a` - pointer to the indexed array
- `obj` - an object with the key/hash to remove

**Returns:** `0` on success, `-1` if the object was not found.

**Note**: the element's memory is zeroed, but no destructor is called. Handle resource cleanup before calling this function.

-------------------------------------------------------------------------------

### Internal Seeker Types

The iMap module also provides internal seeker types and functions for different integer sizes. These are used internally by other facil.io modules.

#### `fio___imapN_seeker_s`

```c
typedef struct {
  uintN_t pos;     /* Position in the array */
  uintN_t ipos;    /* Position in the index map */
  uintN_t set_val; /* Value to set in the index map */
  bool is_valid;   /* True if a valid element was found */
} fio___imapN_seeker_s;
```

Where `N` is one of `8`, `16`, `32`, or `64`.

#### `fio___imapN_seek`

```c
fio___imapN_seeker_s fio___imapN_seek(
    void *ary,
    uintN_t *imap,
    const uintN_t capa_bits,
    void *pobj,
    uintN_t hash,
    bool cmp_fn(void *ary, void *obj, uintN_t indx),
    const size_t max_attempts);
```

A lower-level seek function that searches for an element in an index map.

**Parameters:**
- `ary` - pointer to the array
- `imap` - pointer to the index map
- `capa_bits` - log2 of the capacity
- `pobj` - pointer to the object to search for
- `hash` - the hash value of the object
- `cmp_fn` - comparison function
- `max_attempts` - maximum number of probing attempts

#### `fio___imapN_set`

```c
void fio___imapN_set(uintN_t *imap, uintN_t ipos, uintN_t set_val);
```

Sets a value in the index map at the specified position.

-------------------------------------------------------------------------------

### Example

```c
#define FIO_IMAP_CORE
#include "fio-stl.h"

/* Define a simple key-value pair type */
typedef struct {
  uint64_t key;
  int value;
} my_kv_s;

/* Hash function - takes a pointer, returns hash of the key */
static uint64_t my_kv_hash(my_kv_s *p) {
  return fio_risky_num(p->key, 0);
}

/* Comparison function - takes two pointers, returns true if keys match */
static int my_kv_cmp(my_kv_s *a, my_kv_s *b) {
  return a->key == b->key;
}

/* Validity function - takes a pointer, returns true if valid */
static int my_kv_valid(my_kv_s *p) {
  return p->key != 0;
}

/* Define the indexed array type */
FIO_TYPEDEF_IMAP_ARRAY(my_kv,        /* array_name */
                       my_kv_s,      /* array_type */
                       uint32_t,     /* imap_type */
                       my_kv_hash,   /* hash_fn */
                       my_kv_cmp,    /* cmp_fn */
                       my_kv_valid)  /* is_valid_fn */

int main(void) {
  my_kv_s map = {0};
  
  /* Insert some key-value pairs */
  my_kv_set(&map, (my_kv_s){.key = 1, .value = 100}, 1);
  my_kv_set(&map, (my_kv_s){.key = 2, .value = 200}, 1);
  my_kv_set(&map, (my_kv_s){.key = 3, .value = 300}, 1);
  
  /* Look up a value */
  my_kv_s *found = my_kv_get(&map, (my_kv_s){.key = 2});
  if (found) {
    printf("Found key 2 with value: %d\n", found->value);
  }
  
  /* Iterate over all elements (in insertion order) */
  FIO_IMAP_EACH(my_kv, &map, i) {
    printf("Key: %llu, Value: %d\n", 
           (unsigned long long)map.ary[i].key, 
           map.ary[i].value);
  }
  
  /* Remove an element */
  my_kv_remove(&map, (my_kv_s){.key = 2});
  
  /* Clean up */
  my_kv_destroy(&map);
  
  return 0;
}
```

-------------------------------------------------------------------------------
## Multi-Precision Math

```c
#define FIO_MATH
#include "fio-stl.h"
```

When requiring more than the core multi-precision ADD, SUB and MUL operations, `FIO_MATH` provides commonly used (yet more advanced) operations such as division, bit shifting, and bit index detection.

Note that this implementation assumes that the CPU performs MUL in constant time (which may or may not be true).

**Note**: The core multi-precision math building blocks (`fio_math_add`, `fio_math_sub`, `fio_math_mul`, `fio_math_addc64`, etc.) and the vector helper types (`fio_u128`, `fio_u256`, etc.) are always available as part of the core module and do not require `FIO_MATH` to be defined. See the [Core Module documentation](000 core.md) for details on those functions.

-------------------------------------------------------------------------------

### Multi-Precision Math with Little Endian Arrays

The following multi-precision math implementation focuses on constant time operations (where possible). It assumes an array of local endian 64-bit numbers ordered within the array in little endian (word `0` contains the least significant bits and word `n-1` contains the most significant bits).

#### `fio_math_div`

```c
void fio_math_div(uint64_t *dest,
                  uint64_t *reminder,
                  const uint64_t *a,
                  const uint64_t *b,
                  const size_t number_array_length);
```

Multi-precision DIV for `len*64` bit long numbers `a` and `b`.

Computes `a / b`, storing the quotient in `dest` and the remainder in `reminder`.

**Parameters:**
- `dest` - destination array for the quotient (may be NULL if only remainder is needed)
- `reminder` - destination array for the remainder (may be NULL if only quotient is needed)
- `a` - the dividend (numerator)
- `b` - the divisor (denominator)
- `number_array_length` - the number of 64-bit words in each array

**Note**: This is **NOT** constant time.

**Note**: The algorithm might be slow, as it uses a factorized variation on long division rather than faster algorithms like Newton-Raphson division.

#### `fio_math_shr`

```c
void fio_math_shr(uint64_t *dest,
                  uint64_t *n,
                  const size_t right_shift_bits,
                  size_t number_array_length);
```

Multi-precision shift right for a `len` word number `n`.

Shifts the multi-precision number `n` right by `right_shift_bits` bits, storing the result in `dest`.

**Parameters:**
- `dest` - destination array for the result
- `n` - the number to shift
- `right_shift_bits` - number of bits to shift right
- `number_array_length` - the number of 64-bit words in the arrays

#### `fio_math_shl`

```c
void fio_math_shl(uint64_t *dest,
                  uint64_t *n,
                  const size_t left_shift_bits,
                  const size_t number_array_length);
```

Multi-precision shift left for a `len*64` bit number `n`.

Shifts the multi-precision number `n` left by `left_shift_bits` bits, storing the result in `dest`.

**Parameters:**
- `dest` - destination array for the result
- `n` - the number to shift
- `left_shift_bits` - number of bits to shift left
- `number_array_length` - the number of 64-bit words in the arrays

#### `fio_math_inv`

```c
void fio_math_inv(uint64_t *dest, uint64_t *n, size_t len);
```

Multi-precision two's complement inverse for a `len*64` bit number `n`.

Computes the two's complement negation (i.e., turns `1` into `-1` in two's complement representation).

**Parameters:**
- `dest` - destination array for the result
- `n` - the number to invert
- `len` - the number of 64-bit words in the arrays

#### `fio_math_msb_index`

```c
size_t fio_math_msb_index(uint64_t *n, const size_t len);
```

Multi-precision - returns the index for the most significant bit, or `(size_t)-1` if the number is zero.

This can be used to determine a number's bit length.

**Parameters:**
- `n` - the multi-precision number
- `len` - the number of 64-bit words in the array

**Returns:** The zero-based index of the most significant set bit, or `(size_t)-1` if all bits are zero.

#### `fio_math_lsb_index`

```c
size_t fio_math_lsb_index(uint64_t *n, const size_t len);
```

Multi-precision - returns the index for the least significant bit, or `(size_t)-1` if the number is zero.

This can be used to extract an exponent value in base 2.

**Parameters:**
- `n` - the multi-precision number
- `len` - the number of 64-bit words in the array

**Returns:** The zero-based index of the least significant set bit, or `(size_t)-1` if all bits are zero.

-------------------------------------------------------------------------------
## Pseudo Random Generation

```c
#define FIO_RAND
#include "fio-stl.h"
```

If the `FIO_RAND` macro is defined, the following non-cryptographic pseudo-random generator and hash functions will be defined.

The "random" data is initialized / seeded automatically using a small number of functional cycles that collect data and hash it, hopefully resulting in enough jitter entropy.

The data is collected using `getrusage` (or the system clock if `getrusage` is unavailable) and hashed using RiskyHash. The data is then combined with the previous state / cycle.

The CPU "jitter" within the calculation **should** affect `getrusage` in a way that makes it impossible for an attacker to determine the resulting random state (assuming jitter exists).

However, this is unlikely to prove cryptographically safe and isn't likely to produce a large number of entropy bits (even though a small number of bits have a large impact on the final state).

The facil.io random generator functions appear both faster and more random than the standard `rand` on my computer (you can test it for yours).

I designed it in the hopes of achieving a cryptographically safe PRNG, but it wasn't cryptographically analyzed, lacks a good source of entropy and should be considered as a good enough non-cryptographic PRNG for general use.

**Note**: bitwise operations (`FIO_BITWISE`), Risky Hash and Stable Hash are automatically defined along with `FIO_RAND`, since they are required by the algorithm.

### Pseudo-Random Generator Functions

#### `fio_rand64`

```c
uint64_t fio_rand64(void);
```

Returns 64 pseudo-random bits. Probably **not** cryptographically safe.

#### `fio_rand128`

```c
fio_u128 fio_rand128(void);
```

Returns 128 pseudo-random bits. Probably **not** cryptographically safe.

**Note**: returns a `fio_u128` type which is a 128-bit unsigned integer structure.

#### `fio_rand_bytes`

```c
void fio_rand_bytes(void *target, size_t len);
```

Writes `len` bytes of pseudo-random data to the buffer pointed to by `target`. Probably **not** cryptographically safe.

#### `fio_rand_bytes_secure`

```c
int fio_rand_bytes_secure(void *target, size_t len);
```

Writes `len` bytes of cryptographically secure random data to `target`.

Uses the system CSPRNG: `arc4random_buf()` on BSD/macOS, or `/dev/urandom` as fallback on other POSIX systems.

**Returns:** `0` on success, `-1` on failure.

**Note**: Use this function for security-sensitive operations like key generation, nonces, or any cryptographic purpose. For non-security-critical random data, prefer `fio_rand_bytes` which is faster.

#### `fio_rand_reseed`

```c
void fio_rand_reseed(void);
```

Forces the random generator state to rotate.

**Note**: SHOULD be called after `fork` to prevent the two processes from outputting the same random numbers (until a reseed is called automatically).

### Risky Hash / Stable Hash (data hashing)

Stable Hash is a stable block hashing algorithm that can be used to hash non-ephemeral data. The hashing speeds are competitively fast, the algorithm is fairly simple with good avalanche dispersion and minimal bias.

Risky Hash is a non-stable hashing algorithm that is aimed at ephemeral data hashing (i.e., hash map keys) and might be updated periodically to produce different hashing results. It too aims to balance security concerns with performance.

Both algorithms are **non-cryptographic** and produce 64-bit hashes by default (though internally both use a 256-bit block that could be used to produce 128-bit hashes). Both pass the SMHasher test suite for hashing functions.

#### `FIO_USE_STABLE_HASH_WHEN_CALLING_RISKY_HASH`

```c
#define FIO_USE_STABLE_HASH_WHEN_CALLING_RISKY_HASH 0
```

When set to `1`, calls to `fio_risky_hash` will be redirected to `fio_stable_hash` instead. This can be useful when you need stable hashing behavior but are using code that calls `fio_risky_hash`.

Default is `0` (disabled).

#### `fio_stable_hash`

```c
uint64_t fio_stable_hash(const void *data, size_t len, uint64_t seed);
```

Computes a 64-bit facil.io Stable Hash.

Once version 1.0 is released, this algorithm will not be updated, even if broken. This makes it suitable for persistent storage or cross-system communication where hash stability is required.

#### `fio_stable_hash128`

```c
void fio_stable_hash128(void *restrict dest,
                        const void *restrict data,
                        size_t len,
                        uint64_t seed);
```

Computes a 128-bit facil.io Stable Hash.

Once version 1.0 is released, this algorithm will not be updated, even if broken.

**Parameters:**
- `dest` - pointer to a 16-byte buffer where the 128-bit hash will be written
- `data` - pointer to the data to hash
- `len` - length of the data in bytes
- `seed` - seed value for the hash

#### `fio_risky_hash`

```c
uint64_t fio_risky_hash(const void *buf, size_t len, uint64_t seed);
```

This is a non-streaming implementation of the RiskyHash v.3 algorithm.

This function will produce a 64-bit hash for the given data.

**Note**: the hashing algorithm may change at any time and the hash value should be considered ephemeral. Meant to be safe enough for use with hash maps.

**Note**: if `FIO_USE_STABLE_HASH_WHEN_CALLING_RISKY_HASH` is defined and true, `fio_stable_hash` will be called instead.

#### `fio_risky_ptr`

```c
uint64_t fio_risky_ptr(void *ptr);
```

Adds a bit of entropy to pointer values. Designed to be unsafe (fast, not cryptographically secure).

**Note**: the hashing algorithm may change at any time and the hash value should be considered ephemeral. Meant to be safe enough for use with hash maps.

#### `fio_risky_num`

```c
uint64_t fio_risky_num(uint64_t number, uint64_t seed);
```

Adds a bit of entropy to numeral values. Designed to be unsafe (fast, not cryptographically secure).

**Note**: the hashing algorithm may change at any time and the hash value should be considered ephemeral. Meant to be safe enough for use with hash maps, but that's about it.

#### `fio_risky256`

```c
fio_u256 fio_risky256(const void *data, uint64_t len);
```

Computes a 256-bit non-cryptographic hash using the RiskyHash 256 algorithm.

Based on the A3 (Zero-Copy ILP) design: two independent 512-bit states process 128 bytes per iteration using multiply-fold with cross-lane mixing. Returns a `fio_u256` (32 bytes).

**Quality**: passes strict avalanche (50.0%), collision resistance (0 collisions in 1M hashes), differential (min Hamming distance 85/256), and length independence tests.

**Performance**: ~25-27 GB/s on modern hardware for large inputs, ~3.7 GB/s for 64-byte inputs.

**Note**: this is a non-cryptographic hash. The algorithm may change at any time and hash values should be considered ephemeral.

#### `fio_risky512`

```c
fio_u512 fio_risky512(const void *data, uint64_t len);
```

Computes a 512-bit non-cryptographic hash using the RiskyHash 512 algorithm.

This is a SHAKE-style extension of `fio_risky256`: the first 256 bits of the 512-bit output are **identical** to `fio_risky256` (truncation-safe). The second 256 bits come from an additional squeeze round. Returns a `fio_u512` (64 bytes).

**Note**: this is a non-cryptographic hash. The algorithm may change at any time and hash values should be considered ephemeral.

#### `fio_risky256_hmac`

```c
fio_u256 fio_risky256_hmac(const void *key, uint64_t key_len,
                           const void *msg, uint64_t msg_len);
```

Computes HMAC-RiskyHash-256 using the RFC 2104 construction with `fio_risky256` as the underlying hash function. Uses a 64-byte block size with standard ipad (0x36) and opad (0x5C) padding.

If `key_len > 64`, the key is first hashed with `fio_risky256`. Returns a `fio_u256` (32 bytes).

All sensitive intermediates (padded key, inner hash, buffers) are securely zeroed after use.

**Note**: while this uses the standard RFC 2104 HMAC construction, the underlying hash is non-cryptographic, so the standard HMAC security proofs do not apply. For cryptographic HMAC, use `fio_blake2b_hmac` or `fio_blake2s_hmac`.

#### `fio_risky512_hmac`

```c
fio_u512 fio_risky512_hmac(const void *key, uint64_t key_len,
                           const void *msg, uint64_t msg_len);
```

Computes HMAC-RiskyHash-512 using the RFC 2104 construction with `fio_risky512` as the underlying hash function. Uses a 64-byte block size with standard ipad (0x36) and opad (0x5C) padding.

If `key_len > 64`, the key is first hashed with `fio_risky512`. Returns a `fio_u512` (64 bytes).

All sensitive intermediates (padded key, inner hash, buffers) are securely zeroed after use.

**Note**: while this uses the standard RFC 2104 HMAC construction, the underlying hash is non-cryptographic, so the standard HMAC security proofs do not apply. For cryptographic HMAC, use `fio_blake2b_hmac` or `fio_blake2s_hmac`.

-------------------------------------------------------------------------------
## Signal Monitoring

```c
#define FIO_SIGNAL
#include "fio-stl.h"
```

OS signal callbacks are very limited in the actions they are allowed to take. In fact, one of the only actions they are allowed to take is to set a volatile atomic flag.

The facil.io STL offers helpers that perform this very common pattern of declaring a flag, watching a signal, setting a flag and (later) calling a callback outside of the signal handler that would handle the actual event.

**Note**: Either POSIX or Windows is required for the `fio_signal` API.

### Configuration Macros

#### `FIO_SIGNAL_MONITOR_MAX`

```c
#ifndef FIO_SIGNAL_MONITOR_MAX
/* The maximum number of signals the implementation will be able to monitor */
#define FIO_SIGNAL_MONITOR_MAX 24
#endif
```

Defines the maximum number of signals that can be monitored simultaneously. Defaults to `24`.

### Signal Monitoring API

#### `fio_signal_monitor`

```c
int fio_signal_monitor(fio_signal_monitor_args_s args);
/* Named arguments using macro. */
#define fio_signal_monitor(...)                                                \
  fio_signal_monitor((fio_signal_monitor_args_s){__VA_ARGS__})

typedef struct {
  /** The signal number to listen for. */
  int sig;
  /** The callback to run - leave NULL to ignore signal. */
  void (*callback)(int sig, void *udata);
  /** Opaque user data. */
  void *udata;
  /** Should the signal propagate to existing handler(s)? */
  bool propagate;
  /** Call (safe) callback immediately? or wait for `fio_signal_review`? */
  bool immediate;
} fio_signal_monitor_args_s;
```

Starts to monitor for the specified signal, setting an optional callback.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_signal_monitor(.sig = SIGINT,
                   .callback = on_sigint,
                   .udata = my_data);
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `sig` | `int` | The signal number to listen for (required) |
| `callback` | `void (*)(int, void *)` | The callback to run; leave `NULL` to ignore signal |
| `udata` | `void *` | Opaque user data passed to the callback |
| `propagate` | `bool` | If `true` and a previous handler was set, it will be called |
| `immediate` | `bool` | If `true`, callback runs immediately in signal context; otherwise waits for `fio_signal_review` |

**Returns:** `0` on success, `-1` on error.

**Note**: if `callback` is `NULL`, the signal will be ignored.

**Note**: if the signal is already being monitored, the callback and `udata` pointers are updated.

**Note**: `udata` stands for "user data", it is an opaque pointer that is simply passed along to the callback.

**Note**: when `immediate` is `true`, the callback must be signal-safe (async-signal-safe). Most operations are not safe to perform in a signal handler context.

#### `fio_signal_review`

```c
int fio_signal_review(void);
```

Reviews all signals, calling any relevant callbacks that were deferred (i.e., monitors where `immediate` was `false`).

**Returns:** the number of callbacks that were called.

#### `fio_signal_forget`

```c
int fio_signal_forget(int sig);
```

Stops monitoring the specified signal and restores the default signal handler.

**Returns:** `0` on success, `-1` on error (e.g., signal was not being monitored).

### Example

```c
#define FIO_SIGNAL
#define FIO_LOG
#include "fio-stl.h"

static volatile int running = 1;

static void on_sigint(int sig, void *udata) {
  (void)sig;
  (void)udata;
  FIO_LOG_INFO("SIGINT received, shutting down...");
  running = 0;
}

int main(void) {
  /* Monitor SIGINT - callback deferred until fio_signal_review is called */
  fio_signal_monitor(.sig = SIGINT,
                     .callback = on_sigint,
                     .udata = NULL);

  FIO_LOG_INFO("Running... Press Ctrl+C to stop.");

  while (running) {
    /* Check for signals and call deferred callbacks */
    fio_signal_review();
    /* ... do work ... */
  }

  /* Stop monitoring */
  fio_signal_forget(SIGINT);

  return 0;
}
```

-------------------------------------------------------------------------------
## Quick Sort and Insert Sort

```c
#define FIO_SORT_NAME num
#define FIO_SORT_TYPE size_t
#include "fio-stl.h"
```

If `FIO_SORT_NAME` is defined, the following sorting functions will be defined. The `FIO_SORT_TYPE` macro **must** also be defined to specify the type of array elements to sort.

This module can be included multiple times to create sorting functions for different types.

### Sort Settings

The following macros define the behavior of the sorting algorithm.

#### `FIO_SORT_NAME`

```c
#define FIO_SORT_NAME num // produces function names: num_sort, num_qsort, num_isort
```

The prefix used for naming the sorting functions.

#### `FIO_SORT_TYPE`

```c
#define FIO_SORT_TYPE size_t
```

The type of the array members to be sorted.

**Note**: this macro **must** be defined.

#### `FIO_SORT_IS_BIGGER`

```c
#define FIO_SORT_IS_BIGGER(a, b) ((a) > (b))
```

Comparison macro that **must** evaluate to `1` if `a > b`, and `0` if equal or smaller.

The default implementation uses the `>` operator, which works for numeric types.

#### `FIO_SORT_SWAP`

```c
#define FIO_SORT_SWAP(a, b)                                                    \
  do {                                                                         \
    FIO_SORT_TYPE tmp__ = (a);                                                 \
    (a) = (b);                                                                 \
    (b) = tmp__;                                                               \
  } while (0)
```

Swaps two array members. The default implementation uses a temporary variable.

Usually there is no need to override this macro.

#### `FIO_SORT_THRESHOLD`

```c
#define FIO_SORT_THRESHOLD 96
```

The threshold below which quick-sort delegates to insert sort. For small arrays, insert sort is faster due to lower overhead.

Usually there is no need to override this macro.

### Sorting API

The following functions are created using the `FIO_SORT_NAME` prefix. In the examples below, `FIO_SORT_NAME` is assumed to be `num`.

#### `num_sort`

```c
void num_sort(FIO_SORT_TYPE *array, size_t count);
```

Sorts the first `count` members of `array`.

This is the main sorting function and currently wraps `num_qsort` (quick-sort).

#### `num_qsort`

```c
void num_qsort(FIO_SORT_TYPE *array, size_t count);
```

Sorts the first `count` members of `array` using quick-sort.

The implementation is non-recursive, using an internal stack to avoid stack overflow on large arrays. For small partitions (below `FIO_SORT_THRESHOLD`), it delegates to insert sort for better performance.

The algorithm uses median-of-three pivot selection for improved performance on partially sorted data.

#### `num_isort`

```c
void num_isort(FIO_SORT_TYPE *array, size_t count);
```

Sorts the first `count` members of `array` using insert-sort.

Insert sort is efficient for small arrays but has O(n) complexity. Use only with small arrays or when the data is nearly sorted.

### Sort Example

The following example creates an array of random strings and then sorts the array:

```c
#define FIO_STR_SMALL sstr
#define FIO_SORT_NAME      sstr
#define FIO_SORT_TYPE sstr_s
#define FIO_SORT_IS_BIGGER(a, b)                                               \
  fio_string_is_greater(sstr_info(&a), sstr_info(&b))
#define FIO_RAND
#include "fio-stl.h"

#define STRING_ARRAY_LENGTH 128
int main(int argc, char const *argv[]) {
  (void)argc;
  (void)argv;
  sstr_s ary[STRING_ARRAY_LENGTH] = {{0}};
  /* fill array with random data and print state */
  for (size_t i = 0; i < STRING_ARRAY_LENGTH; ++i) {
    sstr_write_hex(ary + i, fio_rand64());
  }
  printf("Starting with array of strings as:\n");
  for (size_t i = 0; i < STRING_ARRAY_LENGTH; ++i) {
    printf("[%zu] %s\n", i, sstr2ptr(ary + i));
  }
  /* sort array and print state */
  sstr_qsort(ary, STRING_ARRAY_LENGTH);
  printf("\n\nOrdered array of strings is:\n");
  for (size_t i = 0; i < STRING_ARRAY_LENGTH; ++i) {
    printf("[%zu] %s\n", i, sstr2ptr(ary + i));
    sstr_destroy(ary + i); /* cleanup */
  }
  return 0;
}
```

A simpler example sorting integers:

```c
#define FIO_SORT_NAME int
#define FIO_SORT_TYPE int
#include "fio-stl.h"

int main(void) {
  int numbers[] = {5, 2, 8, 1, 9, 3, 7, 4, 6, 0};
  size_t count = sizeof(numbers) / sizeof(numbers[0]);
  
  int_sort(numbers, count);
  
  for (size_t i = 0; i < count; ++i) {
    printf("%d ", numbers[i]);
  }
  printf("\n"); /* Output: 0 1 2 3 4 5 6 7 8 9 */
  return 0;
}
```

-------------------------------------------------------------------------------
## Threads (portable)

```c
#define FIO_THREADS
#include "fio-stl.h"
```

The facil.io `FIO_THREADS` module provides a simple API for threading that is OS portable between POSIX systems and Windows OS.

The POSIX systems implementation uses `pthreads` under the hood.

Please note that due to thread return value and methodology differences, `FIO_THREADS` do not return any value.

The following methods are provided when the `FIO_THREADS` macro is defined before including the `fio-stl.h` header.

### Types

#### `fio_thread_t`

```c
/* POSIX */
typedef pthread_t fio_thread_t;

/* Windows */
typedef HANDLE fio_thread_t;
```

The thread type, representing a thread handle. Platform-specific implementation.

#### `fio_thread_pid_t`

```c
/* POSIX */
typedef pid_t fio_thread_pid_t;

/* Windows */
typedef DWORD fio_thread_pid_t;
```

The process ID type. Platform-specific implementation.

#### `fio_thread_mutex_t`

```c
/* POSIX */
typedef pthread_mutex_t fio_thread_mutex_t;

/* Windows */
typedef CRITICAL_SECTION fio_thread_mutex_t;
```

The mutex type. Platform-specific implementation.

#### `fio_thread_cond_t`

```c
/* POSIX */
typedef pthread_cond_t fio_thread_cond_t;

/* Windows */
typedef CONDITION_VARIABLE fio_thread_cond_t;
```

The conditional variable type. Platform-specific implementation.

#### `fio_thread_priority_e`

```c
/** Possible thread priority values. */
typedef enum {
  FIO_THREAD_PRIORITY_ERROR = -1,
  FIO_THREAD_PRIORITY_LOWEST = 0,
  FIO_THREAD_PRIORITY_LOW,
  FIO_THREAD_PRIORITY_NORMAL,
  FIO_THREAD_PRIORITY_HIGH,
  FIO_THREAD_PRIORITY_HIGHEST,
} fio_thread_priority_e;
```

An enumeration of possible thread priority levels.

### Process Functions

#### `FIO_THREADS_FORK_BYO`

* **BYO**: **B**ring **Y**our **O**wn.

If this macro is defined, these processes forking functions are only declared, but they are **not** defined (implemented).

The facil.io C STL implementation expects you to provide your own alternatives.

#### `fio_thread_fork`

```c
fio_thread_pid_t fio_thread_fork(void);
```

Behaves (or should behave) the same as the POSIX system call `fork`.

**Note**: on Windows, `fork` is not natively supported. The function will log an error and return `-1`.

#### `fio_thread_getpid`

```c
fio_thread_pid_t fio_thread_getpid(void);
```

Behaves (or should behave) the same as the POSIX system call `getpid`.

#### `fio_thread_kill`

```c
int fio_thread_kill(fio_thread_pid_t pid, int sig);
```

Behaves (or should behave) the same as the POSIX system call `kill`.

**Parameters:**
- `pid` - the process ID to send the signal to
- `sig` - the signal to send

**Returns:** `0` on success, `-1` on error.

#### `fio_thread_waitpid`

```c
int fio_thread_waitpid(fio_thread_pid_t pid, int *stat_loc, int options);
```

Behaves (or should behave) the same as the POSIX system call `waitpid`.

**Parameters:**
- `pid` - the process ID to wait for (or `-1` for any child process)
- `stat_loc` - pointer to store the status information
- `options` - options flags (e.g., `WNOHANG`)

**Returns:** the process ID of the child that changed state, `0` if `WNOHANG` was specified and no child changed state, or `-1` on error.

### Thread Functions

#### `FIO_THREADS_BYO`

* **BYO**: **B**ring **Y**our **O**wn.

If this macro is defined, these thread functions are only declared, but they are **not** defined (implemented).

The facil.io C STL implementation expects you to provide your own alternatives.

#### `fio_thread_create`

```c
int fio_thread_create(fio_thread_t *t, void *(*fn)(void *), void *arg);
```

Starts a new thread, returns `0` on success and `-1` on failure.

**Parameters:**
- `t` - pointer to the thread handle to initialize
- `fn` - the function to execute in the new thread
- `arg` - argument to pass to the thread function

**Returns:** `0` on success, `-1` on failure.

#### `fio_thread_join`

```c
int fio_thread_join(fio_thread_t *t);
```

Waits for the thread to finish.

**Parameters:**
- `t` - pointer to the thread handle

**Returns:** `0` on success, `-1` on error.

#### `fio_thread_detach`

```c
int fio_thread_detach(fio_thread_t *t);
```

Detaches the thread, so thread resources are freed automatically.

**Parameters:**
- `t` - pointer to the thread handle

**Returns:** `0` on success, `-1` on error.

#### `fio_thread_exit`

```c
void fio_thread_exit(void);
```

Ends the current running thread.

#### `fio_thread_equal`

```c
int fio_thread_equal(fio_thread_t *a, fio_thread_t *b);
```

Returns non-zero if both threads refer to the same thread.

**Parameters:**
- `a` - pointer to the first thread handle
- `b` - pointer to the second thread handle

**Returns:** non-zero if threads are equal, `0` otherwise.

#### `fio_thread_current`

```c
fio_thread_t fio_thread_current(void);
```

Returns the current thread.

#### `fio_thread_yield`

```c
void fio_thread_yield(void);
```

Yields thread execution, allowing other threads to run.

#### `fio_thread_priority`

```c
fio_thread_priority_e fio_thread_priority(void);
```

Returns the current thread's priority level as a `fio_thread_priority_e` enum.

**Returns:** the current thread's priority, or `FIO_THREAD_PRIORITY_ERROR` on error.

#### `fio_thread_priority_set`

```c
int fio_thread_priority_set(fio_thread_priority_e pr);
```

Sets the current thread's priority level.

**Parameters:**
- `pr` - the priority level to set (see [`fio_thread_priority_e`](#fio_thread_priority_e))

**Returns:** `0` on success, `-1` on error.

### Mutex Functions

#### `FIO_THREADS_MUTEX_BYO`

* **BYO**: **B**ring **Y**our **O**wn.

If this macro is defined, these mutex functions are only declared, but they are **not** defined (implemented).

The facil.io C STL implementation expects you to provide your own alternatives.

#### `FIO_THREAD_MUTEX_INIT`

```c
#define FIO_THREAD_MUTEX_INIT /* platform specific */
```

Statically initializes a Mutex.

Example:

```c
fio_thread_mutex_t my_mutex = FIO_THREAD_MUTEX_INIT;
```

#### `fio_thread_mutex_init`

```c
int fio_thread_mutex_init(fio_thread_mutex_t *m);
```

Initializes a simple Mutex.

Or use the static initialization value: `FIO_THREAD_MUTEX_INIT`

**Parameters:**
- `m` - pointer to the mutex to initialize

**Returns:** `0` on success, non-zero on error.

#### `fio_thread_mutex_lock`

```c
int fio_thread_mutex_lock(fio_thread_mutex_t *m);
```

Locks a simple Mutex, blocking until the lock is acquired.

**Parameters:**
- `m` - pointer to the mutex

**Returns:** `0` on success, `-1` on error.

#### `fio_thread_mutex_trylock`

```c
int fio_thread_mutex_trylock(fio_thread_mutex_t *m);
```

Attempts to lock a simple Mutex without blocking.

**Parameters:**
- `m` - pointer to the mutex

**Returns:** `0` on success (lock acquired), non-zero if the mutex is already locked.

#### `fio_thread_mutex_unlock`

```c
int fio_thread_mutex_unlock(fio_thread_mutex_t *m);
```

Unlocks a simple Mutex.

**Parameters:**
- `m` - pointer to the mutex

**Returns:** `0` on success, `-1` on error.

#### `fio_thread_mutex_destroy`

```c
void fio_thread_mutex_destroy(fio_thread_mutex_t *m);
```

Destroys the simple Mutex (cleanup).

**Parameters:**
- `m` - pointer to the mutex to destroy

### Conditional Variable Functions

#### `FIO_THREADS_COND_BYO`

* **BYO**: **B**ring **Y**our **O**wn.

If this macro is defined, these conditional variable functions are only declared, but they are **not** defined (implemented).

The facil.io C STL implementation expects you to provide your own alternatives.

#### `fio_thread_cond_init`

```c
int fio_thread_cond_init(fio_thread_cond_t *c);
```

Initializes a simple conditional variable.

**Parameters:**
- `c` - pointer to the conditional variable to initialize

**Returns:** `0` on success, non-zero on error.

#### `fio_thread_cond_wait`

```c
int fio_thread_cond_wait(fio_thread_cond_t *c, fio_thread_mutex_t *m);
```

Waits on a conditional variable. The mutex MUST be previously locked.

**Parameters:**
- `c` - pointer to the conditional variable
- `m` - pointer to the mutex (must be locked before calling)

**Returns:** `0` on success, non-zero on error.

**Note**: the mutex is atomically released while waiting and re-acquired before returning.

#### `fio_thread_cond_timedwait`

```c
int fio_thread_cond_timedwait(fio_thread_cond_t *c,
                              fio_thread_mutex_t *m,
                              size_t milliseconds);
```

Waits on a conditional variable with a timeout. The mutex MUST be previously locked.

**Parameters:**
- `c` - pointer to the conditional variable
- `m` - pointer to the mutex (must be locked before calling)
- `milliseconds` - maximum time to wait in milliseconds

**Returns:** `0` on success (signaled), non-zero on timeout or error.

**Note**: the mutex is atomically released while waiting and re-acquired before returning.

#### `fio_thread_cond_signal`

```c
int fio_thread_cond_signal(fio_thread_cond_t *c);
```

Signals a simple conditional variable, waking one waiting thread.

**Parameters:**
- `c` - pointer to the conditional variable

**Returns:** `0` on success, non-zero on error.

#### `fio_thread_cond_destroy`

```c
void fio_thread_cond_destroy(fio_thread_cond_t *c);
```

Destroys a simple conditional variable.

**Parameters:**
- `c` - pointer to the conditional variable to destroy

### Multi-Threaded Memory Copy

#### `FIO_MEMCPY_THREADS`

```c
#ifndef FIO_MEMCPY_THREADS
#define FIO_MEMCPY_THREADS 8
#endif
```

Defines the maximum number of threads to use for multi-threaded memory copy operations.

Default value is `8`.

#### `FIO_MEMCPY_THREADS___MINCPY`

```c
#ifndef FIO_MEMCPY_THREADS___MINCPY
#define FIO_MEMCPY_THREADS___MINCPY (1ULL << 23)
#endif
```

Defines the minimum number of bytes required before multi-threaded copy is used.

Default value is `8388608` bytes (8 MB). Below this threshold, a single-threaded copy is performed.

#### `fio_thread_memcpy`

```c
size_t fio_thread_memcpy(const void *restrict dest,
                         void *restrict src,
                         size_t bytes);
```

Multi-threaded memcpy using up to `FIO_MEMCPY_THREADS` threads.

For small copies (below `FIO_MEMCPY_THREADS___MINCPY` bytes), a single-threaded copy is performed.

**Parameters:**
- `dest` - destination buffer
- `src` - source buffer
- `bytes` - number of bytes to copy

**Returns:** the number of threads used for the copy operation.

Example:

```c
#define FIO_THREADS
#include "fio-stl.h"

void copy_large_buffer(void) {
  char *src = malloc(16 * 1024 * 1024);  /* 16 MB */
  char *dest = malloc(16 * 1024 * 1024);
  
  /* Fill source with data... */
  
  size_t threads_used = fio_thread_memcpy(dest, src, 16 * 1024 * 1024);
  printf("Copy completed using %zu threads\n", threads_used);
  
  free(src);
  free(dest);
}
```

**Note**: this is a naive implementation intended for very large memory copies where parallelization may provide benefits.

-------------------------------------------------------------------------------
## URL (URI) Parsing

```c
#define FIO_URL
#include "fio-stl.h"
```

URIs (Universal Resource Identifier), commonly referred to as URL (Uniform Resource Locator), are a common way to describe network and file addresses.

A common use case for URIs is within the command line interface (CLI), allowing a client to point at a resource that may be local (i.e., `file:///users/etc/my.conf`) or remote (i.e. `http://example.com/conf`).

By defining `FIO_URL` (or `FIO_URI`), the following types and functions will be defined.

**Note**: the parser is non-destructive, with zero-copy and zero-allocation. All returned strings are pointers into the original URL string and are **not NUL terminated**.

### Types

#### `fio_url_s`

```c
/** the result returned by `fio_url_parse` */
typedef struct {
  fio_buf_info_s scheme;
  fio_buf_info_s user;
  fio_buf_info_s password;
  fio_buf_info_s host;
  fio_buf_info_s port;
  fio_buf_info_s path;
  fio_buf_info_s query;
  fio_buf_info_s target;
} fio_url_s;
```

The `fio_url_s` contains information about a URL (or, URI).

When the information is returned from `fio_url_parse`, the strings in the `fio_url_s` (i.e., `url.scheme.buf`) are **not NUL terminated**, since the parser is non-destructive, with zero-copy and zero-allocation.

**Members:**
- `scheme` - The URL scheme (e.g., `http`, `https`, `file`)
- `user` - The username, if provided
- `password` - The password, if provided
- `host` - The host name or IP address
- `port` - The port number as a string
- `path` - The path component
- `query` - The query string (without the leading `?`)
- `target` - The fragment/target (without the leading `#`)

**Note**: empty components will have both `.buf` set to `NULL` and `.len` set to `0`.

#### `fio_url_tls_info_s`

```c
/* Return type for `fio_url_is_tls` */
typedef struct {
  fio_buf_info_s key;   /* path or env variable name for the private key */
  fio_buf_info_s cert;  /* path or env variable name for the certificate */
  fio_buf_info_s pass;  /* password for decrypting key data */
  bool tls;             /* true if TLS is requested according to the URL */
} fio_url_tls_info_s;
```

Contains TLS-related information extracted from a URL.

**Members:**
- `key` - Path or environment variable name for the private key file
- `cert` - Path or environment variable name for the public certificate file
- `pass` - Password for decrypting key/cert data
- `tls` - `true` if TLS is requested by the URL (either implicitly via scheme or explicitly via query parameters)

#### `fio_url_query_each_s`

```c
/** The type used by the `FIO_URL_QUERY_EACH` iterator macro. */
typedef struct {
  fio_buf_info_s name;
  fio_buf_info_s value;
  fio_buf_info_s private___;
} fio_url_query_each_s;
```

Iterator state type used by the `FIO_URL_QUERY_EACH` macro.

**Members:**
- `name` - The current query parameter name
- `value` - The current query parameter value
- `private___` - Internal state (do not access directly)

### API Functions

#### `fio_url_parse`

```c
fio_url_s fio_url_parse(const char *url, size_t len);
```

Parses the URI returning its components and their lengths (no decoding performed, **doesn't accept decoded URIs**).

The returned strings are **not NUL terminated**, they are merely locations within the original (unmodified) string.

This function attempts to accept many different formats, including any of the following:

* `/complete_path?query#target`

  i.e.: `/index.html?page=1#list`

* `host:port/complete_path?query#target`

  i.e.:
  - `example.com`
  - `example.com:8080`
  - `example.com/index.html`
  - `example.com:8080/index.html`
  - `example.com:8080/index.html?key=val#target`

* `user:password@host:port/path?query#target`

  i.e.: `user:1234@example.com:8080/index.html`

* `username[:password]@host[:port][...]`

  i.e.: `john:1234@example.com`

* `schema://user:password@host:port/path?query#target`

  i.e.: `http://example.com/index.html?page=1#list`

* `file://some/path`

  i.e.: `file://./relative/path` or `file:///absolute/path`

Invalid formats might produce unexpected results. No error testing performed.

**Note**: the `file`, `unix` and `priv` schemas are special in the sense that they produce no `host` (only `path`) and are parsed as if they contain file path information.

#### `fio_url_is_tls`

```c
fio_url_tls_info_s fio_url_is_tls(fio_url_s u);
```

Returns TLS data associated with the URL.

This function supports **implicit TLS** by scheme data for the following possible values:

- `wss`   - Secure WebSockets
- `sses`  - Secure SSE (Server Sent Events)
- `ssse`  - Secure SSE (alternative spelling)
- `https` - Secure HTTP
- `tcps`  - Secure TCP/IP
- `stcp`  - Secure TCP/IP (alternative spelling)
- `tls`   - Secure TCP/IP
- `ssl`   - Secure TCP/IP
- `udps`  - Secure UDP
- `sudp`  - Secure UDP (alternative spelling)

i.e.:

- `tls://example.com/`
- `tcps://example.com/`
- `udps://example.com/`
- `wss://example.com/`
- `https://example.com/`
- `sses://example.com/`

This function also supports **explicit TLS** by query data for the following possible key-pair values:

- `tls`                   - self-signed TLS (unless key / cert are provided)
- `tls=true`              - self-signed TLS (unless key / cert are provided)
- `tls=<file>`            - key and certificate files (same path / prefix, one ends with "key.pem" the other with "cert.pem")
- `key=<file/env_data>`   - path or env variable name for the private key
- `cert=<file/env_data>`  - path or env variable name for the public certificate
- `pass=<password>`       - password for decrypting key data

i.e.:

- `tcp://example.com/?tls` (anonymous TLS)
- `udp://example.com/?tls=true` (anonymous TLS)
- `https://example.com/?tls=key_cert_folder_or_prefix&pass=key_password`
- `https://example.com/?key=key_file_or_env_var&cert=cert_file_or_env_var&pass=key_password`
- `wss://example.com/?key=key_file_or_env_var&cert=cert_file_or_env_var&pass=key_password`
- `tcp://example.com/?key=key_file_or_env_var&cert=cert_file_or_env_var&pass=key_password`

### Macros

#### `FIO_URL_QUERY_EACH`

```c
/** Iterates through each of the query elements. */
#define FIO_URL_QUERY_EACH(query_buf, i)                                       \
  for (fio_url_query_each_s i = fio_url_query_each_next(                       \
           (fio_url_query_each_s){.private___ = (query_buf)});                 \
       i.name.buf;                                                             \
       i = fio_url_query_each_next(i))
```

Iterates through each of the query elements in a URL query string.

The macro accepts a `fio_buf_info_s` argument (`query_buf`) and iterates over each `name` and `value` pair in the query buffer.

Example:

```c
fio_url_s url = fio_url_parse(my_url, strlen(my_url));
FIO_URL_QUERY_EACH(url.query, param) {
  printf("  %.*s = %.*s\n",
         (int)param.name.len, param.name.buf,
         (int)param.value.len, param.value.buf);
}
```

**Note**: both `i.name` and `i.value` may be empty strings, with a valid `.buf` but with `.len` set to zero.

**Note**: the iterator does not unescape URL-encoded data. Unescaping may be required before either `i.name` or `i.value` can be used.

### Helper Functions

#### `fio_url_query_each_next`

```c
fio_url_query_each_s fio_url_query_each_next(fio_url_query_each_s i);
```

A helper function for the `FIO_URL_QUERY_EACH` macro implementation.

Advances the iterator to the next query parameter. Generally not called directly; use the `FIO_URL_QUERY_EACH` macro instead.

### Example

```c
#define FIO_URL
#include "fio-stl.h"

int main(void) {
  const char *url_str = "http://user:pass@example.com:8080/path?key=value#section";
  fio_url_s url = fio_url_parse(url_str, strlen(url_str));
  
  printf("Parsed URL:\n");
  printf("  scheme:   %.*s\n", (int)url.scheme.len, url.scheme.buf);
  printf("  user:     %.*s\n", (int)url.user.len, url.user.buf);
  printf("  password: %.*s\n", (int)url.password.len, url.password.buf);
  printf("  host:     %.*s\n", (int)url.host.len, url.host.buf);
  printf("  port:     %.*s\n", (int)url.port.len, url.port.buf);
  printf("  path:     %.*s\n", (int)url.path.len, url.path.buf);
  printf("  query:    %.*s\n", (int)url.query.len, url.query.buf);
  printf("  target:   %.*s\n", (int)url.target.len, url.target.buf);
  
  /* Iterate query parameters */
  if (url.query.buf) {
    printf("Query parameters:\n");
    FIO_URL_QUERY_EACH(url.query, param) {
      printf("  %.*s = %.*s\n",
             (int)param.name.len, param.name.buf,
             (int)param.value.len, param.value.buf);
    }
  }
  
  /* Check for TLS */
  fio_url_tls_info_s tls = fio_url_is_tls(url);
  if (tls.tls) {
    printf("TLS is enabled\n");
    if (tls.key.buf)
      printf("  key:  %.*s\n", (int)tls.key.len, tls.key.buf);
    if (tls.cert.buf)
      printf("  cert: %.*s\n", (int)tls.cert.len, tls.cert.buf);
  }
  
  return 0;
}
```

-------------------------------------------------------------------------------
## File Utility Helpers

```c
#define FIO_FILES
#include "fio-stl.h"
```

By defining the macro `FIO_FILES`, the following file helper functions, macros, and types are defined for common file operations using POSIX-style APIs.

### Types

#### `fio_filename_s`

```c
typedef struct {
  fio_buf_info_s folder;   /* folder name */
  fio_buf_info_s basename; /* base file name */
  fio_buf_info_s ext;      /* extension (without '.') */
} fio_filename_s;
```

A result type for the filename parsing helper functions.

**Members:**
- `folder` - The folder/directory path component (includes trailing separator)
- `basename` - The base file name (without extension)
- `ext` - The file extension (without the leading `.`)

**Note**: all members are `fio_buf_info_s` types pointing into the original string (zero-copy). Empty components will have `.buf` set to `NULL` and `.len` set to `0`.

### Macros

#### `FIO_FOLDER_SEPARATOR`

```c
#if FIO_OS_WIN
#define FIO_FOLDER_SEPARATOR '\\'
#else
#define FIO_FOLDER_SEPARATOR '/'
#endif
```

Selects the folder separation character according to the detected OS.

**Note**: on Windows, both separators (`\` and `/`) will be tested for when parsing paths.

#### `fio_file_dup`

```c
#if FIO_OS_WIN
#define fio_file_dup(fd) _dup(fd)
#else
#define fio_file_dup(fd) dup(fd)
#endif
```

Duplicates the file handle (int).

#### `fio_filename_is_folder`

```c
#define fio_filename_is_folder(filename) (fio_filename_type((filename)) == S_IFDIR)
```

Tests if `filename` references a folder/directory.

Returns non-zero if the path is a directory, `0` if it is not a directory, or `0` on error (when `fio_filename_type` returns `0`).

#### `FIO_FD_FIND_EOF`

```c
#define FIO_FD_FIND_EOF ((size_t)-1)
```

End of file value returned by `fio_fd_find_next` when the token is not found before EOF.

#### `FIO_FD_FIND_BLOCK`

```c
#ifndef FIO_FD_FIND_BLOCK
#define FIO_FD_FIND_BLOCK 4096
#endif
```

Size on the stack used by `fio_fd_find_next` for each read cycle. Can be overridden before including the header.

### File Opening and Creation

#### `fio_filename_open`

```c
int fio_filename_open(const char *filename, int flags);
```

Opens `filename`, returning the same values as `open` on POSIX systems.

If `filename` starts with `"~/"` then it will be relative to the user's home folder (on Windows, also tests for `"~\"`).

**Parameters:**
- `filename` - path to the file to open
- `flags` - file open flags (e.g., `O_RDONLY`, `O_RDWR | O_CREAT | O_TRUNC`)

**Returns:** a file descriptor on success, or `-1` on error.

#### `fio_filename_tmp`

```c
int fio_filename_tmp(void);
```

Creates a temporary file, returning its file descriptor.

The function attempts to use the system's temporary directory (checking `TMPDIR`, `TMP`, `TEMP` environment variables, and `P_tmpdir` if defined). If no temporary directory is found, the current directory is used.

**Returns:** a file descriptor on success, or `-1` on error.

#### `fio_filename_overwrite`

```c
int fio_filename_overwrite(const char *filename, const void *buf, size_t len);
```

Overwrites `filename` with the data in the buffer.

If `filename` starts with `"~/"` then it will be relative to the user's home folder (on Windows, also tests for `"~\"`).

**Parameters:**
- `filename` - path to the file to overwrite
- `buf` - pointer to the data to write
- `len` - number of bytes to write

**Returns:** `0` on success, or `-1` on error. On error, the state of the file is undefined (may not exist, nothing written, or partially written).

### File Reading and Writing

#### `fio_fd_write`

```c
ssize_t fio_fd_write(int fd, const void *buf, size_t len);
```

Writes data to a file handle, returning the number of bytes written.

Since some systems have a limit on the number of bytes that can be written at a single time, this function fragments the system calls into smaller `write` blocks, allowing large data to be written.

**Parameters:**
- `fd` - file descriptor to write to
- `buf` - pointer to the data to write
- `len` - number of bytes to write

**Returns:** the number of bytes written, or `-1` on error.

**Note**: if the file descriptor is non-blocking, test `errno` for `EAGAIN` / `EWOULDBLOCK`.

#### `fio_fd_read`

```c
size_t fio_fd_read(int fd, void *buf, size_t len, off_t start_at);
```

Reads up to `len` bytes from `fd` starting at `start_at` offset.

Since some systems have a limit on the number of bytes that can be read at a time, this function fragments the system calls into smaller `read` blocks, allowing larger data blocks to be read.

**Parameters:**
- `fd` - file descriptor to read from
- `buf` - buffer to read data into
- `len` - maximum number of bytes to read
- `start_at` - offset in the file to start reading from (negative values read from end)

**Returns:** the number of bytes read, or `0` if no bytes were read or on error.

**Note**: if the file descriptor is non-blocking, test `errno` for `EAGAIN` / `EWOULDBLOCK`.

**Note**: may (or may not) change the file's pointer (reading/writing position), depending on the OS and POSIX version.

### File Information

#### `fio_filename_size`

```c
size_t fio_filename_size(const char *filename);
```

Returns the file size for the given filename.

**Parameters:**
- `filename` - path to the file

**Returns:** the file size in bytes, or `0` on both error and empty file.

#### `fio_fd_size`

```c
size_t fio_fd_size(int fd);
```

Returns the file size for the given file descriptor.

**Parameters:**
- `fd` - file descriptor

**Returns:** the file size in bytes, or `0` on both error and empty file.

#### `fio_filename_type`

```c
size_t fio_filename_type(const char *filename);
```

Returns the file type for the given filename.

**Parameters:**
- `filename` - path to the file

**Returns:** the file type as a bitmask (e.g., `S_IFREG` for regular file, `S_IFDIR` for directory), or `0` on error.

See: https://www.man7.org/linux/man-pages/man7/inode.7.html for file type constants.

#### `fio_fd_type`

```c
size_t fio_fd_type(int fd);
```

Returns the file type for the given file descriptor.

**Parameters:**
- `fd` - file descriptor

**Returns:** the file type as a bitmask (e.g., `S_IFREG` for regular file, `S_IFDIR` for directory), or `0` on error.

See: https://www.man7.org/linux/man-pages/man7/inode.7.html for file type constants.

### Path Safety

#### `fio_filename_is_unsafe`

```c
int fio_filename_is_unsafe(const char *path);
```

Returns `1` if `path` possibly folds backwards (path traversal attack detection).

This function checks for patterns that could escape a base directory:
- Leading `../` sequences
- `/../` or `/..` at end (path traversal)
- `//` (double separator, potential path confusion)

The check is OS separator dependent (uses `\` on Windows, `/` on other systems).

**Parameters:**
- `path` - the path string to check

**Returns:** `1` if the path is potentially unsafe, `0` if safe (or if `path` is `NULL`).

#### `fio_filename_is_unsafe_url`

```c
int fio_filename_is_unsafe_url(const char *path);
```

Returns `1` if `path` possibly folds backwards using URL-style separators.

Same as `fio_filename_is_unsafe`, but always uses `/` as the separator regardless of OS. Use this for validating URL paths.

**Parameters:**
- `path` - the path string to check

**Returns:** `1` if the path is potentially unsafe, `0` if safe (or if `path` is `NULL`).

### Filename Parsing

#### `fio_filename_parse`

```c
fio_filename_s fio_filename_parse(const char *filename);
```

Parses a file name into folder, base name, and extension components (zero-copy).

**Parameters:**
- `filename` - NUL-terminated path string to parse

**Returns:** a `fio_filename_s` struct with pointers into the original string.

Example:

```c
fio_filename_s parts = fio_filename_parse("/path/to/file.txt");
// parts.folder   -> "/path/to/"
// parts.basename -> "file"
// parts.ext      -> "txt"
```

#### `fio_filename_parse2`

```c
fio_filename_s fio_filename_parse2(const char *filename, size_t len);
```

Same as `fio_filename_parse`, but limited to `len` characters.

Use this when the `filename` string might not end with a NUL character.

**Parameters:**
- `filename` - path string to parse
- `len` - number of characters to parse

**Returns:** a `fio_filename_s` struct with pointers into the original string.

### File Search

#### `fio_fd_find_next`

```c
size_t fio_fd_find_next(int fd, char token, size_t start_at);
```

Returns the offset for the next occurrence of `token` in `fd`, or `FIO_FD_FIND_EOF` if reached EOF.

This function uses `FIO_FD_FIND_BLOCK` bytes on the stack to read the file in a loop.

**Parameters:**
- `fd` - file descriptor to search in
- `token` - character to search for
- `start_at` - offset to start searching from

**Returns:** the offset of the next `token`, or `FIO_FD_FIND_EOF` (`(size_t)-1`) if not found.

**Pros**: limits memory use and (re)allocations, easier overflow protection.

**Cons**: may be slower, as data will most likely be copied again from the file.

### Example

```c
#define FIO_FILES
#include "fio-stl.h"

int main(void) {
  /* Parse a filename */
  fio_filename_s parts = fio_filename_parse("/home/user/documents/report.pdf");
  printf("Folder:   %.*s\n", (int)parts.folder.len, parts.folder.buf);
  printf("Basename: %.*s\n", (int)parts.basename.len, parts.basename.buf);
  printf("Extension: %.*s\n", (int)parts.ext.len, parts.ext.buf);

  /* Check path safety */
  const char *safe_path = "/var/www/index.html";
  const char *unsafe_path = "/var/www/../etc/passwd";
  printf("Safe path: %s -> %s\n", safe_path,
         fio_filename_is_unsafe(safe_path) ? "UNSAFE" : "safe");
  printf("Unsafe path: %s -> %s\n", unsafe_path,
         fio_filename_is_unsafe(unsafe_path) ? "UNSAFE" : "safe");

  /* Get file information */
  const char *filename = "test.txt";
  size_t size = fio_filename_size(filename);
  if (size) {
    printf("File size: %zu bytes\n", size);
  }

  /* Check if path is a directory */
  if (fio_filename_is_folder("/tmp")) {
    printf("/tmp is a directory\n");
  }

  /* Write and read a file */
  const char *data = "Hello, World!";
  if (fio_filename_overwrite("~/test.txt", data, strlen(data)) == 0) {
    printf("File written successfully\n");
  }

  /* Create a temporary file */
  int tmp_fd = fio_filename_tmp();
  if (tmp_fd != -1) {
    fio_fd_write(tmp_fd, "temporary data", 14);
    close(tmp_fd);
  }

  return 0;
}
```

-------------------------------------------------------------------------------
## Custom JSON Parser

```c
#define FIO_JSON
#include "fio-stl.h"
```

The facil.io JSON parser is a non-strict parser, with support for trailing commas in collections, new-lines in strings, extended escape characters, comments, and common numeral formats (octal, hex and binary).

The facil.io JSON parser should be considered **unsafe** as overflow protection depends on the `NUL` character appearing at the end of the string passed to the parser.

**Note**: this module depends on the `FIO_ATOL` module which will be automatically included.

### Configuration Macros

#### `FIO_JSON_MAX_DEPTH`

```c
#ifndef FIO_JSON_MAX_DEPTH
/** Maximum allowed JSON nesting level. MUST be less than 65536. */
#define FIO_JSON_MAX_DEPTH 128
#endif
```

To ensure the program's stack isn't abused, the parser will limit JSON nesting levels to a customizable `FIO_JSON_MAX_DEPTH` number of nesting levels.

Values above 65536 might cause the stack to overflow and cause a failure.

#### `FIO_JSON_USE_FIO_ATON`

```c
#ifndef FIO_JSON_USE_FIO_ATON
#define FIO_JSON_USE_FIO_ATON 0
#endif
```

When set to `1`, the JSON parser will use `fio_aton` for number parsing instead of the default number parsing logic.

The default value is `0`.

### Types

#### `fio_json_parser_callbacks_s`

```c
typedef struct {
  /** NULL object was detected. Returns new object as `void *`. */
  void *(*on_null)(void);
  /** TRUE object was detected. Returns new object as `void *`. */
  void *(*on_true)(void);
  /** FALSE object was detected. Returns new object as `void *`. */
  void *(*on_false)(void);
  /** Number was detected (long long). Returns new object as `void *`. */
  void *(*on_number)(int64_t i);
  /** Float was detected (double). Returns new object as `void *`. */
  void *(*on_float)(double f);
  /** (escaped) String was detected. Returns a new String as `void *`. */
  void *(*on_string)(const void *start, size_t len);
  /** (unescaped) String was detected. Returns a new String as `void *`. */
  void *(*on_string_simple)(const void *start, size_t len);
  /** Dictionary was detected. Returns ctx to hash map or NULL on error. */
  void *(*on_map)(void *ctx, void *at);
  /** Array was detected. Returns ctx to array or NULL on error. */
  void *(*on_array)(void *ctx, void *at);
  /** Map push. Returns non-zero on error. */
  int (*map_push)(void *ctx, void *key, void *value);
  /** Array push. Returns non-zero on error. */
  int (*array_push)(void *ctx, void *value);
  /** Called when an array object (`ctx`) appears done. */
  int (*array_finished)(void *ctx);
  /** Called when a map object (`ctx`) appears done. */
  int (*map_finished)(void *ctx);
  /** Called when context is expected to be an array (i.e., fio_json_parse_update). */
  int (*is_array)(void *ctx);
  /** Called when context is expected to be a map (i.e., fio_json_parse_update). */
  int (*is_map)(void *ctx);
  /** Called for the `key` element in case of error or NULL value. */
  void (*free_unused_object)(void *ctx);
  /** The JSON parsing encountered an error - what to do with ctx? */
  void *(*on_error)(void *ctx);
} fio_json_parser_callbacks_s;
```

The JSON parser requires certain callbacks to create objects or perform actions based on JSON data.

**Required Callbacks:**

The following callbacks **MUST** be provided to the parser:

- `on_null` - `NULL` object was detected. Returns NULL object as `void *`.

- `on_true` - `true` object was detected. Returns TRUE object as `void *`.

- `on_false` - `false` object was detected. Returns FALSE object as `void *`.

- `on_number` - Number was detected (`int64_t`). Returns new number object as `void *`.

- `on_float` - Float was detected (`double`). Returns new float object as `void *`.

- `on_string` - Escaped string was detected. `start` points to a JSON escaped String (remember to unescape). Returns a new String as `void *`.

- `on_map` - Dictionary was detected. `ctx` is the current context, `at` is the key (if any). Returns new `ctx` to hash map or `NULL` on error.

- `on_array` - Array was detected. `ctx` is the current context, `at` is the key (if any). Returns new `ctx` to array or `NULL` on error.

- `map_push` - Pushes a key-value pair to a dictionary. Returns non-zero on error.

- `array_push` - Pushes a value to an array. Returns non-zero on error.

- `free_unused_object` - Called for the `key` element in case of error that caused `key` to be unused.

**Optional Callbacks:**

The following callbacks are optional and will use default no-op implementations if not provided:

- `on_string_simple` - Unescaped string was detected (no escape sequences). If not provided, falls back to `on_string`. If `on_string` is not provided but `on_string_simple` is, `on_string` will use `on_string_simple`.

- `array_finished` - Called when an array object (`ctx`) appears done. Returns non-zero on error. Default: no-op returning 0.

- `map_finished` - Called when a map object (`ctx`) appears done. Returns non-zero on error. Default: no-op returning 0.

- `is_array` - Called to check if context is an array (used by `fio_json_parse_update`). Returns non-zero if true. Default: no-op returning 0.

- `is_map` - Called to check if context is a map (used by `fio_json_parse_update`). Returns non-zero if true. Default: no-op returning 0.

- `on_error` - The JSON parsing encountered an error. Receives the current context and returns what to do with it. Default: returns ctx unchanged.

#### `fio_json_result_s`

```c
typedef struct {
  void *ctx;
  size_t stop_pos;
  int err;
} fio_json_result_s;
```

The JSON return type containing the parsing result.

**Members:**

- `ctx` - The top-most context/object in the JSON stream (the root object)
- `stop_pos` - The number of bytes consumed before parsing stopped
- `err` - Non-zero if the parsing stopped due to an error

### JSON Parser API

#### `fio_json_parse`

```c
fio_json_result_s fio_json_parse(fio_json_parser_callbacks_s *callbacks,
                                 const char *json_string,
                                 const size_t len);
```

Parses a JSON string using the provided callbacks.

The facil.io JSON parser is a non-strict parser, with support for:

- Trailing commas in collections
- New-lines in strings
- Extended escape characters
- Comments (C-style `//` and `/* */`, and shell-style `#`)
- Octal, hex, and binary number formats
- `NaN` and `Infinity` float values

The parser decouples the parsing process from the resulting data-structure by calling the requested callbacks for JSON related events.

**Parameters:**

- `callbacks` - Pointer to the callback structure defining how to handle JSON elements
- `json_string` - The JSON string to parse
- `len` - Length of the JSON string in bytes

**Returns:** A `fio_json_result_s` containing:

- `ctx` - The root object created by the callbacks
- `stop_pos` - Number of bytes consumed (position where parsing stopped)
- `err` - Non-zero if an error occurred

**Note**: The parser automatically skips UTF-8 BOM (Byte Order Mark) if present at the beginning of the string.

#### `fio_json_parse_update`

```c
fio_json_result_s fio_json_parse_update(fio_json_parser_callbacks_s *callbacks,
                                        void *ctx,
                                        const char *json_string,
                                        const size_t len);
```

Updates an existing object with data from a JSON string.

Use only when `ctx` is an existing object (array or map) and the JSON data is wrapped in an object of the same type.

This function is useful for merging JSON data into an existing data structure.

**Parameters:**

- `callbacks` - Pointer to the callback structure (must include `is_array` and `is_map` callbacks)
- `ctx` - The existing object to update
- `json_string` - The JSON string containing update data
- `len` - Length of the JSON string in bytes

**Returns:** A `fio_json_result_s` with the updated context.

**Note**: The `is_array` and `is_map` callbacks **MUST** be provided when using this function, as they are used to verify that the existing context matches the JSON structure.

### JSON Parsing Example

The biggest question about parsing JSON is - where do we store the resulting data?

Different parsers solve this question in different ways.

The `FIOBJ` soft-typed object system offers a very effective solution for data manipulation, as it creates a separate object for every JSON element.

However, many parsers store the result in an internal data structure that can't be separated into different elements. These parsers appear faster while actually deferring a lot of the heavy lifting to a later stage.

Here is a short example that parses JSON data and prints it back as minified JSON:

```c
#define FIO_JSON
#define FIO_STR_NAME fio_str
#define FIO_LOG
#include "fio-stl.h"

/* Forward declarations for our object types */
typedef struct my_json_obj_s my_json_obj_s;

/* Simple tagged union for JSON values */
typedef enum {
  MY_JSON_NULL,
  MY_JSON_TRUE,
  MY_JSON_FALSE,
  MY_JSON_NUMBER,
  MY_JSON_FLOAT,
  MY_JSON_STRING,
  MY_JSON_ARRAY,
  MY_JSON_MAP,
} my_json_type_e;

struct my_json_obj_s {
  my_json_type_e type;
  union {
    int64_t i;
    double f;
    fio_str_s str;
    struct {
      my_json_obj_s **items;
      size_t len;
      size_t capa;
    } array;
    struct {
      my_json_obj_s **keys;
      my_json_obj_s **values;
      size_t len;
      size_t capa;
    } map;
  };
};

/* Callback implementations */
static void *my_on_null(void) {
  my_json_obj_s *o = calloc(1, sizeof(*o));
  o->type = MY_JSON_NULL;
  return o;
}

static void *my_on_true(void) {
  my_json_obj_s *o = calloc(1, sizeof(*o));
  o->type = MY_JSON_TRUE;
  return o;
}

static void *my_on_false(void) {
  my_json_obj_s *o = calloc(1, sizeof(*o));
  o->type = MY_JSON_FALSE;
  return o;
}

static void *my_on_number(int64_t i) {
  my_json_obj_s *o = calloc(1, sizeof(*o));
  o->type = MY_JSON_NUMBER;
  o->i = i;
  return o;
}

static void *my_on_float(double f) {
  my_json_obj_s *o = calloc(1, sizeof(*o));
  o->type = MY_JSON_FLOAT;
  o->f = f;
  return o;
}

static void *my_on_string(const void *start, size_t len) {
  my_json_obj_s *o = calloc(1, sizeof(*o));
  o->type = MY_JSON_STRING;
  /* Note: in production, you'd want to unescape the string */
  fio_str_write(&o->str, start, len);
  return o;
}

static void *my_on_array(void *ctx, void *at) {
  my_json_obj_s *o = calloc(1, sizeof(*o));
  o->type = MY_JSON_ARRAY;
  o->array.capa = 8;
  o->array.items = calloc(o->array.capa, sizeof(void *));
  (void)ctx;
  (void)at;
  return o;
}

static void *my_on_map(void *ctx, void *at) {
  my_json_obj_s *o = calloc(1, sizeof(*o));
  o->type = MY_JSON_MAP;
  o->map.capa = 8;
  o->map.keys = calloc(o->map.capa, sizeof(void *));
  o->map.values = calloc(o->map.capa, sizeof(void *));
  (void)ctx;
  (void)at;
  return o;
}

static int my_array_push(void *ctx, void *value) {
  my_json_obj_s *arr = ctx;
  if (arr->array.len >= arr->array.capa) {
    arr->array.capa *= 2;
    arr->array.items = realloc(arr->array.items, arr->array.capa * sizeof(void *));
  }
  arr->array.items[arr->array.len++] = value;
  return 0;
}

static int my_map_push(void *ctx, void *key, void *value) {
  my_json_obj_s *map = ctx;
  if (map->map.len >= map->map.capa) {
    map->map.capa *= 2;
    map->map.keys = realloc(map->map.keys, map->map.capa * sizeof(void *));
    map->map.values = realloc(map->map.values, map->map.capa * sizeof(void *));
  }
  map->map.keys[map->map.len] = key;
  map->map.values[map->map.len] = value;
  map->map.len++;
  return 0;
}

static void my_free_obj(void *ctx) {
  my_json_obj_s *o = ctx;
  if (!o)
    return;
  switch (o->type) {
  case MY_JSON_STRING:
    fio_str_destroy(&o->str);
    break;
  case MY_JSON_ARRAY:
    for (size_t i = 0; i < o->array.len; i++)
      my_free_obj(o->array.items[i]);
    free(o->array.items);
    break;
  case MY_JSON_MAP:
    for (size_t i = 0; i < o->map.len; i++) {
      my_free_obj(o->map.keys[i]);
      my_free_obj(o->map.values[i]);
    }
    free(o->map.keys);
    free(o->map.values);
    break;
  default:
    break;
  }
  free(o);
}

/* Print JSON object as minified string */
static void my_print_json(my_json_obj_s *o) {
  if (!o)
    return;
  switch (o->type) {
  case MY_JSON_NULL:
    printf("null");
    break;
  case MY_JSON_TRUE:
    printf("true");
    break;
  case MY_JSON_FALSE:
    printf("false");
    break;
  case MY_JSON_NUMBER:
    printf("%lld", (long long)o->i);
    break;
  case MY_JSON_FLOAT:
    printf("%g", o->f);
    break;
  case MY_JSON_STRING:
    printf("\"%s\"", fio_str2ptr(&o->str));
    break;
  case MY_JSON_ARRAY:
    printf("[");
    for (size_t i = 0; i < o->array.len; i++) {
      if (i > 0)
        printf(",");
      my_print_json(o->array.items[i]);
    }
    printf("]");
    break;
  case MY_JSON_MAP:
    printf("{");
    for (size_t i = 0; i < o->map.len; i++) {
      if (i > 0)
        printf(",");
      my_print_json(o->map.keys[i]);
      printf(":");
      my_print_json(o->map.values[i]);
    }
    printf("}");
    break;
  }
}

int main(void) {
  const char *json = "{ \"name\": \"John\", \"age\": 30, \"active\": true, "
                     "\"scores\": [100, 95, 87] }";

  fio_json_parser_callbacks_s callbacks = {
      .on_null = my_on_null,
      .on_true = my_on_true,
      .on_false = my_on_false,
      .on_number = my_on_number,
      .on_float = my_on_float,
      .on_string = my_on_string,
      .on_string_simple = my_on_string,
      .on_array = my_on_array,
      .on_map = my_on_map,
      .array_push = my_array_push,
      .map_push = my_map_push,
      .free_unused_object = my_free_obj,
  };

  fio_json_result_s result = fio_json_parse(&callbacks, json, strlen(json));

  if (result.err) {
    FIO_LOG_ERROR("JSON parsing failed at position %zu", result.stop_pos);
    return 1;
  }

  printf("Minified: ");
  my_print_json(result.ctx);
  printf("\n");

  my_free_obj(result.ctx);
  return 0;
}
```

### Supported JSON Extensions

The facil.io JSON parser supports several extensions beyond strict JSON:

**Comments:**
- C-style single-line comments: `// comment`
- C-style multi-line comments: `/* comment */`
- Shell/Ruby-style comments: `# comment`

**Numbers:**
- Hexadecimal: `0x1A2B`
- Binary: `0b1010`
- Octal: `0755`
- Infinity: `Infinity`, `inf`, `-Infinity`
- NaN: `NaN`, `nan`
- Leading plus sign: `+42`

**Strings:**
- New-lines within strings (non-strict)

**Collections:**
- Trailing commas: `[1, 2, 3,]` and `{"a": 1,}`

-------------------------------------------------------------------------------
## Basic Socket / IO Helpers

```c
#define FIO_SOCK
#include "fio-stl.h"
```

The facil.io standard library provides a few simple IO / Sockets helpers for POSIX systems and Windows.

By defining `FIO_SOCK`, the following functions will be defined.

**Note**: On Windows, `fd` is a 64-bit number with no promises made as to its value. On POSIX systems the `fd` is a 32-bit number which is sequential.

Since facil.io prefers the POSIX approach, it will validate the `fd` value for overflow and might fail to open / accept sockets when their value overflows the 32-bit type limit set on POSIX machines.

However, for most implementations this should be a non-issue as it seems (from observation, not knowledge) that Windows maps `fd` values to a kernel array (rather than a process specific array) and it is unlikely that any Windows machine will actually open more than 2 Giga "handles" unless it's doing something wrong.

**Note**: this module depends on the `FIO_URL` module which will be automatically included.

### Configuration Macros

#### `FIO_SOCK_DEFAULT_MAXIMIZE_LIMIT`

```c
#ifndef FIO_SOCK_DEFAULT_MAXIMIZE_LIMIT
#define FIO_SOCK_DEFAULT_MAXIMIZE_LIMIT (1ULL << 24)
#endif
```

The default maximum limit used by `fio_sock_maximize_limits` when called with `0` as the argument.

#### `FIO_SOCK_AVOID_UMASK`

This compilation flag, if defined before including the `FIO_SOCK` implementation, will avoid using `umask` (only using `chmod`).

Using `umask` in multi-threaded environments could cause `umask` data corruption due to race condition (as two calls are actually required, making the operation non-atomic).

If more than one thread is expected to create Unix sockets or call `umask` at the same time, it is recommended that the `FIO_SOCK_AVOID_UMASK` be used.

This, however, may affect permissions on some systems (i.e., some Linux distributions) where calling `chmod` on a Unix socket file doesn't properly update access permissions.

**Note**: on Windows facil.io behaves as if this flag was set.

### Types

#### `fio_sock_open_flags_e`

```c
typedef enum {
  FIO_SOCK_SERVER = 0,        /* Server socket (binds to local address) */
  FIO_SOCK_CLIENT = 1,        /* Client socket (connects to remote address) */
  FIO_SOCK_NONBLOCK = 2,      /* Set socket to non-blocking mode */
  FIO_SOCK_TCP = 4,           /* TCP/IP socket */
  FIO_SOCK_UDP = 8,           /* UDP socket */
  FIO_SOCK_UNIX = 16,         /* Unix domain socket (POSIX only) */
  FIO_SOCK_UNIX_PRIVATE = 48, /* Unix socket with restricted permissions */
} fio_sock_open_flags_e;
```

Socket type flags used with `fio_sock_open` and `fio_sock_open2`.

**Values:**

- `FIO_SOCK_SERVER` - Initializes a Server socket. For TCP/IP and Unix sockets, the new socket will be listening for incoming connections (`listen` will be automatically called).
- `FIO_SOCK_CLIENT` - Initializes a Client socket, calling `connect` using the `address` and `port` arguments.
- `FIO_SOCK_NONBLOCK` - Sets the new socket to non-blocking mode.
- `FIO_SOCK_TCP` - Creates a TCP/IP socket.
- `FIO_SOCK_UDP` - Creates a UDP socket.
- `FIO_SOCK_UNIX` - Creates a Unix socket (requires a POSIX system). If an existing file / Unix socket exists, they will be deleted and replaced.
- `FIO_SOCK_UNIX_PRIVATE` - Same as `FIO_SOCK_UNIX`, only does not use `umask` and `chmod` to make the socket publicly available.

**Note**: `FIO_SOCK_UNIX` and `FIO_SOCK_UNIX_PRIVATE` are only available on systems that support Unix domain sockets (defined as `0` otherwise).

**Note**: if neither `FIO_SOCK_SERVER` nor `FIO_SOCK_CLIENT` are specified, the function will default to a server socket.

### API Functions

#### `fio_sock_open`

```c
int fio_sock_open(const char *restrict address,
                  const char *restrict port,
                  uint16_t flags);
```

Creates a new socket according to the provided flags.

The `port` string will be ignored when `FIO_SOCK_UNIX` is set.

The `address` can be NULL for Server sockets (`FIO_SOCK_SERVER`) when binding to all available interfaces (this is actually recommended unless network filtering is desired).

The `flags` integer can be a combination of any of the `fio_sock_open_flags_e` flags.

**Note**: UDP Server Sockets might need to handle traffic from multiple clients, which could require a significantly larger OS buffer than the default buffer offered.

Consider (from [this SO answer](https://stackoverflow.com/questions/2090850/specifying-udp-receive-buffer-size-at-runtime-in-linux/2090902#2090902), see [this blog post](https://medium.com/@CameronSparr/increase-os-udp-buffers-to-improve-performance-51d167bb1360), [this article](http://fasterdata.es.net/network-tuning/udp-tuning/) and [this article](https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Web_Platform/5/html/Administration_And_Configuration_Guide/jgroups-perf-udpbuffer.html)):

```c
int n = 32*1024*1024; /* try for 32Mb */
while (n >= (4*1024*1024) && setsockopt(socket, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) == -1) {
  /* failed - repeat attempt at 1Mb interval */
  if (n >= (4 * 1024 * 1024)) // OS may have returned max value
    n -= 1024 * 1024;
}
```

#### `fio_sock_open2`

```c
int fio_sock_open2(const char *url, uint16_t flags);
```

See [`fio_sock_open`](#fio_sock_open) for details. Accepts a single, URL style string instead of an address / port pair.

The `tcp` / `udp` information **may** appear in the URL schema if missing from the flags (i.e., `tcp://localhost:3000/`).

If a Unix socket URL is detected on a POSIX system, a `FIO_SOCK_UNIX` socket flag will override any `FIO_SOCK_TCP` or `FIO_SOCK_UDP` that were originally given.

**Note**: a `file://` or `unix://` (or even a simple `./file.sock`) URL will create a publicly available Unix Socket (permissions set to allow everyone RW access). To create a private Unix Socket (one with permissions equal to the process's `umask`), use a `priv://` schema (i.e., `priv://my.sock`).

#### `fio_sock_address_new`

```c
struct addrinfo *fio_sock_address_new(const char *restrict address,
                                      const char *restrict port,
                                      int sock_type);
```

Attempts to resolve an address to a valid IP6 / IP4 address pointer.

The `sock_type` element should be a socket type, such as `SOCK_DGRAM` (UDP) or `SOCK_STREAM` (TCP/IP).

The address should be freed using `fio_sock_address_free`.

**Note**: common web service names are automatically resolved to port numbers:
- `ws`  `80`
- `wss`, `sse`, `sses`  `443`
- `http`  `80`
- `https`  `443`

#### `fio_sock_address_free`

```c
void fio_sock_address_free(struct addrinfo *a);
```

Frees the pointer returned by `fio_sock_address_new`.

#### `fio_sock_peer_addr`

```c
fio_buf_info_s fio_sock_peer_addr(int s);
```

Returns a human readable address representation of the socket's peer address.

On error, returns a NULL buffer with zero length.

Buffer lengths are limited to 63 bytes.

**Note**: this function is limited in its thread safety to 128 threads / calls.

#### `fio_sock_open_local`

```c
int fio_sock_open_local(struct addrinfo *addr, int nonblock);
```

Creates a new network socket and binds it to a local address.

- `addr` - address information from `fio_sock_address_new`
- `nonblock` - if non-zero, sets the socket to non-blocking mode

Returns the file descriptor on success, or -1 on error.

#### `fio_sock_open_remote`

```c
int fio_sock_open_remote(struct addrinfo *addr, int nonblock);
```

Creates a new network socket and connects it to a remote address.

- `addr` - address information from `fio_sock_address_new`
- `nonblock` - if non-zero, sets the socket to non-blocking mode

Returns the file descriptor on success, or -1 on error.

#### `fio_sock_open_unix`

```c
int fio_sock_open_unix(const char *address, uint16_t flags);
```

Creates a new Unix socket and binds it to a local address.

- `address` - the Unix socket path
- `flags` - socket flags (see `fio_sock_open_flags_e`)

Returns the file descriptor on success, or -1 on error.

**Note**: not available on all systems. On Windows, when Unix Sockets are available (which isn't always), the permissions for the socket are system defined (facil.io doesn't change them).

#### `fio_sock_set_non_block`

```c
int fio_sock_set_non_block(int fd);
```

Sets a file descriptor / socket to non-blocking state.

Returns 0 on success, -1 on error.

#### `fio_sock_maximize_limits`

```c
size_t fio_sock_maximize_limits(size_t max_limit);
```

Attempts to maximize the allowed open file limits (with values up to `max_limit`).

Returns the new known limit.

If `max_limit` is 0, uses `FIO_SOCK_DEFAULT_MAXIMIZE_LIMIT`.

#### `fio_sock_wait_io`

```c
short fio_sock_wait_io(int fd, short events, int timeout);
```

Uses `poll` to wait until an IO device has one or more of the events listed in `events` (`POLLIN | POLLOUT`) or `timeout` (in milliseconds) has passed.

A zero timeout returns immediately.

Returns 0 on timeout, -1 on error, or the events that are valid.

Possible valid return values also include `POLLIN | POLLOUT | POLLHUP | POLLNVAL`.

### Portability Macros

These macros provide cross-platform compatibility between POSIX and Windows (WinSock2).

#### `fio_sock_write`

```c
/* POSIX */
#define fio_sock_write(fd, data, len) write((fd), (data), (len))
/* Windows */
#define fio_sock_write(fd, data, len) send((fd), (data), (len), 0)
```

Acts as POSIX `write`. Use this macro for portability with WinSock2.

#### `fio_sock_read`

```c
/* POSIX */
#define fio_sock_read(fd, buf, len) read((fd), (buf), (len))
/* Windows */
#define fio_sock_read(fd, buf, len) recv((fd), (buf), (len), 0)
```

Acts as POSIX `read`. Use this macro for portability with WinSock2.

#### `fio_sock_close`

```c
/* POSIX */
#define fio_sock_close(fd) close(fd)
/* Windows */
#define fio_sock_close(fd) closesocket(fd)
```

Acts as POSIX `close`. Use this macro for portability with WinSock2.

#### `fio_sock_dup`

```c
/* POSIX */
#define fio_sock_dup(fd) dup(fd)
/* Windows - function wrapper */
int fio_sock_dup(int original);
```

Acts as POSIX `dup`. Use this for portability with WinSock2.

On Windows, this is a function that uses `WSADuplicateSocket` internally.

#### `fio_sock_accept`

```c
/* POSIX */
#define fio_sock_accept(fd, addr, addrlen) accept(fd, addr, addrlen)
/* Windows - function wrapper */
int fio_sock_accept(int s, struct sockaddr *addr, int *addrlen);
```

Acts as POSIX `accept`. Use this macro for portability with WinSock2.

On Windows, this is a function that validates the returned socket value doesn't overflow the portable int range.

**Note**: on Windows, `accept` is redefined to `fio_sock_accept`.

#### `FIO_SOCK_FD_ISVALID`

```c
/* POSIX */
#define FIO_SOCK_FD_ISVALID(fd) ((int)(fd) != (int)-1)
/* Windows */
#define FIO_SOCK_FD_ISVALID(fd) ((size_t)(fd) <= (size_t)0x7FFFFFFF)
```

Tests if a file descriptor value is valid.

On Windows, this also checks that the socket value fits within the portable 32-bit range.

### Helper Macros

#### `FIO_SOCK_WAIT_RW`

```c
#define FIO_SOCK_WAIT_RW(fd, timeout_) fio_sock_wait_io(fd, POLLIN | POLLOUT, timeout_)
```

A helper macro that waits on a single IO for both read and write readiness (0 = no event / timeout).

#### `FIO_SOCK_WAIT_R`

```c
#define FIO_SOCK_WAIT_R(fd, timeout_) fio_sock_wait_io(fd, POLLIN, timeout_)
```

A helper macro that waits on a single IO for read readiness (0 = no event / timeout).

#### `FIO_SOCK_WAIT_W`

```c
#define FIO_SOCK_WAIT_W(fd, timeout_) fio_sock_wait_io(fd, POLLOUT, timeout_)
```

A helper macro that waits on a single IO for write readiness (0 = no event / timeout).

#### `FIO_SOCK_IS_OPEN`

```c
/* When POLLRDHUP is available */
#define FIO_SOCK_IS_OPEN(fd)                                                   \
  (!(fio_sock_wait_io(fd, (POLLOUT | POLLRDHUP), 0) &                          \
     (POLLRDHUP | POLLHUP | POLLNVAL)))
/* Otherwise */
#define FIO_SOCK_IS_OPEN(fd)                                                   \
  (!(fio_sock_wait_io(fd, POLLOUT, 0) & (POLLHUP | POLLNVAL)))
```

A helper macro that tests if a socket is still open (not remotely closed).

Returns non-zero if the socket is open, zero if closed or invalid.

### Example

```c
#define FIO_SOCK
#define FIO_LOG
#include "fio-stl.h"

int main(void) {
  /* Maximize file descriptor limits */
  size_t max_fds = fio_sock_maximize_limits(0);
  FIO_LOG_INFO("Maximum file descriptors: %zu", max_fds);

  /* Create a TCP server socket */
  int server_fd = fio_sock_open(NULL, "8080",
                                FIO_SOCK_TCP | FIO_SOCK_SERVER | FIO_SOCK_NONBLOCK);
  if (server_fd == -1) {
    FIO_LOG_ERROR("Failed to create server socket");
    return 1;
  }
  FIO_LOG_INFO("Server listening on port 8080 (fd=%d)", server_fd);

  /* Alternative: create socket using URL */
  int server_fd2 = fio_sock_open2("tcp://0.0.0.0:8081",
                                  FIO_SOCK_SERVER | FIO_SOCK_NONBLOCK);
  if (server_fd2 != -1) {
    FIO_LOG_INFO("Server also listening on port 8081 (fd=%d)", server_fd2);
  }

  /* Wait for incoming connection (with 5 second timeout) */
  short events = FIO_SOCK_WAIT_R(server_fd, 5000);
  if (events & POLLIN) {
    struct sockaddr_storage client_addr;
    socklen_t addr_len = sizeof(client_addr);
    int client_fd = fio_sock_accept(server_fd,
                                    (struct sockaddr *)&client_addr,
                                    (int *)&addr_len);
    if (client_fd != -1) {
      fio_buf_info_s peer = fio_sock_peer_addr(client_fd);
      FIO_LOG_INFO("Accepted connection from %.*s", (int)peer.len, peer.buf);
      
      /* Set client to non-blocking */
      fio_sock_set_non_block(client_fd);
      
      /* Send a response */
      const char *response = "Hello, World!\n";
      fio_sock_write(client_fd, response, strlen(response));
      
      /* Close client connection */
      fio_sock_close(client_fd);
    }
  } else {
    FIO_LOG_INFO("No connection received (timeout)");
  }

  /* Check if socket is still open */
  if (FIO_SOCK_IS_OPEN(server_fd)) {
    FIO_LOG_INFO("Server socket is still open");
  }

  /* Cleanup */
  fio_sock_close(server_fd);
  if (server_fd2 != -1)
    fio_sock_close(server_fd2);

  return 0;
}
```

### Unix Socket Example

```c
#define FIO_SOCK
#define FIO_LOG
#include "fio-stl.h"

int main(void) {
  /* Create a Unix domain socket server */
  int unix_fd = fio_sock_open("/tmp/my_app.sock", NULL,
                              FIO_SOCK_UNIX | FIO_SOCK_SERVER | FIO_SOCK_NONBLOCK);
  if (unix_fd == -1) {
    FIO_LOG_ERROR("Failed to create Unix socket");
    return 1;
  }
  FIO_LOG_INFO("Unix socket server created at /tmp/my_app.sock");

  /* Alternative: using URL syntax */
  int unix_fd2 = fio_sock_open2("unix:///tmp/my_app2.sock",
                                FIO_SOCK_SERVER | FIO_SOCK_NONBLOCK);
  
  /* For a private socket (restricted permissions) */
  int priv_fd = fio_sock_open2("priv:///tmp/my_private.sock",
                               FIO_SOCK_SERVER | FIO_SOCK_NONBLOCK);

  /* Cleanup */
  fio_sock_close(unix_fd);
  if (unix_fd2 != -1) fio_sock_close(unix_fd2);
  if (priv_fd != -1) fio_sock_close(priv_fd);
  
  /* Remove socket files */
  unlink("/tmp/my_app.sock");
  unlink("/tmp/my_app2.sock");
  unlink("/tmp/my_private.sock");

  return 0;
}
```

### Client Connection Example

```c
#define FIO_SOCK
#define FIO_LOG
#include "fio-stl.h"

int main(void) {
  /* Connect to a remote server */
  int client_fd = fio_sock_open("example.com", "80",
                                FIO_SOCK_TCP | FIO_SOCK_CLIENT | FIO_SOCK_NONBLOCK);
  if (client_fd == -1) {
    FIO_LOG_ERROR("Failed to connect");
    return 1;
  }

  /* Wait for connection to complete */
  if (FIO_SOCK_WAIT_W(client_fd, 5000) & POLLOUT) {
    FIO_LOG_INFO("Connected to example.com:80");
    
    /* Send HTTP request */
    const char *request = "GET / HTTP/1.0\r\nHost: example.com\r\n\r\n";
    fio_sock_write(client_fd, request, strlen(request));
    
    /* Wait for response */
    if (FIO_SOCK_WAIT_R(client_fd, 5000) & POLLIN) {
      char buffer[4096];
      ssize_t bytes = fio_sock_read(client_fd, buffer, sizeof(buffer) - 1);
      if (bytes > 0) {
        buffer[bytes] = '\0';
        FIO_LOG_INFO("Received %zd bytes:\n%s", bytes, buffer);
      }
    }
  }

  fio_sock_close(client_fd);
  return 0;
}
```

-------------------------------------------------------------------------------
## State Callbacks

```c
#define FIO_STATE
#include "fio-stl.h"
```

The state callback API allows callbacks to be registered for specific changes in the state of the application. This is also used internally by stateful modules such as the memory allocator.

This allows modules to react to changes in the state of the program without requiring the functions that caused the change in state to know about each of the modules that wish to react, only requiring it to publish a notification by calling `fio_state_callback_force`.

When using this module it is better if it is used as a global `FIO_EXTERN` module, so state notifications are not limited to the scope of the C file (the translation unit).

**Note**: this module depends on the `FIO_RAND`, `FIO_ATOMIC`, and `FIO_IMAP_CORE` modules which will be automatically included.

### Event Types

#### `fio_state_event_type_e`

```c
typedef enum {
  /** Called once during library initialization. */
  FIO_CALL_ON_INITIALIZE,
  /** Called once before starting up the IO reactor. */
  FIO_CALL_PRE_START,
  /** Called before each time the IO reactor forks a new worker. */
  FIO_CALL_BEFORE_FORK,
  /** Called after each fork (both parent and child), before FIO_CALL_IN_XXX */
  FIO_CALL_AFTER_FORK,
  /** Called by a worker process right after forking. */
  FIO_CALL_IN_CHILD,
  /** Called by the master process after spawning a worker (after forking). */
  FIO_CALL_IN_MASTER,
  /** Called by each worker thread in a Server Async queue as it starts. */
  FIO_CALL_ON_WORKER_THREAD_START,
  /** Called every time a *Worker* process starts. */
  FIO_CALL_ON_START,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED1,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED2,
  /** User state event queue (unused, available for the user). */
  FIO_CALL_ON_USER1,
  /** User state event queue (unused, available for the user). */
  FIO_CALL_ON_USER2,
  /** Called when facil.io enters idling mode. */
  FIO_CALL_ON_IDLE,
  /** A reversed user state event queue (unused, available for the user). */
  FIO_CALL_ON_USER1_REVERSE,
  /** A reversed user state event queue (unused, available for the user). */
  FIO_CALL_ON_USER2_REVERSE,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED1_REVERSED,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED2_REVERSED,
  /** Called before starting the shutdown sequence. */
  FIO_CALL_ON_SHUTDOWN,
  /** Called by each worker the moment it detects the master process crashed. */
  FIO_CALL_ON_PARENT_CRUSH,
  /** Called by the parent (master) after a worker process crashed. */
  FIO_CALL_ON_CHILD_CRUSH,
  /** Called by each worker thread in a Server Async queue as it ends. */
  FIO_CALL_ON_WORKER_THREAD_END,
  /** Called when either a *Worker* or *Master* stopped. */
  FIO_CALL_ON_STOP,
  /** An alternative to the system's at_exit. */
  FIO_CALL_AT_EXIT,
  /** used for testing and array allocation - must be last. */
  FIO_CALL_NEVER
} fio_state_event_type_e;
```

An enumeration of event types that can be used with the state callback API.

Events are performed either in the order in which they were registered (FIFO) or in reverse order (LIFO), depending on the event type:

- Events where `event <= FIO_CALL_ON_IDLE` are called in order of registration (FIFO)
- Events where `event >= FIO_CALL_ON_SHUTDOWN` are called in reverse order (LIFO)

**Note**: some events are only relevant in the context of the `FIO_SERVER` module and were designed for the server's use.

### State Callback API

#### `fio_state_callback_add`

```c
void fio_state_callback_add(fio_state_event_type_e event,
                            void (*func)(void *),
                            void *arg);
```

Adds a callback to the list of callbacks to be called for the `event`.

The callback should accept a single `void *` as an argument.

**Parameters:**
- `event` - the event type to register the callback for
- `func` - the callback function to be called when the event occurs
- `arg` - an opaque pointer that will be passed to the callback

**Note**: if `FIO_CALL_ON_INITIALIZE` callbacks have already been performed and a new callback is added for that event, the callback will be executed immediately.

#### `fio_state_callback_remove`

```c
int fio_state_callback_remove(fio_state_event_type_e event,
                              void (*func)(void *),
                              void *arg);
```

Removes a callback from the list of callbacks to be called for the event.

**Parameters:**
- `event` - the event type to remove the callback from
- `func` - the callback function to remove
- `arg` - the opaque pointer that was passed when adding the callback

**Returns:** `0` on success, `-1` if the callback was not found or the event type is invalid.

#### `fio_state_callback_clear`

```c
void fio_state_callback_clear(fio_state_event_type_e event);
```

Clears all the existing callbacks for the specified event.

**Parameters:**
- `event` - the event type to clear all callbacks for

#### `fio_state_callback_force`

```c
void fio_state_callback_force(fio_state_event_type_e event);
```

Forces all the existing callbacks to run, as if the event occurred.

Callbacks for all initialization / idling tasks are called in order of creation (where `event <= FIO_CALL_ON_IDLE`).

Callbacks for all cleanup oriented tasks are called in reverse order of creation (where `event >= FIO_CALL_ON_SHUTDOWN`).

**Note**: during an event, changes to the callback list are ignored (callbacks can't add or remove other callbacks for the same event).

**Note**: when `FIO_CALL_AFTER_FORK` is forced, all internal locks are re-initialized. When `FIO_CALL_IN_CHILD` is forced, the random generator is re-seeded.

### Example

```c
#define FIO_STATE
#define FIO_LOG
#include "fio-stl.h"

static void my_cleanup(void *arg) {
  FIO_LOG_INFO("Cleanup called with arg: %p", arg);
}

static void my_startup(void *arg) {
  FIO_LOG_INFO("Startup called with arg: %p", arg);
}

int main(void) {
  /* Register a callback for when the application starts */
  fio_state_callback_add(FIO_CALL_ON_START, my_startup, (void *)0x1234);
  
  /* Register a cleanup callback for when the application exits */
  fio_state_callback_add(FIO_CALL_AT_EXIT, my_cleanup, (void *)0x5678);
  
  /* Force the ON_START event to run all registered callbacks */
  fio_state_callback_force(FIO_CALL_ON_START);
  
  /* Remove a specific callback */
  fio_state_callback_remove(FIO_CALL_ON_START, my_startup, (void *)0x1234);
  
  /* Clear all callbacks for a specific event */
  fio_state_callback_clear(FIO_CALL_ON_USER1);
  
  return 0;
  /* AT_EXIT callbacks will be called automatically on program exit */
}
```

-------------------------------------------------------------------------------
## Time Helpers

```c
#define FIO_TIME
#include "fio-stl.h"
```

By defining `FIO_TIME` or `FIO_QUEUE`, the following time-related helper functions are defined.

**Note**: this module depends on the `FIO_ATOL` module which will be automatically included.

### Collecting Monotonic / Real Time

#### `fio_time_real`

```c
struct timespec fio_time_real(void);
```

Returns human (wall clock) time. This value isn't as safe for measurements since it can be affected by system time adjustments.

#### `fio_time_mono`

```c
struct timespec fio_time_mono(void);
```

Returns monotonic time. This is the preferred time source for measuring elapsed time, as it is not affected by system time changes.

#### `fio_time_nano`

```c
int64_t fio_time_nano(void);
```

Returns monotonic time in nanoseconds (1 billionth of a second).

#### `fio_time_micro`

```c
int64_t fio_time_micro(void);
```

Returns monotonic time in microseconds (1 millionth of a second).

#### `fio_time_milli`

```c
int64_t fio_time_milli(void);
```

Returns monotonic time in milliseconds.

### Time Conversion Functions

#### `fio_time2milli`

```c
int64_t fio_time2milli(struct timespec t);
```

Converts a `struct timespec` to milliseconds.

#### `fio_time2micro`

```c
int64_t fio_time2micro(struct timespec t);
```

Converts a `struct timespec` to microseconds.

#### `fio_time2gm`

```c
struct tm fio_time2gm(time_t time);
```

A faster (yet less localized) alternative to `gmtime_r`.

See the libc `gmtime_r` documentation for details.

Returns a `struct tm` object filled with the date information.

Falls back to `gmtime_r` for dates before epoch.

This function is used internally for the formatting functions: `fio_time2rfc7231`, `fio_time2rfc2109`, `fio_time2rfc2822`, `fio_time2log`, and `fio_time2iso`.

#### `fio_gm2time`

```c
time_t fio_gm2time(struct tm tm);
```

Converts a `struct tm` to time in seconds (assuming UTC).

This function is less localized than the `mktime` / `timegm` library functions.

### Time Arithmetic Functions

#### `fio_time_add`

```c
struct timespec fio_time_add(struct timespec t, struct timespec t2);
```

Adds two `struct timespec` objects together.

Returns a normalized `struct timespec` with the sum of both time values.

#### `fio_time_add_milli`

```c
struct timespec fio_time_add_milli(struct timespec t, int64_t milli);
```

Adds milliseconds to a `struct timespec` object.

Returns a normalized `struct timespec` with the adjusted time value.

#### `fio_time_cmp`

```c
int fio_time_cmp(struct timespec t1, struct timespec t2);
```

Compares two `struct timespec` objects.

**Returns:**
- `-1` if `t1 < t2`
- `0` if `t1 == t2`
- `1` if `t1 > t2`

### Time Formatting Functions

#### `fio_time2rfc7231`

```c
size_t fio_time2rfc7231(char *target, time_t time);
```

Writes an RFC 7231 date representation (HTTP date format) to `target`.

Usually requires 29 characters, although this may vary.

The format is: `DDD, dd MON YYYY HH:MM:SS GMT`

i.e.: `Sun, 06 Nov 1994 08:49:37 GMT`

**Returns:** the number of characters written (excluding NUL terminator).

#### `fio_time2rfc2109`

```c
size_t fio_time2rfc2109(char *target, time_t time);
```

Writes an RFC 2109 date representation to `target` (HTTP Cookie format).

Usually requires 31 characters, although this may vary.

**Returns:** the number of characters written (excluding NUL terminator).

#### `fio_time2rfc2822`

```c
size_t fio_time2rfc2822(char *target, time_t time);
```

Writes an RFC 2822 date representation to `target` (Internet Message Format).

Usually requires 28 to 29 characters, although this may vary.

**Returns:** the number of characters written (excluding NUL terminator).

#### `fio_time2log`

```c
size_t fio_time2log(char *target, time_t time);
```

Writes a date representation to `target` in common log format.

Format: `[DD/MMM/yyyy:hh:mm:ss +0000]`

Usually requires 29 characters (including square brackets and NUL).

**Returns:** the number of characters written (excluding NUL terminator).

#### `fio_time2iso`

```c
size_t fio_time2iso(char *target, time_t time);
```

Writes a date representation to `target` in ISO 8601 format.

Format: `YYYY-MMM-DD HH:MM:SS`

Usually requires 20 characters (including NUL).

**Note**: the month is written as a 3-letter abbreviation (e.g., `Jan`, `Feb`), not as a numeric value.

**Returns:** the number of characters written (excluding NUL terminator).

### Example

```c
#define FIO_TIME
#include "fio-stl.h"

int main(void) {
  /* Get current time */
  struct timespec mono = fio_time_mono();
  struct timespec real = fio_time_real();
  
  /* Convert to different units */
  int64_t ms = fio_time_milli();
  int64_t us = fio_time_micro();
  int64_t ns = fio_time_nano();
  
  printf("Monotonic time: %lld ms, %lld us, %lld ns\n",
         (long long)ms, (long long)us, (long long)ns);
  
  /* Time arithmetic */
  struct timespec future = fio_time_add_milli(mono, 5000); /* 5 seconds later */
  if (fio_time_cmp(future, mono) > 0) {
    printf("Future time is greater than current time\n");
  }
  
  /* Format current time */
  time_t now = real.tv_sec;
  char buf[64];
  
  fio_time2rfc7231(buf, now);
  printf("RFC 7231: %s\n", buf);
  
  fio_time2rfc2109(buf, now);
  printf("RFC 2109: %s\n", buf);
  
  fio_time2rfc2822(buf, now);
  printf("RFC 2822: %s\n", buf);
  
  fio_time2log(buf, now);
  printf("Log format: %s\n", buf);
  
  fio_time2iso(buf, now);
  printf("ISO 8601: %s\n", buf);
  
  /* Convert between struct tm and time_t */
  struct tm tm = fio_time2gm(now);
  printf("Year: %d, Month: %d, Day: %d\n",
         tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);
  
  time_t converted = fio_gm2time(tm);
  printf("Converted back: %s", ctime(&converted));
  
  return 0;
}
```

-------------------------------------------------------------------------------
## CLI (Command Line Interface)

```c
#define FIO_CLI
#include "fio-stl.h"
```

The facil.io library includes a CLI parser that provides a simpler API and more features than the array iteration based `getopt`, such as:

* Auto-generation of the "help" / usage output.

* Argument type testing (String, Boolean, and Integer types are supported).

* Global Hash map storage and access to the parsed argument values (until `fio_cli_end` is called).

* Support for unnamed options / arguments, including adjustable limits on how many a user may input.

* Array style support and access to unnamed arguments.

By defining `FIO_CLI`, the following functions will be defined.

In addition, `FIO_CLI` automatically includes the `FIO_ATOL`, `FIO_RAND` and `FIO_IMAP` flags, since CLI parsing and cleanup depends on them.

**Note**: the `fio_cli` module is **NOT** thread-safe unless limited to reading once multi-threading has started (reading is immutable, writing is where things can go wrong).

-------------------------------------------------------------------------------

### Types

#### `fio_cli_arg_e`

```c
typedef enum {
  FIO_CLI_ARG_STRING,       /* A String CLI argument */
  FIO_CLI_ARG_BOOL,         /* A Boolean CLI argument */
  FIO_CLI_ARG_INT,          /* An integer CLI argument */
  FIO_CLI_ARG_PRINT,        /* Print text with offset */
  FIO_CLI_ARG_PRINT_LINE,   /* Print text as-is */
  FIO_CLI_ARG_PRINT_HEADER, /* Print text as header */
} fio_cli_arg_e;

#define FIO_CLI_ARG_NONE FIO_CLI_ARG_PRINT_HEADER
```

An enumeration of CLI argument types used internally and returned by `fio_cli_type`.

**Values:**
- `FIO_CLI_ARG_STRING` - A string argument that accepts any value
- `FIO_CLI_ARG_BOOL` - A boolean flag (no value accepted)
- `FIO_CLI_ARG_INT` - An integer argument (validated during parsing)
- `FIO_CLI_ARG_PRINT` - Used for printing help text with offset
- `FIO_CLI_ARG_PRINT_LINE` - Used for printing help text as-is
- `FIO_CLI_ARG_PRINT_HEADER` - Used for printing section headers in help
- `FIO_CLI_ARG_NONE` - Alias for `FIO_CLI_ARG_PRINT_HEADER`

-------------------------------------------------------------------------------

### Argument Definition Macros

These macros are used within `fio_cli_start` to define command line arguments and help text formatting.

#### `FIO_CLI_STRING`

```c
#define FIO_CLI_STRING(line) /* ... */
```

Indicates the CLI argument should be a String (default type).

Example:

```c
FIO_CLI_STRING("-o -output (stdout) output file path")
```

#### `FIO_CLI_INT`

```c
#define FIO_CLI_INT(line) /* ... */
```

Indicates the CLI argument should be an Integer (numerical). The parser validates that the provided value is a valid integer.

Example:

```c
FIO_CLI_INT("-p -port (8080) the port number to use")
```

#### `FIO_CLI_BOOL`

```c
#define FIO_CLI_BOOL(line) /* ... */
```

Indicates the CLI argument is a Boolean value (flag). Boolean arguments cannot have default values and do not accept values - their presence indicates `true`.

Example:

```c
FIO_CLI_BOOL("-v -verbose enable verbose logging")
```

**Note**: Boolean flags can be chained, e.g., `-abc` is equivalent to `-a -b -c`.

#### `FIO_CLI_PRINT`

```c
#define FIO_CLI_PRINT(line) /* ... */
```

Indicates the CLI string should be printed as-is with proper offset (indentation). Used to add extra information related to the previous argument.

Example:

```c
FIO_CLI_INT("-p -port (8080) the port number"),
FIO_CLI_PRINT("Set to 0 for Unix socket mode.")
```

#### `FIO_CLI_PRINT_LINE`

```c
#define FIO_CLI_PRINT_LINE(line) /* ... */
```

Indicates the CLI string should be printed as-is with no offset. Used for raw text output in help.

Example:

```c
FIO_CLI_PRINT_LINE("Visit https://example.com for more information.")
```

#### `FIO_CLI_PRINT_HEADER`

```c
#define FIO_CLI_PRINT_HEADER(line) /* ... */
```

Indicates the CLI string should be printed as a section header (with underline formatting).

Example:

```c
FIO_CLI_PRINT_HEADER("Network Options:")
```

-------------------------------------------------------------------------------

### Initialization and Cleanup

#### `fio_cli_start`

```c
#define fio_cli_start(argc, argv, unnamed_min, unnamed_max, description, ...)  \
  fio_cli_start((argc),                                                        \
                (argv),                                                        \
                (unnamed_min),                                                 \
                (unnamed_max),                                                 \
                (description),                                                 \
                (fio___cli_line_s[]){__VA_ARGS__, {0}})

/* The shadowed function: */
void fio_cli_start(int argc,
                   char const *argv[],
                   int unnamed_min,
                   int unnamed_max,
                   char const *description,
                   fio___cli_line_s *arguments);
```

The `fio_cli_start` **macro** shadows the `fio_cli_start` function and defines the CLI interface to be parsed.

The macro accepts:
- `argc` - command line argument count (from `main`)
- `argv` - command line argument list (from `main`)
- `unnamed_min` - the required minimum of unnamed arguments
- `unnamed_max` - the maximum limit of unnamed arguments (use `-1` for unlimited)
- `description` - a C string containing the program's description
- `...` - a variable list of argument definitions using the `FIO_CLI_*` macros

If `unnamed_min` is set to `-1`, there will be no limit on the number of unnamed/unrecognized arguments allowed.

The text `NAME` in the description (all capitals) will be replaced with the executable command invoking the application.

Argument names **must** start with the `-` character. The first word starting without the `-` character will begin the description for the CLI argument.

The arguments `-?`, `-h`, `-help` and `--help` are automatically handled unless overridden.

**Note**: default values may optionally be provided by placing them in parenthesis immediately after the argument name and aliases. Default values that start with `(` must end with `)` (the surrounding parenthesis are ignored). Default values that start with `("` must end with `")` (the surrounding start and end markers are ignored).

**Note**: this function is **NOT** thread-safe.

Example:

```c
#define FIO_CLI
#include "fio-stl.h"

int main(int argc, char const *argv[]) {
  fio_cli_start(argc, argv, 0, -1,
                "This is a CLI example for the NAME application.\n"
                "This example allows for unlimited arguments that will be printed.",
                FIO_CLI_PRINT_HEADER("CLI type validation"),
                FIO_CLI_STRING("-s -str (my default string) any string data"),
                FIO_CLI_INT("-i -int (42) integer data"),
                FIO_CLI_BOOL("-b -bool flag (boolean) only - no data"),
                FIO_CLI_PRINT("Boolean flags cannot have default values."),
                FIO_CLI_PRINT_LINE("We hope you enjoy the NAME example.")
                );

  if (fio_cli_get("-s")) /* always true when default value is provided */
    fprintf(stderr, "String: %s\n", fio_cli_get("-s"));

  fprintf(stderr, "Integer: %d\n", (int)fio_cli_get_i("-i"));
  fprintf(stderr, "Boolean: %d\n", (int)fio_cli_get_i("-b"));

  if (fio_cli_unnamed_count()) {
    fprintf(stderr, "Printing unlisted / unrecognized arguments:\n");
    for (size_t i = 0; i < fio_cli_unnamed_count(); ++i) {
      fprintf(stderr, "%s\n", fio_cli_unnamed(i));
    }
  }

  fio_cli_end();
  return 0;
}
```

Arguments can be provided in multiple formats:

```
app -t=1 -p3000 -a localhost
app -t 1 -p 3000 -a localhost
app --threads=1 --port=3000 --address=localhost
```

#### `fio_cli_end`

```c
void fio_cli_end(void);
```

Clears the CLI data storage and frees all memory used by the CLI parser.

**Note**: this function has a destructor attribute and will be called automatically at program exit. However, calling it explicitly allows memory to be freed earlier.

**Note**: this function is **NOT** thread-safe.

-------------------------------------------------------------------------------

### Getting Argument Values

#### `fio_cli_get`

```c
char const *fio_cli_get(char const *name);
```

Returns the argument's value as a NUL-terminated C string, or `NULL` if the argument wasn't provided.

If `name` is `NULL`, returns the first unnamed argument (equivalent to `fio_cli_unnamed(0)`).

#### `fio_cli_get_str`

```c
fio_buf_info_s fio_cli_get_str(char const *name);
```

Returns the argument's value as a `fio_buf_info_s` structure containing both the string pointer and its length.

If `name` is `NULL`, returns the first unnamed argument.

Returns an empty `fio_buf_info_s` (with `NULL` buffer) if the argument wasn't provided.

#### `fio_cli_get_i`

```c
int64_t fio_cli_get_i(char const *name);
```

Returns the argument's value as an integer, or `0` if the argument wasn't provided.

**Note**: the command-line accepts integers in base 10, base 16, base 8 and binary as long as they have the appropriate prefix (i.e., none, `0x`, `0`, `0b`).

#### `fio_cli_get_bool`

```c
#define fio_cli_get_bool(name) (fio_cli_get((name)) != NULL)
```

Evaluates to `true` (non-zero) if the argument was provided. Otherwise evaluates to `false` (0).

This is typically used for boolean flags but works with any argument type.

#### `fio_cli_type`

```c
fio_cli_arg_e fio_cli_type(char const *name);
```

Returns the argument's expected content type as defined during `fio_cli_start`.

Returns `FIO_CLI_ARG_NONE` if the argument name is not recognized.

-------------------------------------------------------------------------------

### Unnamed Arguments

#### `fio_cli_unnamed_count`

```c
unsigned int fio_cli_unnamed_count(void);
```

Returns the number of unnamed arguments (arguments not matching any defined argument names).

#### `fio_cli_unnamed`

```c
char const *fio_cli_unnamed(unsigned int index);
```

Returns a NUL-terminated C string containing the unnamed argument at the stated `index` (indexes are zero-based).

Returns `NULL` if `index` is out of bounds.

#### `fio_cli_unnamed_str`

```c
fio_buf_info_s fio_cli_unnamed_str(unsigned int index);
```

Returns the unnamed argument at the stated `index` as a `fio_buf_info_s` structure containing both the string pointer and its length.

Returns an empty `fio_buf_info_s` if `index` is out of bounds.

-------------------------------------------------------------------------------

### Setting Argument Values

#### `fio_cli_set`

```c
void fio_cli_set(char const *name, char const *value);
```

Sets a value for the named argument. The value will propagate to all named aliases.

If `name` is `NULL`, adds `value` as a new unnamed argument.

**Note**: this function is **NOT** thread-safe.

#### `fio_cli_set_i`

```c
void fio_cli_set_i(char const *name, int64_t i);
```

Sets a numerical value for the named argument by converting it to a base-10 string representation.

**Note**: this function is **NOT** thread-safe.

#### `fio_cli_set_unnamed`

```c
unsigned int fio_cli_set_unnamed(unsigned int index, const char *value);
```

Sets or adds an unnamed argument at the specified `index` in the array of unnamed elements.

If `index` is greater than or equal to the current count of unnamed arguments, the value is appended to the end.

Returns the actual index where the value was stored, or `(unsigned int)-1` if `value` is `NULL` or empty.

**Note**: this function is **NOT** thread-safe.

-------------------------------------------------------------------------------

### Iteration

#### `fio_cli_each`

```c
size_t fio_cli_each(int (*task)(fio_buf_info_s name,
                                fio_buf_info_s value,
                                fio_cli_arg_e arg_type,
                                void *udata),
                    void *udata);
```

Calls `task` for every argument that was received (has a value), returning the number of times `task` was called.

If `task` returns a non-zero value, iteration stops early and `fio_cli_each` returns.

The `udata` pointer is an opaque user pointer passed to each invocation of `task`.

For unnamed arguments, `name` will have a `NULL` buffer and zero length.

-------------------------------------------------------------------------------
## Local Memory Allocation

```c
#define FIO_MEMORY_NAME mem
#include "fio-stl.h"
```

The facil.io library includes a fast, concurrent, local memory allocator designed for grouping together objects with similar lifespans. [This has many advantages](https://youtu.be/nZNd5FjSquk).

Multiple allocators can be defined using `FIO_MEMORY_NAME` and including `fio-stl.h` multiple times.

The shortcut `FIO_MALLOC` MACRO will define a local memory allocator shared by any facil.io types that are defined after that macro (in multiple `include` space).

When `FIO_MEMORY_DISABLE` is defined, all custom memory allocators will route to the system's `malloc`.

**Note**: this module defines memory allocation macros for all subsequent modules in the same `include` statement.

**Note**: when a memory allocator is defined, this module requires `FIO_STATE`, `FIO_THREADS`, `FIO_ATOMIC`, `FIO_IMAP_CORE`, and `FIO_RAND`, which will be automatically included.

**Note**: Use [`fio_mmap`](#fio_mmap) or the system's `malloc` for long-term allocations.

### Memory Allocator Overview

To minimize contention, the memory allocator uses allocation "arenas" that can work independently, allowing a number of threads to allocate memory in parallel with other threads (depending on the number of arenas).

The memory allocator collects "chunks" of memory from the system.

Each chunk is divided into "blocks" or used in whole as a "big-block".

Each block is assigned to an arena. Big block allocations aren't assigned to arenas and aren't performed in parallel.

Blocks and big-blocks are "sliced" in a similar manner to `sbrk` in order to allocate the actual memory.

A block (or big-block) is returned to the allocator for reuse only when it's memory was fully freed. A leaked allocation will prevent a block / big-block from being released back to the allocator.

If all the blocks in a memory chunk were freed, the chunk is either cached or returned to the system, according to the allocator's settings.

This behavior, including the allocator's default alignment, can be tuned / changed using compile-time macros.

It should be possible to use tcmalloc or jemalloc alongside facil.io's allocator.

It's also possible to prevent facil.io's custom allocator from compiling by defining `FIO_MEMORY_DISABLE` (`-DFIO_MEMORY_DISABLE`).

### The Memory Allocator's API

The functions were designed to be a drop in replacement to the system's memory allocation functions (`malloc`, `free` and friends).

Where some improvement could be made, it was made using an added function name to add improved functionality (such as `fio_realloc2`).

**Note**: the prefix `fio` will be different according to the `FIO_MEMORY_NAME` macro, it is used here because this is the prefix defined when using the `FIO_MALLOC` shortcut macro.

#### `fio_malloc`

```c
void * fio_malloc(size_t size);
```

Allocates memory of requested size, using the defined alignment (`FIO_MEMORY_ALIGN_LOG`).

Memory is **always** zeroed out, no need to manually zero the memory after allocation.

Allocations above the allocator's per-arena limit will be redirected to a large allocation chunk if enabled (see `FIO_MEMORY_ENABLE_BIG_ALLOC`).

Allocations above the allocator limit will be redirected to `mmap`, as if `fio_mmap` was called.

**Note**: the prefix `fio` will be different according to the `FIO_MEMORY_NAME` macro, it is used here because this is the prefix defined when using the `FIO_MALLOC` shortcut macro.

#### `fio_calloc`

```c
void * fio_calloc(size_t size_per_unit, size_t unit_count);
```

Same as calling `fio_malloc(size_per_unit * unit_count)`.

**Note**: the prefix `fio` will be different according to the `FIO_MEMORY_NAME` macro, it is used here because this is the prefix defined when using the `FIO_MALLOC` shortcut macro.

#### `fio_realloc`

```c
void * fio_realloc(void *ptr, size_t new_size);
```

Re-allocates memory. An attempt to avoid copying the data is made only for memory allocations that are performed directly against the system (sizes over the allocator limit).

**Note**: when reallocating, junk data may be copied onto the new allocation unit. It is better to use `fio_realloc2`.

**Note**: the prefix `fio` will be different according to the `FIO_MEMORY_NAME` macro, it is used here because this is the prefix defined when using the `FIO_MALLOC` shortcut macro.

#### `fio_realloc2`

```c
void * fio_realloc2(void *ptr, size_t new_size, size_t copy_length);
```

Re-allocates memory. An attempt to avoid copying the data is made only for memory allocations that are performed directly against the system (sizes over the allocator limit).

This variation could be significantly faster as it will copy less data.

This variation also promises that any memory over `copy_length` is zeroed out.

**Note**: the prefix `fio` will be different according to the `FIO_MEMORY_NAME` macro, it is used here because this is the prefix defined when using the `FIO_MALLOC` shortcut macro.

#### `fio_mmap`

```c
void * fio_mmap(size_t size);
```

Allocates memory directly using `mmap`, this is preferred for objects that both require almost a page of memory (or more) and expect a long lifetime.

However, since this allocation will invoke the system call (`mmap`), it will be inherently slower.

`fio_free` can be used for deallocating the memory.

**Note**: some overhead is added to the `size` allocation (about the same size as the alignment required), in order to store the allocation size information.

**Note**: the prefix `fio` will be different according to the `FIO_MEMORY_NAME` macro, it is used here because this is the prefix defined when using the `FIO_MALLOC` shortcut macro.

#### `fio_free`

```c
void fio_free(void *ptr);
```

Frees memory that was allocated using this allocator.

If memory was allocator using a different allocator,behavior is undefined... i.e.: with some bad luck, nothing will happen, not even a memory leak, with some good luck the program will crash and expose the bug.

**Note**: the prefix `fio` will be different according to the `FIO_MEMORY_NAME` macro, it is used here because this is the prefix defined when using the `FIO_MALLOC` shortcut macro.

**Note**: if `fio_free` is called **after** the allocator had been "destroyed" (cleanup occurred), behavior is undefined.

#### `fio_malloc_after_fork`

```c
void fio_malloc_after_fork(void);
```

Never fork a multi-threaded process. Doing so might corrupt the memory allocation system. The risk applies for child processes.

However, if forking a multi-threaded process, calling this function from the child process would perform a best attempt at mitigating any issues (at the expense of possible leaks).

Instead of calling `fio_malloc_after_fork` for each allocator, it is recommended to call the state callback for all memory allocators by calling withing the child (forked) process:

```c
fio_state_callback_force(FIO_CALL_IN_CHILD);
```

**Note**: the prefix `fio` will be different according to the `FIO_MEMORY_NAME` macro, it is used here because this is the prefix defined when using the `FIO_MALLOC` shortcut macro.


#### `fio_realloc_is_safe`

```c
size_t fio_realloc_is_safe(void);
```

Returns a non-zero value (1) if the allocator will zero out memory before passing the allocated memory to the user.

### Memory Allocator Creation MACROS

#### `FIO_MALLOC` (shortcut)

This shortcut macros defines a general allocator with the prefix `fio` (i.e., `fio_malloc`, `fio_free`, etc').

The general allocator settings consume more memory to allow for higher relative performance when using the memory pool as a generic allocator rather than an object specific memory pool.

Some setup macros are automatically defined and the `FIO_MEM_REALLOC` macro family are automatically updated.


It is similar to using:

```c
/* for a general allocator, increase system allocation size to 8Gb */
#define FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG 23
/* for a general allocator, increase cache size */
#define FIO_MEMORY_CACHE_SLOTS 8
/* set fragmentation cost at 0.5Mb blocks */
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 5
/* support big allocations using undivided memory chunks */
#define FIO_MEMORY_ENABLE_BIG_ALLOC 1
/* secure by default */
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 1

#undef FIO_MEM_REALLOC
#undef FIO_MEM_FREE
#undef FIO_MEM_REALLOC_IS_SAFE
#undef FIO_MEM_ALIGNMENT_SIZE

/*
* Set if FIO_MEM_REALLOC copies only what was asked,
* and the rest of the memory is initialized (as if returned from calloc).
*/
#define FIO_MEM_REALLOC_IS_SAFE fio_realloc_is_safe()
/* Stores memory alignment info. */
#define FIO_MEM_ALIGNMENT_SIZE fio_malloc_alignment()

/** Reallocates memory, copying (at least) `copy_len` if necessary. */
#define FIO_MEM_REALLOC(ptr, old_size, new_size, copy_len) fio_realloc2((ptr), (new_size), (copy_len))
/** Frees allocated memory. */
#define FIO_MEM_FREE(ptr, size) fio_free((ptr))
```

**Note**: this macro also (re)defines the `FIO_MEM_REALLOC_IS_SAFE` macro, allowing you to know if `fio_malloc` (and it's feature of memory being zeroed out) is available.

#### `FIO_MEMORY_NAME`

**REQUIRED**: the prefix for the memory-pool allocator.

This also automatically updates the temporary memory allocation macros (`FIO_MEM_REALLOC_`, etc') so all types defined in the same `include` statement as the allocator will use this allocator instead of the default allocator assigned using `FIO_MEM_REALLOC` (nothe the `_`).

#### `FIO_MALLOC_OVERRIDE_SYSTEM`

Overrides the system's default `malloc` to use this allocator instead.

#### `FIO_MEMORY_ALIGN_LOG`

```c
#define FIO_MEMORY_ALIGN_LOG 6
```

Sets the memory allocation alignment log. This starts with 8 byte alignment (value of 3) and accepts values up to 1024 (value of 10).

The default is 6 (64 byte alignment) which is a typical cache line alignment on many machines.

Allocation alignment, if set, **must** be >= 3 and <= 10.

This macro automatically defines the `FIO_MEMORY_ALIGN_SIZE` macro for internal use.

### Memory Allocator Configuration MACROS

The following compile time MACROS can effect the tuning and configuration of the resulting memory allocator.

#### `FIO_MEMORY_INITIALIZE_ALLOCATIONS`

```c
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT
```

If true, all allocations (including `realloc2` but excluding `realloc`) will return initialized memory and memory will be zeroed out earlier.

**Note**: when using `realloc` (vs., `realloc2`), the allocator does not know the size of the original allocation or its copy limits, so the memory isn't guaranteed to be initialized unless using `realloc2` which promises that any memory over `copy_len`is initialized.

The default value is controlled by the macro `FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT`.

#### `FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT`

```c
/* secure by default */
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT 1
```

Controls the default behavior for facil.io memory allocators (see `FIO_MEMORY_INITIALIZE_ALLOCATIONS`).

To increase performance, at the expense of the improved security and features provided by an allocator that zeros out memory early and often, set this value to 0.

#### `FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG`

```c
#define FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG 21
```

The logarithmic size of a single allocatiion "chunk" (16 blocks).

Limited to >=17 and <=24.

By default 22, which is a \~2Mb allocation per system call, resulting in a maximum allocation size of 131Kb.

This macro automatically defines the `FIO_MEMORY_SYS_ALLOCATION_SIZE` macro for internal use.

#### `FIO_MEMORY_CACHE_SLOTS`

```c
#define FIO_MEMORY_CACHE_SLOTS 4
```

The number of system allocation "chunks" to cache even if they are not in use.


#### `FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG`

```c
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 2 /* 8 blocks per allocation */
```

The number of blocks per system allocation.

More blocks protect against fragmentation and improve memory leak detection, but lower the maximum number of bytes that can be allocated without reverting to large allocations (see `FIO_MEMORY_ENABLE_BIG_ALLOC`) or `fio_mmap`.

**Range**: 0-4

**Recommended**: depends on object allocation sizes, usually 1 or 2.

#### `FIO_MEMORY_ENABLE_BIG_ALLOC`

```c
#define FIO_MEMORY_ENABLE_BIG_ALLOC 1
```

Uses a whole system allocation to support bigger allocations.

Using big allocations could increase fragmentation costs for large long-life objects and decrease the chance of a memory-leak detection.

However, if there are no bugs in the system and objects have shot/medium lifespans, this could increase performance for larger allocations as it could avoid system calls.

#### `FIO_MEMORY_ARENA_COUNT`

```c
#define FIO_MEMORY_ARENA_COUNT -1
```

Memory arenas mitigate thread contention while using more memory.

Note that at some point arenas are statistically irrelevant (except when benchmarking contention in multi-core machines).

Zero / negative values will result in dynamic selection based on CPU core count.

#### `FIO_MEMORY_ARENA_COUNT_FALLBACK`

```c
#define FIO_MEMORY_ARENA_COUNT_FALLBACK 24
```

Used when the dynamic arena count calculations fails.

**Note**: relevant if `FIO_MEMORY_ARENA_COUNT` is zero/negative, since dynamic arena calculation is performed using CPU core calculation.

#### `FIO_MEMORY_ARENA_COUNT_MAX`

```c
#define FIO_MEMORY_ARENA_COUNT_MAX 64
```

Defines the maximum number of arenas to allocate when using dynamic arena calculation.

**Note**: relevant if `FIO_MEMORY_ARENA_COUNT` is zero/negative, since dynamic arena calculation is performed using CPU core calculation.

#### `FIO_MEMORY_USE_THREAD_MUTEX`

```c
/*
* If arena count isn't linked to the CPU count, threads might busy-spin.
* It is better to slow wait than fast busy spin when the work in the lock is longer...
* and system allocations are performed inside arena locks.
*/
#if FIO_MEMORY_ARENA_COUNT > 0
#define FIO_MEMORY_USE_THREAD_MUTEX 1
#else
#define FIO_MEMORY_USE_THREAD_MUTEX 0
#endif
```

If true, uses a `pthread mutex` instead of a `fio_lock_i` spinlock.

When setting `FIO_USE_THREAD_MUTEX_TMP` or `FIO_USE_THREAD_MUTEX` to true (`1`), than the default value of this macro will be `1`. However, this macro can be used to override the default `FIO_USE_THREAD_MUTEX` / `FIO_USE_THREAD_MUTEX_TMP`.

#### `FIO_MEMORY_WARMUP`

```c
#define FIO_MEMORY_WARMUP 0
```

If set to a number, will allocate memory on startup to the number of arenas indicated.

It is usually better to avoid this unless using a single arena.

#### `FIO_MEM_SYS_ALLOC`, `FIO_MEM_SYS_REALLOC` and `FIO_MEM_SYS_FREE`

```c
#define FIO_MEM_SYS_ALLOC(pages, alignment_log)                                \
  FIO_MEM_SYS_ALLOC_def_func((pages), (alignment_log))

#define FIO_MEM_SYS_REALLOC(ptr, old_pages, new_pages, alignment_log)          \
  FIO_MEM_SYS_REALLOC_def_func((ptr), (old_pages), (new_pages), (alignment_log))

#define FIO_MEM_SYS_FREE(ptr, pages)                                           \
  FIO_MEM_SYS_FREE_def_func((ptr), (pages))
```

These MACROS, when all of them are defined, allow the memory allocator to collect memory from the system using an alternative method.

This allows the allocator to be used in situations where `mmap` is unavailable.

**Note:** the alignment property for the allocated memory is essential and may be quite large (see `FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG`).

### Debugging the allocator

The following functions will also be defined per-allocator. However, they should be considered experimental and unstable as they are linked to the allocator's internal workings.

#### `fio_malloc_arenas`

```c
size_t fio_malloc_arenas(void);
```

Returns the number of arenas used by the allocator.

**Note**: the prefix `fio` will be different according to the `FIO_MEMORY_NAME` macro, it is used here because this is the prefix defined when using the `FIO_MALLOC` shortcut macro.

#### `fio_malloc_sys_alloc_size`

```c
size_t fio_malloc_sys_alloc_size(void);
```

Returns the allocation size used when allocating memory from the system.

#### `fio_malloc_block_size`

```c
size_t fio_malloc_block_size(void);
```

Returns the block size used for allocations. Blocks are slices of system allocations used for allocating memory to the user.

#### `fio_malloc_cache_slots`

```c
size_t fio_malloc_cache_slots(void);
```

Returns the number of cache slots. Cache slots prevent memory chunks from being returned to the system, assuming that the memory will be needed again by the user.

#### `fio_malloc_alignment`

```c
size_t fio_malloc_alignment(void);
```

Returns the allocation alignment set for the allocator.

#### `fio_malloc_alignment_log`

```c
size_t fio_malloc_alignment_log(void);
```

Returns the allocation alignment log set for the allocator.

#### `fio_malloc_alloc_limit`

```c
size_t fio_malloc_alloc_limit(void);
```

Returns the per-allocation size limit, after which a call to `mmap` will be used.

#### `fio_malloc_arena_alloc_limit`

```c
size_t fio_malloc_arena_alloc_limit(void);
```

Returns the per-allocation size limit for an arena based allocation, after which a big-block allocation or `mmap` will be used.

#### `fio_malloc_print_state`

```c
void fio_malloc_print_state(void);
```

Prints information from the allocator's data structure. May be used for debugging.

#### `fio_malloc_print_free_block_list`

```c
void fio_malloc_print_free_block_list(void);
```

Prints the allocator's free block list. May be used for debugging.

#### `fio_malloc_print_settings`

```c
void fio_malloc_print_settings(void);
```

Prints the settings used to define the allocator.

### Reserved `FIO_MEMORY` related macros

The following are reserved macro names:

* `FIO_ALIGN_NEW`

* `FIO_ALIGN`

* `FIO_MEMORY_ALIGN_SIZE`

* `FIO_MEMORY_ALLOC_LIMIT`

* `FIO_MEMORY_BIG_ALLOC_LIMIT`

* `FIO_MEMORY_BLOCK_ALLOC_LIMIT`

* `FIO_MEMORY_BLOCKS_PER_ALLOCATION`

* `FIO_MEMORY_SYS_ALLOCATION_SIZE`

* `FIO_MALLOC_TMP_USE_SYSTEM`


-------------------------------------------------------------------------------
## Basic IO Polling

```c
#define FIO_POLL
#include "fio-stl.h"
```

IO polling using `kqueue`, `epoll` or the portable `poll` POSIX function is another area that's of common need and where many solutions are required.

The facil.io standard library provides a persistent polling container for evented management of (small) IO (file descriptor) collections using the "one-shot" model.

"One-Shot" means that once a specific event has "fired" (occurred), it will no longer be monitored (unless re-submitted). If the same file descriptor is waiting on multiple events, only those events that occurred will be removed from the monitored collection.

There's no real limit on the number of file descriptors that can be monitored, except possible system limits that the system may impose on the `kqueue`/`epoll`/`poll` system calls. However, performance will degrade significantly as the ratio between inactive vs. active IO objects being monitored increases when using the `poll` system call.

It is recommended to use the system specific polling "engine" (`epoll` / `kqueue`) if polling thousands of persistent file descriptors.

By defining `FIO_POLL`, the following functions will be defined.

**Note**: the same type and range limitations that apply to the Sockets implementation on Windows apply to the `poll` implementation.

### `FIO_POLL` API


#### `fio_poll_s`

```c
typedef struct fio_poll_s fio_poll_s;
```

The `fio_poll_s` type should be considered opaque and should **not** be accessed directly.

#### `fio_poll_init`

```c
void fio_poll_init(fio_poll_s *p, fio_poll_settings_s settings);
/* Named arguments using macro. */
#define fio_poll_init(p, ...) fio_poll_init((p), (fio_poll_settings_s){__VA_ARGS__})

typedef struct {
  /** callback for when data is available in the incoming buffer. */
  void (*on_data)(void *udata);
  /** callback for when the outgoing buffer allows a call to `write`. */
  void (*on_ready)(void *udata);
  /** callback for closed connections and / or connections with errors. */
  void (*on_close)(void *udata);
} fio_poll_settings_s;
```

Initializes a polling object, allocating its resources.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_poll_s poller;
fio_poll_init(&poller,
              .on_data = my_on_data_callback,
              .on_ready = my_on_ready_callback,
              .on_close = my_on_close_callback);
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `on_data` | `void (*)(void *)` | Callback for when data is available in the incoming buffer |
| `on_ready` | `void (*)(void *)` | Callback for when the outgoing buffer allows a call to `write` |
| `on_close` | `void (*)(void *)` | Callback for closed connections and/or connections with errors |

**Note**: callbacks that are not provided will default to a no-op function.

#### `fio_poll_destroy`

```c
void fio_poll_destroy(fio_poll_s *p);
```

Destroys the polling object, freeing its resources.

**Note**: the monitored file descriptors will remain untouched (possibly open).

#### `fio_poll_monitor`

```c
int fio_poll_monitor(fio_poll_s *p, int fd, void *udata, unsigned short flags);
```

Adds a file descriptor to be monitored, adds events to be monitored or updates the monitored file's `udata`.

Possible flags are: `POLLIN` and `POLLOUT`. Other flags may be set but might be ignored.

On systems where `POLLRDHUP` is supported, it is always monitored for.

Monitoring mode is always one-shot. If an event if fired, it is removed from the monitoring state.

Returns -1 on error.

#### `fio_poll_review`

```c
int fio_poll_review(fio_poll_s *p, size_t timeout);
```

Reviews if any of the monitored file descriptors has any events.

**Parameters:**
- `p` - pointer to the polling object
- `timeout` - timeout in milliseconds

**Returns:** the number of events called.

**Note**: polling is thread safe, but has different effects on different threads. Adding a new file descriptor from one thread while polling in a different thread will not poll that IO until `fio_poll_review` is called again.

#### `fio_poll_forget`

```c
int fio_poll_forget(fio_poll_s *p, int fd);
```

Stops monitoring the specified file descriptor even if some of its events hadn't occurred yet.

**Parameters:**
- `p` - pointer to the polling object
- `fd` - the file descriptor to stop monitoring

**Returns:** `0` on success, `-1` on error (e.g., if the file descriptor was not being monitored).

#### `fio_poll_close_all`

```c
void fio_poll_close_all(fio_poll_s *p);
```

Closes all monitored sockets, calling the `on_close` callback for each.

**Parameters:**
- `p` - pointer to the polling object

**Note**: this function is only available when using the `poll` engine (`FIO_POLL_ENGINE_POLL`).

#### `fio_poll_engine`

```c
const char *fio_poll_engine(void);
```

Returns the system call used for polling as a constant string.

**Returns:** `"poll"`, `"epoll"`, or `"kqueue"` depending on the selected engine.

### `FIO_POLL` Compile Time Macros

#### `FIO_POLL_ENGINE`

```c
#define FIO_POLL_ENGINE_POLL   1
#define FIO_POLL_ENGINE_EPOLL  2
#define FIO_POLL_ENGINE_KQUEUE 3
```

Allows for both the detection and the manual selection (override) of the underlying IO multiplexing API.

When multiplexing a small number of IO sockets, using the `poll` engine might be faster, as it uses fewer system calls.

```c
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_POLL
```

If `FIO_POLL_ENGINE` is not defined, the engine is automatically detected based on system availability (`epoll` on Linux, `kqueue` on BSD/macOS, `poll` as fallback).

#### `FIO_POLL_ENGINE_STR`

```c
#if FIO_POLL_ENGINE == FIO_POLL_ENGINE_POLL
#define FIO_POLL_ENGINE_STR "poll"
#elif FIO_POLL_ENGINE == FIO_POLL_ENGINE_EPOLL
#define FIO_POLL_ENGINE_STR "epoll"
#elif FIO_POLL_ENGINE == FIO_POLL_ENGINE_KQUEUE
#define FIO_POLL_ENGINE_STR "kqueue"
#endif
```

A string macro representing the used IO multiplexing "engine".

#### `FIO_POLL_POSSIBLE_FLAGS`

```c
#define FIO_POLL_POSSIBLE_FLAGS (POLLIN | POLLOUT | POLLPRI)
```

Defines the user flags that IO events recognize. This can be overridden before including the header.

#### `FIO_POLL_MAX_EVENTS`

```c
#define FIO_POLL_MAX_EVENTS 128 /* or 256 on 32-bit systems */
```

Defines the maximum number of events per review call. This is relevant only for `epoll` and `kqueue` engines.

The default value is `128` on 64-bit systems and `256` on 32-bit systems.

-------------------------------------------------------------------------------
## Task Queue

```c
#define FIO_QUEUE
#include "fio-stl.h"
```

The facil.io library includes a simple, thread-safe, task queue based on a linked list of ring buffers.

Since delayed processing is a common task, this queue provides an easy way to schedule and perform delayed tasks.

In addition, a Timer type allows timed events to be scheduled and moved (according to their "due date") to an existing Task Queue.

By defining `FIO_QUEUE`, the following task and timer related helpers are defined:

### Configuration Macros

#### `FIO_QUEUE_TASKS_PER_ALLOC`

```c
#define FIO_QUEUE_TASKS_PER_ALLOC 168 /* or 338 on 32-bit systems */
```

Controls the number of tasks per allocation block in the queue's ring buffer. The default value is chosen to fit `fio_queue_s` in one memory page on most systems (168 for 64-bit, 338 for 32-bit).

**Note**: This value cannot exceed 65535.

### Queue Related Types

#### `fio_queue_task_s`

```c
/** Task information */
typedef struct {
  /** The function to call */
  void (*fn)(void *, void *);
  /** User opaque data */
  void *udata1;
  /** User opaque data */
  void *udata2;
} fio_queue_task_s;
```

The `fio_queue_task_s` type contains information about a delayed task. The information is important for the `fio_queue_push` MACRO, where it is used as named arguments for the task information.

#### `fio_queue_s`

```c
/** The queue object - should be considered opaque (or, at least, read only). */
typedef struct {
  /** task read pointer. */
  fio___task_ring_s *r;
  /** task write pointer. */
  fio___task_ring_s *w;
  /** the number of tasks waiting to be performed. */
  uint32_t count;
  /** global queue lock. */
  FIO___LOCK_TYPE lock;
  /** linked lists of consumer threads. */
  FIO_LIST_NODE consumers;
  /** main ring buffer associated with the queue. */
  fio___task_ring_s mem;
} fio_queue_s;
```

The `fio_queue_s` object is the queue object.

This object could be placed on the stack or allocated on the heap (using [`fio_queue_new`](#fio_queue_new)).

Once the object is no longer in use call [`fio_queue_destroy`](#fio_queue_destroy) (if placed on the stack) or [`fio_queue_free`](#fio_queue_free) (if allocated using [`fio_queue_new`](#fio_queue_new)).

### Queue API

#### `fio_queue_init`

```c
/** Used to initialize a fio_queue_s object. */
void fio_queue_init(fio_queue_s *q);
```

#### `fio_queue_destroy`

```c
void fio_queue_destroy(fio_queue_s *q);
```

Destroys a queue and re-initializes it, after freeing any used resources.

**Note**:
When using the optional `pthread_mutex_t` implementation or using timers on Windows, the timer object needs to be re-initialized explicitly before re-used after being destroyed (call `fio_queue_init`).

#### `FIO_QUEUE_STATIC_INIT(queue)`

```c
#define FIO_QUEUE_STATIC_INIT(queue)                                           \
  {                                                                            \
    .r = &(queue).mem, .w = &(queue).mem, .lock = FIO_LOCK_INIT,               \
    .consumers = FIO_LIST_INIT((queue).consumers),                             \
  }
```

May be used to initialize global, static memory, queues.

**Note**: while the use of `FIO_QUEUE_STATIC_INIT` is possible, this macro resets a whole page of memory to zero whereas `fio_queue_init` only initializes a few bytes of memory which are the only relevant bytes during initialization.

**Note**: when using `FIO_USE_THREAD_MUTEX_TMP`, the lock initialization uses `FIO_THREAD_MUTEX_INIT` instead of `FIO_LOCK_INIT`.

#### `fio_queue_new`

```c
fio_queue_s *fio_queue_new(void);
```

Creates a new queue object (allocated on the heap).

#### `fio_queue_free`

```c
void fio_queue_free(fio_queue_s *q);
```

Frees a queue object after calling fio_queue_destroy.

#### `fio_queue_push`

```c
int fio_queue_push(fio_queue_s *q, fio_queue_task_s task);
#define fio_queue_push(q, ...)                                                 \
  fio_queue_push((q), (fio_queue_task_s){__VA_ARGS__})

```

Pushes a **valid** (non-NULL) task to the queue.

This function is shadowed by the `fio_queue_push` MACRO, allowing named arguments to be used.

For example:

```c
void tsk(void *, void *);
fio_queue_s q = FIO_QUEUE_STATIC_INIT(q);
fio_queue_push(&q, .fn = tsk);
// ...
fio_queue_destroy(&q);
```

Returns 0 if `task.fn == NULL` or if the task was successfully added to the queue.

Returns -1 on error (no memory).


#### `fio_queue_push_urgent`

```c
int fio_queue_push_urgent(fio_queue_s *q, fio_queue_task_s task);
#define fio_queue_push_urgent(q, ...)                                          \
  fio_queue_push_urgent((q), (fio_queue_task_s){__VA_ARGS__})
```

Pushes a task to the head of the queue (LIFO).

Returns -1 on error (no memory).

See [`fio_queue_push`](#fio_queue_push) for details.

#### `fio_queue_pop`

```c
fio_queue_task_s fio_queue_pop(fio_queue_s *q);
```

Pops a task from the queue (FIFO).

Returns a NULL task on error (`task.fn == NULL`).

**Note**: The task isn't performed automatically, it's just returned. This is useful for queues that don't necessarily contain callable functions.

#### `fio_queue_perform`

```c
int fio_queue_perform(fio_queue_s *q);
```

Pops and performs a task from the queue (FIFO).

Returns -1 on error (queue empty).

#### `fio_queue_perform_all`

```c
void fio_queue_perform_all(fio_queue_s *q);
```

Performs all tasks in the queue.

#### `fio_queue_count`

```c
uint32_t fio_queue_count(fio_queue_s *q);
```

Returns the number of tasks in the queue.

### Worker Thread API

The queue supports consumer/worker threads that automatically perform tasks as they are added to the queue.

#### `fio_queue_workers_add`

```c
int fio_queue_workers_add(fio_queue_s *q, size_t count);
```

Adds worker/consumer threads to perform the jobs in the queue.

**Parameters:**
- `q` - the queue to add workers to
- `count` - the number of worker threads to add

**Returns:** `0` on success, `-1` on error (thread creation failed).

**Note**: Worker threads will automatically wake up when new tasks are added to the queue and sleep when the queue is empty.

#### `fio_queue_workers_stop`

```c
void fio_queue_workers_stop(fio_queue_s *q);
```

Signals all worker threads to stop performing tasks and terminate.

This function returns immediately without waiting for threads to finish. Use [`fio_queue_workers_join`](#fio_queue_workers_join) to wait for threads to complete.

#### `fio_queue_workers_join`

```c
void fio_queue_workers_join(fio_queue_s *q);
```

Signals all worker threads to stop and waits for them to complete.

This function blocks until all worker threads have terminated.

#### `fio_queue_workers_wake`

```c
void fio_queue_workers_wake(fio_queue_s *q);
```

Signals all worker threads to wake up and check for new tasks.

**Note**: This is typically called automatically when tasks are pushed to the queue, but can be called manually if needed.

### Timer Related Types

#### `fio_timer_queue_s`

```c
typedef struct {
  fio___timer_event_s *next;
  FIO___LOCK_TYPE lock;
} fio_timer_queue_s;
```

The `fio_timer_queue_s` struct should be considered an opaque data type and accessed only using the functions or the initialization MACRO.

To create a `fio_timer_queue_s` on the stack (or statically):

```c
fio_timer_queue_s foo_timer = FIO_TIMER_QUEUE_INIT;
```

A timer could be allocated dynamically:

```c
fio_timer_queue_s *foo_timer = malloc(sizeof(*foo_timer));
FIO_ASSERT_ALLOC(foo_timer);
*foo_timer = (fio_timer_queue_s)FIO_TIMER_QUEUE_INIT;
```

#### `FIO_TIMER_QUEUE_INIT`

```c
#define FIO_TIMER_QUEUE_INIT                                                   \
  { .lock = FIO_LOCK_INIT }
```

This is a MACRO used to statically initialize a `fio_timer_queue_s` object.

**Note**: when using `FIO_USE_THREAD_MUTEX_TMP`, the lock initialization uses `FIO_THREAD_MUTEX_INIT` instead of `FIO_LOCK_INIT`.

### Timer API

#### `fio_timer_schedule`

```c
void fio_timer_schedule(fio_timer_queue_s *timer_queue,
                        fio_timer_schedule_args_s args);
/* Named arguments using macro. */
#define fio_timer_schedule(timer_queue, ...)                                   \
  fio_timer_schedule((timer_queue), (fio_timer_schedule_args_s){__VA_ARGS__})

typedef struct {
  /** The timer function. If it returns a non-zero value, the timer stops. */
  int (*fn)(void *, void *);
  /** Opaque user data. */
  void *udata1;
  /** Opaque user data. */
  void *udata2;
  /** Called when the timer is done (finished). */
  void (*on_finish)(void *, void *);
  /** Timer interval, in milliseconds. */
  uint32_t every;
  /** The number of times the timer should be performed. -1 == infinity. */
  int32_t repetitions;
  /** Millisecond at which to start. If missing, filled automatically. */
  int64_t start_at;
} fio_timer_schedule_args_s;
```

Adds a time-bound event to the timer queue.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_timer_schedule(timer_queue,
                   .fn = my_timer_callback,
                   .udata1 = my_data,
                   .every = 1000,        /* every 1000ms (1 second) */
                   .repetitions = -1);   /* repeat forever */
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `fn` | `int (*)(void *, void *)` | Timer callback. Return non-zero to stop the timer. |
| `udata1` | `void *` | Opaque user data passed to callbacks |
| `udata2` | `void *` | Opaque user data passed to callbacks |
| `on_finish` | `void (*)(void *, void *)` | Called when timer is done/stopped |
| `every` | `uint32_t` | Timer interval in milliseconds |
| `repetitions` | `int32_t` | Number of times to repeat; `-1` for infinite |
| `start_at` | `int64_t` | Start time in milliseconds; `0` uses `fio_time_milli()` |

**Note**: the event will repeat every `every` milliseconds (or the same units as `start_at` and `now`).

**Note**: if the scheduler is busy or the event is otherwise delayed, its next scheduling may compensate for the delay by being scheduled sooner.

#### `fio_timer_push2queue`

```c
size_t fio_timer_push2queue(fio_queue_s *queue,
                            fio_timer_queue_s *timer_queue,
                            int64_t now_in_milliseconds);
```

Pushes due events from the timer queue to an event queue.

**Parameters:**
- `queue` - the task queue to push due events to
- `timer_queue` - the timer queue to check for due events
- `now_in_milliseconds` - current time in milliseconds; if `0`, `fio_time_milli()` is called automatically

**Returns:** the number of tasks pushed to the queue. A value of `0` indicates no new tasks were scheduled.

**Note**: all the `start_at` values for all the events in the timer queue will be treated as if they use the same units as (and are relative to) `now_in_milliseconds`. By default, this unit should be milliseconds, to allow `now_in_milliseconds` to be zero.

#### `fio_timer_next_at`

```c
int64_t fio_timer_next_at(fio_timer_queue_s *timer_queue);
```

Returns the millisecond at which the next event should occur.

If no timer is due (list is empty), returns `-1`.

**Note**: Unless manually specified, millisecond timers are relative to  `fio_time_milli()`.


#### `fio_timer_destroy`

```c
void fio_timer_destroy(fio_timer_queue_s *timer_queue);
```

Clears any waiting timer bound tasks.

**Note**:

The timer queue must NEVER be freed when there's a chance that timer tasks are waiting to be performed in a `fio_queue_s`.

This is due to the fact that the tasks may try to reschedule themselves (if they repeat).

**Note 2**:
When using the optional `pthread_mutex_t` implementation or using timers on Windows, the timer object needs to be reinitialized before re-used after being destroyed.

-------------------------------------------------------------------------------
## Data Stream Container

```c
#define FIO_STREAM
#include "fio-stl.h"
```

Data Stream objects solve the issues that could arise when `write` operations don't write all the data (due to OS buffering). 

Data Streams offer a way to store / concat different data sources (static strings, dynamic strings, files) as a single data stream. This allows the data to be easily written to an IO target (socket / pipe / file) using the `write` operation.

By defining the macro `FIO_STREAM`, the following macros and functions will be defined.

### Configuration Macros

#### `FIO_STREAM_COPY_PER_PACKET`

```c
#define FIO_STREAM_COPY_PER_PACKET 98304
```

When copying data to the stream, large memory sections will be divided into smaller allocations in order to free memory faster and minimize the direct use of `mmap`.

This macro should be set according to the specific allocator limits. By default, it is set to 96Kb (98304 bytes).

#### `FIO_STREAM_ALWAYS_COPY_IF_LESS_THAN`

```c
#define FIO_STREAM_ALWAYS_COPY_IF_LESS_THAN 116
```

If the data added is less than this number of bytes, copying is preferred over referencing for better memory locality. By default, it is set to 116 bytes (or 8 bytes in DEBUG mode).

### Types

#### `fio_stream_s`

```c
typedef struct {
  /* do not directly access! */
  fio_stream_packet_s *next;
  fio_stream_packet_s **pos;
  size_t consumed;
  size_t length;
} fio_stream_s;
```

The `fio_stream_s` type should be considered opaque and only accessed through the following API.

#### `fio_stream_packet_s`

The `fio_stream_packet_s` type should be considered opaque and only accessed through the following API.

This type is used to separate data packing from any updates made to the stream object, allowing data packing to be performed concurrently with stream reading / updating (which requires a lock in multi-threaded applications).

### Initialization and Destruction

#### `FIO_STREAM_INIT`

```c
#define FIO_STREAM_INIT(s)                                                     \
  { .next = NULL, .pos = &(s).next }
```

Object initialization macro.

#### `fio_stream_new`

```c
fio_stream_s *fio_stream_new(void);
```

Allocates a new object on the heap and initializes its memory.

**Returns:** a pointer to the newly allocated stream, or NULL on allocation failure.

#### `fio_stream_free`

```c
int fio_stream_free(fio_stream_s *stream);
```

Frees any internal data AND the object's container!

**Parameters:**
- `stream` - the stream object to free

**Returns:** 0.

#### `fio_stream_destroy`

```c
void fio_stream_destroy(fio_stream_s *stream);
```

Destroys the object, reinitializing its container.

**Parameters:**
- `stream` - the stream object to destroy

### Stream Information

#### `fio_stream_any`

```c
uint8_t fio_stream_any(fio_stream_s *stream);
```

Returns true if there's any data in the stream.

**Parameters:**
- `stream` - the stream object to check

**Returns:** non-zero if there's data in the stream, 0 otherwise.

**Note**: this isn't truly thread safe, but it often doesn't matter if it is.

#### `fio_stream_length`

```c
size_t fio_stream_length(fio_stream_s *stream);
```

Returns the number of bytes waiting in the stream.

**Parameters:**
- `stream` - the stream object to query

**Returns:** the number of bytes in the stream.

**Note**: this isn't truly thread safe, but it often doesn't matter if it is.

### Packing Data into the Stream

#### `fio_stream_pack_data`

```c
fio_stream_packet_s *fio_stream_pack_data(void *buf,
                                          size_t len,
                                          size_t offset,
                                          uint8_t copy_buffer,
                                          void (*dealloc_func)(void *));
```

Packs data into a `fio_stream_packet_s` container.

**Parameters:**
- `buf` - pointer to the data buffer
- `len` - length of the data in bytes
- `offset` - offset within the buffer to start from
- `copy_buffer` - if non-zero, the data will be copied; otherwise, the buffer is referenced
- `dealloc_func` - function to call to free the buffer when done (can be NULL)

**Returns:** a pointer to the packet, or NULL on error.

**Note**: can be performed concurrently with other stream operations. If `copy_buffer` is set or if `len` is less than `FIO_STREAM_ALWAYS_COPY_IF_LESS_THAN`, the data will be copied. Large data blocks may be split into multiple packets based on `FIO_STREAM_COPY_PER_PACKET`. If `dealloc_func` is provided, it will be called even on error.

#### `fio_stream_pack_fd`

```c
fio_stream_packet_s *fio_stream_pack_fd(int fd,
                                        size_t len,
                                        size_t offset,
                                        uint8_t keep_open);
```

Packs a file descriptor into a `fio_stream_packet_s` container.

**Parameters:**
- `fd` - the file descriptor to pack
- `len` - number of bytes to read from the file (0 to auto-detect from file size)
- `offset` - offset within the file to start reading from
- `keep_open` - if non-zero, the file descriptor will NOT be closed when the packet is freed

**Returns:** a pointer to the packet, or NULL on error.

**Note**: if `len` is 0, the file size will be queried and `len` will be set to `file_size - offset`. If `keep_open` is 0 and an error occurs, the file descriptor will be closed.

#### `fio_stream_add`

```c
void fio_stream_add(fio_stream_s *stream, fio_stream_packet_s *packet);
```

Adds a packet to the stream.

**Parameters:**
- `stream` - the stream to add the packet to
- `packet` - the packet to add

**Note**: this isn't thread safe. If `stream` or `packet` is NULL, the packet will be freed.

#### `fio_stream_pack_free`

```c
void fio_stream_pack_free(fio_stream_packet_s *packet);
```

Destroys the `fio_stream_packet_s` - call this ONLY if the packed data was never added to the stream using `fio_stream_add`.

**Parameters:**
- `packet` - the packet to free

### Reading / Consuming Data from the Stream

#### `fio_stream_read`

```c
void fio_stream_read(fio_stream_s *stream, char **buf, size_t *len);
```

Reads data from the stream (if any), leaving the data in the stream **without advancing the reading position** (see [`fio_stream_advance`](#fio_stream_advance)).

`buf` MUST point to a buffer with - at least - `len` bytes. This is required in case the packed data is fragmented or references a file and needs to be copied to an available buffer.

On error, or if the stream is empty, `buf` will be set to NULL and `len` will be set to zero.

Otherwise, `buf` may retain the same value or it may point directly to a memory address within the stream's buffer (the original value may be lost) and `len` will be updated to the largest possible value for valid data that can be read from `buf`.

**Parameters:**
- `stream` - the stream to read from
- `buf` - pointer to a buffer pointer (will be updated)
- `len` - pointer to the buffer length (will be updated)

**Note**: this isn't thread safe.

#### `fio_stream_advance`

```c
void fio_stream_advance(fio_stream_s *stream, size_t len);
```

Advances the Stream, so the first `len` bytes are marked as consumed.

**Parameters:**
- `stream` - the stream to advance
- `len` - number of bytes to mark as consumed

**Note**: this isn't thread safe.

-------------------------------------------------------------------------------
## Binary Safe Core String Helpers

```c
#define FIO_STR
#include "fio-stl.h"
```

The following helpers are part of the String core library and they become available whenever [a String type was defined](#dynamic-strings) or when the `FIO_STR` is defined before any inclusion of the C STL header.

The main difference between using the Core String API directly and defining a String type is that String types provide a few additional optimizations, such as embedding short strings (embedded within the type data rather than allocated), optional reference counting and pointer tagging features.

**Note**: the `fio_string` functions might fail or truncate data if memory allocation fails. Test the returned value for failure (success returns `0`, failure returns `-1`).

**Note:** this module depends on the `FIO_ATOL`, `FIO_ATOMIC`, `FIO_RAND`, and `FIO_FILES` modules which will be automatically included.

### Reallocation Callback Type

#### `fio_string_realloc_fn`

```c
typedef int (*fio_string_realloc_fn)(fio_str_info_s *dest, size_t len);
```

A reallocation callback type for buffers in a `fio_str_info_s`.

The callback MUST allocate at least `len + 1` bytes, setting the new capacity in `dest->capa`.

**Returns:** `0` on success, `-1` on failure.

### Core String Authorship

#### `fio_string_write`

```c
int fio_string_write(fio_str_info_s *dest,
                     fio_string_realloc_fn reallocate,
                     const void *restrict src,
                     size_t len);
```

Writes data to the end of the string in the `fio_str_info_s` struct.

The returned string is NUL terminated if edited.

**Parameters:**

- `dest` - an `fio_str_info_s` struct containing the destination string.

- `reallocate` - a callback that attempts to reallocate more memory (i.e., using `realloc`) and returns `0` on success or `-1` on failure. If `reallocate` is NULL or fails, the data copied will be truncated.

- `src` - the data to be written to the end of `dest`.

- `len` - the length of the data to be written to the end of `dest`.

**Returns:** `0` on success, `-1` if memory reallocation was needed but failed (data may be truncated).

**Note**: this function performs only minimal checks and assumes that `dest` is fully valid - i.e., that `dest.capa >= dest.len`, that `dest.buf` is valid, etc'.

**Note**: `reallocate`, if called, will be called only once.

An example for a `reallocate` callback using the system's `realloc` function (or use `FIO_STRING_REALLOC` / `FIO_STRING_FREE`):

```c
int fio_string_realloc_system(fio_str_info_s *dest, size_t len) {
  /* must allocate at least len + 1 bytes. */
  const size_t new_capa = fio_string_capa4len(len);
  void *tmp = realloc(dest->buf, new_capa);
  if (!tmp)
    return -1;
  dest->capa = new_capa;
  dest->buf = (char *)tmp;
  return 0;
}
```

An example for using the function:

```c
void example(void) {
  char buf[32];
  fio_str_info_s str = FIO_STR_INFO3(buf, 0, 32);
  fio_string_write(&str, NULL, "The answer is: 0x", 17);
  str.len += fio_ltoa(str.buf + str.len, 42, 16);
  fio_string_write(&str, NULL, "!\n", 2);
  printf("%s", str.buf);
}
```

#### `fio_string_replace`

```c
int fio_string_replace(fio_str_info_s *dest,
                       fio_string_realloc_fn reallocate,
                       intptr_t start_pos,
                       size_t overwrite_len,
                       const void *src,
                       size_t len);
```

Similar to `fio_string_write`, only replacing/inserting a sub-string in a specific location.

Negative `start_pos` values are calculated backwards, `-1` == end of String.

When `overwrite_len` is zero, the function will insert the data at `start_pos`, pushing existing data until after the inserted data.

If `overwrite_len` is non-zero, than `overwrite_len` bytes will be overwritten (or deleted).

If `len == 0` than `src` will be ignored and the data marked for replacement will be erased.

**Note**: `reallocate`, if called, will be called only once.

#### `fio_string_write2`

```c
int fio_string_write2(fio_str_info_s *restrict dest,
                      fio_string_realloc_fn reallocate,
                      const fio_string_write_s srcs[]);
/* Helper macro for fio_string_write2 */
#define fio_string_write2(dest, reallocate, ...)                               \
  fio_string_write2((dest),                                                    \
                    (reallocate),                                              \
                    (fio_string_write_s[]){__VA_ARGS__, {0}})
```

Writes a group of objects (strings, numbers, etc') to `dest`.

`dest` and `reallocate` are similar to `fio_string_write`.

**Note**: `reallocate`, if called, will be called only once.

`srcs` is an array of `fio_string_write_s` structs, ending with a struct that's all set to 0. This array is usually populated using the following macros:

```c
/** Used to write raw string data to the string. */
#define FIO_STRING_WRITE_STR1(str_)                                            \
  ((fio_string_write_s){.klass = 1,                                            \
                        .info.str = {.len = FIO_STRLEN((str_)), .buf = (str_)}})
/** Used to write raw (possibly binary) string data to the string. */
#define FIO_STRING_WRITE_STR2(str_, len_)                                      \
  ((fio_string_write_s){.klass = 1, .info.str = {.len = (len_), .buf = (str_)}})
/** Used to write a fio_str_info_s or fio_buf_info_s to the string. */
#define FIO_STRING_WRITE_STR_INFO(str_)                                        \
  ((fio_string_write_s){.klass = 1,                                            \
                        .info.str = {.len = (str_).len, .buf = (str_).buf}})
/** Used to write a signed number to the string. */
#define FIO_STRING_WRITE_NUM(num)                                              \
  ((fio_string_write_s){.klass = 2, .info.i = (int64_t)(num)})
/** Used to write an unsigned number to the string. */
#define FIO_STRING_WRITE_UNUM(num)                                             \
  ((fio_string_write_s){.klass = 3, .info.u = (uint64_t)(num)})
/** Used to write a hex representation of a number to the string. */
#define FIO_STRING_WRITE_HEX(num)                                              \
  ((fio_string_write_s){.klass = 4, .info.u = (uint64_t)(num)})
/** Used to write a binary representation of a number to the string. */
#define FIO_STRING_WRITE_BIN(num)                                              \
  ((fio_string_write_s){.klass = 5, .info.u = (uint64_t)(num)})
/** Used to write a double(!) to the string. */
#define FIO_STRING_WRITE_FLOAT(num)                                            \
  ((fio_string_write_s){.klass = 6, .info.f = (double)(num)})
```

Use the `fio_string_write2` macro for ease, i.e.:

```c
fio_str_info_s str = {0};
fio_string_write2(&str, my_reallocate,
                   FIO_STRING_WRITE_STR1("The answer is: "),
                   FIO_STRING_WRITE_NUM(42),
                   FIO_STRING_WRITE_STR2("(0x", 3),
                   FIO_STRING_WRITE_HEX(42),
                   FIO_STRING_WRITE_STR2(")", 1));
```

**Note**: this function might end up allocating more memory than absolutely required as it favors speed over memory savings.

For this function, the facil.io C STL reserves and defines the following type:

```c
/** Argument type used by fio_string_write2. */
typedef struct {
  size_t klass;
  union {
    struct {
      size_t len;
      const char *buf;
    } str;
    double f;
    int64_t i;
    uint64_t u;
  } info;
} fio_string_write_s;
```

### Core String Numeral Helpers

#### `fio_string_write_i`

```c
int fio_string_write_i(fio_str_info_s *dest,
                       fio_string_realloc_fn reallocate,
                       int64_t i);
```

Writes a signed number `i` to the String.

**Note**: `reallocate`, if called, will be called only once.

#### `fio_string_write_u`

```c
int fio_string_write_u(fio_str_info_s *dest,
                       fio_string_realloc_fn reallocate,
                       uint64_t u);
```

Writes an unsigned number `u` to the String.

**Note**: `reallocate`, if called, will be called only once.

#### `fio_string_write_hex`

```c
int fio_string_write_hex(fio_str_info_s *dest,
                         fio_string_realloc_fn reallocate,
                         uint64_t i);
```

Writes a hex representation of `i` to the String.

**Note**: `reallocate`, if called, will be called only once.

#### `fio_string_write_bin`

```c
int fio_string_write_bin(fio_str_info_s *dest,
                         fio_string_realloc_fn reallocate,
                         uint64_t i);
```

Writes a binary representation of `i` to the String.

**Note**: `reallocate`, if called, will be called only once.

### Core String `printf` Helpers

#### `fio_string_printf`

```c
int fio_string_printf(fio_str_info_s *dest,
                      fio_string_realloc_fn reallocate,
                      const char *format,
                      ...);
```

Similar to fio_string_write, only using printf semantics.

#### `fio_string_vprintf`

```c
int fio_string_vprintf(fio_str_info_s *dest,
                       fio_string_realloc_fn reallocate,
                       const char *format,
                       va_list argv);
```

Similar to fio_string_write, only using vprintf semantics.

### Core String Authorship Memory Helpers

#### `fio_string_capa4len`

```c
size_t fio_string_capa4len(size_t new_len);
```

Calculates a 16 bytes boundary aligned capacity for `new_len`.

The Core String API always allocates 16 byte aligned memory blocks, since most memory allocators will only allocate memory in multiples of 16 or more. By requesting the full 16 byte allocation, future allocations could be avoided without increasing memory usage.

#### `FIO_STRING_SYS_REALLOC`

```c
#define FIO_STRING_SYS_REALLOC fio_string_sys_reallocate
int fio_string_sys_reallocate(fio_str_info_s *dest, size_t len);
```

Default reallocation callback implementation using libc `realloc`.

#### `FIO_STRING_REALLOC`

```c
#define FIO_STRING_REALLOC fio_string_default_reallocate
int fio_string_default_reallocate(fio_str_info_s *dest, size_t len);
```

Default reallocation callback implementation using the default allocator.

#### `FIO_STRING_ALLOC_COPY`

```c
#define FIO_STRING_ALLOC_COPY fio_string_default_allocate_copy
int fio_string_default_allocate_copy(fio_str_info_s *dest, size_t new_capa);
```

Default reallocation callback for memory that mustn't be freed.

#### `FIO_STRING_ALLOC_KEY`

```c
#define FIO_STRING_ALLOC_KEY fio_string_default_key_alloc
void *fio_string_default_key_alloc(size_t len);
```

Default allocator for the `fio_keystr_s` string data.

#### `FIO_STRING_FREE`

```c
#define FIO_STRING_FREE fio_string_default_free
void fio_string_default_free(void *);
```

Frees memory that was allocated with the default callbacks.

#### `FIO_STRING_FREE2`

```c
#define FIO_STRING_FREE2 fio_string_default_free2
void fio_string_default_free2(fio_str_info_s str);
```

Frees memory that was allocated with the default callbacks.

#### `FIO_STRING_FREE_KEY`

```c
#define FIO_STRING_FREE_KEY fio_string_default_free_key
void fio_string_default_free_key(void *buf, size_t capa);
```

Frees memory that was allocated for a key string with the default callback.

#### `FIO_STRING_FREE_NOOP`

```c
#define FIO_STRING_FREE_NOOP fio_string_default_free_noop
void fio_string_default_free_noop(void *str);
```

Does nothing. Made available for APIs that require a callback for memory management.

#### `FIO_STRING_FREE_NOOP2`

```c
#define FIO_STRING_FREE_NOOP2 fio_string_default_free_noop2
void fio_string_default_free_noop2(fio_str_info_s str);
```

Does nothing. Made available for APIs that require a callback for memory management.

### Core String Comparison

In addition to [`FIO_STR_INFO_IS_EQ(a,b)`](#fio_str_info_is_eq) and [`FIO_BUF_INFO_IS_EQ(a,b)`](#fio_buf_info_is_eq) MACROs, the following comparisons helpers are available:

#### `fio_string_is_greater`

```c
int fio_string_is_greater(fio_str_info_s a, fio_str_info_s b);
```
Equivalent to: `memcmp(a.buf, b.buf, min(a.len, b.len)) > 0 || (!memcmp(a.buf, b.buf, min(a.len, b,len)) && a.len > b.len)`

Compares two strings, returning 1 if the data in string `a` is greater in value than the data in string `b`.

**Note**: returns 0 if string `b` is bigger than string `a` or if strings are equal, designed to be used with `FIO_SORT_IS_BIGGER(a,b)`.

**Note**: it is often faster to define `FIO_SORT_IS_BIGGER` using a `memcmp` wrapper, however the speed depends on the `clib` implementation and this function provides a good enough fallback that should be very portable.

#### `fio_string_is_greater_buf`

```c
int fio_string_is_greater_buf(fio_buf_info_s a, fio_buf_info_s b);
```

Equivalent to: `memcmp(a.buf, b.buf, min(a.len, b.len)) > 0 || (!memcmp(a.buf, b.buf, min(a.len, b,len)) && a.len > b.len)`

Compares two `fio_buf_info_s`, returning 1 if the data in buffer `a` is greater in value than the data in buffer `b`.

**Note**: returns 0 if data in `b` is greater than **or equal** to `a`, designed to be used with `FIO_SORT_IS_BIGGER(a,b)`.

**Note**: it is often faster to define `FIO_SORT_IS_BIGGER` using a `memcmp` wrapper, however the speed depends on the `clib` implementation and this function provides a good enough fallback that should be very portable.

### Core String UTF-8 Support

#### `fio_string_utf8_valid`

```c
bool fio_string_utf8_valid(fio_str_info_s str);
```

Returns `true` (1) if the String is UTF-8 valid and `false` (0) if not.

#### `fio_string_utf8_len`

```c
size_t fio_string_utf8_len(fio_str_info_s str);
```

Returns the String's length in UTF-8 characters or 0 on either an error or an empty string.

#### `fio_string_utf8_valid_code_point`

```c
size_t fio_string_utf8_valid_code_point(const void *u8c, size_t buf_len);
```

Returns 0 if non-UTF-8 or returns 1-4 (the number of bytes in the UTF-8 character) if a valid UTF-8 character.

**Parameters:**

- `u8c` - pointer to the start of a potential UTF-8 character.
- `buf_len` - the remaining buffer length (to avoid reading past the buffer).

#### `fio_string_utf8_select`

```c
int fio_string_utf8_select(fio_str_info_s str, intptr_t *pos, size_t *len);
```

Takes a UTF-8 character selection information (UTF-8 position and length) and updates the same variables so they reference the raw byte slice information.

If the String isn't UTF-8 valid up to the requested selection, than `pos` will be updated to `-1` otherwise values are always positive.

The returned `len` value may be shorter than the original if there wasn't enough data left to accommodate the requested length. When a `len` value of `0` is returned, this means that `pos` marks the end of the String.

if `pos` is negative, counts backwards (`-1` is the position of the last UTF-8 character).

Returns -1 on error and 0 on success.

### Core String C / JSON escaping

#### `fio_string_write_escape`

```c
int fio_string_write_escape(fio_str_info_s *restrict dest,
                            fio_string_realloc_fn reallocate,
                            const void *raw,
                            size_t raw_len);
```

Writes data at the end of the String, escaping the data using JSON semantics.

The JSON semantic are common to many programming languages, promising a UTF-8
String while making it easy to read and copy the string during debugging.

#### `fio_string_write_unescape`

```c
int fio_string_write_unescape(fio_str_info_s *dest,
                              fio_string_realloc_fn reallocate,
                              const void *escaped,
                              size_t escaped_len);
```

Writes an escaped data into the string after un-escaping the data.

### Core String Base32 support

#### `fio_string_write_base32enc`

```c
int fio_string_write_base32enc(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               const void *raw,
                               size_t raw_len);
```

Writes data to String using Base32 encoding.

#### `fio_string_write_base32dec`

```c
int fio_string_write_base32dec(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               const void *encoded,
                               size_t encoded_len);
```

Writes decoded Base32 data to String.

### Core String Base64 support

#### `fio_string_write_base64enc`

```c
int fio_string_write_base64enc(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               const void *raw,
                               size_t raw_len,
                               uint8_t url_encoded);
```

Writes data to String using Base64 encoding.

**Parameters:**

- `dest` - destination string info.
- `reallocate` - reallocation callback.
- `raw` - raw data to encode.
- `raw_len` - length of raw data.
- `url_encoded` - if non-zero, uses URL-safe Base64 encoding (`-` and `_` instead of `+` and `/`).

#### `fio_string_write_base64dec`

```c
int fio_string_write_base64dec(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               const void *encoded,
                               size_t encoded_len);
```

Writes decoded base64 data to String.

### Core String URL escaping support

#### `fio_string_write_url_enc`

```c
int fio_string_write_url_enc(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             const void *raw,
                             size_t raw_len);
```

Writes data to String using URL encoding (a.k.a., percent encoding). Always encodes spaces as `%20` rather than `+`.

#### `fio_string_write_url_dec`

```c
int fio_string_write_url_dec(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             const void *encoded,
                             size_t encoded_len);
```

Writes decoded URL data to String. Decodes "percent encoding" as well as spaces encoded using `+`.

**Note**: the decoding function reads the non-standard `"%uXXXX"` as UTF-8 encoded data.

#### `fio_string_write_path_dec`

```c
int fio_string_write_path_dec(fio_str_info_s *dest,
                              fio_string_realloc_fn reallocate,
                              const void *encoded,
                              size_t encoded_len);
```

Writes decoded URL data to String. Decodes "percent encoding" without converting `+` to spaces.

**Note**: the decoding function reads the non-standard `"%uXXXX"` as UTF-8 encoded data.

### Core String HTML escaping support

#### `fio_string_write_html_escape`

```c
int fio_string_write_html_escape(fio_str_info_s *dest,
                                 fio_string_realloc_fn reallocate,
                                 const void *raw,
                                 size_t raw_len);
```

Writes HTML escaped data to a String.

#### `fio_string_write_html_unescape`

```c
int fio_string_write_html_unescape(fio_str_info_s *dest,
                                   fio_string_realloc_fn reallocate,
                                   const void *escaped,
                                   size_t escaped_len);
```

Writes HTML (mostly) un-escaped data to a String.

**Note**:

The un-escaping of HTML content includes a long list of named code-point. This list isn't handled here, instead only numerical and super-basic named code-points are supported.

The supported named code-points include a small group, among them: `&lt`, `&gt`, `&amp`, `&tab`, `&quot`, `&apos`, `&nbsp`, `&copy` (with or without a trailing `;`).

### Core String File Reading support

#### `fio_string_readfd`

```c
int fio_string_readfd(fio_str_info_s *dest,
                      fio_string_realloc_fn reallocate,
                      int fd,
                      intptr_t start_at,
                      size_t limit);
```

Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at`.

If `limit` is 0 (or less than 0) data will be written until EOF.

If `start_at` is negative, position will be calculated from the end of the file where `-1 == EOF`.

Note: this will fail unless used on actual files (not sockets, not pipes).

#### `fio_string_readfile`

```c
int fio_string_readfile(fio_str_info_s *dest,
                        fio_string_realloc_fn reallocate,
                        const char *filename,
                        intptr_t start_at,
                        size_t limit);
```

Opens the file `filename` and pastes it's contents (or a slice ot it) at the end of the String. If `limit == 0`, than the data will be read until EOF.

If the file can't be located, opened or read, or if `start_at` is beyond the EOF position, NULL is returned in the state's `data` field.


#### `fio_string_getdelim_fd`

```c
int fio_string_getdelim_fd(fio_str_info_s *dest,
                           fio_string_realloc_fn reallocate,
                           int fd,
                           intptr_t start_at,
                           char delim,
                           size_t limit);
```

Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at` and ending either at the first occurrence of `delim` or at EOF.

If `limit` is 0 (or less than 0) as much data as may be required will be written.

If `start_at` is negative, position will be calculated from the end of the file where `-1 == EOF`.

**Note**: this will fail unless used on actual seekable files (not sockets, not pipes).

#### `fio_string_getdelim_file`

```c
int fio_string_getdelim_file(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             const char *filename,
                             intptr_t start_at,
                             char delim,
                             size_t limit);
```

Opens the file `filename`, calls `fio_string_getdelim_fd` and closes the file.

-------------------------------------------------------------------------------

## C Strings with Binary Data

The facil.io C STL provides a very simple String library (`fio_bstr`) that wraps around the *Binary Safe Core String Helpers*, emulating (to some effect and degree) the behavior of the famous [Simple Dynamic Strings library](https://github.com/antirez/sds) while providing copy-on-write reference counting.

This String storage paradigm can be very effective and it is used as the default String key implementation in Maps when `FIO_MAP_KEY` is undefined.

To create a new String simply write to `NULL` and a new `char *` pointer will be returned, pointing to the first byte of the new string.

All `fio_bstr` functions that mutate the string return a pointer to the new string (**make sure to update the pointer!**).

The pointer should be freed using `fio_bstr_free`. i.e.:

```c
char * str = fio_bstr_write(NULL, "Hello World!", 12);
fprintf(stdout, "%s\n", str);
fio_bstr_free(str);
```

To copy a `fio_bstr` String use `fio_bstr_copy` - this uses a *copy-on-write* approach which can increase performance:

```c
char * str_org = fio_bstr_write(NULL, "Hello World", 11);
char * str_cpy = fio_bstr_copy(str_org);   /* str_cpy == str_org : only a reference count increase. */
str_cpy = fio_bstr_write(str_cpy, "!", 1); /* str_cpy != str_org : copy-on-write, data copied here. */
fprintf(stdout, "Original:    %s\nEdited Copy: %s\n", str_org, str_cpy);
fio_bstr_free(str_org);
fio_bstr_free(str_cpy);
```

The `fio_bstr` functions wrap all `fio_string` core API, resulting in the following available functions:

* `fio_bstr_write` - see [`fio_string_write`](#fio_string_write) for details.
* `fio_bstr_write2` (macro) - see [`fio_string_write2`](#fio_string_write2) for details.
* `fio_bstr_printf` - see [`fio_string_printf`](#fio_string_printf) for details.
* `fio_bstr_replace` - see [`fio_string_replace`](#fio_string_replace) for details.

* `fio_bstr_write_i` - see [`fio_string_write_i`](#fio_string_write_i) for details.
* `fio_bstr_write_u` - see [`fio_string_write_u`](#fio_string_write_u) for details.
* `fio_bstr_write_hex` - see [`fio_string_write_hex`](#fio_string_write_hex) for details.
* `fio_bstr_write_bin` - see [`fio_string_write_bin`](#fio_string_write_bin) for details.

* `fio_bstr_write_escape` - see [`fio_string_write_escape`](#fio_string_write_escape) for details.
* `fio_bstr_write_unescape` - see [`fio_string_write_unescape`](#fio_string_write_unescape) for details.

* `fio_bstr_write_base64enc` - see [`fio_string_write_base64enc`](#fio_string_write_base64enc) for details.
* `fio_bstr_write_base64dec` - see [`fio_string_write_base64dec`](#fio_string_write_base64dec) for details.

* `fio_bstr_write_url_enc` - see [`fio_string_write_url_enc`](#fio_string_write_url_enc) for details.
* `fio_bstr_write_url_dec` - see [`fio_string_write_url_dec`](#fio_string_write_url_dec) for details.

* `fio_bstr_write_html_escape` - see [`fio_string_write_html_escape`](#fio_string_write_html_escape) for details.
* `fio_bstr_write_html_unescape` - see [`fio_string_write_html_unescape`](#fio_string_write_html_unescape) for details.


* `fio_bstr_readfd` - see [`fio_string_readfd`](#fio_string_readfd) for details.
* `fio_bstr_readfile` - see [`fio_string_readfile`](#fio_string_readfile) for details.
* `fio_bstr_getdelim_fd` - see [`fio_string_getdelim_fd`](#fio_string_getdelim_fd) for details.
* `fio_bstr_getdelim_file` - see [`fio_string_getdelim_file`](#fio_string_getdelim_file) for details.

* `fio_bstr_is_greater` - see [`fio_string_is_greater`](#fio_string_is_greater) for details.

**Note**: the `fio_bstr` functions do not take a `reallocate` argument and their `dest` argument should be the existing `fio_bstr` pointer (`char *`).

**Note**: the `fio_bstr` functions might fail quietly if memory allocation fails. For better error handling use the `fio_bstr_info`, `fio_bstr_reallocate` and `fio_bstr_len_set` functions with the Core String API (the `.buf` in the `fio_str_info_s` struct is the `fio_bstr` pointer).

In addition, the following helpers are provided:

#### `fio_bstr_copy`

```c
char *fio_bstr_copy(char *bstr);
```

Returns a Copy-on-Write copy of the original `bstr`, increasing the original's reference count.

This approach to Copy-on-Write is **not** completely thread-safe, as a data race exists when an original string (without additional `copy`s) is being actively edited by another thread while `copy` is being called (in which case the still-in-process `write` will apply to the new copy, which may result in a re-allocation and the pointer `copy` is using being invalidated).

However, once the copy operation had completed in a thread-safe manner, further operations between the two instances do not need to be synchronized.

**Note**: This reference counter will automatically make a copy if more than 2 billion (2,147,483,648) references are counted.

**Note**: To avoid the Copy-on-Write logic, use:

```c
char *copy = fio_bstr_write(NULL, original, fio_bstr_len(original));
```

#### `fio_bstr_free`

```c
void fio_bstr_free(char *bstr);
```

Frees a binary string allocated by a `fio_bstr` function (or decreases its reference count).

#### `fio_bstr_reserve`

```c
char *fio_bstr_reserve(char *bstr, size_t len);
```

Reserves `len` bytes for future `write` operations (used to minimize realloc).

Returns the (possibly updated) `fio_bstr` pointer.

#### `fio_bstr_info`

```c
fio_str_info_s fio_bstr_info(const char *bstr);
```

Returns information about the `fio_bstr` using the `fio_str_info_s` struct.

#### `fio_bstr_buf`

```c
fio_buf_info_s fio_bstr_buf(const char *bstr);
```

Returns information about the `fio_bstr` using the `fio_buf_info_s` struct.

#### `fio_bstr_len`

```c
size_t fio_bstr_len(const char *bstr);
```

Gets the length of the `fio_bstr`.

#### `fio_bstr_len_set`

```c
char *fio_bstr_len_set(char *bstr, size_t len);
```

Sets the length of the `fio_bstr`.

**Note**: `len` **must** be less then the capacity of the `bstr`, or the function call will quietly fail.

Returns `bstr`.

#### `fio_bstr_is_eq2info`

```c
int fio_bstr_is_eq(const char *a, const char *b);
```

Tests two `fio_bstr` objects for equality.

Returns 1 if equal, 0 if not.


#### `fio_bstr_is_eq2info`

```c
int fio_bstr_is_eq2info(const char *a, fio_str_info_s b);
```

Compares a `fio_bstr` to a `fio_str_info_s` for equality.

Returns 1 if equal, 0 if not.

#### `fio_bstr_is_eq2buf`

```c
int fio_bstr_is_eq2buf(const char *a, fio_buf_info_s b);
```

Compares a `fio_bstr` to a `fio_buf_info_s` for equality.

Returns 1 if equal, 0 if not.

#### `fio_bstr_reallocate` - for internal use

```c
int fio_bstr_reallocate(fio_str_info_s *dest, size_t len);
```

Default reallocation callback implementation. The new `fio_bstr` pointer will replace the old one in `dest->buf`.

-------------------------------------------------------------------------------

## Small Key Strings for Maps - Binary Safe

It is very common for Hash Maps to contain String keys. When the String keys are usually short, than it could be more efficient to embed the Key String data into the map itself (improve cache locality) rather than allocate memory for each separate Key String.

The `fio_keystr_s` type included with the String Core performs exactly this optimization. When the majority of the Strings are short (`len <= 14` on 64 bit machines or `len <= 10` on 32 bit machines) than the strings are stored inside the Map's memory rather than allocated separately.

See example at the end of this section. The example shows how to use the `fio_keystr_s` type and the `FIO_MAP_KEY_KSTR` MACRO.

#### `FIO_MAP_KEY_STR`

A helper macro for defining Key String keys in Hash Maps.

#### `fio_keystr_s`

```c
typedef struct fio_keystr_s fio_keystr_s;
```

a semi-opaque type used for the `fio_keystr` functions

#### `fio_keystr_buf`

```c
fio_buf_info_s fio_keystr_buf(fio_keystr_s *str);
```

Returns the Key String as a `fio_buf_info_s`.

**Note**: Key Strings are NOT NUL TERMINATED!

#### `fio_keystr_info`

```c
fio_str_info_s fio_keystr_info(fio_keystr_s *str);
```

Returns the Key String as a `fio_str_info_s`.

**Note**: Key Strings are NOT NUL TERMINATED!

#### `fio_keystr_tmp`

```c
fio_keystr_s fio_keystr_tmp(const char *buf, uint32_t len);
```

Returns a **temporary** `fio_keystr_s` to be used as a key for a hash map.

Do **not** `fio_keystr_destroy` this key.

#### `fio_keystr_init`

```c
fio_keystr_s fio_keystr_init(fio_str_info_s str, void *(*alloc_func)(size_t len)) 
```

Returns a copy of `fio_keystr_s` - used internally by the hash map.

**Note**: when `.capa == FIO_KEYSTR_CONST` then the new `fio_keystr_s` will most likely point to the original pointer (which much remain valid in memory for the lifetime of the key string). Short enough strings are always copied to allow for improved cache locality.

#### `fio_keystr_destroy`

```c
void fio_keystr_destroy(fio_keystr_s *key, void (*free_func)(void *, size_t));
```

Destroys a copy of `fio_keystr_s` - used internally by the hash map.

#### `fio_keystr_is_eq`

```c
int fio_keystr_is_eq(fio_keystr_s a, fio_keystr_s b);
```

Compares two Key Strings - used internally by the hash map.

#### `fio_keystr_is_eq2`

```c
int fio_keystr_is_eq2(fio_keystr_s a, fio_str_info_s b);
```

Compares a Key String to a `fio_str_info_s` - used internally by the hash map.

#### `fio_keystr_is_eq3`

```c
int fio_keystr_is_eq3(fio_keystr_s a, fio_buf_info_s b);
```

Compares a Key String to a `fio_buf_info_s` - used internally by the hash map.

#### `fio_keystr_hash`

```c
uint64_t fio_keystr_hash(fio_keystr_s a);
```

Returns a good-enough `fio_keystr_s` risky hash.

#### `FIO_KEYSTR_CONST`

```c
#define FIO_KEYSTR_CONST ((size_t)-1LL)
```

### `fio_keystr` Example

This example maps words to numbers. Note that this will work also with binary data and dynamic strings.

```c
/* map words to numbers. */
#define FIO_MAP_KEY_KSTR
#define FIO_UMAP_NAME umap
#define FIO_MAP_VALUE uintptr_t
#define FIO_MAP_HASH_FN(k)                                                     \
  fio_risky_hash((k).buf, (k).len, (uint64_t)(uintptr_t)&umap_destroy)
#include "fio-stl/include.h" /* or "fio-stl.h" */

/* example adding strings to map and printing data. */
void map_keystr_example(void) {
  umap_s map = FIO_MAP_INIT;
  /* FIO_KEYSTR_CONST prevents copying of longer constant strings */
  umap_set(&map, FIO_STR_INFO3("One", 3, FIO_KEYSTR_CONST), 1, NULL);
  umap_set(&map, FIO_STR_INFO3("Two", 3, FIO_KEYSTR_CONST), 2, NULL);
  umap_set(&map, FIO_STR_INFO3("Three", 5, FIO_KEYSTR_CONST), 3, NULL);
  FIO_MAP_EACH(umap, &map, pos) {
    uintptr_t value = pos.value;
    printf("%.*s: %llu\n",
           (int)pos.key.len,
           pos.key.buf,
           (unsigned long long)value);
  }
  umap_destroy(&map);
}
```
-------------------------------------------------------------------------------
## Mustache Template Engine

```c
#define FIO_MUSTACHE
#include "fio-stl.h"
```

The facil.io library includes a Mustache-ish template engine that can be used to render dynamic content from templates.

Mustache is a logic-less template syntax that can be used for HTML, config files, source code, or any text-based format. The templates consist of tags surrounded by mustache-style delimiters (double curly braces `{{` and `}}`).

This implementation supports most standard Mustache features including variables, sections, inverted sections, partials, comments, and delimiter changes. It also includes support for YAML front matter in template files.

**Note**: this module depends on `FIO_STR` and related modules which will be automatically included.

### Configuration Macros

#### `FIO_MUSTACHE_MAX_DEPTH`

```c
#ifndef FIO_MUSTACHE_MAX_DEPTH
#define FIO_MUSTACHE_MAX_DEPTH 128
#endif
```

The maximum depth of a template's context (nesting level for sections and partials).

This prevents stack overflow from deeply nested templates or recursive partial includes.

#### `FIO_MUSTACHE_PRESERVE_PADDING`

```c
#ifndef FIO_MUSTACHE_PRESERVE_PADDING
#define FIO_MUSTACHE_PRESERVE_PADDING 0
#endif
```

When enabled (set to `1`), preserves padding (leading whitespace) for stand-alone variables and partial templates.

This is useful for generating properly indented output, especially when including partial templates that should maintain the indentation level of their inclusion point.

#### `FIO_MUSTACHE_LAMBDA_SUPPORT`

```c
#ifndef FIO_MUSTACHE_LAMBDA_SUPPORT
#define FIO_MUSTACHE_LAMBDA_SUPPORT 0
#endif
```

When enabled (set to `1`), supports raw text for lambda-style template processing.

Lambda support allows sections to receive the raw, unprocessed template text, enabling dynamic template manipulation at runtime.

#### `FIO_MUSTACHE_ISOLATE_PARTIALS`

```c
#ifndef FIO_MUSTACHE_ISOLATE_PARTIALS
#define FIO_MUSTACHE_ISOLATE_PARTIALS 1
#endif
```

When enabled (set to `1`, the default), limits the scope of partial templates to the context of their section.

This prevents partials from accessing variables outside their immediate context, providing better encapsulation.

-------------------------------------------------------------------------------

### Mustache Syntax

The following Mustache syntax elements are supported:

| Syntax | Description |
|--------|-------------|
| `{{variable}}` | HTML-escaped variable output |
| `{{{variable}}}` | Raw (unescaped) variable output |
| `{{&variable}}` | Raw (unescaped) variable output (alternative syntax) |
| `{{#section}}...{{/section}}` | Section block (renders if truthy or iterates over arrays) |
| `{{^section}}...{{/section}}` | Inverted section (renders if falsy or empty) |
| `{{>partial}}` | Include a partial template |
| `{{!comment}}` | Comment (ignored in output) |
| `{{=<% %>=}}` | Change delimiters (example changes to `<%` and `%>`) |

#### Variable Tags

Variables are the most basic tag type. A `{{name}}` tag renders the value of the `name` key in the current context, with HTML escaping applied.

To render unescaped HTML, use triple mustaches `{{{name}}}` or the ampersand syntax `{{&name}}`.

Dot notation is supported for accessing nested values: `{{person.name}}` will look for a `name` key within the `person` object.

The special variable `{{.}}` refers to the current context itself, useful when iterating over arrays of simple values.

#### Section Tags

Sections render blocks of text zero or more times, depending on the value of the key:

- **Falsy values** (false, null, empty arrays): The section is not rendered.
- **Truthy non-array values**: The section is rendered once with the value as the new context.
- **Arrays**: The section is rendered once for each item, with the item as the context.

```mustache
{{#items}}
  <li>{{name}}</li>
{{/items}}
```

#### Inverted Sections

Inverted sections render only when the value is falsy or an empty array:

```mustache
{{^items}}
  <p>No items found.</p>
{{/items}}
```

#### Partials

Partials allow you to include other template files:

```mustache
{{>header}}
<main>Content here</main>
{{>footer}}
```

**Note**: Partial templates are loaded relative to the including template's directory. The engine will search for files with `.mustache`, `.html`, or no extension.

#### Comments

Comments are ignored and produce no output:

```mustache
{{! This is a comment }}
```

#### Delimiter Changes

You can change the tag delimiters if the default `{{` and `}}` conflict with your content:

```mustache
{{=<% %>=}}
<%variable%>
<%={{ }}=%>
```

-------------------------------------------------------------------------------

### Types

#### `fio_mustache_s`

```c
typedef struct fio_mustache_s fio_mustache_s;
```

An opaque type representing a parsed Mustache template.

Templates are reference counted and can be safely shared between threads (for reading). Use `fio_mustache_dup` to increase the reference count and `fio_mustache_free` to decrease it.

#### `fio_mustache_load_args_s`

```c
typedef struct {
  /** The file's content (if pre-loaded) */
  fio_buf_info_s data;
  /** The file's name (even if preloaded, used for partials load paths) */
  fio_buf_info_s filename;
  /** Loads the file's content, returning a `fio_buf_info_s` structure. */
  fio_buf_info_s (*load_file_data)(fio_buf_info_s filename, void *udata);
  /** Frees the file's content from its `fio_buf_info_s` structure. */
  void (*free_file_data)(fio_buf_info_s file_data, void *udata);
  /** Called when YAML front matter data was found. */
  void (*on_yaml_front_matter)(fio_buf_info_s yaml_front_matter, void *udata);
  /** Opaque user data. */
  void *udata;
} fio_mustache_load_args_s;
```

Arguments structure for loading and parsing a Mustache template.

**Members:**

- `data` - The template content as a buffer. If provided, the template is parsed from this data instead of loading from a file.
- `filename` - The template file path. Used for loading the template (if `data` is not provided) and for resolving relative paths when loading partial templates.
- `load_file_data` - Custom callback for loading file content. If not provided, a default implementation using `fio_bstr_readfile` is used.
- `free_file_data` - Custom callback for freeing loaded file content. Must be provided if `load_file_data` is provided.
- `on_yaml_front_matter` - Callback invoked when YAML front matter is detected at the beginning of a template. The front matter content (including delimiters) is passed to this callback.
- `udata` - Opaque user data passed to all callbacks.

#### `fio_mustache_bargs_s`

```c
typedef struct fio_mustache_bargs_s {
  /* callback should write `txt` to output and return updated `udata.` */
  void *(*write_text)(void *udata, fio_buf_info_s txt);
  /* same as `write_text`, but should also HTML escape (sanitize) data. */
  void *(*write_text_escaped)(void *udata, fio_buf_info_s raw);
  /* callback should return a new context pointer with the value of `name`. */
  void *(*get_var)(void *ctx, fio_buf_info_s name);
  /* if context is an Array, should return its length. */
  size_t (*array_length)(void *ctx);
  /* if context is an Array, should return a context pointer @ index. */
  void *(*get_var_index)(void *ctx, size_t index);
  /* should return the String value of context `var` as a `fio_buf_info_s`. */
  fio_buf_info_s (*var2str)(void *var);
  /* should return non-zero if the context pointer refers to a valid value. */
  int (*var_is_truthful)(void *ctx);
  /* callback signals that the `ctx` context pointer is no longer in use. */
  void (*release_var)(void *ctx);
  /* returns non-zero if `ctx` is a lambda and handles section manually. */
  int (*is_lambda)(void **udata, void *ctx, fio_buf_info_s raw_template_section);
  /* the root context for finding named values. */
  void *ctx;
  /* opaque user data (settable as well as readable), the final return value. */
  void *udata;
} fio_mustache_bargs_s;
```

Arguments structure for building (rendering) a Mustache template.

**Members:**

- `write_text` - Callback to write raw text to the output. Should return the updated `udata` value.
- `write_text_escaped` - Callback to write HTML-escaped text to the output. Used for `{{variable}}` tags. Should return the updated `udata` value.
- `get_var` - Callback to retrieve a variable from the context by name. Returns a new context pointer representing the value, or `NULL` if not found.
- `array_length` - Callback to get the length of an array context. Returns `0` for non-array contexts.
- `get_var_index` - Callback to get an element from an array context by index.
- `var2str` - Callback to convert a context/variable to its string representation.
- `var_is_truthful` - Callback to determine if a context represents a truthy value. Returns non-zero for truthy values.
- `release_var` - Callback to release a context pointer when it's no longer needed. Used for memory management.
- `is_lambda` - Callback for lambda support. If the context is a lambda, this callback should handle the section rendering and return non-zero. Only called if `FIO_MUSTACHE_LAMBDA_SUPPORT` is enabled.
- `ctx` - The root context object containing the data for template rendering.
- `udata` - Opaque user data. This value is passed to callbacks and returned as the final result of `fio_mustache_build`.

**Note**: If `write_text` and `write_text_escaped` are both `NULL`, default implementations are used that build a `fio_bstr` string, which is returned via `udata`.

-------------------------------------------------------------------------------

### Loading and Parsing API

#### `fio_mustache_load`

```c
fio_mustache_s *fio_mustache_load(fio_mustache_load_args_s args);
/* Named arguments using macro. */
#define fio_mustache_load(...) fio_mustache_load((fio_mustache_load_args_s){__VA_ARGS__})
```

Loads and parses a Mustache template, returning a template object.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_mustache_s *template = fio_mustache_load(.filename = FIO_BUF_INFO1("template.mustache"));
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `data` | `fio_buf_info_s` | Template content (if pre-loaded) |
| `filename` | `fio_buf_info_s` | Template file path |
| `load_file_data` | `fio_buf_info_s (*)(fio_buf_info_s, void *)` | Custom file loader callback |
| `free_file_data` | `void (*)(fio_buf_info_s, void *)` | Custom file data cleanup callback |
| `on_yaml_front_matter` | `void (*)(fio_buf_info_s, void *)` | YAML front matter callback |
| `udata` | `void *` | User data passed to callbacks |

**Returns:** a pointer to the parsed template object, or `NULL` on error.

**Note**: Either `data` or `filename` must be provided. If both are provided, `data` is used as the template content and `filename` is used only for resolving partial template paths.

#### `fio_mustache_free`

```c
void fio_mustache_free(fio_mustache_s *m);
```

Frees the Mustache template object (or reduces its reference count).

If the reference count reaches zero, the template and all its resources are freed.

#### `fio_mustache_dup`

```c
fio_mustache_s *fio_mustache_dup(fio_mustache_s *m);
```

Increases the Mustache template's reference count and returns the same pointer.

Use this when you need to share a template between multiple owners.

-------------------------------------------------------------------------------

### Building / Rendering API

#### `fio_mustache_build`

```c
void *fio_mustache_build(fio_mustache_s *m, fio_mustache_bargs_s args);
/* Named arguments using macro. */
#define fio_mustache_build(m, ...) fio_mustache_build((m), ((fio_mustache_bargs_s){__VA_ARGS__}))
```

Builds (renders) the template with the provided context, returning the final value of `udata`.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
char *result = fio_mustache_build(template,
                                  .ctx = my_data_context,
                                  .udata = NULL);
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `write_text` | `void *(*)(void *, fio_buf_info_s)` | Raw text output callback |
| `write_text_escaped` | `void *(*)(void *, fio_buf_info_s)` | HTML-escaped output callback |
| `get_var` | `void *(*)(void *, fio_buf_info_s)` | Variable lookup callback |
| `array_length` | `size_t (*)(void *)` | Array length callback |
| `get_var_index` | `void *(*)(void *, size_t)` | Array element access callback |
| `var2str` | `fio_buf_info_s (*)(void *)` | Variable to string conversion callback |
| `var_is_truthful` | `int (*)(void *)` | Truthiness check callback |
| `release_var` | `void (*)(void *)` | Variable release callback |
| `is_lambda` | `int (*)(void **, void *, fio_buf_info_s)` | Lambda support callback |
| `ctx` | `void *` | Root data context |
| `udata` | `void *` | User data (becomes return value) |

**Returns:** the final value of `udata` (or `NULL` if the template is `NULL`).

**Note**: If no writer callbacks are provided, the function uses default implementations that build a `fio_bstr` string. In this case, the returned `udata` is the resulting string which must be freed with `fio_bstr_free`.

-------------------------------------------------------------------------------

### YAML Front Matter

The Mustache engine supports YAML front matter at the beginning of template files. Front matter is delimited by `---` on its own line:

```yaml
---
title: My Page
author: John Doe
---
<html>
<head><title>{{title}}</title></head>
...
```

When front matter is detected, the `on_yaml_front_matter` callback is invoked with the complete front matter content (including the `---` delimiters). This allows you to parse metadata from templates for use in your application.

**Note**: The front matter is stripped from the template content before parsing. The Mustache engine does not parse the YAML itself - you must provide your own YAML parser in the callback if needed.

-------------------------------------------------------------------------------

### Partial Template Loading

When loading partial templates (via `{{>partial}}`), the engine searches for files in the following order:

1. Relative to the including template's directory
2. Relative to parent template directories (recursively)
3. In the current working directory

For each location, the engine tries the following file extensions:

1. `.mustache`
2. `.html`
3. No extension (exact filename)

**Example**: If `templates/page.mustache` includes `{{>header}}`, the engine will search for:
- `templates/header.mustache`
- `templates/header.html`
- `templates/header`
- `header.mustache`
- `header.html`
- `header`

-------------------------------------------------------------------------------

### Example - Basic Usage with FIOBJ

The following example demonstrates using the Mustache engine with the FIOBJ type system:

```c
#define FIO_FIOBJ
#define FIO_MUSTACHE
#include "fio-stl.h"

/* FIOBJ integration callbacks */
static void *fiobj_mustache_get_var(void *ctx, fio_buf_info_s name) {
  if (!ctx || !FIOBJ_TYPE_IS((FIOBJ)ctx, FIOBJ_T_HASH))
    return NULL;
  FIOBJ key = fiobj_str_new_cstr(name.buf, name.len);
  FIOBJ val = fiobj_hash_get((FIOBJ)ctx, key);
  fiobj_free(key);
  return (void *)fiobj_dup(val);
}

static size_t fiobj_mustache_array_length(void *ctx) {
  if (!ctx || !FIOBJ_TYPE_IS((FIOBJ)ctx, FIOBJ_T_ARRAY))
    return 0;
  return fiobj_array_count((FIOBJ)ctx);
}

static void *fiobj_mustache_get_var_index(void *ctx, size_t index) {
  if (!ctx || !FIOBJ_TYPE_IS((FIOBJ)ctx, FIOBJ_T_ARRAY))
    return NULL;
  return (void *)fiobj_dup(fiobj_array_get((FIOBJ)ctx, index));
}

static fio_buf_info_s fiobj_mustache_var2str(void *var) {
  return FIO_STR2BUF_INFO(fiobj2cstr((FIOBJ)var));
}

static int fiobj_mustache_var_is_truthful(void *ctx) {
  if (!ctx)
    return 0;
  FIOBJ o = (FIOBJ)ctx;
  switch (FIOBJ_TYPE(o)) {
  case FIOBJ_T_NULL:
  case FIOBJ_T_FALSE:
    return 0;
  case FIOBJ_T_ARRAY:
    return fiobj_array_count(o) > 0;
  default:
    return 1;
  }
}

static void fiobj_mustache_release_var(void *ctx) {
  fiobj_free((FIOBJ)ctx);
}

void example(void) {
  /* Load template */
  fio_mustache_s *m = fio_mustache_load(
      .filename = FIO_BUF_INFO1("template.mustache"));
  if (!m) {
    fprintf(stderr, "Failed to load template\n");
    return;
  }

  /* Create data context */
  FIOBJ data = fiobj_hash_new();
  fiobj_hash_set2(data, "name", 4, fiobj_str_new_cstr("World", 5));
  
  FIOBJ items = fiobj_array_new();
  fiobj_array_push(items, fiobj_str_new_cstr("Apple", 5));
  fiobj_array_push(items, fiobj_str_new_cstr("Banana", 6));
  fiobj_array_push(items, fiobj_str_new_cstr("Cherry", 6));
  fiobj_hash_set2(data, "items", 5, items);

  /* Render template */
  char *result = fio_mustache_build(m,
      .ctx = (void *)data,
      .get_var = fiobj_mustache_get_var,
      .array_length = fiobj_mustache_array_length,
      .get_var_index = fiobj_mustache_get_var_index,
      .var2str = fiobj_mustache_var2str,
      .var_is_truthful = fiobj_mustache_var_is_truthful,
      .release_var = fiobj_mustache_release_var);

  /* Output result */
  printf("%s\n", result);

  /* Cleanup */
  fio_bstr_free(result);
  fiobj_free(data);
  fio_mustache_free(m);
}
```

With a template file `template.mustache`:

```mustache
Hello, {{name}}!

Items:
{{#items}}
  - {{.}}
{{/items}}
{{^items}}
  No items available.
{{/items}}
```

Output:

```
Hello, World!

Items:
  - Apple
  - Banana
  - Cherry
```

-------------------------------------------------------------------------------

### Example - Simple String Rendering

For simple use cases where you just want to render a template to a string without a complex data context:

```c
#define FIO_MUSTACHE
#include "fio-stl.h"

void simple_example(void) {
  /* Load template from string */
  fio_mustache_s *m = fio_mustache_load(
      .data = FIO_BUF_INFO1("Hello, {{name}}!"));
  
  if (!m) {
    fprintf(stderr, "Failed to parse template\n");
    return;
  }

  /* Render with default (empty) context - variables won't be replaced */
  char *result = fio_mustache_build(m, .udata = NULL);
  
  printf("%s\n", result);  /* Output: Hello, ! */
  
  fio_bstr_free(result);
  fio_mustache_free(m);
}
```

**Note**: Without providing context callbacks, variables will render as empty strings. For meaningful output, you need to provide at least `ctx`, `get_var`, `var2str`, and `var_is_truthful` callbacks.

-------------------------------------------------------------------------------
## BLAKE2

```c
#define FIO_BLAKE2
#include FIO_INCLUDE_FILE
```

By defining `FIO_BLAKE2`, the BLAKE2 cryptographic hash functions are defined and made available. This module provides both BLAKE2b (64-bit optimized, up to 64-byte digest) and BLAKE2s (32-bit optimized, up to 32-byte digest).

BLAKE2 is a high-speed cryptographic hash function standardized in [RFC 7693](https://tools.ietf.org/html/rfc7693). It is faster than MD5, SHA-1, and SHA-2 while providing security comparable to SHA-3.

Each variant supports:

- **One-shot hashing** - hash data in a single call, returning a fixed-size result type
- **Flexible-output hashing** - hash with configurable digest length and optional keying
- **HMAC construction** - standard HMAC (RFC 2104) using BLAKE2 as the underlying hash
- **Streaming** - init/consume/finalize pattern for incremental hashing

### BLAKE2b Types

#### `fio_blake2b_s`

```c
typedef struct {
  uint64_t h[8];    /* state */
  uint64_t t[2];    /* total bytes processed (128-bit counter) */
  uint64_t f[2];    /* finalization flags */
  uint8_t buf[128]; /* input buffer */
  size_t buflen;    /* bytes in buffer */
  size_t outlen;    /* digest length */
} fio_blake2b_s;
```

Streaming BLAKE2b context (64-bit, up to 64-byte digest).

**Members:**
- `h` - 8-word internal state (512 bits)
- `t` - 128-bit byte counter (total bytes processed)
- `f` - finalization flags
- `buf` - 128-byte input buffer for partial blocks
- `buflen` - number of bytes currently in the buffer
- `outlen` - requested digest length in bytes (1-64)

**Note**: this type should be treated as opaque. Use `fio_blake2b_init` to initialize it.

### BLAKE2b Functions

#### `fio_blake2b`

```c
fio_u512 fio_blake2b(const void *data, uint64_t len);
```

One-shot BLAKE2b hash with maximum-length (64-byte) digest.

Returns the hash as a `fio_u512` value. All 64 bytes of the result are valid.

**Parameters:**
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

**Returns:** a `fio_u512` containing the 64-byte BLAKE2b digest.

**Note**: this function has the same signature as `fio_sha512`, making them interchangeable as function pointers of type `fio_u512 (*)(const void *, uint64_t)`.

#### `fio_blake2b_hash`

```c
void fio_blake2b_hash(void *restrict out,
                      size_t outlen,
                      const void *restrict data,
                      size_t len,
                      const void *restrict key,
                      size_t keylen);
```

Flexible-output BLAKE2b hash with optional keying.

Computes a BLAKE2b hash of `data` with a configurable output length and optional secret key. The result is written to `out`.

**Parameters:**
- `out` - destination buffer (must have capacity for at least `outlen` bytes)
- `outlen` - desired digest length in bytes (1-64; defaults to 64 if 0)
- `data` - pointer to the data to hash
- `len` - length of the data in bytes
- `key` - optional secret key for keyed hashing (NULL for unkeyed)
- `keylen` - length of the key in bytes (0-64; clamped to 64 if larger)

**Note**: keyed BLAKE2b is a built-in MAC mode defined by the BLAKE2 specification. It differs from HMAC-BLAKE2b (see `fio_blake2b_hmac`).

#### `fio_blake2b_hmac`

```c
fio_u512 fio_blake2b_hmac(const void *key,
                          uint64_t key_len,
                          const void *msg,
                          uint64_t msg_len);
```

Computes HMAC-BLAKE2b using the standard HMAC construction (RFC 2104), producing a 64-byte authentication code.

Uses a 128-byte block size (BLAKE2b's internal block size). If the key exceeds 128 bytes, it is first hashed with BLAKE2b. Intermediate key material is securely zeroed after use.

**Parameters:**
- `key` - pointer to the secret key
- `key_len` - length of the key in bytes
- `msg` - pointer to the message to authenticate
- `msg_len` - length of the message in bytes

**Returns:** a `fio_u512` containing the 64-byte HMAC authentication code.

**Note**: this uses the standard HMAC construction `H((K ^ opad) || H((K ^ ipad) || msg))`, which is different from BLAKE2b's built-in keyed mode. Use this when interoperability with standard HMAC implementations is required.

#### `fio_blake2b_init`

```c
fio_blake2b_s fio_blake2b_init(size_t outlen,
                               const void *key,
                               size_t keylen);
```

Initializes a BLAKE2b streaming context.

**Parameters:**
- `outlen` - desired digest length in bytes (1-64; defaults to 64 if 0; clamped to 64 if larger)
- `key` - optional secret key for keyed hashing (NULL for unkeyed)
- `keylen` - length of the key in bytes (0-64; clamped to 64 if larger)

**Returns:** an initialized `fio_blake2b_s` context.

#### `fio_blake2b_consume`

```c
void fio_blake2b_consume(fio_blake2b_s *restrict h,
                         const void *restrict data,
                         size_t len);
```

Feeds data into a BLAKE2b streaming context.

Can be called multiple times to incrementally hash data. Internally buffers partial blocks and processes complete 128-byte blocks as they become available.

**Parameters:**
- `h` - pointer to an initialized `fio_blake2b_s` context
- `data` - pointer to the data to consume
- `len` - length of the data in bytes

#### `fio_blake2b_finalize`

```c
fio_u512 fio_blake2b_finalize(fio_blake2b_s *h);
```

Finalizes a BLAKE2b streaming context and returns the digest.

Pads the remaining buffer with zeros, performs the final compression with the finalization flag set, and outputs the hash in little-endian byte order.

**Parameters:**
- `h` - pointer to the streaming context to finalize

**Returns:** a `fio_u512` containing the digest. Only the first `outlen` bytes (as specified during `fio_blake2b_init`) are valid.

**Note**: the context should not be used after finalization.

### BLAKE2s Types

#### `fio_blake2s_s`

```c
typedef struct {
  uint32_t h[8];   /* state */
  uint32_t t[2];   /* total bytes processed (64-bit counter) */
  uint32_t f[2];   /* finalization flags */
  uint8_t buf[64]; /* input buffer */
  size_t buflen;   /* bytes in buffer */
  size_t outlen;   /* digest length */
} fio_blake2s_s;
```

Streaming BLAKE2s context (32-bit, up to 32-byte digest).

**Members:**
- `h` - 8-word internal state (256 bits)
- `t` - 64-bit byte counter (total bytes processed)
- `f` - finalization flags
- `buf` - 64-byte input buffer for partial blocks
- `buflen` - number of bytes currently in the buffer
- `outlen` - requested digest length in bytes (1-32)

**Note**: this type should be treated as opaque. Use `fio_blake2s_init` to initialize it.

### BLAKE2s Functions

#### `fio_blake2s`

```c
fio_u256 fio_blake2s(const void *data, uint64_t len);
```

One-shot BLAKE2s hash with maximum-length (32-byte) digest.

Returns the hash as a `fio_u256` value. All 32 bytes of the result are valid.

**Parameters:**
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

**Returns:** a `fio_u256` containing the 32-byte BLAKE2s digest.

#### `fio_blake2s_hash`

```c
void fio_blake2s_hash(void *restrict out,
                      size_t outlen,
                      const void *restrict data,
                      size_t len,
                      const void *restrict key,
                      size_t keylen);
```

Flexible-output BLAKE2s hash with optional keying.

Computes a BLAKE2s hash of `data` with a configurable output length and optional secret key. The result is written to `out`.

**Parameters:**
- `out` - destination buffer (must have capacity for at least `outlen` bytes)
- `outlen` - desired digest length in bytes (1-32; defaults to 32 if 0)
- `data` - pointer to the data to hash
- `len` - length of the data in bytes
- `key` - optional secret key for keyed hashing (NULL for unkeyed)
- `keylen` - length of the key in bytes (0-32; clamped to 32 if larger)

#### `fio_blake2s_hmac`

```c
fio_u256 fio_blake2s_hmac(const void *key,
                          uint64_t key_len,
                          const void *msg,
                          uint64_t msg_len);
```

Computes HMAC-BLAKE2s using the standard HMAC construction (RFC 2104), producing a 32-byte authentication code.

Uses a 64-byte block size (BLAKE2s's internal block size). If the key exceeds 64 bytes, it is first hashed with BLAKE2s. Intermediate key material is securely zeroed after use.

**Parameters:**
- `key` - pointer to the secret key
- `key_len` - length of the key in bytes
- `msg` - pointer to the message to authenticate
- `msg_len` - length of the message in bytes

**Returns:** a `fio_u256` containing the 32-byte HMAC authentication code.

#### `fio_blake2s_init`

```c
fio_blake2s_s fio_blake2s_init(size_t outlen,
                               const void *key,
                               size_t keylen);
```

Initializes a BLAKE2s streaming context.

**Parameters:**
- `outlen` - desired digest length in bytes (1-32; defaults to 32 if 0; clamped to 32 if larger)
- `key` - optional secret key for keyed hashing (NULL for unkeyed)
- `keylen` - length of the key in bytes (0-32; clamped to 32 if larger)

**Returns:** an initialized `fio_blake2s_s` context.

#### `fio_blake2s_consume`

```c
void fio_blake2s_consume(fio_blake2s_s *restrict h,
                         const void *restrict data,
                         size_t len);
```

Feeds data into a BLAKE2s streaming context.

Can be called multiple times to incrementally hash data. Internally buffers partial blocks and processes complete 64-byte blocks as they become available.

**Parameters:**
- `h` - pointer to an initialized `fio_blake2s_s` context
- `data` - pointer to the data to consume
- `len` - length of the data in bytes

#### `fio_blake2s_finalize`

```c
fio_u256 fio_blake2s_finalize(fio_blake2s_s *h);
```

Finalizes a BLAKE2s streaming context and returns the digest.

Pads the remaining buffer with zeros, performs the final compression with the finalization flag set, and outputs the hash in little-endian byte order.

**Parameters:**
- `h` - pointer to the streaming context to finalize

**Returns:** a `fio_u256` containing the digest. Only the first `outlen` bytes (as specified during `fio_blake2s_init`) are valid.

**Note**: the context should not be used after finalization.

### BLAKE2 Examples

#### One-Shot Hashing

```c
#define FIO_BLAKE2
#include FIO_INCLUDE_FILE

void example_oneshot(void) {
  const char *msg = "Hello, BLAKE2!";
  
  /* BLAKE2b - 64-byte digest */
  fio_u512 b2b = fio_blake2b(msg, strlen(msg));
  /* b2b.u8[0..63] contains the digest */

  /* BLAKE2s - 32-byte digest */
  fio_u256 b2s = fio_blake2s(msg, strlen(msg));
  /* b2s.u8[0..31] contains the digest */
}
```

#### Flexible-Output with Keying

```c
void example_keyed(void) {
  const char *key = "my-secret-key";
  const char *data = "message to hash";
  uint8_t digest[16]; /* 16-byte digest */

  fio_blake2b_hash(digest, 16,
                   data, strlen(data),
                   key, strlen(key));
  /* digest[0..15] contains the 16-byte keyed hash */
}
```

#### Streaming (Incremental) Hashing

```c
void example_streaming(void) {
  fio_blake2b_s ctx = fio_blake2b_init(64, NULL, 0);
  
  /* Feed data in chunks */
  fio_blake2b_consume(&ctx, "Hello, ", 7);
  fio_blake2b_consume(&ctx, "BLAKE2!", 7);
  
  fio_u512 result = fio_blake2b_finalize(&ctx);
  /* result.u8[0..63] contains the digest */
}
```

#### HMAC Authentication

```c
void example_hmac(void) {
  const char *key = "authentication-key";
  const char *msg = "message to authenticate";

  /* BLAKE2b HMAC - 64-byte MAC */
  fio_u512 mac = fio_blake2b_hmac(key, strlen(key),
                                  msg, strlen(msg));
  /* mac.u8[0..63] contains the authentication code */

  /* BLAKE2s HMAC - 32-byte MAC */
  fio_u256 mac_s = fio_blake2s_hmac(key, strlen(key),
                                    msg, strlen(msg));
  /* mac_s.u8[0..31] contains the authentication code */
}
```

### BLAKE2b vs BLAKE2s

| Property | BLAKE2b | BLAKE2s |
|----------|---------|---------|
| Word size | 64-bit | 32-bit |
| Block size | 128 bytes | 64 bytes |
| Max digest | 64 bytes | 32 bytes |
| Max key | 64 bytes | 32 bytes |
| Rounds | 12 | 10 |
| Optimized for | 64-bit platforms | 32-bit platforms |
| Result type | `fio_u512` | `fio_u256` |

-------------------------------------------------------------------------------
## ChaCha20 & Poly1305

```c
#define FIO_CHACHA
#include "fio-stl.h"
```

Non-streaming ChaCha20 and Poly1305 implementations are provided for cases when a cryptography library isn't available (or too heavy) but a good enough symmetric cryptographic solution is required. Please note that this implementation was not tested from a cryptographic viewpoint and although constant time was desired it might not have been achieved on all systems / CPUs.

**Note:** some CPUs do not offer constant time MUL and might leak information through side-chain attacks.

**Note:** this module depends on the `FIO_MATH` module which will be automatically included.

### ChaCha20Poly1305 API

#### `fio_chacha20_poly1305_enc`

```c
void fio_chacha20_poly1305_enc(void *restrict mac,
                               void *restrict data,
                               size_t len,
                               const void *ad, /* additional data */
                               size_t adlen,
                               const void *key,
                               const void *nonce);
```

Performs an in-place encryption of `data` using ChaCha20 with additional data, producing a 16 byte message authentication code (MAC) using Poly1305.

* `mac`    MUST point to a buffer with (at least) 16 available bytes.
* `data`   MAY be omitted, WILL be encrypted.
* `len`    length of `data` in bytes.
* `ad`     MAY be omitted, will NOT be encrypted.
* `adlen`  length of `ad` in bytes.
* `key`    MUST point to a 256 bit long memory address (32 Bytes).
* `nonce`  MUST point to a  96 bit long memory address (12 Bytes).

#### `fio_chacha20_poly1305_dec`

```c
int fio_chacha20_poly1305_dec(void *restrict mac,
                              void *restrict data,
                              size_t len,
                              const void *ad, /* additional data */
                              size_t adlen,
                              const void *key,
                              const void *nonce);
```

Performs an in-place decryption of `data` using ChaCha20 after authenticating the message authentication code (MAC) using Poly1305.

* `mac`    MUST point to a buffer where the 16 byte MAC is placed.
* `data`   MAY be omitted, WILL be decrypted.
* `len`    length of `data` in bytes.
* `ad`     MAY be omitted ONLY IF originally omitted.
* `adlen`  length of `ad` in bytes.
* `key`    MUST point to a 256 bit long memory address (32 Bytes).
* `nonce`  MUST point to a  96 bit long memory address (12 Bytes).

**Returns:** `0` on success, `-1` on error (authentication failed).

#### `fio_chacha20_poly1305_auth`

```c
void fio_chacha20_poly1305_auth(void *restrict mac,
                                void *restrict data,
                                size_t len,
                                const void *ad, /* additional data */
                                size_t adlen,
                                const void *key,
                                const void *nonce);
```

Computes the Poly1305 authentication tag for already-encrypted data without performing decryption.

This function is useful when you need to verify or compute the MAC for ciphertext that was encrypted using ChaCha20Poly1305, without decrypting the data.

* `mac`    MUST point to a buffer with (at least) 16 available bytes for the computed MAC.
* `data`   the encrypted data (ciphertext).
* `len`    length of `data` in bytes.
* `ad`     additional authenticated data (MAY be omitted).
* `adlen`  length of `ad` in bytes.
* `key`    MUST point to a 256 bit long memory address (32 Bytes).
* `nonce`  MUST point to a  96 bit long memory address (12 Bytes).

### Using ChaCha20 and Poly1305 Separately

#### `fio_chacha20`

```c
void fio_chacha20(void *restrict data,
                  size_t len,
                  const void *key,
                  const void *nonce,
                  uint32_t counter);
```

Performs an in-place encryption/decryption of `data` using ChaCha20.

* `data`    the data to encrypt/decrypt in-place.
* `len`     length of `data` in bytes.
* `key`     MUST point to a 256 bit long memory address (32 Bytes).
* `nonce`   MUST point to a  96 bit long memory address (12 Bytes).
* `counter` is the block counter, usually 1 unless `data` is mid-cyphertext.

#### `fio_poly1305_auth`

```c
void fio_poly1305_auth(void *restrict mac,
                       const void *key,
                       void *restrict msg,
                       size_t len,
                       const void *ad,
                       size_t ad_len);
```

Given a Poly1305 256bit (32 byte) key, writes the Poly1305 authentication code for the message and additional data into `mac`.

* `mac`    MUST point to a 128 bit long memory address (16 Bytes).
* `key`    MUST point to a 256 bit long memory address (32 Bytes).
* `msg`    the message to authenticate.
* `len`    length of `msg` in bytes.
* `ad`     additional data to authenticate (MAY be omitted).
* `ad_len` length of `ad` in bytes.

### XChaCha20-Poly1305 API (Extended Nonce)

XChaCha20-Poly1305 is the extended-nonce variant that uses a 192-bit (24-byte) nonce instead of the standard 96-bit (12-byte) nonce. This makes it safe to use randomly-generated nonces without collision risk due to the birthday paradox.

**How it works:**
1. HChaCha20 derives a 256-bit subkey from the original key and first 16 bytes of the nonce
2. Standard ChaCha20-Poly1305 is applied using the subkey and remaining 8 bytes of the nonce

#### `fio_xchacha20_poly1305_enc`

```c
void fio_xchacha20_poly1305_enc(void *restrict mac,
                                void *restrict data,
                                size_t len,
                                const void *ad,
                                size_t adlen,
                                const void *key,
                                const void *nonce);
```

Performs an in-place encryption of `data` using XChaCha20 with additional data, producing a 16 byte message authentication code (MAC) using Poly1305.

* `mac`    MUST point to a buffer with (at least) 16 available bytes.
* `data`   MAY be omitted, WILL be encrypted.
* `len`    length of `data` in bytes.
* `ad`     MAY be omitted, will NOT be encrypted.
* `adlen`  length of `ad` in bytes.
* `key`    MUST point to a 256 bit long memory address (32 Bytes).
* `nonce`  MUST point to a 192 bit long memory address (24 Bytes).

#### `fio_xchacha20_poly1305_dec`

```c
int fio_xchacha20_poly1305_dec(void *restrict mac,
                               void *restrict data,
                               size_t len,
                               const void *ad,
                               size_t adlen,
                               const void *key,
                               const void *nonce);
```

Performs an in-place decryption of `data` using XChaCha20 after authenticating the message authentication code (MAC) using Poly1305.

* `mac`    MUST point to a buffer where the 16 byte MAC is placed.
* `data`   MAY be omitted, WILL be decrypted.
* `len`    length of `data` in bytes.
* `ad`     MAY be omitted ONLY IF originally omitted.
* `adlen`  length of `ad` in bytes.
* `key`    MUST point to a 256 bit long memory address (32 Bytes).
* `nonce`  MUST point to a 192 bit long memory address (24 Bytes).

**Returns:** `0` on success, `-1` on error (authentication failed).

#### `fio_xchacha20`

```c
void fio_xchacha20(void *restrict data,
                   size_t len,
                   const void *key,
                   const void *nonce,
                   uint32_t counter);
```

Performs an in-place encryption/decryption of `data` using XChaCha20.

* `data`    the data to encrypt/decrypt in-place.
* `len`     length of `data` in bytes.
* `key`     MUST point to a 256 bit long memory address (32 Bytes).
* `nonce`   MUST point to a 192 bit long memory address (24 Bytes).
* `counter` is the block counter, usually 0 unless `data` is mid-cyphertext.

-------------------------------------------------------------------------------
## HKDF

```c
#define FIO_HKDF
#include FIO_INCLUDE_FILE
```

By defining `FIO_HKDF`, the HMAC-based Key Derivation Function (HKDF) is defined and made available.

HKDF is standardized in [RFC 5869](https://www.rfc-editor.org/rfc/rfc5869) and provides a two-stage key derivation process:

1. **Extract** - concentrates entropy from input keying material into a fixed-length pseudorandom key (PRK)
2. **Expand** - derives one or more output keys from the PRK

Supports both SHA-256 and SHA-384 as the underlying HMAC hash function.

**Note**: HKDF requires SHA-2 HMAC functions (`fio_sha256_hmac`, `fio_sha512_hmac`). Either define `FIO_SHA2` before `FIO_HKDF`, or use `FIO_CRYPTO` to include all crypto modules.

### HKDF Constants

#### `FIO_HKDF_SHA256_HASH_LEN`

```c
#define FIO_HKDF_SHA256_HASH_LEN 32
```

SHA-256 hash output length in bytes.

#### `FIO_HKDF_SHA384_HASH_LEN`

```c
#define FIO_HKDF_SHA384_HASH_LEN 48
```

SHA-384 hash output length in bytes.

### HKDF Functions

#### `fio_hkdf_extract`

```c
void fio_hkdf_extract(void *restrict prk,
                      const void *restrict salt,
                      size_t salt_len,
                      const void *restrict ikm,
                      size_t ikm_len,
                      int use_sha384);
```

HKDF-Extract: computes `PRK = HMAC-Hash(salt, IKM)`.

Extracts a pseudorandom key (PRK) from input keying material (IKM). The PRK concentrates the entropy from the IKM into a fixed-length output suitable for use with HKDF-Expand.

**Parameters:**
- `prk` - output buffer for the pseudorandom key (32 bytes for SHA-256, 48 bytes for SHA-384)
- `salt` - optional salt value (if NULL, uses a string of zeros of hash length)
- `salt_len` - length of the salt in bytes
- `ikm` - input keying material
- `ikm_len` - length of the IKM in bytes
- `use_sha384` - if non-zero, use SHA-384; otherwise use SHA-256

#### `fio_hkdf_expand`

```c
void fio_hkdf_expand(void *restrict okm,
                     size_t okm_len,
                     const void *restrict prk,
                     size_t prk_len,
                     const void *restrict info,
                     size_t info_len,
                     int use_sha384);
```

HKDF-Expand: computes `OKM = HKDF-Expand(PRK, info, L)`.

Expands a pseudorandom key (PRK) into output keying material (OKM) of the desired length. The `info` parameter provides application-specific context to derive distinct keys from the same PRK.

**Parameters:**
- `okm` - output buffer for the derived keying material
- `okm_len` - desired output length in bytes (maximum 255 * hash_len)
- `prk` - pseudorandom key from HKDF-Extract (32 or 48 bytes)
- `prk_len` - length of the PRK (32 for SHA-256, 48 for SHA-384)
- `info` - optional context and application-specific information
- `info_len` - length of the info in bytes
- `use_sha384` - if non-zero, use SHA-384; otherwise use SHA-256

#### `fio_hkdf`

```c
void fio_hkdf(void *restrict okm,
              size_t okm_len,
              const void *restrict salt,
              size_t salt_len,
              const void *restrict ikm,
              size_t ikm_len,
              const void *restrict info,
              size_t info_len,
              int use_sha384);
```

Combined HKDF (Extract + Expand) in a single call.

Derives keying material from input keying material using the full HKDF process (RFC 5869 Section 2). Equivalent to calling `fio_hkdf_extract` followed by `fio_hkdf_expand`.

**Parameters:**
- `okm` - output buffer for the derived keying material
- `okm_len` - desired output length in bytes (maximum 255 * hash_len)
- `salt` - optional salt value (if NULL, uses a string of zeros of hash length)
- `salt_len` - length of the salt in bytes
- `ikm` - input keying material
- `ikm_len` - length of the IKM in bytes
- `info` - optional context and application-specific information
- `info_len` - length of the info in bytes
- `use_sha384` - if non-zero, use SHA-384; otherwise use SHA-256

### HKDF Examples

#### Basic Key Derivation

```c
#define FIO_SHA2
#define FIO_HKDF
#include FIO_INCLUDE_FILE

void example_hkdf(void) {
  const char *ikm = "input keying material";
  const char *salt = "optional salt";
  const char *info = "application context";
  uint8_t derived_key[32];

  /* Derive a 32-byte key using SHA-256 */
  fio_hkdf(derived_key, 32,
           salt, strlen(salt),
           ikm, strlen(ikm),
           info, strlen(info),
           0 /* use SHA-256 */);
}
```

#### Two-Stage Key Derivation

```c
void example_two_stage(void) {
  const char *ikm = "shared secret from key exchange";
  uint8_t prk[48]; /* SHA-384 PRK */

  /* Extract: concentrate entropy */
  fio_hkdf_extract(prk, NULL, 0,
                   ikm, strlen(ikm),
                   1 /* use SHA-384 */);

  /* Expand: derive multiple keys from same PRK */
  uint8_t client_key[32], server_key[32];
  fio_hkdf_expand(client_key, 32, prk, 48,
                  "client key", 10, 1);
  fio_hkdf_expand(server_key, 32, prk, 48,
                  "server key", 10, 1);
}
```

-------------------------------------------------------------------------------
## SHA1

```c
#define FIO_SHA1
#include FIO_INCLUDE_FILE
```

By defining the `FIO_SHA1`, the SHA1 (broken) Cryptographic Hash functions will be defined and made available.

**Warning(!) / Broken**: Do **NOT** use SHA1 for security concerns, it's broken and hopefully future cryptographic libraries won't include it in their packages... however, for some reason, some protocols require SHA1 (i.e., WebSockets).

### SHA1 Types

#### `fio_sha1_s`

```c
typedef union {
  uint32_t v[5];
  uint8_t digest[20];
} fio_sha1_s;
```

The data type containing the SHA1 digest (result).

**Members:**
- `v` - The 5 x 32-bit words of the SHA1 state
- `digest` - The 20-byte digest as raw bytes

### SHA1 Functions

#### `fio_sha1`

```c
fio_sha1_s fio_sha1(const void *data, uint64_t len);
```

A simple, non streaming, implementation of the SHA1 hashing algorithm.

**Parameters:**
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

**Returns:** a `fio_sha1_s` containing the SHA1 digest.

#### `fio_sha1_hmac`

```c
fio_sha1_s fio_sha1_hmac(const void *key,
                         uint64_t key_len,
                         const void *msg,
                         uint64_t msg_len);
```

Computes HMAC-SHA1, resulting in a 20 byte authentication code.

**Parameters:**
- `key` - pointer to the secret key
- `key_len` - length of the key in bytes
- `msg` - pointer to the message to authenticate
- `msg_len` - length of the message in bytes

**Returns:** a `fio_sha1_s` containing the 20-byte HMAC authentication code.

**Note**: if `key_len` exceeds 64 bytes, the key is first hashed with SHA1.

#### `fio_sha1_len`

```c
size_t fio_sha1_len(void);
```

Returns the digest length of SHA1 in bytes (which is always 20).

#### `fio_sha1_digest`

```c
uint8_t *fio_sha1_digest(fio_sha1_s *s);
```

Returns a pointer to the digest of a SHA1 object. The digest is always 20 bytes long.

**Parameters:**
- `s` - pointer to a `fio_sha1_s` object

**Returns:** pointer to the 20-byte digest.

-------------------------------------------------------------------------------
## SHA2

```c
#define FIO_SHA2
#include FIO_INCLUDE_FILE
```

By defining `FIO_SHA2`, the SHA-2 family of cryptographic hash functions (SHA-256 and SHA-512) will be defined and made available, along with their HMAC variants.

### Types

#### `fio_sha256_s`

```c
typedef struct {
  fio_u256 hash;
  fio_u512 cache;
  uint64_t total_len;
} fio_sha256_s;
```

Streaming SHA-256 type. Used with `fio_sha256_init`, `fio_sha256_consume`, and `fio_sha256_finalize` for incremental hashing.

#### `fio_sha512_s`

```c
typedef struct {
  fio_u512 hash;
  fio_u1024 cache;
  uint64_t total_len;
} fio_sha512_s;
```

Streaming SHA-512 type. Used with `fio_sha512_init`, `fio_sha512_consume`, and `fio_sha512_finalize` for incremental hashing.

### SHA-256 Functions

#### `fio_sha256`

```c
fio_u256 fio_sha256(const void *data, uint64_t len);
```

A simple, non-streaming implementation of the SHA-256 hashing algorithm.

**Parameters:**
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

**Returns:** a `fio_u256` containing the 256-bit (32-byte) hash result.

#### `fio_sha256_init`

```c
fio_sha256_s fio_sha256_init(void);
```

Initializes a `fio_sha256_s` so the hash can consume streaming data.

**Returns:** an initialized `fio_sha256_s` structure.

#### `fio_sha256_consume`

```c
void fio_sha256_consume(fio_sha256_s *h, const void *data, uint64_t len);
```

Feeds data into the hash.

**Parameters:**
- `h` - pointer to the streaming hash state
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

#### `fio_sha256_finalize`

```c
fio_u256 fio_sha256_finalize(fio_sha256_s *h);
```

Finalizes the streaming hash and returns the SHA-256 result.

**Parameters:**
- `h` - pointer to the streaming hash state

**Returns:** a `fio_u256` containing the 256-bit (32-byte) hash result.

**Note**: after finalization, the hash state should not be reused without re-initialization.

### SHA-512 Functions

#### `fio_sha512`

```c
fio_u512 fio_sha512(const void *data, uint64_t len);
```

A simple, non-streaming implementation of the SHA-512 hashing algorithm.

**Parameters:**
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

**Returns:** a `fio_u512` containing the 512-bit (64-byte) hash result.

#### `fio_sha512_init`

```c
fio_sha512_s fio_sha512_init(void);
```

Initializes a `fio_sha512_s` so the hash can consume streaming data.

**Returns:** an initialized `fio_sha512_s` structure.

#### `fio_sha512_consume`

```c
void fio_sha512_consume(fio_sha512_s *h, const void *data, uint64_t len);
```

Feeds data into the hash.

**Parameters:**
- `h` - pointer to the streaming hash state
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

#### `fio_sha512_finalize`

```c
fio_u512 fio_sha512_finalize(fio_sha512_s *h);
```

Finalizes the streaming hash and returns the SHA-512 result.

**Parameters:**
- `h` - pointer to the streaming hash state

**Returns:** a `fio_u512` containing the 512-bit (64-byte) hash result.

**Note**: after finalization, the hash state should not be reused without re-initialization.

### HMAC Functions

#### `fio_sha256_hmac`

```c
fio_u256 fio_sha256_hmac(const void *key,
                         uint64_t key_len,
                         const void *msg,
                         uint64_t msg_len);
```

Computes HMAC-SHA256, resulting in a 32-byte authentication code.

**Parameters:**
- `key` - pointer to the secret key
- `key_len` - length of the key in bytes
- `msg` - pointer to the message to authenticate
- `msg_len` - length of the message in bytes

**Returns:** a `fio_u256` containing the 256-bit (32-byte) HMAC result.

**Note**: keys longer than 64 bytes are hashed first (per HMAC specification).

#### `fio_sha512_hmac`

```c
fio_u512 fio_sha512_hmac(const void *key,
                         uint64_t key_len,
                         const void *msg,
                         uint64_t msg_len);
```

Computes HMAC-SHA512, resulting in a 64-byte authentication code.

**Parameters:**
- `key` - pointer to the secret key
- `key_len` - length of the key in bytes
- `msg` - pointer to the message to authenticate
- `msg_len` - length of the message in bytes

**Returns:** a `fio_u512` containing the 512-bit (64-byte) HMAC result.

**Note**: keys longer than 128 bytes are hashed first (per HMAC specification).

-------------------------------------------------------------------------------
## SHA-3

```c
#define FIO_SHA3
#include FIO_INCLUDE_FILE
```

By defining `FIO_SHA3`, the SHA-3 cryptographic hash functions and SHAKE extendable-output functions are defined and made available.

This module provides the full SHA-3 family standardized in [FIPS 202](https://csrc.nist.gov/publications/detail/fips/202/final):

- **SHA3-224** - 28-byte (224-bit) fixed-output hash
- **SHA3-256** - 32-byte (256-bit) fixed-output hash
- **SHA3-384** - 48-byte (384-bit) fixed-output hash
- **SHA3-512** - 64-byte (512-bit) fixed-output hash
- **SHAKE128** - extendable-output function with 128-bit security
- **SHAKE256** - extendable-output function with 256-bit security

All variants share a single streaming type (`fio_sha3_s`) and support both one-shot and streaming (init/consume/finalize) usage patterns.

### SHA-3 Types

#### `fio_sha3_s`

```c
typedef struct {
  uint64_t state[25]; /* Keccak state (1600 bits) */
  uint8_t buf[200];   /* rate buffer (max rate = 1600 - 2*capacity) */
  size_t buflen;      /* bytes in buffer */
  size_t rate;        /* rate in bytes */
  size_t outlen;      /* output length in bytes (0 for SHAKE) */
  uint8_t delim;      /* domain separation byte */
} fio_sha3_s;
```

Streaming context for all SHA-3 and SHAKE variants. The Keccak state is 1600 bits (25 x 64-bit words).

**Members:**
- `state` - the 25-word Keccak-f[1600] state
- `buf` - input buffer for partial blocks (up to `rate` bytes)
- `buflen` - number of bytes currently in the buffer
- `rate` - rate in bytes, determined by the variant (e.g., 136 for SHA3-256)
- `outlen` - fixed output length in bytes (0 for SHAKE variants)
- `delim` - domain separation byte (0x06 for SHA-3, 0x1F for SHAKE)

**Note**: this type should be treated as opaque. Use the appropriate init function to initialize it.

### SHA-3 Fixed-Output Functions

#### `fio_sha3_224`

```c
void fio_sha3_224(void *restrict out,
                  const void *restrict data,
                  size_t len);
```

One-shot SHA3-224 hash producing a 28-byte digest.

**Parameters:**
- `out` - destination buffer (must have capacity for at least 28 bytes)
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

#### `fio_sha3_256`

```c
void fio_sha3_256(void *restrict out,
                  const void *restrict data,
                  size_t len);
```

One-shot SHA3-256 hash producing a 32-byte digest.

**Parameters:**
- `out` - destination buffer (must have capacity for at least 32 bytes)
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

#### `fio_sha3_384`

```c
void fio_sha3_384(void *restrict out,
                  const void *restrict data,
                  size_t len);
```

One-shot SHA3-384 hash producing a 48-byte digest.

**Parameters:**
- `out` - destination buffer (must have capacity for at least 48 bytes)
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

#### `fio_sha3_512`

```c
void fio_sha3_512(void *restrict out,
                  const void *restrict data,
                  size_t len);
```

One-shot SHA3-512 hash producing a 64-byte digest.

**Parameters:**
- `out` - destination buffer (must have capacity for at least 64 bytes)
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

### SHA-3 Streaming API

#### `fio_sha3_224_init`

```c
fio_sha3_s fio_sha3_224_init(void);
```

Initializes a SHA3-224 streaming context (28-byte output, rate = 144 bytes).

**Returns:** an initialized `fio_sha3_s` context.

#### `fio_sha3_256_init`

```c
fio_sha3_s fio_sha3_256_init(void);
```

Initializes a SHA3-256 streaming context (32-byte output, rate = 136 bytes).

**Returns:** an initialized `fio_sha3_s` context.

#### `fio_sha3_384_init`

```c
fio_sha3_s fio_sha3_384_init(void);
```

Initializes a SHA3-384 streaming context (48-byte output, rate = 104 bytes).

**Returns:** an initialized `fio_sha3_s` context.

#### `fio_sha3_512_init`

```c
fio_sha3_s fio_sha3_512_init(void);
```

Initializes a SHA3-512 streaming context (64-byte output, rate = 72 bytes).

**Returns:** an initialized `fio_sha3_s` context.

#### `fio_sha3_consume`

```c
void fio_sha3_consume(fio_sha3_s *restrict h,
                      const void *restrict data,
                      size_t len);
```

Feeds data into a SHA-3 streaming context.

Can be called multiple times to incrementally hash data. Full blocks are absorbed directly from the input pointer (avoiding an extra copy), while partial blocks are buffered internally.

**Parameters:**
- `h` - pointer to an initialized `fio_sha3_s` context
- `data` - pointer to the data to consume
- `len` - length of the data in bytes

**Note**: this function is also used for SHAKE via the `fio_shake_consume` alias.

#### `fio_sha3_finalize`

```c
void fio_sha3_finalize(fio_sha3_s *restrict h, void *restrict out);
```

Finalizes a SHA-3 streaming context and writes the digest to `out`.

Applies SHA-3 padding (domain separator 0x06, then 10*1 padding), performs the final Keccak-f[1600] permutation, and squeezes the output.

**Parameters:**
- `h` - pointer to the streaming context to finalize
- `out` - destination buffer (must have capacity for at least `h->outlen` bytes)

**Note**: the context should not be used after finalization. Do **not** use this function for SHAKE  use `fio_shake_squeeze` instead.

### SHAKE Extendable-Output Functions

SHAKE (Secure Hash Algorithm KECCAK) provides extendable-output: you can request any number of output bytes. SHAKE128 provides 128-bit security and SHAKE256 provides 256-bit security.

#### `fio_shake128`

```c
void fio_shake128(void *restrict out,
                  size_t outlen,
                  const void *restrict data,
                  size_t len);
```

One-shot SHAKE128 with specified output length.

**Parameters:**
- `out` - destination buffer (must have capacity for at least `outlen` bytes)
- `outlen` - desired output length in bytes (can be any value)
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

#### `fio_shake256`

```c
void fio_shake256(void *restrict out,
                  size_t outlen,
                  const void *restrict data,
                  size_t len);
```

One-shot SHAKE256 with specified output length.

**Parameters:**
- `out` - destination buffer (must have capacity for at least `outlen` bytes)
- `outlen` - desired output length in bytes (can be any value)
- `data` - pointer to the data to hash
- `len` - length of the data in bytes

### SHAKE Streaming API

#### `fio_shake128_init`

```c
fio_sha3_s fio_shake128_init(void);
```

Initializes a SHAKE128 streaming context (variable output, rate = 168 bytes).

**Returns:** an initialized `fio_sha3_s` context.

#### `fio_shake256_init`

```c
fio_sha3_s fio_shake256_init(void);
```

Initializes a SHAKE256 streaming context (variable output, rate = 136 bytes).

**Returns:** an initialized `fio_sha3_s` context.

#### `fio_shake_consume`

```c
#define fio_shake_consume fio_sha3_consume
```

Alias for `fio_sha3_consume`. Feeds data into a SHAKE streaming context.

#### `fio_shake_squeeze`

```c
void fio_shake_squeeze(fio_sha3_s *restrict h,
                       void *restrict out,
                       size_t outlen);
```

Squeezes output from a SHAKE context. Can be called multiple times to produce an arbitrary amount of output.

On the first call, applies SHAKE padding (domain separator 0x1F, then 10*1 padding) and performs the initial Keccak-f[1600] permutation. Subsequent calls continue squeezing from the Keccak state, applying additional permutations as needed.

**Parameters:**
- `h` - pointer to a SHAKE streaming context (must have been initialized with `fio_shake128_init` or `fio_shake256_init` and fed data via `fio_shake_consume`)
- `out` - destination buffer
- `outlen` - number of bytes to squeeze

**Note**: do **not** call `fio_sha3_finalize` on a SHAKE context. Use `fio_shake_squeeze` instead.

### SHA-3 Examples

#### One-Shot Hashing

```c
#define FIO_SHA3
#include FIO_INCLUDE_FILE

void example_oneshot(void) {
  const char *msg = "Hello, SHA-3!";
  uint8_t digest[32];

  fio_sha3_256(digest, msg, strlen(msg));
  /* digest[0..31] contains the SHA3-256 hash */
}
```

#### Streaming (Incremental) Hashing

```c
void example_streaming(void) {
  fio_sha3_s ctx = fio_sha3_512_init();

  /* Feed data in chunks */
  fio_sha3_consume(&ctx, "Hello, ", 7);
  fio_sha3_consume(&ctx, "SHA-3!", 6);

  uint8_t digest[64];
  fio_sha3_finalize(&ctx, digest);
  /* digest[0..63] contains the SHA3-512 hash */
}
```

#### SHAKE Extendable Output

```c
void example_shake(void) {
  const char *msg = "seed data";
  uint8_t output[1024]; /* Request 1024 bytes of output */

  /* One-shot */
  fio_shake256(output, 1024, msg, strlen(msg));

  /* Streaming with multiple squeezes */
  fio_sha3_s ctx = fio_shake128_init();
  fio_shake_consume(&ctx, msg, strlen(msg));
  
  uint8_t block1[64], block2[64];
  fio_shake_squeeze(&ctx, block1, 64); /* First 64 bytes */
  fio_shake_squeeze(&ctx, block2, 64); /* Next 64 bytes */
}
```

### SHA-3 Variant Summary

| Variant | Output | Rate | Security | Domain |
|---------|--------|------|----------|--------|
| SHA3-224 | 28 bytes | 144 bytes | 112-bit | 0x06 |
| SHA3-256 | 32 bytes | 136 bytes | 128-bit | 0x06 |
| SHA3-384 | 48 bytes | 104 bytes | 192-bit | 0x06 |
| SHA3-512 | 64 bytes | 72 bytes | 256-bit | 0x06 |
| SHAKE128 | variable | 168 bytes | 128-bit | 0x1F |
| SHAKE256 | variable | 136 bytes | 256-bit | 0x1F |

-------------------------------------------------------------------------------
## AES-GCM

```c
#define FIO_AES
#include "fio-stl/include.h"
```

AES-GCM provides authenticated encryption with associated data (AEAD). This is the most common cipher suite for TLS 1.3 and is widely used in secure communications.

The implementation automatically uses hardware acceleration when available:
- **x86/x64**: AES-NI and PCLMULQDQ instructions
- **ARM**: Crypto Extensions (PMULL)
- **Fallback**: Portable software implementation using T-tables

**Note:** the API matches `fio_chacha20_poly1305` for easy function pointer substitution, allowing applications to switch between cipher suites without code changes.

**Note:** this module depends on the `FIO_MATH` module which will be automatically included.

### AES-128-GCM

#### `fio_aes128_gcm_enc`

```c
void fio_aes128_gcm_enc(void *restrict mac,
                        void *restrict data,
                        size_t len,
                        const void *ad,
                        size_t adlen,
                        const void *key,
                        const void *nonce);
```

Performs an in-place encryption of `data` using AES-128-GCM with additional data, producing a 16 byte message authentication code (MAC).

* `mac`    MUST point to a buffer with (at least) 16 available bytes.
* `key`    MUST point to a 128 bit long memory address (16 Bytes).
* `nonce`  MUST point to a  96 bit long memory address (12 Bytes).
* `ad`     MAY be omitted, will NOT be encrypted.
* `data`   MAY be omitted, WILL be encrypted.

**Note:** the nonce MUST be unique for each message encrypted with the same key. Reusing a nonce with the same key completely breaks the security of GCM.

#### `fio_aes128_gcm_dec`

```c
int fio_aes128_gcm_dec(void *restrict mac,
                       void *restrict data,
                       size_t len,
                       const void *ad,
                       size_t adlen,
                       const void *key,
                       const void *nonce);
```

Performs an in-place decryption of `data` using AES-128-GCM after authenticating the message authentication code (MAC).

* `mac`    MUST point to a buffer with the 16 byte MAC to verify.
* `key`    MUST point to a 128 bit long memory address (16 Bytes).
* `nonce`  MUST point to a  96 bit long memory address (12 Bytes).
* `ad`     MAY be omitted ONLY IF originally omitted.
* `data`   MAY be omitted, WILL be decrypted.

Returns `-1` on error (authentication failed). When authentication fails, the data buffer is NOT modified.

### AES-256-GCM

#### `fio_aes256_gcm_enc`

```c
void fio_aes256_gcm_enc(void *restrict mac,
                        void *restrict data,
                        size_t len,
                        const void *ad,
                        size_t adlen,
                        const void *key,
                        const void *nonce);
```

Performs an in-place encryption of `data` using AES-256-GCM with additional data, producing a 16 byte message authentication code (MAC).

* `mac`    MUST point to a buffer with (at least) 16 available bytes.
* `key`    MUST point to a 256 bit long memory address (32 Bytes).
* `nonce`  MUST point to a  96 bit long memory address (12 Bytes).
* `ad`     MAY be omitted, will NOT be encrypted.
* `data`   MAY be omitted, WILL be encrypted.

**Note:** the nonce MUST be unique for each message encrypted with the same key. Reusing a nonce with the same key completely breaks the security of GCM.

#### `fio_aes256_gcm_dec`

```c
int fio_aes256_gcm_dec(void *restrict mac,
                       void *restrict data,
                       size_t len,
                       const void *ad,
                       size_t adlen,
                       const void *key,
                       const void *nonce);
```

Performs an in-place decryption of `data` using AES-256-GCM after authenticating the message authentication code (MAC).

* `mac`    MUST point to a buffer with the 16 byte MAC to verify.
* `key`    MUST point to a 256 bit long memory address (32 Bytes).
* `nonce`  MUST point to a  96 bit long memory address (12 Bytes).
* `ad`     MAY be omitted ONLY IF originally omitted.
* `data`   MAY be omitted, WILL be decrypted.

Returns `-1` on error (authentication failed). When authentication fails, the data buffer is NOT modified.

### Security Considerations

**Nonce Uniqueness:** GCM mode requires that each (key, nonce) pair is used only once. Reusing a nonce with the same key allows an attacker to recover the authentication key and forge messages. For random nonces with a 96-bit nonce space, the probability of collision becomes significant after approximately 2^32 messages.

**Key Sizes:** AES-256-GCM provides a higher security margin than AES-128-GCM. While both are considered secure, AES-256 is recommended for long-term security and compliance with stricter security requirements.

**TLS 1.3 Compatibility:** Both AES-128-GCM and AES-256-GCM are mandatory cipher suites in TLS 1.3 (`TLS_AES_128_GCM_SHA256` and `TLS_AES_256_GCM_SHA384`).

------------------------------------------------------------
## ED25519 & X25519

```c
#define FIO_ED25519
#include "fio-stl.h"
```

This module provides elliptic curve cryptography using Curve25519, offering both digital signatures (Ed25519) and key exchange (X25519) with 128-bit security level. These are the minimal building blocks for secure inter-machine communication.

**Note:** this implementation has not been audited. Use at your own risk. A tested cryptographic library (e.g., OpenSSL) is preferred when available.

**Note:** this module depends on the `FIO_SHA2` module which will be automatically included.

### Ed25519 Digital Signatures

Ed25519 provides fast, secure digital signatures.

- Secret key: 32 bytes
- Public key: 32 bytes
- Signature: 64 bytes

#### `fio_ed25519_keypair`

```c
void fio_ed25519_keypair(uint8_t secret_key[32], uint8_t public_key[32]);
```

Generates a new random Ed25519 key pair.

The secret key must be kept secret and securely erased when no longer needed. The public key can be freely shared.

#### `fio_ed25519_public_key`

```c
void fio_ed25519_public_key(uint8_t public_key[32],
                            const uint8_t secret_key[32]);
```

Derives the public key from an Ed25519 secret key.

Useful when the secret key is loaded from storage and the public key needs to be recomputed.

#### `fio_ed25519_sign`

```c
void fio_ed25519_sign(uint8_t signature[64],
                      const void *message,
                      size_t len,
                      const uint8_t secret_key[32],
                      const uint8_t public_key[32]);
```

Signs a message using Ed25519.

* `signature`   MUST point to a 64 byte buffer for the output signature.
* `message`     the message to sign (may be NULL if `len` is 0).
* `len`         the length of the message in bytes.
* `secret_key`  MUST point to a 32 byte secret key.
* `public_key`  MUST point to a 32 byte public key.

The signature is deterministic (same message + key = same signature).

#### `fio_ed25519_verify`

```c
int fio_ed25519_verify(const uint8_t signature[64],
                       const void *message,
                       size_t len,
                       const uint8_t public_key[32]);
```

Verifies an Ed25519 signature.

* `signature`   MUST point to a 64 byte signature.
* `message`     the message that was signed.
* `len`         the length of the message in bytes.
* `public_key`  MUST point to a 32 byte public key.

Returns `0` on success (valid signature), `-1` on failure (invalid signature).

### X25519 Key Exchange (ECDH)

X25519 provides Elliptic Curve Diffie-Hellman key exchange. Two parties can derive a shared secret using their secret key and the other party's public key.

- Secret key: 32 bytes
- Public key: 32 bytes
- Shared secret: 32 bytes

#### `fio_x25519_keypair`

```c
void fio_x25519_keypair(uint8_t secret_key[32], uint8_t public_key[32]);
```

Generates a new random X25519 key pair.

The secret key must be kept secret. The public key can be shared with the other party for key exchange.

#### `fio_x25519_public_key`

```c
void fio_x25519_public_key(uint8_t public_key[32],
                           const uint8_t secret_key[32]);
```

Derives the public key from an X25519 secret key.

This performs scalar multiplication of the secret key with the base point.

#### `fio_x25519_shared_secret`

```c
int fio_x25519_shared_secret(uint8_t shared_secret[32],
                             const uint8_t secret_key[32],
                             const uint8_t their_public_key[32]);
```

Computes a shared secret using X25519 (ECDH).

Both parties compute the same shared secret:

```c
shared = X25519(my_secret, their_public)
```

* `shared_secret`    MUST point to a 32 byte buffer for the output.
* `secret_key`       MUST point to your 32 byte secret key.
* `their_public_key` MUST point to the other party's 32 byte public key.

Returns `0` on success, `-1` on failure (e.g., if `their_public_key` is a low-order point, which would result in an all-zero shared secret).

**Note:** the shared secret should be passed through a KDF (e.g., HKDF with SHA-256) before being used as an encryption key.

### Key Conversion

Ed25519 and X25519 use the same underlying curve but with different representations. These functions convert between the two formats, allowing a single key pair to be used for both signing and encryption.

**Note:** converting keys is generally safe, but using the same key for both signing and encryption is debated. Consider using separate key pairs for maximum security.

#### `fio_ed25519_sk_to_x25519`

```c
void fio_ed25519_sk_to_x25519(uint8_t x_secret_key[32],
                              const uint8_t ed_secret_key[32]);
```

Converts an Ed25519 secret key to an X25519 secret key.

This allows using an Ed25519 signing key for X25519 key exchange.

#### `fio_ed25519_pk_to_x25519`

```c
void fio_ed25519_pk_to_x25519(uint8_t x_public_key[32],
                              const uint8_t ed_public_key[32]);
```

Converts an Ed25519 public key to an X25519 public key.

This allows encrypting to someone who has only shared their Ed25519 signing public key.

### Public Key Encryption (ECIES)

This provides asymmetric encryption where anyone can encrypt a message using only the recipient's public key, and only the recipient can decrypt it using their private key. No prior key exchange or handshake is required.

The scheme uses:
- X25519 for ephemeral key agreement
- SHA-256 for key derivation
- ChaCha20-Poly1305 or AES256-GCM for authenticated encryption

Ciphertext format: `[32-byte ephemeral public key][16-byte MAC][encrypted data]`

Total overhead: 48 bytes

#### `FIO_X25519_CIPHERTEXT_LEN`

```c
#define FIO_X25519_CIPHERTEXT_LEN(message_len) ((message_len) + 48)
```

Returns the ciphertext length for a given plaintext length.

Ciphertext = ephemeral_pk (32) + mac (16) + encrypted_message (message_len)

#### `FIO_X25519_PLAINTEXT_LEN`

```c
#define FIO_X25519_PLAINTEXT_LEN(ciphertext_len) \
  ((ciphertext_len) > 48 ? ((ciphertext_len) - 48) : 0)
```

Returns the plaintext length for a given ciphertext length.

Returns `0` if `ciphertext_len < 48` (invalid ciphertext).

#### `fio_x25519_encrypt`

```c
int fio_x25519_encrypt(uint8_t *ciphertext,
                       const void *message,
                       size_t message_len,
                       fio_crypto_enc_fn encryption_function,
                       const uint8_t recipient_pk[32]);
```

Encrypts a message using the recipient's X25519 public key.

* `ciphertext`          MUST point to a buffer of at least `message_len + 48` bytes.
* `message`             the plaintext message to encrypt.
* `message_len`         the length of the message in bytes.
* `encryption_function` the encryption function (e.g., `fio_chacha20_poly1305_enc`).
* `recipient_pk`        MUST point to the recipient's 32 byte X25519 public key.

The ciphertext includes:
- 32 bytes: ephemeral public key (for key agreement)
- 16 bytes: authentication tag (MAC)
- N bytes: encrypted message

Returns `0` on success, `-1` on failure.

#### `fio_x25519_decrypt`

```c
int fio_x25519_decrypt(uint8_t *plaintext,
                       const uint8_t *ciphertext,
                       size_t ciphertext_len,
                       fio_crypto_dec_fn decryption_function,
                       const uint8_t recipient_sk[32]);
```

Decrypts a message using the recipient's X25519 secret key.

* `plaintext`           MUST point to a buffer of at least `ciphertext_len - 48` bytes.
* `ciphertext`          the ciphertext (ephemeral_pk || mac || encrypted_data).
* `ciphertext_len`      the length of the ciphertext (must be >= 48).
* `decryption_function` the decryption function (e.g., `fio_chacha20_poly1305_dec`).
* `recipient_sk`        MUST point to the recipient's 32 byte X25519 secret key.

Returns `0` on success, `-1` on failure (authentication failed or invalid input).

------------------------------------------------------------
## ASN.1 DER Parser

```c
#define FIO_ASN1
#include FIO_INCLUDE_FILE
```

By defining `FIO_ASN1`, an ASN.1 DER (Distinguished Encoding Rules) parser is made available. This module provides parsing capabilities for X.509 certificates and other DER-encoded data structures commonly used in TLS and cryptographic applications.

The parser is non-allocating - all returned pointers reference the original DER data, which must remain valid while the parsed structures are in use.

### Types

#### `fio_asn1_tag_e`

```c
typedef enum {
  FIO_ASN1_EOC = 0x00,               /* End-of-contents */
  FIO_ASN1_BOOLEAN = 0x01,           /* Boolean */
  FIO_ASN1_INTEGER = 0x02,           /* Integer */
  FIO_ASN1_BIT_STRING = 0x03,        /* Bit String */
  FIO_ASN1_OCTET_STRING = 0x04,      /* Octet String */
  FIO_ASN1_NULL = 0x05,              /* Null */
  FIO_ASN1_OID = 0x06,               /* Object Identifier */
  FIO_ASN1_UTF8_STRING = 0x0C,       /* UTF-8 String */
  FIO_ASN1_SEQUENCE = 0x10,          /* Sequence (0x30 with constructed bit) */
  FIO_ASN1_SET = 0x11,               /* Set (0x31 with constructed bit) */
  FIO_ASN1_PRINTABLE_STRING = 0x13,  /* Printable String */
  FIO_ASN1_IA5_STRING = 0x16,        /* IA5 String (ASCII) */
  FIO_ASN1_UTC_TIME = 0x17,          /* UTC Time */
  FIO_ASN1_GENERALIZED_TIME = 0x18,  /* Generalized Time */
  FIO_ASN1_CONTEXT_0 = 0xA0,         /* [0] EXPLICIT/IMPLICIT */
  FIO_ASN1_CONTEXT_1 = 0xA1,         /* [1] EXPLICIT/IMPLICIT */
  FIO_ASN1_CONTEXT_2 = 0xA2,         /* [2] EXPLICIT/IMPLICIT */
  FIO_ASN1_CONTEXT_3 = 0xA3,         /* [3] EXPLICIT/IMPLICIT */
} fio_asn1_tag_e;
```

ASN.1 Universal Tag Types used to identify element types in DER-encoded data.

#### `fio_asn1_class_e`

```c
typedef enum {
  FIO_ASN1_CLASS_UNIVERSAL = 0,   /* Universal (built-in types) */
  FIO_ASN1_CLASS_APPLICATION = 1, /* Application-specific */
  FIO_ASN1_CLASS_CONTEXT = 2,     /* Context-specific */
  FIO_ASN1_CLASS_PRIVATE = 3,     /* Private */
} fio_asn1_class_e;
```

ASN.1 Tag Class values (bits 7-6 of the tag byte).

#### `fio_asn1_element_s`

```c
typedef struct {
  const uint8_t *data;    /* Pointer to element content (after tag+length) */
  size_t len;             /* Length of content */
  uint8_t tag;            /* Raw tag byte */
  uint8_t is_constructed; /* 1 if constructed (contains other elements) */
  uint8_t tag_class;      /* 0=Universal, 1=Application, 2=Context, 3=Private */
  uint8_t tag_number;     /* Tag number (bits 4-0, or extended) */
} fio_asn1_element_s;
```

Parsed ASN.1 DER element structure.

**Members:**
- `data` - pointer to the element's content bytes (after tag and length fields)
- `len` - length of the content in bytes
- `tag` - the raw tag byte as it appears in the DER encoding
- `is_constructed` - 1 if the element contains nested elements, 0 for primitive
- `tag_class` - the tag class (Universal, Application, Context, or Private)
- `tag_number` - the tag number within its class

#### `fio_asn1_iterator_s`

```c
typedef struct {
  const uint8_t *pos; /* Current position */
  const uint8_t *end; /* End of sequence */
} fio_asn1_iterator_s;
```

Iterator for traversing SEQUENCE or SET contents.

**Members:**
- `pos` - current position within the sequence
- `end` - pointer to the end of the sequence data

### OID Constants

The module defines commonly used OID string constants for X.509 and TLS:

```c
/* Signature Algorithms */
#define FIO_OID_SHA256_WITH_RSA   "1.2.840.113549.1.1.11"
#define FIO_OID_SHA384_WITH_RSA   "1.2.840.113549.1.1.12"
#define FIO_OID_SHA512_WITH_RSA   "1.2.840.113549.1.1.13"
#define FIO_OID_RSA_PSS           "1.2.840.113549.1.1.10"
#define FIO_OID_ECDSA_WITH_SHA256 "1.2.840.10045.4.3.2"
#define FIO_OID_ED25519           "1.3.101.112"

/* Public Key Algorithms */
#define FIO_OID_RSA_ENCRYPTION "1.2.840.113549.1.1.1"
#define FIO_OID_EC_PUBLIC_KEY  "1.2.840.10045.2.1"

/* Elliptic Curves */
#define FIO_OID_SECP256R1 "1.2.840.10045.3.1.7"
#define FIO_OID_SECP384R1 "1.3.132.0.34"
#define FIO_OID_X25519    "1.3.101.110"

/* X.509 Extensions */
#define FIO_OID_BASIC_CONSTRAINTS "2.5.29.19"
#define FIO_OID_KEY_USAGE         "2.5.29.15"
#define FIO_OID_SUBJECT_ALT_NAME  "2.5.29.17"

/* Distinguished Name Attributes */
#define FIO_OID_COMMON_NAME  "2.5.4.3"
#define FIO_OID_ORGANIZATION "2.5.4.10"
```

### Core Parser Functions

#### `fio_asn1_parse`

```c
const uint8_t *fio_asn1_parse(fio_asn1_element_s *elem,
                              const uint8_t *data,
                              size_t data_len);
```

Parses one ASN.1 element from DER-encoded data.

**Parameters:**
- `elem` - output structure to fill with parsed element info
- `data` - pointer to DER-encoded data
- `data_len` - length of data buffer

**Returns:** pointer to the next element (after this one), or NULL on error.

Example:

```c
fio_asn1_element_s elem;
const uint8_t *next = fio_asn1_parse(&elem, der_data, der_len);
if (next) {
  printf("Tag: 0x%02X, Length: %zu\n", elem.tag, elem.len);
}
```

#### `fio_asn1_element_total_len`

```c
size_t fio_asn1_element_total_len(const fio_asn1_element_s *elem,
                                  const uint8_t *data);
```

Gets the total encoded length of an ASN.1 element (tag + length + content).

**Parameters:**
- `elem` - parsed element
- `data` - original data pointer where element was parsed from

**Returns:** total bytes used by the element encoding.

### Type-Specific Parsers

#### `fio_asn1_parse_integer`

```c
int fio_asn1_parse_integer(const fio_asn1_element_s *elem, uint64_t *value);
```

Parses an ASN.1 INTEGER element.

For small integers (<= 64-bit), sets `*value`. For large integers (e.g., RSA modulus), use `elem->data` and `elem->len` directly. Leading zero bytes for positive numbers are handled correctly.

**Parameters:**
- `elem` - parsed element (must be INTEGER type)
- `value` - output for integer value (can be NULL for large integers)

**Returns:** 0 on success, -1 on error.

#### `fio_asn1_parse_bit_string`

```c
int fio_asn1_parse_bit_string(const fio_asn1_element_s *elem,
                              const uint8_t **bits,
                              size_t *bit_len,
                              uint8_t *unused_bits);
```

Parses an ASN.1 BIT STRING element.

**Parameters:**
- `elem` - parsed element (must be BIT STRING type)
- `bits` - output pointer to bit data
- `bit_len` - output length of bit data in bytes
- `unused_bits` - output number of unused bits in last byte (0-7)

**Returns:** 0 on success, -1 on error.

#### `fio_asn1_parse_oid`

```c
int fio_asn1_parse_oid(const fio_asn1_element_s *elem,
                       char *buf,
                       size_t buf_len);
```

Parses an ASN.1 OID into a dot-separated string.

**Parameters:**
- `elem` - parsed element (must be OID type)
- `buf` - output buffer for string
- `buf_len` - buffer size

**Returns:** number of characters written (excluding NUL), or -1 on error.

Example:

```c
char oid_str[128];
int len = fio_asn1_parse_oid(&elem, oid_str, sizeof(oid_str));
if (len > 0) {
  printf("OID: %s\n", oid_str);  /* e.g., "1.2.840.113549.1.1.11" */
}
```

#### `fio_asn1_oid_eq`

```c
int fio_asn1_oid_eq(const fio_asn1_element_s *elem, const char *oid_string);
```

Compares an ASN.1 OID element to a known OID string.

**Parameters:**
- `elem` - parsed element (must be OID type)
- `oid_string` - OID in dot notation (e.g., "1.2.840.113549.1.1.11")

**Returns:** 1 if match, 0 if no match.

Example:

```c
if (fio_asn1_oid_eq(&elem, FIO_OID_SHA256_WITH_RSA)) {
  printf("Signature algorithm: SHA-256 with RSA\n");
}
```

#### `fio_asn1_parse_time`

```c
int fio_asn1_parse_time(const fio_asn1_element_s *elem, int64_t *unix_time);
```

Parses an ASN.1 time (UTC Time or Generalized Time) to Unix timestamp.

**Parameters:**
- `elem` - parsed element (must be UTC_TIME or GENERALIZED_TIME type)
- `unix_time` - output Unix timestamp (seconds since 1970-01-01 00:00:00 UTC)

**Returns:** 0 on success, -1 on error.

#### `fio_asn1_parse_string`

```c
const char *fio_asn1_parse_string(const fio_asn1_element_s *elem, size_t *len);
```

Parses an ASN.1 string element.

Supports UTF8String, PrintableString, IA5String, and other string types. Returns a pointer directly into the element data (no copy).

**Parameters:**
- `elem` - parsed element (must be a string type)
- `len` - output length of string

**Returns:** pointer to string data, or NULL on error.

#### `fio_asn1_parse_boolean`

```c
int fio_asn1_parse_boolean(const fio_asn1_element_s *elem, int *value);
```

Parses an ASN.1 BOOLEAN element.

**Parameters:**
- `elem` - parsed element (must be BOOLEAN type)
- `value` - output boolean value (0 = false, non-zero = true)

**Returns:** 0 on success, -1 on error.

### Sequence/Set Iteration

#### `fio_asn1_iterator_init`

```c
void fio_asn1_iterator_init(fio_asn1_iterator_s *it,
                            const fio_asn1_element_s *sequence);
```

Initializes an iterator for a SEQUENCE or SET element.

**Parameters:**
- `it` - iterator to initialize
- `sequence` - parsed element (must be SEQUENCE or SET)

#### `fio_asn1_iterator_next`

```c
int fio_asn1_iterator_next(fio_asn1_iterator_s *it, fio_asn1_element_s *elem);
```

Gets the next element from an iterator.

**Parameters:**
- `it` - iterator (updated to point to next element)
- `elem` - output for parsed element

**Returns:** 0 if element available, -1 if end or error.

#### `fio_asn1_iterator_has_next`

```c
int fio_asn1_iterator_has_next(const fio_asn1_iterator_s *it);
```

Checks if iterator has more elements.

**Parameters:**
- `it` - iterator

**Returns:** 1 if more elements available, 0 otherwise.

Example:

```c
fio_asn1_iterator_s it;
fio_asn1_element_s child;

fio_asn1_iterator_init(&it, &sequence_elem);
while (fio_asn1_iterator_next(&it, &child) == 0) {
  printf("Child tag: 0x%02X\n", child.tag);
}
```

### Helper Functions

#### `fio_asn1_is_tag`

```c
int fio_asn1_is_tag(const fio_asn1_element_s *elem, uint8_t tag);
```

Checks if an element is a specific tag type.

**Parameters:**
- `elem` - parsed element
- `tag` - expected tag (e.g., `FIO_ASN1_INTEGER`)

**Returns:** 1 if match, 0 otherwise.

#### `fio_asn1_is_context_tag`

```c
int fio_asn1_is_context_tag(const fio_asn1_element_s *elem, uint8_t tag_num);
```

Checks if an element is a context-specific tag.

**Parameters:**
- `elem` - parsed element
- `tag_num` - context tag number (0-31)

**Returns:** 1 if match, 0 otherwise.

Example:

```c
/* Check for X.509 version field [0] */
if (fio_asn1_is_context_tag(&elem, 0)) {
  /* Parse version number */
}
```

#### `fio_asn1_tag_number`

```c
uint8_t fio_asn1_tag_number(const fio_asn1_element_s *elem);
```

Gets the tag number from an element.

For universal tags, returns the tag value (0-30). For context-specific tags, returns the context number.

**Parameters:**
- `elem` - parsed element

**Returns:** tag number.

### Example: Parsing an X.509 Certificate

```c
#define FIO_ASN1
#include "fio-stl/include.h"

void parse_certificate(const uint8_t *der, size_t der_len) {
  fio_asn1_element_s cert_seq;
  
  /* Parse outer SEQUENCE */
  if (!fio_asn1_parse(&cert_seq, der, der_len)) {
    printf("Failed to parse certificate\n");
    return;
  }
  
  if (!fio_asn1_is_tag(&cert_seq, FIO_ASN1_SEQUENCE)) {
    printf("Not a valid certificate\n");
    return;
  }
  
  /* Iterate through certificate fields */
  fio_asn1_iterator_s it;
  fio_asn1_element_s tbs, sig_alg, sig_value;
  
  fio_asn1_iterator_init(&it, &cert_seq);
  
  /* TBSCertificate */
  if (fio_asn1_iterator_next(&it, &tbs) != 0) return;
  
  /* SignatureAlgorithm */
  if (fio_asn1_iterator_next(&it, &sig_alg) != 0) return;
  
  /* SignatureValue */
  if (fio_asn1_iterator_next(&it, &sig_value) != 0) return;
  
  printf("Certificate parsed successfully\n");
  printf("TBS length: %zu bytes\n", tbs.len);
}
```

------------------------------------------------------------
## RSA Signature Verification

```c
#define FIO_RSA
#include FIO_INCLUDE_FILE
```

By defining `FIO_RSA`, RSA signature verification functions are made available. This module provides verification-only operations for TLS 1.3 certificate chain validation.

**Supported Features:**
- PKCS#1 v1.5 signatures (sha256WithRSAEncryption, sha384WithRSAEncryption, sha512WithRSAEncryption)
- RSA-PSS signatures (required for TLS 1.3 CertificateVerify)
- Key sizes: 2048, 3072, 4096 bits

**Note**: This module is verification-only. No private key operations (signing, decryption) are supported.

**Note**: This implementation has not been audited. Use at your own risk for security-critical applications.

### Constants

```c
#define FIO_RSA_MAX_BITS  4096  /* Maximum RSA key size in bits */
#define FIO_RSA_MAX_BYTES 512   /* Maximum RSA key size in bytes */
```

### Types

#### `fio_rsa_hash_e`

```c
typedef enum {
  FIO_RSA_HASH_SHA256 = 0, /* SHA-256 (32 bytes) */
  FIO_RSA_HASH_SHA384 = 1, /* SHA-384 (48 bytes) */
  FIO_RSA_HASH_SHA512 = 2, /* SHA-512 (64 bytes) */
} fio_rsa_hash_e;
```

Hash algorithm identifiers for RSA verification.

#### `fio_rsa_pubkey_s`

```c
typedef struct {
  const uint8_t *n; /* Modulus (big-endian) */
  size_t n_len;     /* Modulus length in bytes */
  const uint8_t *e; /* Public exponent (big-endian) */
  size_t e_len;     /* Exponent length in bytes */
} fio_rsa_pubkey_s;
```

RSA public key for signature verification.

The modulus (n) and exponent (e) are stored as big-endian byte arrays, matching the DER encoding used in X.509 certificates.

**Members:**
- `n` - pointer to the RSA modulus in big-endian format
- `n_len` - length of the modulus in bytes (256 for 2048-bit, 384 for 3072-bit, 512 for 4096-bit)
- `e` - pointer to the public exponent in big-endian format (typically 65537 = 0x010001)
- `e_len` - length of the exponent in bytes

### Signature Verification Functions

#### `fio_rsa_verify_pkcs1`

```c
int fio_rsa_verify_pkcs1(const uint8_t *sig,
                         size_t sig_len,
                         const uint8_t *msg_hash,
                         size_t hash_len,
                         fio_rsa_hash_e hash_alg,
                         const fio_rsa_pubkey_s *key);
```

Verifies an RSA PKCS#1 v1.5 signature.

This verifies signatures with DigestInfo encoding as used in:
- sha256WithRSAEncryption (OID 1.2.840.113549.1.1.11)
- sha384WithRSAEncryption (OID 1.2.840.113549.1.1.12)
- sha512WithRSAEncryption (OID 1.2.840.113549.1.1.13)

**Parameters:**
- `sig` - signature bytes (same length as modulus)
- `sig_len` - signature length in bytes
- `msg_hash` - pre-computed hash of the message
- `hash_len` - hash length (32, 48, or 64 bytes)
- `hash_alg` - hash algorithm used (`FIO_RSA_HASH_SHA256`, etc.)
- `key` - RSA public key

**Returns:** 0 on success (valid signature), -1 on failure.

Example:

```c
/* Verify a PKCS#1 v1.5 signature */
fio_rsa_pubkey_s pubkey = {
  .n = modulus_bytes,
  .n_len = 256,  /* 2048-bit key */
  .e = exponent_bytes,
  .e_len = 3     /* 65537 = 0x010001 */
};

/* Hash the message first */
fio_u256 hash = fio_sha256(message, message_len);

/* Verify signature */
if (fio_rsa_verify_pkcs1(signature, 256, hash.u8, 32,
                         FIO_RSA_HASH_SHA256, &pubkey) == 0) {
  printf("Signature is valid\n");
} else {
  printf("Signature verification failed\n");
}
```

#### `fio_rsa_verify_pss`

```c
int fio_rsa_verify_pss(const uint8_t *sig,
                       size_t sig_len,
                       const uint8_t *msg_hash,
                       size_t hash_len,
                       fio_rsa_hash_e hash_alg,
                       const fio_rsa_pubkey_s *key);
```

Verifies an RSA-PSS signature (required for TLS 1.3).

RSA-PSS uses probabilistic padding and is the mandatory signature scheme for TLS 1.3 CertificateVerify messages with RSA keys.

This implementation uses:
- MGF1 with the same hash function
- Salt length = hash length (as required by TLS 1.3)
- Trailer field = 0xBC

**Parameters:**
- `sig` - signature bytes (same length as modulus)
- `sig_len` - signature length in bytes
- `msg_hash` - pre-computed hash of the message
- `hash_len` - hash length (32, 48, or 64 bytes)
- `hash_alg` - hash algorithm used
- `key` - RSA public key

**Returns:** 0 on success (valid signature), -1 on failure.

Example:

```c
/* Verify an RSA-PSS signature (TLS 1.3 CertificateVerify) */
fio_rsa_pubkey_s pubkey = {
  .n = cert->pubkey.rsa.n,
  .n_len = cert->pubkey.rsa.n_len,
  .e = cert->pubkey.rsa.e,
  .e_len = cert->pubkey.rsa.e_len
};

/* The message hash is computed over the TLS 1.3 signed content */
if (fio_rsa_verify_pss(signature, sig_len, content_hash, 32,
                       FIO_RSA_HASH_SHA256, &pubkey) == 0) {
  printf("RSA-PSS signature verified\n");
}
```

### Usage with X.509 Certificates

The RSA module is typically used together with the X.509 module for certificate verification:

```c
#define FIO_X509
#define FIO_RSA
#include "fio-stl/include.h"

int verify_certificate_signature(const fio_x509_cert_s *cert,
                                 const fio_x509_cert_s *issuer) {
  /* Check that issuer has an RSA key */
  if (issuer->key_type != FIO_X509_KEY_RSA)
    return -1;
  
  /* Build RSA public key from issuer certificate */
  fio_rsa_pubkey_s pubkey = {
    .n = issuer->pubkey.rsa.n,
    .n_len = issuer->pubkey.rsa.n_len,
    .e = issuer->pubkey.rsa.e,
    .e_len = issuer->pubkey.rsa.e_len
  };
  
  /* Hash the TBS (To-Be-Signed) certificate data */
  fio_u256 hash = fio_sha256(cert->tbs_data, cert->tbs_len);
  
  /* Verify based on signature algorithm */
  switch (cert->sig_alg) {
  case FIO_X509_SIG_RSA_PKCS1_SHA256:
    return fio_rsa_verify_pkcs1(cert->signature, cert->signature_len,
                                hash.u8, 32, FIO_RSA_HASH_SHA256, &pubkey);
  case FIO_X509_SIG_RSA_PSS_SHA256:
    return fio_rsa_verify_pss(cert->signature, cert->signature_len,
                              hash.u8, 32, FIO_RSA_HASH_SHA256, &pubkey);
  default:
    return -1;
  }
}
```

### Security Considerations

1. **Verification Only**: This module only supports signature verification. Private key operations are not implemented.

2. **Constant-Time Operations**: The implementation uses constant-time comparison for signature verification to prevent timing attacks.

3. **Key Size**: Only 2048-bit and larger keys are supported. Smaller keys are rejected as insecure.

4. **No Auditing**: This implementation has not undergone a formal security audit. For production use in security-critical applications, consider using a well-audited cryptographic library.

------------------------------------------------------------
## X.509 Certificate Parser

```c
#define FIO_X509
#include FIO_INCLUDE_FILE
```

By defining `FIO_X509`, an X.509v3 certificate parser is made available for TLS 1.3 certificate verification. This module provides parsing and validation capabilities for DER-encoded certificates.

**Supported Features:**
- RSA, ECDSA (P-256, P-384), and Ed25519 public keys
- Signature verification using issuer certificates
- Validity period checking
- Hostname matching (CN and SAN with wildcards)
- Basic constraints and key usage extensions
- Certificate chain validation
- Trust store management

**Note**: This is a minimal parser for TLS 1.3. Not all X.509 features are supported. The implementation is non-allocating (pointers into DER data).

### Types

#### `fio_x509_key_type_e`

```c
typedef enum {
  FIO_X509_KEY_UNKNOWN = 0,
  FIO_X509_KEY_RSA = 1,        /* RSA (any key size) */
  FIO_X509_KEY_ECDSA_P256 = 2, /* ECDSA with P-256/secp256r1 */
  FIO_X509_KEY_ECDSA_P384 = 3, /* ECDSA with P-384/secp384r1 */
  FIO_X509_KEY_ED25519 = 4,    /* Ed25519 (EdDSA) */
} fio_x509_key_type_e;
```

Public key algorithm types supported in certificates.

#### `fio_x509_sig_alg_e`

```c
typedef enum {
  FIO_X509_SIG_UNKNOWN = 0,
  FIO_X509_SIG_RSA_PKCS1_SHA256 = 1, /* sha256WithRSAEncryption */
  FIO_X509_SIG_RSA_PKCS1_SHA384 = 2, /* sha384WithRSAEncryption */
  FIO_X509_SIG_RSA_PKCS1_SHA512 = 3, /* sha512WithRSAEncryption */
  FIO_X509_SIG_RSA_PSS_SHA256 = 4,   /* RSA-PSS with SHA-256 */
  FIO_X509_SIG_RSA_PSS_SHA384 = 5,   /* RSA-PSS with SHA-384 */
  FIO_X509_SIG_RSA_PSS_SHA512 = 6,   /* RSA-PSS with SHA-512 */
  FIO_X509_SIG_ECDSA_SHA256 = 7,     /* ecdsa-with-SHA256 */
  FIO_X509_SIG_ECDSA_SHA384 = 8,     /* ecdsa-with-SHA384 */
  FIO_X509_SIG_ED25519 = 9,          /* Ed25519 */
} fio_x509_sig_alg_e;
```

Signature algorithm types used in certificate signatures.

#### `fio_x509_key_usage_e`

```c
typedef enum {
  FIO_X509_KU_DIGITAL_SIGNATURE = 0x0080, /* bit 0 = MSB of byte 0 */
  FIO_X509_KU_NON_REPUDIATION = 0x0040,   /* bit 1 */
  FIO_X509_KU_KEY_ENCIPHERMENT = 0x0020,  /* bit 2 */
  FIO_X509_KU_DATA_ENCIPHERMENT = 0x0010, /* bit 3 */
  FIO_X509_KU_KEY_AGREEMENT = 0x0008,     /* bit 4 */
  FIO_X509_KU_KEY_CERT_SIGN = 0x0004,     /* bit 5 */
  FIO_X509_KU_CRL_SIGN = 0x0002,          /* bit 6 */
  FIO_X509_KU_ENCIPHER_ONLY = 0x0001,     /* bit 7 */
  FIO_X509_KU_DECIPHER_ONLY = 0x8000,     /* bit 8 = MSB of byte 1 */
} fio_x509_key_usage_e;
```

Key Usage bit flags (RFC 5280 Section 4.2.1.3).

ASN.1 BIT STRING uses MSB-first bit ordering where bit 0 is the MSB of the first byte (0x80), bit 1 is 0x40, etc. Bits 8+ are in the second byte.

#### `fio_x509_error_e`

```c
typedef enum {
  FIO_X509_OK = 0,                     /* Validation successful */
  FIO_X509_ERR_PARSE = -1,             /* Failed to parse certificate */
  FIO_X509_ERR_EXPIRED = -2,           /* Certificate expired */
  FIO_X509_ERR_NOT_YET_VALID = -3,     /* Certificate not yet valid */
  FIO_X509_ERR_SIGNATURE = -4,         /* Signature verification failed */
  FIO_X509_ERR_ISSUER_MISMATCH = -5,   /* Issuer DN doesn't match subject DN */
  FIO_X509_ERR_NOT_CA = -6,            /* Issuer is not a CA certificate */
  FIO_X509_ERR_NO_TRUST_ANCHOR = -7,   /* Certificate not in trust store */
  FIO_X509_ERR_HOSTNAME_MISMATCH = -8, /* Hostname doesn't match cert */
  FIO_X509_ERR_EMPTY_CHAIN = -9,       /* Empty certificate chain */
  FIO_X509_ERR_CHAIN_TOO_LONG = -10,   /* Chain exceeds maximum depth */
} fio_x509_error_e;
```

Certificate chain validation error codes.

#### `fio_x509_trust_store_s`

```c
typedef struct {
  const uint8_t **roots;   /* Array of root CA certificate DER data */
  const size_t *root_lens; /* Array of root CA certificate lengths */
  size_t root_count;       /* Number of root CAs */
} fio_x509_trust_store_s;
```

Trust store for root CA certificates.

**Members:**
- `roots` - array of pointers to DER-encoded root CA certificates
- `root_lens` - array of lengths for each root certificate
- `root_count` - number of root CAs in the trust store

#### `fio_x509_cert_s`

```c
typedef struct {
  /* Certificate version (0=v1, 1=v2, 2=v3) */
  int version;

  /* Validity period (Unix timestamps) */
  int64_t not_before;
  int64_t not_after;

  /* Subject Distinguished Name (raw DER for comparison) */
  const uint8_t *subject_der;
  size_t subject_der_len;

  /* Issuer Distinguished Name (raw DER for comparison) */
  const uint8_t *issuer_der;
  size_t issuer_der_len;

  /* Subject Common Name (if present, pointer into DER data) */
  const char *subject_cn;
  size_t subject_cn_len;

  /* Public Key Type */
  fio_x509_key_type_e key_type;

  /* Public Key Data (union based on key_type) */
  union {
    struct {
      const uint8_t *n;  /* RSA modulus (big-endian) */
      size_t n_len;
      const uint8_t *e;  /* RSA exponent (big-endian) */
      size_t e_len;
    } rsa;
    struct {
      const uint8_t *point;  /* Uncompressed EC point (04 || x || y) */
      size_t point_len;
    } ecdsa;
    struct {
      const uint8_t *key;  /* 32-byte Ed25519 public key */
    } ed25519;
  } pubkey;

  /* Signature Algorithm */
  fio_x509_sig_alg_e sig_alg;

  /* Signature value (pointer into DER data) */
  const uint8_t *signature;
  size_t signature_len;

  /* TBS Certificate (for signature verification) */
  const uint8_t *tbs_data;
  size_t tbs_len;

  /* Basic Constraints: is CA */
  int is_ca;

  /* Key Usage extension present */
  int has_key_usage;
  /* Key Usage bits */
  uint16_t key_usage;

  /* Subject Alternative Name: first DNS name (if present) */
  const char *san_dns;
  size_t san_dns_len;
} fio_x509_cert_s;
```

Parsed X.509 certificate structure.

**Note**: All pointers reference the original DER data, which must remain valid while the certificate structure is in use.

### Certificate Parsing Functions

#### `fio_x509_parse`

```c
int fio_x509_parse(fio_x509_cert_s *cert,
                   const uint8_t *der_data,
                   size_t der_len);
```

Parses a DER-encoded X.509 certificate.

The cert structure will contain pointers into the original DER data, so the DER data must remain valid while the cert is in use.

**Parameters:**
- `cert` - output certificate structure (will be zeroed first)
- `der_data` - pointer to DER-encoded certificate
- `der_len` - length of DER data in bytes

**Returns:** 0 on success, -1 on error.

Example:

```c
fio_x509_cert_s cert;
if (fio_x509_parse(&cert, der_data, der_len) == 0) {
  printf("Subject CN: %.*s\n", (int)cert.subject_cn_len, cert.subject_cn);
  printf("Key type: %d\n", cert.key_type);
  printf("Is CA: %s\n", cert.is_ca ? "yes" : "no");
}
```

#### `fio_x509_verify_signature`

```c
int fio_x509_verify_signature(const fio_x509_cert_s *cert,
                              const fio_x509_cert_s *issuer);
```

Verifies certificate signature using issuer's public key.

This verifies that the certificate was signed by the issuer.

**Parameters:**
- `cert` - certificate to verify
- `issuer` - certificate of the issuer (contains the public key)

**Returns:** 0 if valid, -1 if invalid or error.

**Note**: Requires `FIO_RSA` module for RSA signatures and `FIO_ED25519` for Ed25519 signatures.

#### `fio_x509_check_validity`

```c
int fio_x509_check_validity(const fio_x509_cert_s *cert, int64_t current_time);
```

Checks if certificate is currently valid (not expired, not yet valid).

**Parameters:**
- `cert` - certificate to check
- `current_time` - current Unix timestamp (seconds since epoch)

**Returns:** 0 if valid, -1 if expired or not yet valid.

#### `fio_x509_match_hostname`

```c
int fio_x509_match_hostname(const fio_x509_cert_s *cert,
                            const char *hostname,
                            size_t hostname_len);
```

Checks if hostname matches certificate (CN or SAN).

Supports wildcard matching (*.example.com). Per RFC 6125, wildcards only match one label.

**Parameters:**
- `cert` - certificate to check
- `hostname` - hostname to match
- `hostname_len` - length of hostname

**Returns:** 0 if match, -1 if no match.

Example:

```c
if (fio_x509_match_hostname(&cert, "www.example.com", 15) == 0) {
  printf("Hostname matches certificate\n");
}
```

#### `fio_x509_dn_equals`

```c
int fio_x509_dn_equals(const uint8_t *dn1, size_t dn1_len,
                       const uint8_t *dn2, size_t dn2_len);
```

Compares two Distinguished Names for equality.

Used for checking if issuer DN matches subject DN.

**Parameters:**
- `dn1` - first DN (DER-encoded)
- `dn1_len` - length of first DN
- `dn2` - second DN (DER-encoded)
- `dn2_len` - length of second DN

**Returns:** 0 if equal, non-zero if different.

### Certificate Chain Validation

#### `fio_x509_verify_chain`

```c
int fio_x509_verify_chain(const uint8_t **certs,
                          const size_t *cert_lens,
                          size_t cert_count,
                          const char *hostname,
                          int64_t current_time,
                          fio_x509_trust_store_s *trust_store);
```

Validates a certificate chain for TLS 1.3.

The chain should be ordered from end-entity to closest-to-root:
- `certs[0]` = server's certificate (end-entity)
- `certs[1]` = intermediate CA (signed certs[0])
- `certs[n-1]` = closest to root (may be root or intermediate)

**Validation performs:**
1. Parse all certificates
2. Check validity period for all certificates
3. Verify hostname matches end-entity certificate (if hostname provided)
4. Verify each certificate's signature using the next certificate's key
5. Verify issuer DNs match subject DNs in the chain
6. Verify intermediate/root certificates have CA:TRUE
7. Verify the chain terminates at a trusted root (if trust store provided)

**Parameters:**
- `certs` - array of DER-encoded certificates
- `cert_lens` - array of certificate lengths
- `cert_count` - number of certificates in chain
- `hostname` - expected hostname for end-entity (NULL to skip check)
- `current_time` - current Unix timestamp for validity checking
- `trust_store` - root CA certificates (NULL to skip trust check)

**Returns:** `FIO_X509_OK` (0) on success, or error code on failure.

Example:

```c
/* Set up trust store with root CAs */
const uint8_t *roots[] = { root_ca_der };
const size_t root_lens[] = { root_ca_len };
fio_x509_trust_store_s trust_store = {
  .roots = roots,
  .root_lens = root_lens,
  .root_count = 1
};

/* Verify certificate chain */
int result = fio_x509_verify_chain(
  cert_chain, cert_lens, cert_count,
  "www.example.com",
  time(NULL),
  &trust_store
);

if (result == FIO_X509_OK) {
  printf("Certificate chain is valid\n");
} else {
  printf("Validation failed: %s\n", fio_x509_error_str(result));
}
```

#### `fio_x509_is_trusted`

```c
int fio_x509_is_trusted(const fio_x509_cert_s *cert,
                        fio_x509_trust_store_s *trust_store);
```

Checks if a certificate is in the trust store.

Comparison is done by matching subject DN.

**Parameters:**
- `cert` - certificate to check
- `trust_store` - trust store to search

**Returns:** 0 if trusted, -1 if not found.

#### `fio_x509_error_str`

```c
const char *fio_x509_error_str(int error);
```

Gets human-readable error string for X.509 validation error code.

**Parameters:**
- `error` - error code from `fio_x509_verify_chain`

**Returns:** static string describing the error.

### TLS Certificate Message Parsing

#### `fio_tls_cert_entry_s`

```c
typedef struct {
  const uint8_t *cert; /* DER-encoded certificate data */
  size_t cert_len;     /* Certificate length */
} fio_tls_cert_entry_s;
```

TLS certificate entry (parsed from Certificate message).

#### `fio_tls_parse_certificate_message`

```c
int fio_tls_parse_certificate_message(fio_tls_cert_entry_s *entries,
                                      size_t max_entries,
                                      const uint8_t *data,
                                      size_t data_len);
```

Parses TLS 1.3 Certificate message into individual certificates.

**Parameters:**
- `entries` - output array for certificate entries
- `max_entries` - maximum entries to parse
- `data` - raw Certificate message data (after handshake header)
- `data_len` - length of Certificate message data

**Returns:** number of certificates parsed, or -1 on error.

### Complete Example

```c
#define FIO_X509
#define FIO_RSA
#define FIO_ASN1
#include "fio-stl/include.h"

int verify_server_certificate(const uint8_t **chain, const size_t *lens,
                              size_t count, const char *hostname) {
  /* Set up trust store (in practice, load from system or file) */
  fio_x509_trust_store_s trust_store = {
    .roots = trusted_roots,
    .root_lens = trusted_root_lens,
    .root_count = trusted_root_count
  };
  
  /* Get current time */
  int64_t now = (int64_t)time(NULL);
  
  /* Verify the chain */
  int result = fio_x509_verify_chain(chain, lens, count,
                                     hostname, now, &trust_store);
  
  if (result != FIO_X509_OK) {
    fprintf(stderr, "Certificate verification failed: %s\n",
            fio_x509_error_str(result));
    return -1;
  }
  
  printf("Certificate chain verified successfully\n");
  
  /* Optionally, extract information from the end-entity certificate */
  fio_x509_cert_s cert;
  if (fio_x509_parse(&cert, chain[0], lens[0]) == 0) {
    printf("Server: %.*s\n", (int)cert.subject_cn_len, cert.subject_cn);
    printf("Valid until: %lld\n", (long long)cert.not_after);
  }
  
  return 0;
}
```

------------------------------------------------------------
## ML-KEM-768

```c
#define FIO_MLKEM
#include FIO_INCLUDE_FILE
```

By defining `FIO_MLKEM`, the ML-KEM-768 post-quantum key encapsulation mechanism and the X25519MLKEM768 hybrid key exchange are defined and made available.

ML-KEM (Module-Lattice-Based Key-Encapsulation Mechanism) is standardized in [FIPS 203](https://csrc.nist.gov/publications/detail/fips/203/final). ML-KEM-768 provides 192-bit security against both classical and quantum adversaries.

This module also provides X25519MLKEM768, the hybrid key exchange combining classical X25519 with post-quantum ML-KEM-768, as specified in [draft-ietf-tls-ecdhe-mlkem](https://datatracker.ietf.org/doc/draft-ietf-tls-ecdhe-mlkem/) for TLS 1.3 (NamedGroup 0x11ec).

**Warning**: this implementation has not been audited. Use at your own risk.

**Note**: X25519MLKEM768 requires `FIO_ED25519` for X25519 support.

### ML-KEM-768 Constants

#### `FIO_MLKEM768_PUBLICKEYBYTES`

```c
#define FIO_MLKEM768_PUBLICKEYBYTES  1184
```

Size of an ML-KEM-768 public (encapsulation) key in bytes.

#### `FIO_MLKEM768_SECRETKEYBYTES`

```c
#define FIO_MLKEM768_SECRETKEYBYTES  2400
```

Size of an ML-KEM-768 secret (decapsulation) key in bytes.

#### `FIO_MLKEM768_CIPHERTEXTBYTES`

```c
#define FIO_MLKEM768_CIPHERTEXTBYTES 1088
```

Size of an ML-KEM-768 ciphertext in bytes.

#### `FIO_MLKEM768_SSBYTES`

```c
#define FIO_MLKEM768_SSBYTES         32
```

Size of the ML-KEM-768 shared secret in bytes.

### ML-KEM-768 Functions

#### `fio_mlkem768_keypair`

```c
int fio_mlkem768_keypair(uint8_t pk[1184], uint8_t sk[2400]);
```

Generates an ML-KEM-768 keypair using the system CSPRNG.

**Parameters:**
- `pk` - output buffer for the public key (1184 bytes)
- `sk` - output buffer for the secret key (2400 bytes)

**Returns:** 0 on success, -1 on failure.

#### `fio_mlkem768_keypair_derand`

```c
int fio_mlkem768_keypair_derand(uint8_t pk[1184],
                                uint8_t sk[2400],
                                const uint8_t coins[64]);
```

Generates an ML-KEM-768 keypair from a deterministic 64-byte seed.

This function is primarily useful for testing with known test vectors (e.g., NIST ACVP vectors). For production use, prefer `fio_mlkem768_keypair`.

**Parameters:**
- `pk` - output buffer for the public key (1184 bytes)
- `sk` - output buffer for the secret key (2400 bytes)
- `coins` - deterministic seed: 32 bytes of `d` followed by 32 bytes of `z`

**Returns:** 0 on success, -1 on failure.

#### `fio_mlkem768_encaps`

```c
int fio_mlkem768_encaps(uint8_t ct[1088],
                        uint8_t ss[32],
                        const uint8_t pk[1184]);
```

Encapsulates a shared secret using the recipient's public key.

Generates a random shared secret and encrypts it into a ciphertext that only the holder of the corresponding secret key can decapsulate.

**Parameters:**
- `ct` - output buffer for the ciphertext (1088 bytes)
- `ss` - output buffer for the shared secret (32 bytes)
- `pk` - the recipient's public key (1184 bytes)

**Returns:** 0 on success, -1 on failure.

#### `fio_mlkem768_encaps_derand`

```c
int fio_mlkem768_encaps_derand(uint8_t ct[1088],
                               uint8_t ss[32],
                               const uint8_t pk[1184],
                               const uint8_t coins[32]);
```

Encapsulates with deterministic randomness. Primarily for testing with known test vectors.

**Parameters:**
- `ct` - output buffer for the ciphertext (1088 bytes)
- `ss` - output buffer for the shared secret (32 bytes)
- `pk` - the recipient's public key (1184 bytes)
- `coins` - deterministic 32-byte randomness

**Returns:** 0 on success, -1 on failure.

#### `fio_mlkem768_decaps`

```c
int fio_mlkem768_decaps(uint8_t ss[32],
                        const uint8_t ct[1088],
                        const uint8_t sk[2400]);
```

Decapsulates a ciphertext to recover the shared secret.

Uses **implicit rejection**: if the ciphertext is invalid, a pseudorandom shared secret is returned (derived from the secret key and ciphertext) rather than an error. This prevents chosen-ciphertext attacks  the caller cannot distinguish valid from invalid ciphertexts.

**Parameters:**
- `ss` - output buffer for the shared secret (32 bytes)
- `ct` - the ciphertext to decapsulate (1088 bytes)
- `sk` - the secret key (2400 bytes)

**Returns:** 0 (always succeeds for well-formed inputs).

### ML-KEM-768 Example

```c
#define FIO_MLKEM
#include FIO_INCLUDE_FILE

void example_mlkem768(void) {
  uint8_t pk[1184], sk[2400];
  uint8_t ct[1088];
  uint8_t ss_enc[32], ss_dec[32];

  /* Generate keypair */
  fio_mlkem768_keypair(pk, sk);

  /* Encapsulate (sender side) */
  fio_mlkem768_encaps(ct, ss_enc, pk);
  /* ss_enc is the shared secret; ct is sent to the recipient */

  /* Decapsulate (recipient side) */
  fio_mlkem768_decaps(ss_dec, ct, sk);
  /* ss_dec == ss_enc (both parties now share the same secret) */
}
```

### X25519MLKEM768 Hybrid Key Exchange

X25519MLKEM768 combines classical X25519 (Curve25519 Diffie-Hellman) with post-quantum ML-KEM-768 to provide security against both classical and quantum adversaries. If either component remains secure, the combined key exchange is secure.

This is the hybrid key exchange specified for TLS 1.3 in [draft-ietf-tls-ecdhe-mlkem](https://datatracker.ietf.org/doc/draft-ietf-tls-ecdhe-mlkem/) (NamedGroup 0x11ec).

**Note**: the group name "X25519MLKEM768" does NOT reflect the concatenation order. The ML-KEM component comes FIRST in all concatenations (per Section 4 of the draft).

### X25519MLKEM768 Constants

#### `FIO_X25519MLKEM768_PUBLICKEYBYTES`

```c
#define FIO_X25519MLKEM768_PUBLICKEYBYTES  1216 /* ML-KEM-768_ek (1184) + X25519_pk (32) */
```

Size of an X25519MLKEM768 hybrid public key in bytes.

#### `FIO_X25519MLKEM768_SECRETKEYBYTES`

```c
#define FIO_X25519MLKEM768_SECRETKEYBYTES  2432 /* ML-KEM-768_dk (2400) + X25519_sk (32) */
```

Size of an X25519MLKEM768 hybrid secret key in bytes.

#### `FIO_X25519MLKEM768_CIPHERTEXTBYTES`

```c
#define FIO_X25519MLKEM768_CIPHERTEXTBYTES 1120 /* ML-KEM-768_ct (1088) + X25519_ephemeral_pk (32) */
```

Size of an X25519MLKEM768 hybrid ciphertext in bytes.

#### `FIO_X25519MLKEM768_SSBYTES`

```c
#define FIO_X25519MLKEM768_SSBYTES         64   /* ML-KEM-768_ss (32) + X25519_ss (32) */
```

Size of the X25519MLKEM768 hybrid shared secret in bytes.

### X25519MLKEM768 Key Format

| Component | Public Key | Secret Key | Ciphertext | Shared Secret |
|-----------|-----------|-----------|-----------|--------------|
| ML-KEM-768 | 1184 bytes (first) | 2400 bytes (first) | 1088 bytes (first) | 32 bytes (first) |
| X25519 | 32 bytes (last) | 32 bytes (last) | 32 bytes (last) | 32 bytes (last) |
| **Total** | **1216 bytes** | **2432 bytes** | **1120 bytes** | **64 bytes** |

### X25519MLKEM768 Functions

#### `fio_x25519mlkem768_keypair`

```c
int fio_x25519mlkem768_keypair(uint8_t pk[1216], uint8_t sk[2432]);
```

Generates an X25519MLKEM768 hybrid keypair using the system CSPRNG.

Generates both an X25519 keypair and an ML-KEM-768 keypair. The public key is `ML-KEM-768_ek (1184) || X25519_pk (32)`. The secret key is `ML-KEM-768_dk (2400) || X25519_sk (32)`.

**Parameters:**
- `pk` - output buffer for the hybrid public key (1216 bytes)
- `sk` - output buffer for the hybrid secret key (2432 bytes)

**Returns:** 0 on success, -1 on failure.

#### `fio_x25519mlkem768_encaps`

```c
int fio_x25519mlkem768_encaps(uint8_t ct[1120],
                              uint8_t ss[64],
                              const uint8_t pk[1216]);
```

Performs X25519MLKEM768 hybrid encapsulation.

Performs both X25519 key exchange and ML-KEM-768 encapsulation against the recipient's hybrid public key. The ciphertext is `ML-KEM-768_ct (1088) || X25519_ephemeral_pk (32)`. The shared secret is `ML-KEM-768_ss (32) || X25519_ss (32)`.

**Parameters:**
- `ct` - output buffer for the hybrid ciphertext (1120 bytes)
- `ss` - output buffer for the hybrid shared secret (64 bytes)
- `pk` - the recipient's hybrid public key (1216 bytes)

**Returns:** 0 on success, -1 on failure.

#### `fio_x25519mlkem768_decaps`

```c
int fio_x25519mlkem768_decaps(uint8_t ss[64],
                              const uint8_t ct[1120],
                              const uint8_t sk[2432]);
```

Performs X25519MLKEM768 hybrid decapsulation.

Performs both X25519 shared secret derivation and ML-KEM-768 decapsulation. The shared secret is `ML-KEM-768_ss (32) || X25519_ss (32)`.

**Parameters:**
- `ss` - output buffer for the hybrid shared secret (64 bytes)
- `ct` - the hybrid ciphertext (1120 bytes)
- `sk` - the hybrid secret key (2432 bytes)

**Returns:** 0 on success, -1 if X25519 shared secret computation fails (low-order point). ML-KEM-768 uses implicit rejection for invalid ciphertexts.

### X25519MLKEM768 Example

```c
#define FIO_ED25519 /* Required for X25519 */
#define FIO_MLKEM
#include FIO_INCLUDE_FILE

void example_hybrid(void) {
  uint8_t pk[1216], sk[2432];
  uint8_t ct[1120];
  uint8_t ss_enc[64], ss_dec[64];

  /* Generate hybrid keypair (server side) */
  fio_x25519mlkem768_keypair(pk, sk);

  /* Encapsulate (client side) */
  fio_x25519mlkem768_encaps(ct, ss_enc, pk);
  /* ss_enc[0..63] is the 64-byte hybrid shared secret */
  /* ct[0..1119] is sent to the server */

  /* Decapsulate (server side) */
  fio_x25519mlkem768_decaps(ss_dec, ct, sk);
  /* ss_dec == ss_enc (both parties share the same 64-byte secret) */
  /* Typically fed into a KDF (e.g., HKDF) for key derivation */
}
```

### ML-KEM-768 Parameters

| Parameter | Value | Description |
|-----------|-------|-------------|
| n | 256 | Polynomial degree |
| k | 3 | Module rank (number of polynomials) |
| q | 3329 | Modulus |
| eta1 | 2 | Noise parameter for key generation |
| eta2 | 2 | Noise parameter for encryption |
| d_u | 10 | Compression bits for ciphertext vector |
| d_v | 4 | Compression bits for ciphertext scalar |

### Browser and Server Support

X25519MLKEM768 (TLS NamedGroup 0x11ec) is supported by:
- Chrome 131+
- Firefox 132+
- Safari / iOS 26+
- ~8.6% of top 1M websites (as of early 2026)

-------------------------------------------------------------------------------
## Lyra2

```c
#define FIO_LYRA2
#include FIO_INCLUDE_FILE
```

By defining `FIO_LYRA2`, the Lyra2 memory-hard password hashing function is defined and made available.

Lyra2 is a memory-hard password hashing scheme that uses a sponge construction with Blake2b as the underlying permutation. It provides configurable time and memory costs for resistance against GPU/ASIC attacks.

This implementation matches the [reference C implementation](https://github.com/leocalm/Lyra) with `nPARALLEL==1`, `SPONGE==0` (Blake2b), and `RHO==1`.

**Note**: when comparing Lyra2 output hashes, use `fio_ct_is_eq` for constant-time comparison to avoid timing side-channel attacks.

### Lyra2 Functions

#### `fio_lyra2`

```c
fio_u512 fio_lyra2(fio_lyra2_args_s args);
/* Named arguments using macro. */
#define fio_lyra2(...) fio_lyra2((fio_lyra2_args_s){__VA_ARGS__})

typedef struct {
  /** The password to hash. */
  fio_buf_info_s password;
  /** The salt for the hash. */
  fio_buf_info_s salt;
  /** Time cost (number of rounds, minimum 1). */
  uint64_t t_cost;
  /** Memory cost (number of rows in the matrix, minimum 3). */
  uint64_t m_cost;
  /** Desired output length in bytes (default 32 if 0). */
  size_t outlen;
  /** Number of columns (default 256 if 0). */
  size_t n_cols;
} fio_lyra2_args_s;
```

Computes a Lyra2 password hash.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_u512 hash = fio_lyra2(
    .password = FIO_BUF_INFO1("my-password"),
    .salt = FIO_BUF_INFO1("random-salt"),
    .t_cost = 3,
    .m_cost = 1024);
/* hash.u8[0..31] contains the 32-byte password hash */
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `password` | `fio_buf_info_s` | The password to hash |
| `salt` | `fio_buf_info_s` | Salt / nonce (should be random) |
| `t_cost` | `uint64_t` | Time cost / number of rounds (minimum 1) |
| `m_cost` | `uint64_t` | Memory cost / number of matrix rows (minimum 3) |
| `outlen` | `size_t` | Output length in bytes (default 32 if 0) |
| `n_cols` | `size_t` | Number of matrix columns (default 256 if 0) |

**Returns:** a `fio_u512` containing the password hash. Only the first `outlen` bytes are valid (default 32). For output lengths greater than 64 bytes, use `fio_lyra2_hash` instead.

#### `fio_lyra2_hash`

```c
int fio_lyra2_hash(void *out, fio_lyra2_args_s args);
/* Named arguments using macro. */
#define fio_lyra2_hash(out, ...) fio_lyra2_hash(out, (fio_lyra2_args_s){__VA_ARGS__})
```

Computes a Lyra2 password hash into a caller-provided buffer.

Supports arbitrary output lengths. Use this instead of `fio_lyra2` when the desired output length exceeds 64 bytes.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
uint8_t hash[128];
int r = fio_lyra2_hash(hash,
    .password = FIO_BUF_INFO1("my-password"),
    .salt = FIO_BUF_INFO1("random-salt"),
    .t_cost = 3,
    .m_cost = 1024,
    .outlen = 128);
```

**Parameters:**
- `out` - destination buffer (must have capacity for at least `outlen` bytes)
- Named arguments are the same as `fio_lyra2` (see table above)

**Returns:** 0 on success, -1 on error.

### Lyra2 Example

```c
#define FIO_LYRA2
#include FIO_INCLUDE_FILE

void example_lyra2(void) {
  fio_u512 hash = fio_lyra2(
      .password = FIO_BUF_INFO1("user-password"),
      .salt = FIO_BUF_INFO1("unique-random-salt"),
      .t_cost = 3,
      .m_cost = 1024);

  /* Verify: recompute and compare in constant time */
  fio_u512 verify = fio_lyra2(
      .password = FIO_BUF_INFO1("user-password"),
      .salt = FIO_BUF_INFO1("unique-random-salt"),
      .t_cost = 3,
      .m_cost = 1024);

  if (fio_ct_is_eq(hash.u8, verify.u8, 32))
    printf("Password matches!\n");
}
```

-------------------------------------------------------------------------------
## OTP

```c
#define FIO_OTP
#include FIO_INCLUDE_FILE
```

By defining the `FIO_OTP`, a small T-OTP (Time based One Time Password) helper API will be provided. This requires the `FIO_SHA1` and `FIO_STR` modules.

### OTP Settings

#### `fio_otp_settings_s`

```c
typedef struct {
  /** The time interval for TOTP rotation. */
  size_t interval; /* 30 == Google OTP */
  /** The number of digits in the OTP. */
  size_t digits; /* 6 == Google OTP */
  /** The time offset (in `interval` units) from the current time. */
  int64_t offset; /* 0 == Google OTP */
  /** Set to true if the secret / key is in Hex instead of Byte32 encoding. */
  uint8_t is_hex;
  /** Set to true if the secret / key is raw bit data (no encoding). */
  uint8_t is_raw;
} fio_otp_settings_s;
```

Settings structure for OTP generation.

**Members:**
- `interval` - The time interval for TOTP rotation (defaults to 30 seconds for Google OTP compatibility)
- `digits` - The number of digits in the OTP (defaults to 6 for Google OTP compatibility)
- `offset` - The time offset in `interval` units from the current time (defaults to 0 for current time)
- `is_hex` - Set to true if the secret/key is in Hex encoding instead of Base32 encoding
- `is_raw` - Set to true if the secret/key is raw bit data (no encoding)

### OTP API

#### `fio_otp_generate_key`

```c
fio_u128 fio_otp_generate_key(void);
```

Generates a cryptographically secure random 128 bit key for TOTP processing.

Uses system CSPRNG via `fio_rand_bytes_secure()`. Random keys may be required when generating a new OTP secret for possible logins.

**Returns:** A 128-bit random key suitable for TOTP secrets.

#### `fio_otp_print_key`

```c
size_t fio_otp_print_key(char *dest, uint8_t *key, size_t len);
```

Prints out an OTP secret (big endian number) as a Base32 encoded String.

Printing out the OTP secret can be important when providing it to authentication apps.

**Parameters:**
- `dest` - destination buffer for the Base32 encoded string
- `key` - pointer to the key bytes (if NULL, generates a new key)
- `len` - length of the key in bytes

**Returns:** The length of the encoded string written to `dest`.

#### `fio_otp`

```c
uint32_t fio_otp(fio_buf_info_s secret, fio_otp_settings_s settings);
/* Named arguments using macro. */
#define fio_otp(secret, ...) fio_otp(secret, (fio_otp_settings_s){__VA_ARGS__})
```

Returns a TOTP based on `secret` and the OTP settings using the current time.

This can be used to either validate an existing TOTP or generate a new one.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
uint32_t totp_now = fio_otp(FIO_BUF_INFO1("My Secret"), .offset = 0);
uint32_t previous = fio_otp(FIO_BUF_INFO1("My Secret"), .offset = -1);
```

**Parameters:**
- `secret` - the shared secret key as a `fio_buf_info_s`

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `interval` | `size_t` | Time interval for rotation; defaults to 30 |
| `digits` | `size_t` | Number of digits in OTP; defaults to 6 |
| `offset` | `int64_t` | Time offset in interval units; defaults to 0 |
| `is_hex` | `uint8_t` | Set true if secret is Hex encoded |
| `is_raw` | `uint8_t` | Set true if secret is raw bit data |

**Returns:** The computed TOTP value as a `uint32_t`.

#### `fio_otp_at`

```c
uint32_t fio_otp_at(fio_buf_info_s secret, uint64_t unix_time, fio_otp_settings_s settings);
/* Named arguments using macro. */
#define fio_otp_at(secret, unix_time, ...)                                     \
  fio_otp_at(secret, unix_time, (fio_otp_settings_s){__VA_ARGS__})
```

Returns a TOTP for a specific unix timestamp.

This is useful for verifying OTPs at specific times or for RFC test vectors.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
/* Compute OTP at a specific timestamp */
uint32_t otp = fio_otp_at(FIO_BUF_INFO1("My Secret"), 1234567890);
```

**Parameters:**
- `secret` - the shared secret key as a `fio_buf_info_s`
- `unix_time` - the unix timestamp to compute the OTP for

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `interval` | `size_t` | Time interval for rotation; defaults to 30 |
| `digits` | `size_t` | Number of digits in OTP; defaults to 6 |
| `offset` | `int64_t` | Time offset in interval units; defaults to 0 |
| `is_hex` | `uint8_t` | Set true if secret is Hex encoded |
| `is_raw` | `uint8_t` | Set true if secret is raw bit data |

**Returns:** The computed TOTP value as a `uint32_t`.

-------------------------------------------------------------------------------
## Secrets

```c
#define FIO_SECRET
#include FIO_INCLUDE_FILE
```

By defining the `FIO_SECRET`, a small secret helper API will be provided. This requires the `FIO_SHA2` and `FIO_ATOL` modules.

### Keeping Secrets

Secrets should be kept secret. 

Secrets should **not** be kept in source files, which too often end up exposed.

Secrets should **not** be logged (such as in case of a crash or a core dump).

Additionally, secrets should **not** be used directly if possible. It is better to use a hashed value of the secret, possibly with some time based salt or spice. This way, if somehow information leaks regarding the secret, what is exposed is actually the hashed value and not the secret itself.

For this reason, the most common place to place a secret is as a hashed value in the OS environment (often as a Hex encoded String).

**Note**: some secrets, such as TLS certificates, are often stored as system files somewhere separate from the source code.

### Environment Variables

The module automatically initializes the global secret from environment variables at startup:

- `SECRET` - The secret value (can be Hex encoded or plain text)
- `SECRET_LENGTH` - Optional; specifies the length of the secret. If not provided, `strlen` is used.

If no `SECRET` environment variable is set, a random secret is generated.

### Secret API

To help with managing a program wide secret, the following helper functions are defined:

#### `fio_secret_is_random`

```c
bool fio_secret_is_random(void);
```

Returns true if the secret was randomly generated.

#### `fio_secret`

```c
fio_u512 fio_secret(void);
```

Gets the SHA512 of a (possibly shared) secret.

Unless updated using `fio_secret_set`, this is either a random secret or the one derived from the `SECRET` environment variable.

Please store the returned value on the stack or not at all. The secret is stored masked in memory and unmasked copies should be temporary with short life-spans.

#### `fio_secret_set`

```c
void fio_secret_set(char *str, size_t len, bool is_random);
```

Sets a (possibly shared) secret and stores its SHA512 hash.

**Parameters:**
- `str` - the secret string (can be Hex encoded or plain text)
- `len` - the length of the secret string
- `is_random` - set to `true` if this is a randomly generated secret

If `str` is Hex encoded, it will be decoded before it is hashed and white spaces will be ignored.

If `str` is `NULL` or `len` is `0`, a random secret will be generated and `is_random` will be set to `true`.

**Note**: the SHA512 hash is masked before it is stored, so that the final secret isn't logged in case of a core dump.

#### `fio_secret_set_at`

```c
void fio_secret_set_at(fio_u512 *secret, char *str, size_t len);
```

Sets a (possibly shared) secret and stores its (masked) SHA512 hash in `secret`.

**Parameters:**
- `secret` - pointer to a `fio_u512` where the masked hash will be stored
- `str` - the secret string (can be Hex encoded or plain text)
- `len` - the length of the secret string

If `str` is Hex encoded, it will be decoded before it is hashed and white spaces will be ignored.

If `str` is `NULL` or `len` is `0`, a random secret will be generated.

**Note**: the SHA512 hash in `secret` is masked before it is stored, so that the final secret isn't logged in case of a core dump.

#### `fio_secret_at`

```c
fio_u512 fio_secret_at(fio_u512 *secret);
```

Gets the SHA512 of a (possibly shared) masked secret stored in `secret`.

**Parameters:**
- `secret` - pointer to a `fio_u512` containing the masked secret

**Returns:** the unmasked SHA512 hash of the secret.

Please store the returned value on the stack or not at all. The secret is stored masked in memory and unmasked copies should be temporary with short life-spans.

-------------------------------------------------------------------------------
## Argon2

```c
#define FIO_ARGON2
#include FIO_INCLUDE_FILE
```

By defining `FIO_ARGON2`, the Argon2 memory-hard password hashing function is defined and made available.

Argon2 is standardized in [RFC 9106](https://www.rfc-editor.org/rfc/rfc9106) and is the winner of the Password Hashing Competition (PHC). It provides resistance against GPU/ASIC attacks through configurable memory and time costs.

This implementation supports all three variants:

- **Argon2d** - data-dependent memory access (fastest, vulnerable to side-channel attacks)
- **Argon2i** - data-independent memory access (resistant to side-channel attacks)
- **Argon2id** - hybrid (recommended for password hashing)

Uses BLAKE2b as the underlying hash function. Single-threaded: the parallelism parameter affects memory layout but lanes are processed sequentially.

**Note**: when comparing Argon2 output hashes, use `fio_ct_is_eq` for constant-time comparison to avoid timing side-channel attacks.

### Argon2 Types

#### `fio_argon2_type_e`

```c
typedef enum {
  FIO_ARGON2D  = 0,  /* Data-dependent (fastest, side-channel vulnerable) */
  FIO_ARGON2I  = 1,  /* Data-independent (side-channel resistant) */
  FIO_ARGON2ID = 2,  /* Hybrid (recommended) */
} fio_argon2_type_e;
```

Selects the Argon2 variant.

- `FIO_ARGON2D` - uses data-dependent memory access patterns; fastest but vulnerable to side-channel attacks. Use for cryptocurrency proof-of-work.
- `FIO_ARGON2I` - uses data-independent memory access patterns; resistant to side-channel attacks. Use when side-channel resistance is critical.
- `FIO_ARGON2ID` - hybrid: first pass uses data-independent access, subsequent passes use data-dependent. **Recommended for password hashing.**

### Argon2 Functions

#### `fio_argon2`

```c
fio_u512 fio_argon2(fio_argon2_args_s args);
/* Named arguments using macro. */
#define fio_argon2(...) fio_argon2((fio_argon2_args_s){__VA_ARGS__})

typedef struct {
  /** The password (message P). */
  fio_buf_info_s password;
  /** The salt (nonce S). */
  fio_buf_info_s salt;
  /** Optional secret key K. */
  fio_buf_info_s secret;
  /** Optional associated data X. */
  fio_buf_info_s ad;
  /** Time cost (number of passes t, minimum 1). */
  uint32_t t_cost;
  /** Memory cost in KiB (minimum 8*parallelism). */
  uint32_t m_cost;
  /** Degree of parallelism (number of lanes, minimum 1). */
  uint32_t parallelism;
  /** Desired output (tag) length in bytes (minimum 4, default 32). */
  uint32_t outlen;
  /** Argon2 variant: FIO_ARGON2D, FIO_ARGON2I, or FIO_ARGON2ID. */
  fio_argon2_type_e type;
} fio_argon2_args_s;
```

Computes an Argon2 password hash (RFC 9106).

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_u512 hash = fio_argon2(
    .password = FIO_BUF_INFO1("my-password"),
    .salt = FIO_BUF_INFO1("random-salt"),
    .t_cost = 3,
    .m_cost = 65536,     /* 64 MiB */
    .parallelism = 4,
    .type = FIO_ARGON2ID);
/* hash.u8[0..31] contains the 32-byte password hash */
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `password` | `fio_buf_info_s` | The password to hash |
| `salt` | `fio_buf_info_s` | Salt / nonce (should be random, at least 16 bytes) |
| `secret` | `fio_buf_info_s` | Optional secret key for keyed hashing |
| `ad` | `fio_buf_info_s` | Optional associated data |
| `t_cost` | `uint32_t` | Time cost / number of passes (minimum 1) |
| `m_cost` | `uint32_t` | Memory cost in KiB (minimum 8 * parallelism) |
| `parallelism` | `uint32_t` | Number of lanes (minimum 1; processed sequentially) |
| `outlen` | `uint32_t` | Output length in bytes (minimum 4, default 32) |
| `type` | `fio_argon2_type_e` | Variant: `FIO_ARGON2D`, `FIO_ARGON2I`, or `FIO_ARGON2ID` |

**Returns:** a `fio_u512` containing the password hash. Only the first `outlen` bytes are valid (default 32). For output lengths greater than 64 bytes, use `fio_argon2_hash` instead.

#### `fio_argon2_hash`

```c
int fio_argon2_hash(void *out, fio_argon2_args_s args);
/* Named arguments using macro. */
#define fio_argon2_hash(out, ...) fio_argon2_hash(out, (fio_argon2_args_s){__VA_ARGS__})
```

Computes an Argon2 password hash into a caller-provided buffer.

Supports arbitrary output lengths (minimum 4 bytes). Use this instead of `fio_argon2` when the desired output length exceeds 64 bytes.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
uint8_t hash[128];
int r = fio_argon2_hash(hash,
    .password = FIO_BUF_INFO1("my-password"),
    .salt = FIO_BUF_INFO1("random-salt"),
    .t_cost = 3,
    .m_cost = 65536,
    .parallelism = 4,
    .outlen = 128,
    .type = FIO_ARGON2ID);
```

**Parameters:**
- `out` - destination buffer (must have capacity for at least `outlen` bytes)
- Named arguments are the same as `fio_argon2` (see table above)

**Returns:** 0 on success, -1 on error.

### Argon2 Examples

#### Password Hashing (Recommended Settings)

```c
#define FIO_ARGON2
#include FIO_INCLUDE_FILE

void example_password_hash(void) {
  /* OWASP recommended minimum: Argon2id, t=3, m=64MiB, p=4 */
  fio_u512 hash = fio_argon2(
      .password = FIO_BUF_INFO1("user-password"),
      .salt = FIO_BUF_INFO1("unique-random-salt"),
      .t_cost = 3,
      .m_cost = 65536,     /* 64 MiB */
      .parallelism = 4,
      .type = FIO_ARGON2ID);

  /* Verify: recompute and compare in constant time */
  fio_u512 verify = fio_argon2(
      .password = FIO_BUF_INFO1("user-password"),
      .salt = FIO_BUF_INFO1("unique-random-salt"),
      .t_cost = 3,
      .m_cost = 65536,
      .parallelism = 4,
      .type = FIO_ARGON2ID);

  if (fio_ct_is_eq(hash.u8, verify.u8, 32))
    printf("Password matches!\n");
}
```

-------------------------------------------------------------------------------
## TLS 1.3 Module

```c
#define FIO_TLS13
#include FIO_INCLUDE_FILE
```

By defining `FIO_TLS13`, a complete TLS 1.3 implementation is made available. This module provides RFC 8446 compliant TLS 1.3 with no external dependencies - all cryptographic primitives are implemented natively.

**Note**: This implementation has not been audited. Use at your own risk for security-critical applications.

------------------------------------------------------------

### Overview

The TLS 1.3 module provides:

- **Full TLS 1.3 client and server support**
- **RFC 8446 compliant** handshake and record layer
- **No external dependencies** - OpenSSL optional, not required
- **Native cryptographic primitives** - all crypto implemented in facil.io STL
- **Automatic key derivation** - complete key schedule implementation
- **Post-handshake messages** - KeyUpdate support for long-lived connections

### Requirements

The TLS 1.3 module requires the following crypto modules (automatically included with `FIO_CRYPTO`):

| Module | Purpose |
|--------|---------|
| `FIO_HKDF` | Key derivation (requires `FIO_SHA2`) |
| `FIO_AES` | AES-GCM cipher suites |
| `FIO_CHACHA` | ChaCha20-Poly1305 cipher suite |
| `FIO_X25519` | X25519 key exchange |
| `FIO_P256` | P-256 key exchange (for HelloRetryRequest) |
| `FIO_ED25519` | Ed25519 signatures |
| `FIO_X509` | Certificate parsing and verification (optional) |
| `FIO_RSA` | RSA signature verification (optional) |
| `FIO_PEM` | PEM file parsing (optional) |

------------------------------------------------------------

### Supported Algorithms

#### Cipher Suites

| Cipher Suite | Code | Hash | Key Length |
|--------------|------|------|------------|
| TLS_AES_128_GCM_SHA256 | 0x1301 | SHA-256 | 16 bytes |
| TLS_AES_256_GCM_SHA384 | 0x1302 | SHA-384 | 32 bytes |
| TLS_CHACHA20_POLY1305_SHA256 | 0x1303 | SHA-256 | 32 bytes |

#### Key Exchange Groups

| Group | Code | Key Size |
|-------|------|----------|
| X25519 | 29 | 32 bytes |
| secp256r1 (P-256) | 23 | 65 bytes (uncompressed) |
| secp384r1 (P-384) | 24 | 97 bytes (uncompressed) |

#### Signature Algorithms

| Algorithm | Code | Notes |
|-----------|------|-------|
| ecdsa_secp256r1_sha256 | 0x0403 | P-256 ECDSA |
| ecdsa_secp384r1_sha384 | 0x0503 | P-384 ECDSA |
| ed25519 | 0x0807 | EdDSA |
| rsa_pss_rsae_sha256 | 0x0804 | RSA-PSS (required for TLS 1.3) |
| rsa_pss_rsae_sha384 | 0x0805 | RSA-PSS |
| rsa_pss_rsae_sha512 | 0x0806 | RSA-PSS |
| rsa_pkcs1_sha256 | 0x0401 | Legacy (certificates only) |
| rsa_pkcs1_sha384 | 0x0501 | Legacy (certificates only) |

------------------------------------------------------------

### Constants

```c
/* Hash lengths */
#define FIO_TLS13_SHA256_HASH_LEN 32
#define FIO_TLS13_SHA384_HASH_LEN 48
#define FIO_TLS13_MAX_HASH_LEN    48

/* Key lengths */
#define FIO_TLS13_AES128_KEY_LEN 16
#define FIO_TLS13_AES256_KEY_LEN 32
#define FIO_TLS13_CHACHA_KEY_LEN 32
#define FIO_TLS13_IV_LEN         12

/* Record layer */
#define FIO_TLS13_RECORD_HEADER_LEN  5
#define FIO_TLS13_MAX_PLAINTEXT_LEN  16384
#define FIO_TLS13_MAX_CIPHERTEXT_LEN (16384 + 256)
#define FIO_TLS13_TAG_LEN            16
```

------------------------------------------------------------

### Types

#### `fio_tls13_content_type_e`

```c
typedef enum {
  FIO_TLS13_CONTENT_INVALID = 0,
  FIO_TLS13_CONTENT_CHANGE_CIPHER_SPEC = 20, /* Legacy, ignored in TLS 1.3 */
  FIO_TLS13_CONTENT_ALERT = 21,
  FIO_TLS13_CONTENT_HANDSHAKE = 22,
  FIO_TLS13_CONTENT_APPLICATION_DATA = 23,
} fio_tls13_content_type_e;
```

TLS 1.3 content types (RFC 8446 Section 5.1).

#### `fio_tls13_handshake_type_e`

```c
typedef enum {
  FIO_TLS13_HS_CLIENT_HELLO = 1,
  FIO_TLS13_HS_SERVER_HELLO = 2,
  FIO_TLS13_HS_NEW_SESSION_TICKET = 4,
  FIO_TLS13_HS_END_OF_EARLY_DATA = 5,
  FIO_TLS13_HS_ENCRYPTED_EXTENSIONS = 8,
  FIO_TLS13_HS_CERTIFICATE = 11,
  FIO_TLS13_HS_CERTIFICATE_REQUEST = 13,
  FIO_TLS13_HS_CERTIFICATE_VERIFY = 15,
  FIO_TLS13_HS_FINISHED = 20,
  FIO_TLS13_HS_KEY_UPDATE = 24,
  FIO_TLS13_HS_MESSAGE_HASH = 254,
} fio_tls13_handshake_type_e;
```

TLS 1.3 handshake message types (RFC 8446 Section 4).

#### `fio_tls13_cipher_suite_e`

```c
typedef enum {
  FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256 = 0x1301,
  FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384 = 0x1302,
  FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256 = 0x1303,
} fio_tls13_cipher_suite_e;
```

TLS 1.3 cipher suites (RFC 8446 Section B.4).

#### `fio_tls13_cipher_type_e`

```c
typedef enum {
  FIO_TLS13_CIPHER_AES_128_GCM = 0,
  FIO_TLS13_CIPHER_AES_256_GCM = 1,
  FIO_TLS13_CIPHER_CHACHA20_POLY1305 = 2,
} fio_tls13_cipher_type_e;
```

Supported AEAD cipher types for TLS 1.3.

#### `fio_tls13_record_keys_s`

```c
typedef struct {
  uint8_t key[32];          /* Write key (16 or 32 bytes depending on cipher) */
  uint8_t iv[12];           /* Write IV (always 12 bytes) */
  uint64_t sequence_number; /* Per-record sequence number (starts at 0) */
  uint8_t key_len;          /* 16 for AES-128, 32 for AES-256/ChaCha20 */
  uint8_t cipher_type;      /* fio_tls13_cipher_type_e */
} fio_tls13_record_keys_s;
```

Record encryption context (per-direction keys).

#### `fio_tls13_client_state_e`

```c
typedef enum {
  FIO_TLS13_STATE_START = 0,     /* Initial state */
  FIO_TLS13_STATE_WAIT_SH,       /* Sent ClientHello, waiting for ServerHello */
  FIO_TLS13_STATE_WAIT_SH2,      /* Sent ClientHello2 after HRR, waiting for SH */
  FIO_TLS13_STATE_WAIT_EE,       /* Received ServerHello, waiting for EE */
  FIO_TLS13_STATE_WAIT_CERT_CR,  /* Waiting for Certificate or CertRequest */
  FIO_TLS13_STATE_WAIT_CERT,     /* Waiting for Certificate */
  FIO_TLS13_STATE_WAIT_CV,       /* Waiting for CertificateVerify */
  FIO_TLS13_STATE_WAIT_FINISHED, /* Waiting for server Finished */
  FIO_TLS13_STATE_CONNECTED,     /* Handshake complete */
  FIO_TLS13_STATE_ERROR,         /* Error state */
} fio_tls13_client_state_e;
```

TLS 1.3 client handshake states.

#### `fio_tls13_client_s`

```c
typedef struct {
  /* State */
  fio_tls13_client_state_e state;

  /* Negotiated parameters */
  uint16_t cipher_suite;
  int use_sha384;

  /* Key material */
  uint8_t client_random[32];
  uint8_t x25519_private_key[32];
  uint8_t x25519_public_key[32];
  uint8_t shared_secret[32];

  /* Traffic keys */
  fio_tls13_record_keys_s client_handshake_keys;
  fio_tls13_record_keys_s server_handshake_keys;
  fio_tls13_record_keys_s client_app_keys;
  fio_tls13_record_keys_s server_app_keys;

  /* Server certificate info */
  const uint8_t *server_cert;
  size_t server_cert_len;

  /* Error info */
  uint8_t alert_level;
  uint8_t alert_description;

  /* Configuration */
  const char *server_name;
  void *trust_store;
  uint8_t skip_cert_verify;
  /* ... additional internal fields ... */
} fio_tls13_client_s;
```

TLS 1.3 client context containing all state for a connection.

#### `fio_tls13_server_state_e`

```c
typedef enum {
  FIO_TLS13_SERVER_STATE_START = 0,        /* Initial state, waiting for CH */
  FIO_TLS13_SERVER_STATE_RECVD_CH,         /* Received ClientHello, parsing */
  FIO_TLS13_SERVER_STATE_NEGOTIATED,       /* Negotiated params, building SH */
  FIO_TLS13_SERVER_STATE_WAIT_FLIGHT2,     /* Sent SH..Fin, waiting for client */
  FIO_TLS13_SERVER_STATE_WAIT_CLIENT_CERT, /* Waiting for client Certificate */
  FIO_TLS13_SERVER_STATE_WAIT_CERT_VERIFY, /* Waiting for client CertVerify */
  FIO_TLS13_SERVER_STATE_WAIT_FINISHED,    /* Waiting for client Finished */
  FIO_TLS13_SERVER_STATE_CONNECTED,        /* Handshake complete */
  FIO_TLS13_SERVER_STATE_ERROR,            /* Error state */
} fio_tls13_server_state_e;
```

TLS 1.3 server handshake states.

#### `fio_tls13_server_s`

```c
typedef struct {
  /* State */
  fio_tls13_server_state_e state;

  /* Negotiated parameters */
  uint16_t cipher_suite;
  uint16_t key_share_group;
  uint16_t signature_scheme;
  int use_sha384;

  /* Key material */
  uint8_t server_random[32];
  uint8_t x25519_private_key[32];
  uint8_t x25519_public_key[32];
  uint8_t shared_secret[32];

  /* Traffic keys */
  fio_tls13_record_keys_s client_handshake_keys;
  fio_tls13_record_keys_s server_handshake_keys;
  fio_tls13_record_keys_s client_app_keys;
  fio_tls13_record_keys_s server_app_keys;

  /* Certificate chain */
  const uint8_t **cert_chain;
  const size_t *cert_chain_lens;
  size_t cert_chain_count;

  /* Private key for signing */
  const uint8_t *private_key;
  size_t private_key_len;
  uint16_t private_key_type;

  /* Client info */
  char client_sni[256];
  size_t client_sni_len;

  /* ALPN */
  char selected_alpn[256];
  size_t selected_alpn_len;

  /* Error info */
  uint8_t alert_level;
  uint8_t alert_description;
  /* ... additional internal fields ... */
} fio_tls13_server_s;
```

TLS 1.3 server context containing all state for a connection.

------------------------------------------------------------

### Key Schedule Functions (RFC 8446 Section 7)

#### `fio_tls13_hkdf_expand_label`

```c
void fio_tls13_hkdf_expand_label(void *restrict out,
                                 size_t out_len,
                                 const void *restrict secret,
                                 size_t secret_len,
                                 const char *label,
                                 size_t label_len,
                                 const void *restrict context,
                                 size_t context_len,
                                 int use_sha384);
```

TLS 1.3 HKDF-Expand-Label function.

Derives keying material using the TLS 1.3 specific label format:
```
HKDF-Expand-Label(Secret, Label, Context, Length) =
    HKDF-Expand(Secret, HkdfLabel, Length)
```

**Parameters:**
- `out` - output buffer for derived key material
- `out_len` - desired output length (max 255)
- `secret` - the secret to expand (PRK from HKDF-Extract)
- `secret_len` - secret length (32 for SHA-256, 48 for SHA-384)
- `label` - the label string (without "tls13 " prefix)
- `label_len` - label length (max 249)
- `context` - optional context (transcript hash or empty)
- `context_len` - context length (max 255)
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_secret`

```c
void fio_tls13_derive_secret(void *restrict out,
                             const void *restrict secret,
                             size_t secret_len,
                             const char *label,
                             size_t label_len,
                             const void *restrict transcript_hash,
                             size_t hash_len,
                             int use_sha384);
```

TLS 1.3 Derive-Secret function.

```
Derive-Secret(Secret, Label, Messages) =
    HKDF-Expand-Label(Secret, Label, Transcript-Hash(Messages), Hash.length)
```

**Parameters:**
- `out` - output buffer (32 bytes for SHA-256, 48 for SHA-384)
- `secret` - the base secret
- `secret_len` - secret length
- `label` - the label string (e.g., "c hs traffic")
- `label_len` - label length
- `transcript_hash` - hash of handshake messages (or NULL for empty hash)
- `hash_len` - hash length (32 or 48)
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_early_secret`

```c
void fio_tls13_derive_early_secret(void *restrict early_secret,
                                   const void *restrict psk,
                                   size_t psk_len,
                                   int use_sha384);
```

Derives the Early Secret from PSK.

```
Early Secret = HKDF-Extract(salt=0, IKM=PSK)
```

**Parameters:**
- `early_secret` - output buffer (32 or 48 bytes)
- `psk` - pre-shared key (or NULL for no PSK)
- `psk_len` - PSK length (0 if no PSK)
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_handshake_secret`

```c
void fio_tls13_derive_handshake_secret(void *restrict handshake_secret,
                                       const void *restrict early_secret,
                                       const void *restrict ecdhe_secret,
                                       size_t ecdhe_len,
                                       int use_sha384);
```

Derives the Handshake Secret from ECDHE shared secret.

**Parameters:**
- `handshake_secret` - output buffer (32 or 48 bytes)
- `early_secret` - the early secret
- `ecdhe_secret` - the ECDHE shared secret (e.g., from X25519)
- `ecdhe_len` - ECDHE secret length (32 for X25519)
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_master_secret`

```c
void fio_tls13_derive_master_secret(void *restrict master_secret,
                                    const void *restrict handshake_secret,
                                    int use_sha384);
```

Derives the Master Secret.

**Parameters:**
- `master_secret` - output buffer (32 or 48 bytes)
- `handshake_secret` - the handshake secret
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_traffic_keys`

```c
void fio_tls13_derive_traffic_keys(void *restrict key,
                                   size_t key_len,
                                   void *restrict iv,
                                   const void *restrict traffic_secret,
                                   int use_sha384);
```

Derives traffic keys and IV from a traffic secret.

**Parameters:**
- `key` - output buffer for write key
- `key_len` - key length (16 for AES-128, 32 for AES-256/ChaCha20)
- `iv` - output buffer for write IV (12 bytes)
- `traffic_secret` - the traffic secret
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_finished_key`

```c
void fio_tls13_derive_finished_key(void *restrict finished_key,
                                   const void *restrict traffic_secret,
                                   int use_sha384);
```

Derives the Finished key from a traffic secret.

**Parameters:**
- `finished_key` - output buffer (32 or 48 bytes)
- `traffic_secret` - the handshake traffic secret
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_compute_finished`

```c
void fio_tls13_compute_finished(void *restrict verify_data,
                                const void *restrict finished_key,
                                const void *restrict transcript_hash,
                                int use_sha384);
```

Computes the Finished verify_data.

```
verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context))
```

**Parameters:**
- `verify_data` - output buffer (32 or 48 bytes)
- `finished_key` - the finished key
- `transcript_hash` - hash of handshake messages up to this point
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_update_traffic_secret`

```c
void fio_tls13_update_traffic_secret(void *restrict new_secret,
                                     const void *restrict current_secret,
                                     int use_sha384);
```

Updates application traffic secret for key update (RFC 8446 Section 4.6.3).

**Parameters:**
- `new_secret` - output buffer (32 or 48 bytes)
- `current_secret` - current application traffic secret
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

------------------------------------------------------------

### Record Layer Functions (RFC 8446 Section 5)

#### `fio_tls13_build_nonce`

```c
void fio_tls13_build_nonce(uint8_t nonce[12],
                           const uint8_t iv[12],
                           uint64_t seq);
```

Builds per-record nonce by XORing sequence number with IV.

**Parameters:**
- `nonce` - output buffer (must be 12 bytes)
- `iv` - static IV from key derivation (12 bytes)
- `seq` - 64-bit sequence number

#### `fio_tls13_record_parse_header`

```c
const uint8_t *fio_tls13_record_parse_header(
    const uint8_t *data,
    size_t data_len,
    fio_tls13_content_type_e *content_type,
    size_t *payload_len);
```

Parses a TLS record header.

**Parameters:**
- `data` - input buffer containing record data
- `data_len` - length of input buffer
- `content_type` - output: content type from header
- `payload_len` - output: payload length from header

**Returns:** pointer to payload data, or NULL if incomplete/invalid.

#### `fio_tls13_record_encrypt`

```c
int fio_tls13_record_encrypt(uint8_t *out,
                             size_t out_capacity,
                             const uint8_t *plaintext,
                             size_t plaintext_len,
                             fio_tls13_content_type_e content_type,
                             fio_tls13_record_keys_s *keys);
```

Encrypts a TLS 1.3 record.

Output format: 5-byte header + encrypted(plaintext + content_type) + tag

**Parameters:**
- `out` - output buffer for encrypted record
- `out_capacity` - capacity of output buffer
- `plaintext` - plaintext data to encrypt
- `plaintext_len` - length of plaintext
- `content_type` - content type (appended to plaintext before encryption)
- `keys` - encryption keys (sequence number will be incremented)

**Returns:** total output length (header + ciphertext + tag), or -1 on error.

#### `fio_tls13_record_decrypt`

```c
int fio_tls13_record_decrypt(uint8_t *out,
                             size_t out_capacity,
                             fio_tls13_content_type_e *content_type,
                             const uint8_t *ciphertext,
                             size_t ciphertext_len,
                             fio_tls13_record_keys_s *keys);
```

Decrypts a TLS 1.3 record.

**Parameters:**
- `out` - output buffer for decrypted plaintext
- `out_capacity` - capacity of output buffer
- `content_type` - output: actual content type from inner plaintext
- `ciphertext` - input ciphertext (includes 5-byte header)
- `ciphertext_len` - total length including header
- `keys` - decryption keys (sequence number will be incremented)

**Returns:** plaintext length (excluding padding and content type), or -1 on error.

#### `fio_tls13_record_keys_init`

```c
void fio_tls13_record_keys_init(fio_tls13_record_keys_s *keys,
                                const uint8_t *key,
                                uint8_t key_len,
                                const uint8_t iv[12],
                                fio_tls13_cipher_type_e cipher_type);
```

Initializes record keys structure.

**Parameters:**
- `keys` - keys structure to initialize
- `key` - key material (16 or 32 bytes)
- `key_len` - key length
- `iv` - IV material (12 bytes)
- `cipher_type` - cipher type

#### `fio_tls13_record_keys_clear`

```c
void fio_tls13_record_keys_clear(fio_tls13_record_keys_s *keys);
```

Clears sensitive key material from memory.

------------------------------------------------------------

### Alert Functions (RFC 8446 Section 6)

#### `fio_tls13_build_alert`

```c
int fio_tls13_build_alert(uint8_t *out,
                          size_t out_capacity,
                          uint8_t alert_level,
                          uint8_t alert_desc);
```

Builds an alert message (2 bytes: level + description).

**Returns:** 2 on success, -1 on error.

#### `fio_tls13_send_alert`

```c
int fio_tls13_send_alert(uint8_t *out,
                         size_t out_capacity,
                         uint8_t alert_level,
                         uint8_t alert_desc,
                         fio_tls13_record_keys_s *keys);
```

Builds an encrypted alert record.

**Returns:** encrypted record length, or -1 on error.

#### `fio_tls13_send_alert_plaintext`

```c
int fio_tls13_send_alert_plaintext(uint8_t *out,
                                   size_t out_capacity,
                                   uint8_t alert_level,
                                   uint8_t alert_desc);
```

Builds an unencrypted alert record (for use before encryption is enabled).

**Returns:** record length (7 bytes), or -1 on error.

#### `fio_tls13_alert_name`

```c
const char *fio_tls13_alert_name(uint8_t alert_desc);
```

Gets human-readable name for an alert description.

**Returns:** static string with alert name.

------------------------------------------------------------

### KeyUpdate Functions (RFC 8446 Section 4.6.3)

KeyUpdate is used to update traffic keys for long-lived connections.

#### `fio_tls13_build_key_update`

```c
int fio_tls13_build_key_update(uint8_t *out,
                               size_t out_capacity,
                               int request_update);
```

Builds a KeyUpdate message.

**Parameters:**
- `out` - output buffer for the handshake message (not encrypted)
- `out_capacity` - capacity of output buffer
- `request_update` - 0 = update_not_requested, 1 = update_requested

**Returns:** message length (5 bytes), or -1 on error.

#### `fio_tls13_parse_key_update`

```c
int fio_tls13_parse_key_update(const uint8_t *data,
                               size_t data_len,
                               int *request_update);
```

Parses a KeyUpdate message.

**Returns:** 0 on success, -1 on error.

#### `fio_tls13_process_key_update`

```c
int fio_tls13_process_key_update(uint8_t *traffic_secret,
                                 fio_tls13_record_keys_s *keys,
                                 const uint8_t *data,
                                 size_t data_len,
                                 uint8_t *key_update_pending,
                                 int use_sha384,
                                 size_t key_len,
                                 fio_tls13_cipher_type_e cipher_type);
```

Processes a received KeyUpdate and updates receiving keys.

**Returns:** 0 on success, -1 on error.

#### `fio_tls13_send_key_update_response`

```c
int fio_tls13_send_key_update_response(uint8_t *out,
                                       size_t out_capacity,
                                       uint8_t *traffic_secret,
                                       fio_tls13_record_keys_s *keys,
                                       uint8_t *key_update_pending,
                                       int use_sha384,
                                       size_t key_len,
                                       fio_tls13_cipher_type_e cipher_type);
```

Sends KeyUpdate response and updates sending keys.

**Returns:** encrypted record length, or -1 on error.

------------------------------------------------------------

### Client API

#### `fio_tls13_client_init`

```c
void fio_tls13_client_init(fio_tls13_client_s *client, const char *server_name);
```

Initializes client context.

**Parameters:**
- `client` - client context to initialize
- `server_name` - SNI hostname (can be NULL)

#### `fio_tls13_client_destroy`

```c
void fio_tls13_client_destroy(fio_tls13_client_s *client);
```

Cleans up client context (zeroes secrets).

#### `fio_tls13_client_set_trust_store`

```c
void fio_tls13_client_set_trust_store(fio_tls13_client_s *client,
                                      void *trust_store);
```

Sets trust store for certificate chain verification.

When set, the client will verify the server's certificate chain against the provided trust store. If NULL (default), chain verification is skipped.

**Note**: Requires `FIO_X509` module. The trust_store pointer must point to a valid `fio_x509_trust_store_s` structure.

#### `fio_tls13_client_skip_verification`

```c
void fio_tls13_client_skip_verification(fio_tls13_client_s *client, int skip);
```

Skips all certificate verification (insecure).

When enabled, the client will NOT verify CertificateVerify signature, certificate chain, or hostname matching.

**Warning**: This is insecure and should only be used for testing.

#### `fio_tls13_client_start`

```c
int fio_tls13_client_start(fio_tls13_client_s *client,
                           uint8_t *out,
                           size_t out_capacity);
```

Generates ClientHello message and starts handshake.

**Parameters:**
- `client` - client context
- `out` - output buffer for ClientHello record
- `out_capacity` - capacity of output buffer

**Returns:** message length on success, -1 on error.

#### `fio_tls13_client_process`

```c
int fio_tls13_client_process(fio_tls13_client_s *client,
                             const uint8_t *in,
                             size_t in_len,
                             uint8_t *out,
                             size_t out_capacity,
                             size_t *out_len);
```

Processes incoming TLS record(s).

May generate response data in out buffer.

**Parameters:**
- `client` - client context
- `in` - input buffer containing TLS record(s)
- `in_len` - length of input data
- `out` - output buffer for response
- `out_capacity` - capacity of output buffer
- `out_len` - output: response length (0 if no response needed)

**Returns:** number of bytes consumed, or -1 on error.

#### `fio_tls13_client_encrypt`

```c
int fio_tls13_client_encrypt(fio_tls13_client_s *client,
                             uint8_t *out,
                             size_t out_capacity,
                             const uint8_t *plaintext,
                             size_t plaintext_len);
```

Encrypts application data for sending.

**Parameters:**
- `client` - client context
- `out` - output buffer for encrypted record
- `out_capacity` - capacity of output buffer
- `plaintext` - plaintext data to encrypt
- `plaintext_len` - length of plaintext

**Returns:** encrypted record length, or -1 on error.

#### `fio_tls13_client_decrypt`

```c
int fio_tls13_client_decrypt(fio_tls13_client_s *client,
                             uint8_t *out,
                             size_t out_capacity,
                             const uint8_t *ciphertext,
                             size_t ciphertext_len);
```

Decrypts received application data.

**Parameters:**
- `client` - client context
- `out` - output buffer for decrypted data
- `out_capacity` - capacity of output buffer
- `ciphertext` - encrypted record (including header)
- `ciphertext_len` - length of encrypted record

**Returns:** plaintext length, or -1 on error.

#### `fio_tls13_client_is_connected`

```c
int fio_tls13_client_is_connected(fio_tls13_client_s *client);
```

Checks if handshake is complete.

**Returns:** 1 if connected, 0 otherwise.

#### `fio_tls13_client_is_error`

```c
int fio_tls13_client_is_error(fio_tls13_client_s *client);
```

Checks if in error state.

**Returns:** 1 if error, 0 otherwise.

#### `fio_tls13_client_state_name`

```c
const char *fio_tls13_client_state_name(fio_tls13_client_s *client);
```

Gets current state name (for debugging).

**Returns:** state name string.

#### `fio_tls13_client_get_cert_error`

```c
int fio_tls13_client_get_cert_error(fio_tls13_client_s *client);
```

Gets the last certificate verification error.

**Returns:** error code (0 = OK, negative = error).

#### `fio_tls13_client_is_cert_verified`

```c
int fio_tls13_client_is_cert_verified(fio_tls13_client_s *client);
```

Checks if certificate verification was successful.

**Returns:** 1 if verified, 0 if not verified or skipped.

#### `fio_tls13_client_alpn_set`

```c
void fio_tls13_client_alpn_set(fio_tls13_client_s *client,
                               const char *protocols);
```

Sets ALPN protocols for client (comma-separated list).

Example: `"h2,http/1.1"` offers HTTP/2 first, then HTTP/1.1.

#### `fio_tls13_client_alpn_get`

```c
const char *fio_tls13_client_alpn_get(fio_tls13_client_s *client);
```

Gets negotiated ALPN protocol after handshake.

**Returns:** selected protocol string, or NULL if none negotiated.

#### `fio_tls13_client_set_cert`

```c
void fio_tls13_client_set_cert(fio_tls13_client_s *client,
                               const uint8_t *cert,
                               size_t cert_len,
                               const uint8_t *private_key,
                               size_t key_len,
                               uint16_t key_type);
```

Sets client certificate for mutual TLS (mTLS) authentication.

When the server requests client authentication (CertificateRequest), the client will send this certificate and sign with the private key.

------------------------------------------------------------

### Server API

#### `fio_tls13_server_init`

```c
void fio_tls13_server_init(fio_tls13_server_s *server);
```

Initializes server context.

#### `fio_tls13_server_destroy`

```c
void fio_tls13_server_destroy(fio_tls13_server_s *server);
```

Cleans up server context (zeroes secrets).

#### `fio_tls13_server_set_cert_chain`

```c
void fio_tls13_server_set_cert_chain(fio_tls13_server_s *server,
                                     const uint8_t **certs,
                                     const size_t *cert_lens,
                                     size_t cert_count);
```

Sets certificate chain for server authentication.

**Parameters:**
- `server` - server context
- `certs` - array of DER-encoded certificate pointers
- `cert_lens` - array of certificate lengths
- `cert_count` - number of certificates (first is end-entity)

#### `fio_tls13_server_set_private_key`

```c
void fio_tls13_server_set_private_key(fio_tls13_server_s *server,
                                      const uint8_t *private_key,
                                      size_t key_len,
                                      uint16_t key_type);
```

Sets private key for server authentication.

**Parameters:**
- `server` - server context
- `private_key` - private key data (Ed25519: 32 bytes seed, P-256: 32 bytes scalar)
- `key_len` - private key length
- `key_type` - key type (FIO_TLS13_SIG_ED25519, FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256, etc.)

#### `fio_tls13_server_process`

```c
int fio_tls13_server_process(fio_tls13_server_s *server,
                             const uint8_t *in,
                             size_t in_len,
                             uint8_t *out,
                             size_t out_capacity,
                             size_t *out_len);
```

Processes incoming TLS record(s).

May generate response data in out buffer.

**Returns:** number of bytes consumed, or -1 on error.

#### `fio_tls13_server_encrypt`

```c
int fio_tls13_server_encrypt(fio_tls13_server_s *server,
                             uint8_t *out,
                             size_t out_capacity,
                             const uint8_t *plaintext,
                             size_t plaintext_len);
```

Encrypts application data for sending.

**Returns:** encrypted record length, or -1 on error.

#### `fio_tls13_server_decrypt`

```c
int fio_tls13_server_decrypt(fio_tls13_server_s *server,
                             uint8_t *out,
                             size_t out_capacity,
                             const uint8_t *ciphertext,
                             size_t ciphertext_len);
```

Decrypts received application data.

**Returns:** plaintext length, or -1 on error.

#### `fio_tls13_server_is_connected`

```c
int fio_tls13_server_is_connected(fio_tls13_server_s *server);
```

Checks if handshake is complete.

**Returns:** 1 if connected, 0 otherwise.

#### `fio_tls13_server_is_error`

```c
int fio_tls13_server_is_error(fio_tls13_server_s *server);
```

Checks if in error state.

**Returns:** 1 if error, 0 otherwise.

#### `fio_tls13_server_state_name`

```c
const char *fio_tls13_server_state_name(fio_tls13_server_s *server);
```

Gets current state name (for debugging).

#### `fio_tls13_server_get_sni`

```c
const char *fio_tls13_server_get_sni(fio_tls13_server_s *server);
```

Gets client's SNI hostname.

**Returns:** SNI hostname, or NULL if not provided.

#### `fio_tls13_server_alpn_set`

```c
void fio_tls13_server_alpn_set(fio_tls13_server_s *server,
                               const char *protocols);
```

Sets ALPN protocols for server (comma-separated list).

Server will select first matching protocol from client's offer.

#### `fio_tls13_server_alpn_get`

```c
const char *fio_tls13_server_alpn_get(fio_tls13_server_s *server);
```

Gets negotiated ALPN protocol after handshake.

#### `fio_tls13_server_require_client_cert`

```c
void fio_tls13_server_require_client_cert(fio_tls13_server_s *server, int mode);
```

Requires client certificate authentication (mutual TLS / mTLS).

**Parameters:**
- `server` - server context
- `mode` - 0=none (default), 1=optional, 2=required

#### `fio_tls13_server_client_cert_received`

```c
int fio_tls13_server_client_cert_received(fio_tls13_server_s *server);
```

Checks if client provided a certificate.

**Returns:** 1 if client sent a certificate, 0 otherwise.

#### `fio_tls13_server_client_cert_verified`

```c
int fio_tls13_server_client_cert_verified(fio_tls13_server_s *server);
```

Checks if client certificate was verified successfully.

#### `fio_tls13_server_get_client_cert`

```c
const uint8_t *fio_tls13_server_get_client_cert(fio_tls13_server_s *server,
                                                size_t *cert_len);
```

Gets client's certificate (first in chain).

**Returns:** pointer to DER-encoded certificate, or NULL if none.

------------------------------------------------------------

### Complete Client Example

```c
#define FIO_TLS13
#define FIO_X509
#define FIO_RSA
#define FIO_SOCK
#include "fio-stl/include.h"

int tls_connect(const char *hostname, int port) {
  /* Connect TCP socket */
  int fd = /* ... establish TCP connection ... */;
  
  /* Initialize TLS client */
  fio_tls13_client_s client;
  fio_tls13_client_init(&client, hostname);
  
  /* Optional: Set trust store for certificate verification */
  fio_x509_trust_store_s trust_store = { /* ... */ };
  fio_tls13_client_set_trust_store(&client, &trust_store);
  
  /* Start handshake - send ClientHello */
  uint8_t out_buf[4096];
  int out_len = fio_tls13_client_start(&client, out_buf, sizeof(out_buf));
  if (out_len < 0) {
    fprintf(stderr, "Failed to create ClientHello\n");
    return -1;
  }
  send(fd, out_buf, out_len, 0);
  
  /* Process handshake messages until connected */
  uint8_t in_buf[16384];
  while (!fio_tls13_client_is_connected(&client)) {
    if (fio_tls13_client_is_error(&client)) {
      fprintf(stderr, "TLS handshake error\n");
      return -1;
    }
    
    /* Receive data */
    ssize_t recv_len = recv(fd, in_buf, sizeof(in_buf), 0);
    if (recv_len <= 0) break;
    
    /* Process received data */
    size_t response_len = 0;
    int consumed = fio_tls13_client_process(&client, in_buf, recv_len,
                                            out_buf, sizeof(out_buf),
                                            &response_len);
    if (consumed < 0) {
      fprintf(stderr, "TLS processing error\n");
      return -1;
    }
    
    /* Send any response (e.g., client Finished) */
    if (response_len > 0) {
      send(fd, out_buf, response_len, 0);
    }
  }
  
  printf("TLS 1.3 handshake complete!\n");
  printf("Cipher suite: 0x%04X\n", client.cipher_suite);
  
  /* Send encrypted application data */
  const char *request = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
  int enc_len = fio_tls13_client_encrypt(&client, out_buf, sizeof(out_buf),
                                         (uint8_t*)request, strlen(request));
  send(fd, out_buf, enc_len, 0);
  
  /* Receive and decrypt response */
  ssize_t recv_len = recv(fd, in_buf, sizeof(in_buf), 0);
  int dec_len = fio_tls13_client_decrypt(&client, out_buf, sizeof(out_buf),
                                         in_buf, recv_len);
  if (dec_len > 0) {
    printf("Response: %.*s\n", dec_len, out_buf);
  }
  
  /* Clean up */
  fio_tls13_client_destroy(&client);
  close(fd);
  
  return 0;
}
```

------------------------------------------------------------

### RFC 8446 Conformance Status

| RFC 8446 Section | Feature | Status |
|------------------|---------|--------|
| 2 | Protocol Overview |  Implemented |
| 4.1.2 | ClientHello |  Implemented |
| 4.1.3 | ServerHello |  Implemented |
| 4.1.4 | HelloRetryRequest |  Implemented |
| 4.2 | Extensions |  Core extensions |
| 4.2.1 | supported_versions |  Implemented |
| 4.2.3 | signature_algorithms |  Implemented |
| 4.2.7 | supported_groups |  Implemented |
| 4.2.8 | key_share |  Implemented |
| 4.2.9 | server_name (SNI) |  Implemented |
| 4.3.2 | CertificateRequest |  Implemented |
| 4.4.2 | Certificate |  Implemented |
| 4.4.3 | CertificateVerify |  Implemented |
| 4.4.4 | Finished |  Implemented |
| 4.6.1 | NewSessionTicket |  Parsed, not used |
| 4.6.3 | KeyUpdate |  Implemented |
| 5 | Record Layer |  Implemented |
| 5.2 | Record Encryption |  Implemented |
| 5.3 | Per-Record Nonce |  Implemented |
| 6 | Alerts |  Implemented |
| 7 | Key Schedule |  Implemented |
| 7.1 | HKDF-Expand-Label |  Implemented |
| 7.3 | Traffic Key Derivation |  Implemented |
| B.4 | Cipher Suites |  All 3 mandatory |
| RFC 7301 | ALPN |  Implemented |

**Legend:**
-  Fully implemented
-  Partially implemented
-  Not implemented

------------------------------------------------------------
## Dynamic Strings

```c
#define FIO_STR_NAME fio_str
#include "fio-stl.h"
```

Dynamic Strings are extremely useful, since:

* They can safely store binary data (unlike regular C strings).

* They make it easy to edit String data. Granted, the standard C library can do this too, but this approach offers some optimizations and safety measures that the C library cannot offer due to its historical design.

To create a dynamic string define the type name using the `FIO_STR_NAME` macro.

Alternatively, the type name could be defined using the `FIO_STR_SMALL` macro, resulting in an alternative data structure with a non-default optimization approach (see details later on).

The type (`FIO_STR_NAME_s`) and the functions will be automatically defined.

For brevity's sake, in this documentation they will be listed as `STR_*` functions / types (i.e., `STR_s`, `STR_new()`, etc').

**Note:** this module depends on the `FIO_STR` module and all the modules required by `FIO_STR` which will be automatically included.

### Optimizations / Flavors

Strings come in two main flavors, Strings optimized for mutability (default) vs. Strings optimized for memory consumption (defined using `FIO_STR_SMALL`).

Both optimizations follow specific use-case performance curves that depend on the length of the String data and effect both editing costs and reading costs differently.

#### When to use the default Dynamic Strings (`FIO_STR_NAME`)

The default optimization stores information about the allocated memory's capacity and it is likely to perform best for most generic use-cases, especially when:

* Multiple `write` operations are required.

* It's pre-known that most strings will be longer than a small container's embedded string limit (`(2 * sizeof(char*)) - 2`) and still fit within the default container's embedded string limit (`((4 + FIO_STR_OPTIMIZE_EMBEDDED) * sizeof(char*)) - 2`).

   This is because short Strings are stored directly within a String's data container, minimizing both memory indirection and memory allocation.

   Strings optimized for mutability, by nature, have a larger data container, allowing longer strings to be stored within a container.

   For example, _on 64bit systems_:

   The default (larger) container requires 32 bytes, allowing Strings of up to 30 bytes to be stored directly within the container. This is in contrast to the smaller container (16 bytes in size).

   Two bytes (2 bytes) are used for metadata and a terminating NUL character (to ensure C string safety), leaving the embedded string capacity at 30 bytes for the default container (and 14 bytes for the small one).

   If it's **pre-known** that most strings are likely to be longer than 14 bytes and shorter than 31 bytes (on 64 bit systems), than the default `FIO_STR_NAME` optimization should perform better.

   **Note**: the default container size can be extended by `sizeof(void*)` units using the `FIO_STR_OPTIMIZE_EMBEDDED` macro (i.e., `#define FIO_STR_OPTIMIZE_EMBEDDED 2` will add 16 bytes to the container on 64 bit systems).

#### Example `FIO_STR_NAME` Use-Case

```c
#define FIO_LOG
#define FIO_QUEUE
#include "fio-stl.h"

#define FIO_STR_NAME fio_str
#define FIO_REF_NAME fio_str
#define FIO_REF_CONSTRUCTOR_ONLY
#include "fio-stl.h"

/* this is NOT thread safe... just an example */
void example_task(void *str_, void *ignore_) {
  fio_str_s *str = (fio_str_s *)str_; /* C++ style cast */
  fprintf(stderr, "%s\n", fio_str_ptr(str));
  fio_str_write(str, ".", 1); /* write will sporadically allocate memory if required. */
  fio_str_free(str);          /* decreases reference count or frees object */
  (void)ignore_;
}

void example(void) {
  fio_queue_s queue = FIO_QUEUE_INIT(queue);
  fio_str_s *str = fio_str_new();
  /* writes to the String */
  fio_str_write(str, "Starting time was: ", 19);
  {
    /* reserves space and resizes String, without writing any data */
    const size_t org_len = fio_str_len(str);
    fio_str_info_s str_info = fio_str_resize(str, 29 + org_len);
    /* write data directly to the existing String buffer */
    size_t r = fio_time2rfc7231(str_info.buf + org_len, fio_time_real().tv_sec);
    FIO_ASSERT(r == 29, "this example self destructs at 9999");
  }
  for (size_t i = 0; i < 10; ++i) {
    /* allow each task to hold a reference to the object */
    fio_queue_push(&queue, .fn = example_task, .udata1 = fio_str_dup(str));
  }
  fio_str_free(str);             /* decreases reference count */
  fio_queue_perform_all(&queue); /* performs all tasks */
  fio_queue_destroy(&queue);
}
```

#### When to use the smaller Dynamic Strings (`FIO_STR_SMALL`)

The classic use-case for the smaller dynamic string type is as a `key` in a Map object. The memory "savings" in these cases could become meaningful.

In addition, the `FIO_STR_SMALL` optimization is likely to perform better than the default when Strings are likely to fit within a small container's embedded string limit (`(2 * sizeof(char*)) - 2`), or when Strings are mostly immutable and likely to be too long for the default container's embedded string limit, **and**:

* Strings are likely to require a single `write` operation; **or**

* Strings will point to static memory (`STR_init_const`).

#### Example `FIO_STR_SMALL` Use-Case

```c
#define FIO_STR_SMALL key /* results in the type name: key_s */
#include "fio-stl.h"

#define FIO_OMAP_NAME map
#define FIO_MAP_KEY key_s /* the small string type */
#define FIO_MAP_KEY_COPY(dest, src) key_init_copy2(&(dest), &(src))
#define FIO_MAP_KEY_DESTROY(k) key_destroy(&k)
#define FIO_MAP_KEY_CMP(a, b) key_is_eq(&(a), &(b))
#define FIO_MAP_VALUE uintptr_t
#include "fio-stl.h"

/* helper for setting values in the map using risky hash with a safe seed */
FIO_IFUNC uintptr_t map_set2(map_s *m, key_s key, uintptr_t value) {
  return map_set(m, key_hash(&key, (uintptr_t)m), key, value, NULL);
}

/* helper for getting values from the map using risky hash with a safe seed */
FIO_IFUNC uintptr_t map_get2(map_s *m, key_s key) {
  return map_get(m, key_hash(&key, (uintptr_t)m), key);
}

void example(void) {
  map_s m = FIO_MAP_INIT;
  /* write the long keys twice, to prove they self-destruct in the Hash-Map */
  for (size_t overwrite = 0; overwrite < 2; ++overwrite) {
    for (size_t i = 0; i < 10; ++i) {
      const char *prefix = "a long key will require memory allocation: ";
      key_s k;
      key_init_const(&k, prefix, strlen(prefix)); /* points to string literal */
      key_write_hex(&k, i); /* automatically converted into a dynamic string */
      map_set2(&m, k, (uintptr_t)i);
      key_destroy(&k);
    }
  }
  /* short keys don't allocate external memory (string embedded in the object) */
  for (size_t i = 0; i < 10; ++i) {
    /* short keys fit in pointer + length type... test assumes 64bit addresses */
    const char *prefix = "embed: ";
    key_s k;
    key_init_const(&k, prefix, strlen(prefix)); /* embeds the (short) string */
    key_write_hex(&k, i); /* automatically converted into a dynamic string */
    map_set2(&m, k, (uintptr_t)i);
    key_destroy(&k);
  }
  FIO_MAP_EACH(&m, pos) {
    fprintf(stderr,
            "[%d] %s - memory allocated: %s\n",
            (int)pos->obj.value,
            key_ptr(&pos->obj.key),
            (key_is_allocated(&pos->obj.key) ? "yes" : "no"));
  }
  map_destroy(&m);
  /* test for memory leaks using valgrind or similar */
}
```
### String Type information

#### `STR_s`

The core type, created by the macro, is the `STR_s` type - where `STR` is replaced by `FIO_STR_NAME`. i.e.:

```c
#define FIO_STR_NAME my_str
#include <fio-stl.h>
// results in: my_str_s - i.e.:
void hello(void){
  my_str_s msg = FIO_STR_INIT;
  my_str_write(&msg, "Hello World", 11);
  printf("%s\n", my_str_ptr(&msg));
  my_str_destroy(&msg);
}
```

The type should be considered **opaque** and **must never be accessed directly**.

The type's attributes should be accessed ONLY through the accessor functions: `STR_info`, `STR_len`, `STR_ptr`, `STR_capa`, etc'.

This is because: Small strings that fit into the type directly use the type itself for memory (except the first and last bytes). Larger strings use the type fields for the string's meta-data. Depending on the string's data, the type behaves differently.

#### `fio_str_info_s` - revisited

Some functions return information about a string's state using the [`fio_str_info_s` type detailed above](#fio_str_info_s). As a reminder, it looks like this:

```c
typedef struct fio_str_info_s {
  char *buf;   /* The string's buffer (pointer to first byte) or NULL on error. */
  size_t len;  /* The string's length, if any. */
  size_t capa; /* The buffer's capacity. Zero (0) indicates the buffer is read-only. */
} fio_str_info_s;
```

This information type, accessible using the `STR_info` function, allows direct access and manipulation of the string data. Changes in string length should be followed by a call to `STR_resize`.

The data in the string object is always NUL terminated. However, string data might contain binary data, where NUL is a valid character, so using C string functions isn't advised.

Equality can be tested using the [`FIO_STR_INFO_IS_EQ` macro](FIO_STR_INFO_IS_EQ).

See [Binary Data Informational Types and Helpers](#binary-data-informational-types-and-helpers) for more details.

#### String allocation alignment / `FIO_STR_NO_ALIGN`

Memory allocators have allocation alignment concerns that require minimum space to be allocated.

The default `STR_s` type makes use of this extra space for small strings, fitting them into the type.

To prevent this behavior and minimize the space used by the `STR_s` type, set the `FIO_STR_NO_ALIGN` macro to `1`.

```c
#define FIO_STR_NAME big_string
#define FIO_STR_NO_ALIGN 1
#include <fio-stl.h>
// ...
big_string_s foo = FIO_STR_INIT;
```

This could save memory when strings aren't short enough to be contained within the type.

This could also save memory, potentially, if the string type will be wrapped / embedded within other data-types (i.e., using `FIO_REF_NAME` for reference counting).

### Configuration Macros

#### `FIO_STR_OPTIMIZE_EMBEDDED`

```c
#define FIO_STR_OPTIMIZE_EMBEDDED 0 /* default */
```

For each unit (0 by default), adds `sizeof(char *)` bytes to the type size, increasing the amount of strings that could be embedded within the type without additional memory allocation.

For example, when using a reference counter wrapper on a 64bit system, it would make sense to set this value to 1 - allowing the type size to fully utilize a 16 byte memory allocation alignment.

**Note**: Maximum value is 4 for default strings, or 1 for `FIO_STR_SMALL` / `FIO_STR_OPTIMIZE4IMMUTABILITY` strings.

#### `FIO_STR_OPTIMIZE4IMMUTABILITY`

```c
#define FIO_STR_OPTIMIZE4IMMUTABILITY 0 /* default */
```

Minimizes the struct size, storing only string length and pointer.

By avoiding extra (mutable related) data, such as the allocated memory's capacity, strings require less memory. However, this does introduce a performance penalty when editing the string data.

**Note**: This is automatically set to `1` when using `FIO_STR_SMALL`.

#### `FIO_STR_NO_ALIGN`

```c
#define FIO_STR_NO_ALIGN 0 /* default */
```

When set to `1`, prevents the default behavior of using extra alignment space for small strings.

This could save memory when strings aren't short enough to be contained within the type, or when the string type will be wrapped / embedded within other data-types (i.e., using `FIO_REF_NAME` for reference counting).

### String API - Initialization and Destruction

#### `FIO_STR_INIT`

This value should be used for initialization. It should be considered opaque, but is defined as:

```c
#define FIO_STR_INIT { .special = 0 }
```

For example:

```c
#define FIO_STR_NAME fio_str
#include <fio-stl.h>
void example(void) {
  // on the stack
  fio_str_s str = FIO_STR_INIT;
  // .. 
  fio_str_destroy(&str);
}
```

#### `FIO_STR_INIT_EXISTING`

This macro allows the container to be initialized with existing data.

```c
#define FIO_STR_INIT_EXISTING(buffer, length, capacity,)              \
  { .buf = (buffer), .len = (length), .capa = (capacity) }
```
The `capacity` value should exclude the space required for the NUL character (if exists).

Memory should be dynamically allocated using the same allocator selected for the String type (see `FIO_MALLOC` / `FIO_MEM_REALLOC` / `FIO_MEM_FREE`).

#### `FIO_STR_INIT_STATIC`

This macro allows the string container to be initialized with existing static data, that shouldn't be freed.

```c
#define FIO_STR_INIT_STATIC(buffer)                                            \
  {                                                                            \
    .special = 4, .capa = FIO_STRLEN((buffer)), .len = FIO_STRLEN((buffer)),   \
    .buf = (char *)(buffer)                                                    \
  }
```

**Note**: This macro isn't valid for `FIO_STR_SMALL` (or strings with the `FIO_STR_OPTIMIZE4IMMUTABILITY` optimization).

#### `FIO_STR_INIT_STATIC2`

This macro allows the string container to be initialized with existing static data, that shouldn't be freed.

```c
#define FIO_STR_INIT_STATIC2(buffer, length)                                   \
  { .special = 4, .capa = (length), .len = (length), .buf = (char *)(buffer) }
```

**Note**: This macro isn't valid for `FIO_STR_SMALL` (or strings with the `FIO_STR_OPTIMIZE4IMMUTABILITY` optimization).


#### `STR_init_const`

```c
fio_str_info_s STR_init_const(FIO_STR_PTR s,
                              const char *str,
                              size_t len);
```

Initializes the container with a pointer to the provided static / constant string.

The string will be copied to the container **only** if it will fit in the container itself. 

Otherwise, the supplied pointer will be used as is **and must remain valid until the string is destroyed** (or written to, at which point the data is duplicated).

The final string can be safely be destroyed (using the `STR_destroy` function).

#### `STR_init_copy`

```c
fio_str_info_s STR_init_copy(FIO_STR_PTR s,
                             const char *str,
                             size_t len);
```

Initializes the container with a copy of the `src` string.

The string is always copied and the final string must be destroyed (using the `destroy` function).

#### `STR_init_copy2`

```c
fio_str_info_s STR_init_copy2(FIO_STR_PTR dest,
                             FIO_STR_PTR src);
```

Initializes the `dest` container with a copy of the `src` String object's content.

The `src` metadata, such as `freeze` state, is ignored - resulting in a mutable String object.

The string is always copied and the final string must be destroyed (using the `destroy` function).

#### `STR_destroy`

```c
void STR_destroy(FIO_STR_PTR s);
```

Frees the String's resources and reinitializes the container.

Note: if the container isn't allocated on the stack, it should be freed separately using the appropriate `free` function, such as `STR_free`.

#### `STR_new`

```c
FIO_STR_PTR STR_new(void);
```

Allocates a new String object on the heap.

#### `STR_free`

```c
void STR_free(FIO_STR_PTR s);
```

Destroys the string and frees the container (if allocated with `STR_new`).

#### `STR_detach`

```c
char * STR_detach(FIO_STR_PTR s);
```

Returns a C string with the existing data, **re-initializing** the String.

The returned C string is **always dynamic** and **must be freed** using the same memory allocator assigned to the type (i.e., `free` or `fio_free`, see [`FIO_MALLOC`](#local-memory-allocation), [`FIO_MEM_REALLOC`](#FIO_MEM_REALLOC) and [`FIO_MALLOC_TMP_USE_SYSTEM`](#FIO_MALLOC_TMP_USE_SYSTEM))

**Note**: the String data is removed from the container, but the container is **not** freed.

Returns NULL if there's no String data.

#### `STR_dealloc`
```c
void FIO_NAME(FIO_STR_NAME, dealloc)(void *ptr);
```

Frees the pointer returned by [`detach`](#str_detach).

**Note**: this might cause memory leaks if the `size` in the [`FIO_MEM_FREE` macro](#fio_mem_free) was a required parameter, as this function will always use `size == -1` (since the information about the size was lost during `detach`.

### String API - String state (data pointers, length, capacity, etc')

#### `STR_info`

```c
fio_str_info_s STR_info(const FIO_STR_PTR s);
```

Returns the String's complete state (capacity, length and pointer).

#### `STR_buf`

```c
fio_buf_info_s STR_buf(const FIO_STR_PTR s);
```

Returns the String's partial state (length and pointer) as a `fio_buf_info_s`.

#### `STR_len`

```c
size_t STR_len(FIO_STR_PTR s);
```

Returns the String's length in bytes.

#### `STR_ptr`

```c
char *STR_ptr(FIO_STR_PTR s);
```

Returns a pointer (`char *`) to the String's content (first character in the string).

#### `STR_capa`

```c
size_t STR_capa(FIO_STR_PTR s);
```

Returns the String's existing capacity (total used & available memory).

#### `STR_freeze`

```c
void STR_freeze(FIO_STR_PTR s);
```

Prevents further manipulations to the String's content.

#### `STR_is_frozen`

```c
uint8_t STR_is_frozen(FIO_STR_PTR s);
```

Returns true if the string is frozen.

#### `STR_is_allocated`

```c
int STR_is_allocated(const FIO_STR_PTR s);
```

Returns 1 if memory was allocated and (the String must be destroyed).

#### `STR_is_eq`

```c
int STR_is_eq(const FIO_STR_PTR str1, const FIO_STR_PTR str2);
```

Binary comparison returns `1` if both strings are equal and `0` if not.

#### `STR_hash`

```c
uint64_t STR_hash(const FIO_STR_PTR s, uint64_t seed);
```

Returns the string's Risky Hash value.

**Parameters:**
- `s` - the String pointer
- `seed` - a seed value for the hash function

**Note**: Hash algorithm might change without notice.

### String API - Memory management

#### `STR_resize`

```c
fio_str_info_s STR_resize(FIO_STR_PTR s, size_t size);
```

Sets the new String size without reallocating any memory (limited by existing capacity).

Returns the updated state of the String.

Note: When shrinking, any existing data beyond the new size may be corrupted or lost.

#### `STR_compact`

```c
void STR_compact(FIO_STR_PTR s);
```

Performs a best attempt at minimizing memory consumption.

Actual effects depend on the underlying memory allocator and it's implementation. Not all allocators will free any memory.

#### `STR_reserve`

```c
fio_str_info_s STR_reserve(FIO_STR_PTR s, size_t amount);
```

Reserves at least `amount` of new bytes to be added to the string's data.

Returns the current state of the String.

**Note**: Doesn't exist for `FIO_STR_SMALL` types, since capacity can't be reserved in advance (either use `STR_resize` and write data manually or suffer a performance penalty when performing multiple `write` operations).

### String API - UTF-8 State

#### `STR_utf8_valid`

```c
size_t STR_utf8_valid(FIO_STR_PTR s);
```

Returns 1 if the String is UTF-8 valid and 0 if not.

#### `STR_utf8_len`

```c
size_t STR_utf8_len(FIO_STR_PTR s);
```

Returns the String's length in UTF-8 characters.

#### `STR_utf8_select`

```c
int STR_utf8_select(FIO_STR_PTR s, intptr_t *pos, size_t *len);
```

Takes a UTF-8 character selection information (UTF-8 position and length) and updates the same variables so they reference the raw byte slice information.

If the String isn't UTF-8 valid up to the requested selection, than `pos` will be updated to `-1` otherwise values are always positive.

The returned `len` value may be shorter than the original if there wasn't enough data left to accommodate the requested length. When a `len` value of `0` is returned, this means that `pos` marks the end of the String.

Returns -1 on error and 0 on success.

### String API - Content Manipulation and Review

#### `STR_write`

```c
fio_str_info_s STR_write(FIO_STR_PTR s, const void *src, size_t src_len);
```

Writes data at the end of the String.

#### `STR_write_i`

```c
fio_str_info_s STR_write_i(FIO_STR_PTR s, int64_t num);
```

Writes a number at the end of the String using normal base 10 notation.

#### `STR_write_hex`

```c
fio_str_info_s STR_write_hex(FIO_STR_PTR s, int64_t num);
```

Writes a number at the end of the String using Hex (base 16) notation.

**Note**: the `0x` prefix **is automatically written** before the hex numerals.

#### `STR_write_bin`

```c
fio_str_info_s STR_write_bin(FIO_STR_PTR s, int64_t num);
```

Writes a number at the end of the String using binary notation.

#### `STR_concat` / `STR_join`

```c
fio_str_info_s STR_concat(FIO_STR_PTR dest, FIO_STR_PTR const src);
```

Appends the `src` String to the end of the `dest` String. If `dest` is empty, the resulting Strings will be equal.

`STR_join` is an alias for `STR_concat`.


#### `STR_replace`

```c
fio_str_info_s STR_replace(FIO_STR_PTR s,
                           intptr_t start_pos,
                           size_t old_len,
                           const void *src,
                           size_t src_len);
```

Replaces the data in the String - replacing `old_len` bytes starting at `start_pos`, with the data at `src` (`src_len` bytes long).

Negative `start_pos` values are calculated backwards, `-1` == end of String.

When `old_len` is zero, the function will insert the data at `start_pos`.

If `src_len == 0` than `src` will be ignored and the data marked for replacement will be erased.

#### `FIO_STR_WRITE2`

```c
#define FIO_STR_WRITE2(str_name, dest, ...)                                    \
  FIO_NAME(str_name, __write2)(dest, (fio_string_write_s[]){__VA_ARGS__, {0}})
```

Writes data at the end of the String using the `fio_string_write2` interface.

This macro allows multiple write operations to be performed in a single call using `fio_string_write_s` arguments.

Example:

```c
FIO_STR_WRITE2(my_str, &str,
               FIO_STRING_WRITE_STR1("Hello "),
               FIO_STRING_WRITE_STR1("World!"));
```

#### `STR_vprintf`

```c
fio_str_info_s STR_vprintf(FIO_STR_PTR s, const char *format, va_list argv);
```

Writes to the String using a vprintf like interface.

Data is written to the end of the String.

#### `STR_printf`

```c
fio_str_info_s STR_printf(FIO_STR_PTR s, const char *format, ...);
```

Writes to the String using a printf like interface.

Data is written to the end of the String.

#### `STR_readfd`

```c
fio_str_info_s STR_readfd(FIO_STR_PTR s,
                            int fd,
                            intptr_t start_at,
                            intptr_t limit);
```

Reads data from a file descriptor `fd` at offset `start_at` and pastes it's contents (or a slice of it) at the end of the String. If `limit == 0`, than the data will be read until EOF.

The file should be a regular file or the operation might fail (can't be used for sockets).

**Note**: the file descriptor will remain open and should be closed manually.

#### `STR_readfile`

```c
fio_str_info_s STR_readfile(FIO_STR_PTR s,
                            const char *filename,
                            intptr_t start_at,
                            intptr_t limit);
```

Opens the file `filename` and pastes it's contents (or a slice of it) at the end of the String. If `limit == 0`, than the data will be read until EOF.

If the file can't be located, opened or read, or if `start_at` is beyond the EOF position, NULL is returned in the state's `data` field.

### String API - Base64 support

#### `STR_write_base64enc`

```c
fio_str_info_s STR_write_base64enc(FIO_STR_PTR s,
                                    const void *data,
                                    size_t data_len,
                                    uint8_t url_encoded);
```

Writes data at the end of the String, encoding the data as Base64 encoded data.

#### `STR_write_base64dec`

```c
fio_str_info_s STR_write_base64dec(FIO_STR_PTR s,
                                    const void *encoded,
                                    size_t encoded_len);
```

Writes decoded Base64 data to the end of the String.


### String API - escaping / JSON encoding support

#### `STR_write_escape`

```c
fio_str_info_s STR_write_escape(FIO_STR_PTR s,
                                const void *data,
                                size_t data_len);

```

Writes data at the end of the String, escaping the data using JSON semantics.

The JSON semantic are common to many programming languages, promising a UTF-8 String while making it easy to read and copy the string during debugging.

#### `STR_write_unescape`

```c
fio_str_info_s STR_write_unescape(FIO_STR_PTR s,
                                  const void *escaped,
                                  size_t len);
```

Writes an escaped data into the string after unescaping the data.

### String API - HTML escaping support


#### `STR_write_html_escape`

```c
fio_str_info_s STR_write_html_escape(FIO_STR_PTR s,
                                     const void *data,
                                     size_t data_len);

```

Writes HTML escaped data to a String.

#### `STR_write_html_unescape`

```c
fio_str_info_s STR_write_html_unescape(FIO_STR_PTR s,
                                       const void *escaped,
                                       size_t len);
```

Writes HTML un-escaped data to a String - incomplete and minimal.

**Note**: the un-escaping of HTML content includes a long list of named code-points. This list isn't handled here, instead only numerical and super-basic named code-points are supported.

-------------------------------------------------------------------------------
## Dynamic Arrays

```c
#define FIO_ARRAY_NAME str_ary
#define FIO_ARRAY_TYPE char *
#define FIO_ARRAY_TYPE_CMP(a,b) (!strcmp((a),(b)))
#include "fio-stl.h"
```

Dynamic arrays are extremely common and useful data structures.

In essence, Arrays are blocks of memory that contain all their elements "in a row". They grow (or shrink) as more items are added (or removed).

Items are accessed using a numerical `index` indicating the element's position within the array.

Indexes are zero based (first element == 0).

**Note:** The dynamic array implementation provided limits the array's capacity to 31bits ((1<<31) - 1).

### Dynamic Array Performance

Seeking time is an extremely fast O(1). Arrays are also very fast to iterate since they enjoy high memory locality.

Adding and editing items is also a very fast O(1), especially if enough memory was previously reserved. Otherwise, memory allocation and copying will slow performance.

However, arrays suffer from slow find operations. Find has a worst case scenario O(n) cost.

They also suffer from slow item removal (except, in our case, for `pop` / `unshift` operations), since middle-element removal requires memory copying when fixing the "hole" made in the array.

A common solution is to reserve a value for "empty" elements and `set` the element's value instead of `remove` the element.

**Note**: unlike some dynamic array implementations, this STL implementation doesn't grow exponentially. Using the `ARY_reserve` function is highly encouraged for performance.


### Dynamic Array Overview

To create a dynamic array type, define the type name using the `FIO_ARRAY_NAME` macro. i.e.:

```c
#define FIO_ARRAY_NAME int_ary
```

Next (usually), define the `FIO_ARRAY_TYPE` macro with the element type. The default element type is `void *`. For example:

```c
#define FIO_ARRAY_TYPE int
```

For complex types, define any (or all) of the following macros:

```c
// set to adjust element copying 
#define FIO_ARRAY_TYPE_COPY(dest, src)  
// set for element cleanup 
#define FIO_ARRAY_TYPE_DESTROY(obj)     
// set to adjust element comparison 
#define FIO_ARRAY_TYPE_CMP(a, b)        
// set to adjust element copying during concat operations
#define FIO_ARRAY_TYPE_CONCAT_COPY(dest, src)
// to be returned when `index` is out of bounds / holes 
#define FIO_ARRAY_TYPE_INVALID 0 
// set ONLY if the invalid element is all zero bytes 
#define FIO_ARRAY_TYPE_INVALID_SIMPLE 1     
// should the object be destroyed when copied to an `old` pointer?
#define FIO_ARRAY_DESTROY_AFTER_COPY 1 
// when array memory grows, how many extra "spaces" should be allocated?
#define FIO_ARRAY_PADDING 4 
// should the array growth be exponential? (ignores FIO_ARRAY_PADDING)
#define FIO_ARRAY_EXPONENTIAL 0 
// optimizes small arrays (mostly tuplets and single item arrays).
// note: values larger than 1 add a memory allocation cost to the array container
#define FIO_ARRAY_ENABLE_EMBEDDED 1
```

For string arrays, the `FIO_ARRAY_TYPE_STR` macro can be used as a shortcut:

```c
// Automatically sets up FIO_ARRAY_TYPE, FIO_ARRAY_TYPE_COPY, 
// FIO_ARRAY_TYPE_DESTROY, FIO_ARRAY_TYPE_CMP, and FIO_ARRAY_DESTROY_AFTER_COPY
// for fio_keystr_s string types
#define FIO_ARRAY_TYPE_STR
```

To create the type and helper functions, include The facil.io library header.

For example:

```c
typedef struct {
  int i;
  float f;
} foo_s;

#define FIO_ARRAY_NAME ary
#define FIO_ARRAY_TYPE foo_s
#define FIO_ARRAY_TYPE_CMP(a,b) (a.i == b.i && a.f == b.f)
#include "fio-stl/include.h"

void example(void) {
  ary_s a = FIO_ARRAY_INIT;
  foo_s *p = ary_push(&a, (foo_s){.i = 42});
  FIO_ARRAY_EACH(ary, &a, pos) { // pos will be a pointer to the element
    fprintf(stderr, "* [%zu]: %p : %d\n", (size_t)(pos - ary2ptr(&a)), (void *)pos, pos->i);
  }
  ary_destroy(&a);
}
```

### Dynamic Arrays - API

#### The Array Type (`ARY_s`)

```c
typedef struct {
  uint32_t start;  /* the offset to the first item */
  uint32_t end;    /* the offset to the first empty location */
  uint32_t capa;   /* the array's capacity */
  FIO_ARRAY_TYPE *ary;  /* pointer to the array's memory (if not embedded) */
} FIO_NAME(FIO_ARRAY_NAME, s); /* ARY_s in these docs */
```

The array type should be considered opaque. Use the helper functions to update the array's state when possible, even though the array's data is easily understood and could be manually adjusted as needed.

#### `FIO_ARRAY_INIT`

````c
#define FIO_ARRAY_INIT  {0}
````

This macro initializes an uninitialized array object.

#### `ARY_destroy`

````c
void ARY_destroy(ARY_s * ary);
````

Destroys any objects stored in the array and frees the internal state.

#### `ARY_new`

````c
ARY_s * ARY_new(void);
````

Allocates a new array object on the heap and initializes it's memory.

#### `ARY_free`

````c
void ARY_free(ARY_s * ary);
````

Frees an array's internal data AND it's container!

#### `ARY_count`

````c
uint32_t ARY_count(ARY_s * ary);
````

Returns the number of elements in the Array.

#### `ARY_capa`

````c
uint32_t ARY_capa(ARY_s * ary);
````

Returns the current, temporary, array capacity (it's dynamic).

#### `ARY_embedded`

````c
int ARY_embedded(ARY_s * ary);
````

Returns 1 if the array is embedded, 0 if it has memory allocated and -1 on an error.

#### `ARY_ptr`

````c
FIO_ARRAY_TYPE * ARY_ptr(ARY_s * ary);
````

Returns a pointer to the C array containing the objects.

#### `ARY_reserve`

```c
uint32_t ARY_reserve(ARY_s * ary, int64_t capa);
```

Reserves capacity for new members to be added to the array.

If `capa` is negative, new memory will be allocated at the beginning of the array rather then it's end.

Returns the array's new capacity.

#### `ARY_concat`

```c
ARY_s * ARY_concat(ARY_s * dest, ARY_s * src);
```

Adds all the items in the `src` Array to the end of the `dest` Array.

The `src` Array remain untouched.

Always returns the destination array (`dest`).

#### `ARY_set`

```c
FIO_ARRAY_TYPE * ARY_set(ARY_s * ary,
                       int64_t index,
                       FIO_ARRAY_TYPE data,
                       FIO_ARRAY_TYPE *old);
```

Sets `index` to the value in `data`.

If `index` is negative, it will be counted from the end of the Array (-1 == last element).

If `old` isn't NULL, the existing data will be copied to the location pointed to by `old` before the copy in the Array is destroyed.

Returns a pointer to the new object, or NULL on error.

#### `ARY_get`

```c
FIO_ARRAY_TYPE ARY_get(ARY_s * ary, int64_t index);
```

Returns the value located at `index` (no copying is performed).

If `index` is negative, it will be counted from the end of the Array (-1 == last element).

**Reminder**: indexes are zero based (first element == 0).

#### `ARY_find`

```c
uint32_t ARY_find(ARY_s * ary, FIO_ARRAY_TYPE data, int64_t start_at);
/* When an object can't be founds, this is the returned value. */
#define FIO_ARRAY_NOT_FOUND ((uint32_t)-1)
```

Returns the index of the object or `FIO_ARRAY_NOT_FOUND` (`(uint32_t)-1`) if the object wasn't found.

If `start_at` is negative (i.e., -1), than seeking will be performed in reverse, where -1 == last index (-2 == second to last, etc').

#### `ARY_remove`
```c
int ARY_remove(ARY_s * ary, int64_t index, FIO_ARRAY_TYPE *old);
```

Removes an object from the array, MOVING all the other objects to prevent "holes" in the data.

If `old` is set, the data is copied to the location pointed to by `old` before the data in the array is destroyed.

Returns 0 on success and -1 on error.

This action is O(n) where n in the length of the array. It could get expensive.

#### `ARY_remove2`

```c
uint32_t ARY_remove2(ARY_S * ary, FIO_ARRAY_TYPE data);
```

Removes all occurrences of an object from the array (if any), MOVING all the existing objects to prevent "holes" in the data.

Returns the number of items removed.

This action is O(n) where n in the length of the array. It could get expensive.

#### `ARY_compact`
```c
void ARY_compact(ARY_s * ary);
```

Attempts to lower the array's memory consumption.

#### `ARY_push`

```c
FIO_ARRAY_TYPE * ARY_push(ARY_s * ary, FIO_ARRAY_TYPE data);
```

 Pushes an object to the end of the Array. Returns a pointer to the new object or NULL on error.

#### `ARY_pop`

```c
int ARY_pop(ARY_s * ary, FIO_ARRAY_TYPE *old);
```

Removes an object from the end of the Array.

If `old` is set, the data is copied to the location pointed to by `old` before the data in the array is destroyed.

Returns -1 on error (Array is empty) and 0 on success.

#### `ARY_unshift`

```c
FIO_ARRAY_TYPE *ARY_unshift(ARY_s * ary, FIO_ARRAY_TYPE data);
```

Unshifts an object to the beginning of the Array. Returns a pointer to the new object or NULL on error.

This could be expensive, causing `memmove`.

#### `ARY_shift`

```c
int ARY_shift(ARY_s * ary, FIO_ARRAY_TYPE *old);
```

Removes an object from the beginning of the Array.

If `old` is set, the data is copied to the location pointed to by `old` before the data in the array is destroyed.

Returns -1 on error (Array is empty) and 0 on success.

#### `ARY_each`

```c
uint32_t ARY_each(ARY_s * ary,
                  int (*task)(ARY_each_s * info),
                  void *udata,
                  int64_t start_at);
```

Iteration using a callback for each entry in the array.

The callback task function must accept an `ARY_each_s` pointer (name matches Array name).

If the callback returns -1, the loop is broken. Any other value is ignored.

Returns the relative "stop" position (number of items processed + starting point).

The `ARY_each_s` data structure looks like this:

```c
/** Iteration information structure passed to the callback. */
typedef struct ARY_each_s {
  /** The array iterated. Once set, cannot be safely changed. */
  FIO_ARRAY_PTR const parent;
  /** The current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct ARY_each_s * info);
  /** Opaque user data. */
  void *udata;
  /** The object / value at the current index. */
  FIO_ARRAY_TYPE value;
  /* memory padding used for FIOBJ */
  uint64_t padding;
} ARY_each_s;
```

#### `ARY_each_next`

```c
FIO_ARRAY_TYPE * ARY_each_next(ARY_s* ary,
                               FIO_ARRAY_TYPE **first,
                               FIO_ARRAY_TYPE *pos);
```

Returns a pointer to the (next) object in the array.

Returns a pointer to the first object if `pos == NULL` and there are objects in the array.

The first pointer is automatically set and it allows object insertions and memory effecting functions to be called from within the loop.

If the object in `pos` (or an object before it) were removed, consider passing `pos-1` to the function, to avoid skipping any elements while looping.

Returns the next object if both `first` and `pos` are valid.

Returns `NULL` if `pos` was the last object or no object exist.

Returns the first object if either `first` or `pos` are invalid.

#### `FIO_ARRAY_EACH`

```c
#define FIO_ARRAY_EACH(array_name, array, pos)                                 \
  for (FIO_NAME(array_name, ____type_t)                                        \
           *first___ai = NULL,                                                 \
           *pos = FIO_NAME(array_name, each_next)((array), &first___ai, NULL); \
       pos;                                                                    \
       pos = FIO_NAME(array_name, each_next)((array), &first___ai, pos))
```

Iterates through the array using a `for` loop.

Access the object with the pointer `pos`. The `pos` variable can be named however you please.

Avoid editing the array during a FOR loop, although I hope it's possible, I wouldn't count on it.

**Note**: this macro supports automatic pointer tagging / untagging.

-------------------------------------------------------------------------------
## Hash Tables and Maps

HashMaps (a.k.a., Hash Tables) and sets are extremely useful and common mapping / dictionary primitives, also sometimes known as "**dictionaries**".

Hash maps use both a `hash` and a `key` to identify a `value`. The `hash` value is calculated by feeding the key's data to a hash function (such as Risky Hash or SipHash).

A hash map without a `value` is known as a Set or a Bag. It uses only a `hash` and a `key` to access the same `key` in the Set. Since Sets promise that all objects in the Set are unique, they offer a pretty powerful tool often used for cache collections or for filtering out duplicates from other data sources.

By default, if not defined differently, facil.io maps use String data as the `key`. If a `FIO_MAP_VALUE` type is not defined, than the default behavior is to create a Set rather than a Dictionary.

```c
/* Set the properties for the key-value Hash Map type called `dict_s` */
#define FIO_MAP_NAME                 dict
#define FIO_MAP_VALUE_BSTR /* a special macro helper to define binary Strings as values */
#define FIO_RAND           /* to provide us with a hash function. */
#include "fio-stl.h"

/* it is often more secure to "salt" the hashing function with a per-map salt, and so: */

/** set helper for consistent and secure hash values */
FIO_IFUNC fio_str_info_s dict_set2(dict_s *m, fio_str_info_s key, fio_str_info_s obj) {
  return dict_set(m, fio_risky_hash(key.buf, key.len, (uint64_t)m), key, obj, NULL);
}
/** conditional set helper for consistent and secure hash values */
FIO_IFUNC fio_str_info_s dict_set_if_missing2(dict_s *m,
                                              fio_str_info_s key,
                                              fio_str_info_s obj) {
  return dict_set_if_missing(m, fio_risky_hash(key.buf, key.len, (uint64_t)m), key, obj);
}
/** get helper for consistent and secure hash values */
FIO_IFUNC fio_str_info_s dict_get2(dict_s *m, fio_str_info_s key) {
  return dict_get(m, fio_risky_hash(key.buf, key.len, (uint64_t)m), key);
}
```

Note that this Map implementation, like all dynamic type templates, supports optional pointer tagging (`FIO_PTR_TAG`) and reference counting (`FIO_REF_NAME`).

### Defining the Map's Keys

Every map / dictionary requires a `key` type that is used for either testing uniqueness (a Set) or accessing a `value` (a Hash Map or Dictionary).

If the `key` type is left undefined (or the `FIO_MAP_KEY_BSTR` macro is defined), the map's API will expect a `fio_str_info_s` as a key and facil.io will default to a String key using the `fio_bstr` functions to allocate, manage and free strings. These strings are always `NUL` terminated and always allocated dynamically.

It is also possible to define the helper macro `FIO_MAP_KEY_KSTR` in which case the Strings internally will use the `fio_keystr` API, which has a special small string optimization for strings up to 14 bytes (on 64bit systems) before allocating memory (while adding an allocation overhead to the map itself). This could improve performance by improving cache locality.

To use a custom `key` type and control its behavior, define any (or all) of the following macros before including the C STL header library (the `FIO_MAP_KEY` macro is required in order to make changes):

#### `FIO_MAP_KEY`

```c
/* default when FIO_MAP_KEY is undefined */
#define FIO_MAP_KEY  fio_str_info_s
```

The "external" / exposed type used to define the key. The external type is the type used by the API for inputting and reviewing key values. However, `FIO_MAP_KEY_INTERNAL` may be (optionally) defined in order for the map to use a different type for storage purposes.

If undefined, keys will be a binary safe buffer / string (`fio_str_info_s`). Internally the implementation will use the `fio_bstr` API to allocate, store and free copies of each key.

#### `FIO_MAP_KEY_INTERNAL`

```c
/* default when FIO_MAP_KEY is defined */
#define FIO_MAP_KEY_INTERNAL FIO_MAP_KEY
/* default when FIO_MAP_KEY is undefined or FIO_MAP_KEY_BSTR is defined */
#define FIO_MAP_KEY_INTERNAL char *
```

The `FIO_MAP_KEY_INTERNAL`, if defined, allows the map to use an internal key storage type that is different than the type used for its external API, allowing for both a more convenient API and possible internal updates without API changes.

#### `FIO_MAP_KEY_FROM_INTERNAL`

```c
/* default when FIO_MAP_KEY is defined */
#define FIO_MAP_KEY_FROM_INTERNAL(k) k
/* default when FIO_MAP_KEY is undefined or FIO_MAP_KEY_BSTR is defined */
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_bstr_info((k))
```

This macro converts between the Map's internal `key` storage type and the API representation.


#### `FIO_MAP_KEY_COPY`

```c
/* default when FIO_MAP_KEY is defined */
#define FIO_MAP_KEY_COPY(dest, src) (dest) = (src)
/* default when FIO_MAP_KEY is undefined or FIO_MAP_KEY_BSTR is defined */
#define FIO_MAP_KEY_COPY(dest, src) (dest) = fio_bstr_write(NULL, (src).buf, (src).len)
```

This macro copies the Map's external representation of the `key` (as defined by the API) into the map's internal `key` storage.

#### `FIO_MAP_KEY_CMP`

```c
/* default when FIO_MAP_KEY is defined */
#define FIO_MAP_KEY_CMP(internal, external) (internal) == (external)
/* default when FIO_MAP_KEY is undefined or FIO_MAP_KEY_BSTR is defined */
#define FIO_MAP_KEY_CMP(internal, external) fio_bstr_is_eq2info((internal), (external))
```

This macro compares a Map's external representation of a `key` (as defined by the API) with a `key` stored in the map's internal storage.

#### `FIO_MAP_KEY_DESTROY`

```c
/* default when FIO_MAP_KEY is defined */
#define FIO_MAP_KEY_DESTROY(key)
/* default when FIO_MAP_KEY is undefined or FIO_MAP_KEY_BSTR is defined */
#define FIO_MAP_KEY_DESTROY(key) fio_bstr_free((key))
```

This macro destroys a `key` stored in the map's internal storage. This means freeing any allocated resources. The map will ignore any remaining junk data.

#### `FIO_MAP_KEY_DISCARD`

```c
/* default does nothing */
#define FIO_MAP_KEY_DISCARD(key)
```

This macro destroys an external representation of a `key` if it didn't make it into the map's internal storage.

This is useful in when the key was pre-allocated, if it's reference was increased in advance for some reason or when "transferring ownership" of the `key` to the map.


#### `FIO_MAP_KEY_KSTR`

```c
#ifdef FIO_MAP_KEY_KSTR
#define FIO_MAP_KEY                  fio_str_info_s
#define FIO_MAP_KEY_INTERNAL         fio_keystr_s
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_keystr_info(&(k))
#define FIO_MAP_KEY_COPY(dest, src)  (dest) = fio_keystr_init((src), ...)
#define FIO_MAP_KEY_CMP(a, b)        fio_keystr_is_eq2((a), (b))
#define FIO_MAP_KEY_DESTROY(key)      fio_keystr_destroy(&(key), FIO_NAME(FIO_MAP_NAME, __key_free))
#define FIO_MAP_KEY_DISCARD(key)
```

If `FIO_MAP_KEY` isn't set, or `FIO_MAP_KEY_KSTR` is explicitly defined, than a `fio_str_info_s` will be the external key type and `fio_keystr_s` will be the internal key type.

Passing a key with `key.capa == (size_t)-1` will prevent a string copy and the map will assume that the string will stay in the same memory address for the whole of the map's lifetime.

### Naming Shortcuts

#### `FIO_OMAP_NAME` / `FIO_UMAP_NAME`

```c
#define FIO_OMAP_NAME my_ordered_map   /* creates an ordered map */
#define FIO_UMAP_NAME my_unordered_map /* creates an unordered map */
```

These macros provide shortcuts for defining ordered or unordered maps without explicitly setting `FIO_MAP_ORDERED`:

- `FIO_OMAP_NAME` - defines `FIO_MAP_NAME` and sets `FIO_MAP_ORDERED` to `1`
- `FIO_UMAP_NAME` - defines `FIO_MAP_NAME` and sets `FIO_MAP_ORDERED` to `0`

### Defining the Map's Values

Most often we want a dictionary or a hash map to retrieve a `value` based on its associated `key`.

Values and their behavior can be controlled using similar macros to the `key` macros.

#### `FIO_MAP_VALUE_BSTR`

```c
#ifdef FIO_MAP_VALUE_BSTR
#define FIO_MAP_VALUE                  fio_str_info_s
#define FIO_MAP_VALUE_INTERNAL         char *
#define FIO_MAP_VALUE_FROM_INTERNAL(v) fio_bstr_info((v))
#define FIO_MAP_VALUE_COPY(dest, src)                                     \
  (dest) = fio_bstr_write(NULL, (src).buf, (src).len)
#define FIO_MAP_VALUE_DESTROY(v) fio_bstr_free((v))
#define FIO_MAP_VALUE_DISCARD(v)
#endif
```

This is a shortcut macro that sets the values to String objects. The strings are binary safe (may contain multiple `NUL` values) and are always `NUL` terminated (for extra safety).

#### `FIO_MAP_VALUE`

```c
/* poor example */
#define FIO_MAP_VALUE void *
```

Similar to `FIO_MAP_KEY`, defines the (external) representation of a Map's `value`.

**Note**: a common `value` is the `void *` pointer. However, this does not provide type safety, and so it is better to use a specific type for the `value`.

#### `FIO_MAP_VALUE_INTERNAL`

```c
/* default when FIO_MAP_VALUE is defined */
#define FIO_MAP_VALUE_FROM_INTERNAL(o) o
```

Similar to `FIO_MAP_KEY_FROM_INTERNAL`, this macro converts between the Map's internal `value` storage type and the API representation.

#### `FIO_MAP_VALUE_COPY`

```c
/* default when FIO_MAP_VALUE is defined */
#define FIO_MAP_VALUE_COPY(internal, external) (internal) = (external)
```

Similar to `FIO_MAP_KEY_COPY`, this macro copies the Map's external representation of the `value` (as defined by the API) into the map's internal `value` storage.


#### `FIO_MAP_VALUE_DESTROY`

```c
/* default when FIO_MAP_VALUE is defined */
#define FIO_MAP_VALUE_DESTROY(o)
#define FIO_MAP_VALUE_DESTROY_SIMPLE 1
```

Similar to `FIO_MAP_KEY_DESTROY`, this macro destroys a `value` stored in the map's internal storage. This means freeing any allocated resources. The map will ignore any remaining junk data.

#### `FIO_MAP_VALUE_DISCARD`

```c
/* default when FIO_MAP_VALUE is defined */
#define FIO_MAP_VALUE_DISCARD(o)
```

Similar to `FIO_MAP_KEY_DISCARD`, this macro destroys the external representation of the `value` if it didn't make it into the map's internal storage.

### Hash Calculations and Security

The map implementation offers protection against too many full collisions or non-random hashes that can occur with poor hash functions or when the Map is attacked. When the map detects a possible "attack", it will start overwriting existing data instead of trying to resolve collisions.

This can be adjusted using the `FIO_MAP_ATTACK_LIMIT` macro which usually allows up to 16 full hash collisions before assuming the map is being attacked, thus giving leeway for faster yet less secure hashing functions.

#### `FIO_MAP_ATTACK_LIMIT`

```c
/* default: */
#define FIO_MAP_ATTACK_LIMIT 16
```

Sets the maximum number of full hash collisions allowed before the map assumes it is under attack and starts overwriting existing data instead of resolving collisions.

When using unsafe input data as the Map `key`, it is still better to manually manage the hashing function by salting it with a map specific value (such as the map's pointer). Then helpers can be used to make sure the code remains DRY.

For example:

```c
/* Set the properties for the key-value Hash Map type called `dict_s` */
#define FIO_MAP_NAME                 dict
#define FIO_MAP_VALUE_BSTR /* a special macro helper to define binary Strings as values */
#define FIO_RAND           /* to provide us with a hash function. */
#include "fio-stl.h"

/* it is often more secure to "salt" the hashing function with a per-map salt, and so: */

/** set helper for consistent and secure hash values */
FIO_IFUNC fio_str_info_s dict_set2(dict_s *m, fio_str_info_s key, fio_str_info_s obj) {
  return dict_set(m, fio_risky_hash(key.buf, key.len, (uint64_t)m), key, obj, NULL);
}
/** conditional set helper for consistent and secure hash values */
FIO_IFUNC fio_str_info_s dict_set_if_missing2(dict_s *m,
                                              fio_str_info_s key,
                                              fio_str_info_s obj) {
  return dict_set_if_missing(m, fio_risky_hash(key.buf, key.len, (uint64_t)m), key, obj);
}
/** get helper for consistent and secure hash values */
FIO_IFUNC fio_str_info_s dict_get2(dict_s *m, fio_str_info_s key) {
  return dict_get(m, fio_risky_hash(key.buf, key.len, (uint64_t)m), key);
}
```

#### `FIO_MAP_HASH_FN`

However, when using safe input or a secure enough hashing function, it makes sense to simplify the API the template produces by having the template automatically calculate the hash.

We can add a lower level of security to this approach by salting the hash with a runtime constant that changes every time we restart the program, such as the memory address of one of the function in the program.

This can be done using the `FIO_MAP_HASH_FN(external_key)` macro i.e.:

```c
/* Set the properties for the key-value Hash Map type called `dict_s` */
#define FIO_MAP_NAME                 dict
#define FIO_MAP_VALUE_BSTR /* a special macro helper to define binary Strings as values. */
#define FIO_RAND           /* to provide us with a hash function. */

/* use any non-inlined function's address as a hash salt. Here `dict_destroy` is used. */
#define FIO_MAP_HASH_FN(ex_key)                                   \
        fio_risky_hash(ex_key.buf,                                \
           ex_key.len,                                            \
           (uint64_t)(dict_destroy) /* function address as salt */\
           )

#include "fio-stl.h"
```

**Default**: by default the `FIO_MAP_HASH_FN` is empty, which means all the API calls require a hash to be pre-computed by the user and passed to the function.

#### `FIO_MAP_RECALC_HASH`

```c
/* default: */
#define FIO_MAP_RECALC_HASH 0
```

Sometimes hashing can be very fast. A good example is when hashing pointer or integer values. In these cases, it makes sense to recalculate the hash rather than spend memory on caching it.

Since the Map always caches an 8 bits permutation of the hash, it is often possible to avoid spending the additional overhead of 8 bytes per-object by setting `FIO_MAP_RECALC_HASH` to `1` (true).

This, of course, requires that the `FIO_MAP_HASH_FN(key)` macro be defined, or the map will not know how to recalculate the hash and instead cache the information.

**Default**: always remembers the hash value, unless both `FIO_MAP_RECALC_HASH` and `FIO_MAP_HASH_FN` are set.

#### `FIO_MAP_CAPA_BITS_LIMIT`

```c
/* default: */
#define FIO_MAP_CAPA_BITS_LIMIT 31
```

Sets the maximum number of bits used for map capacity. The default of 31 allows for maps with up to 2^31 (approximately 2 billion) elements. This cannot exceed 31 bits unless the internal code is rewritten.

### Ordering and Performance

The facil.io implementation supports FIFO (First In First Out) and LRU (Least Recently Used) ordering scheme, allowing to `map_evict` any number of possibly "stale" elements, offering an initial caching solution that can be expanded upon.

Obviously these additional ordering details require more memory per object (8 additional bytes) and additional CPU cycles for ordering management. Although the performance price isn't big, by default Maps / Dictionaries are unordered.

#### `FIO_MAP_ORDERED` 

If defined without a value or with a true value, the Set / Map / Dictionary will be ordered (FIFO unless otherwise specified).

A shortcut to define on ordered map would be to use the `FIO_OMAP_NAME` and `FIO_UMAP_NAME` naming macros instead of the `FIO_MAP_NAME` naming macro.

```c
#if defined(FIO_UMAP_NAME)
#define FIO_MAP_NAME FIO_UMAP_NAME
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 0
#elif defined(FIO_OMAP_NAME)
#define FIO_MAP_NAME FIO_OMAP_NAME
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 1
#endif
```

#### `FIO_MAP_LRU`

If defined, the Set / Map / Dictionary will be ordered using a Least Recently Used approach. This means that iteration will start with the most important element (most recently used) while eviction will start with the most stale element (least recently used).

Auto eviction will be performed once the map reaches `FIO_MAP_LRU` elements.

i.e.,

```c
#define FIO_MAP_LRU (1ULL << 16) /* limits the map to 65,536 elements. */
```

### The Map Types

Each template implementation defines the following main types (named here assuming `FIO_MAP_NAME` is defined as `map`).

#### `FIO_MAP_INIT`

```c
#define FIO_MAP_INIT { 0 }
```

Initialization macro for stack-allocated or embedded map objects.

#### `map_s`

The Map's container (actual type). This should be considered an opaque type and access / mutation should be performed using the published API.

```c
typedef struct {
  uint32_t bits;
  uint32_t count;
  FIO_NAME(FIO_MAP_NAME, node_s) * map;
#if FIO_MAP_ORDERED
  FIO_INDEXED_LIST32_HEAD head;
#endif
} FIO_NAME(FIO_MAP_NAME, s);
```

#### `map_node_s`

This defines the internal object representation and should be considered to be an opaque type.

When a pointer to a node in the internal map is returned (such as when calling `map_get_ptr` or `map_set_ptr`, accessing the data in the type should be performed using the helper functions: `map_node2key(node_ptr)`, `map_node2hash(node_ptr)` and `map_node2val(node_ptr)`.

```c
typedef struct {
#if !FIO_MAP_RECALC_HASH
  uint64_t hash;
#endif
  FIO_MAP_KEY_INTERNAL key;
#ifdef FIO_MAP_VALUE
  FIO_MAP_VALUE_INTERNAL value;
#endif
#if FIO_MAP_ORDERED
  FIO_INDEXED_LIST32_NODE node;
#endif
} FIO_NAME(FIO_MAP_NAME, node_s);
```

#### `map_iterator_s`

```c
typedef struct {
  /** the node in the internal map */
  FIO_NAME(FIO_MAP_NAME, node_s) * node;
  /** the key in the current position */
  FIO_MAP_KEY key;
#ifdef FIO_MAP_VALUE
  /** the value in the current position */
  FIO_MAP_VALUE value;
#endif
#if !FIO_MAP_RECALC_HASH
  /** the hash for the current position */
  uint64_t hash;
#endif
  struct {                   /* internal usage, do not access */
    uint32_t index;          /* the index in the internal map */
    uint32_t pos;            /* the position in the ordering scheme */
    uintptr_t map_validator; /* map mutation guard */
  } private_;
} FIO_NAME(FIO_MAP_NAME, iterator_s);
```

An iterator type represents a specific object and position in the Hash. The object data is valid as long as the object was not removed from the Map and the position is valid for as long as the Map didn't reallocate the internal storage (avoid adding new objects to the map while iterating).

The `node` field provides direct access to the internal node storage, which can be used with the `map_node2key`, `map_node2val`, and `map_node2hash` helper functions.

### Construction / Deconstruction

#### `map_new`

```c
FIO_MAP_PTR map_new(void);
```

Allocates a new object on the heap and initializes it's memory.

#### `map_free`

```c
void map_free(FIO_MAP_PTR map);
```

Frees any internal data AND the object's container!

#### `map_destroy`

```c
void map_destroy(FIO_MAP_PTR map);
```

Destroys the object, re-initializing its container.

### Map State

#### `map_capa`

```c
uint32_t map_capa(FIO_MAP_PTR map);
```

Theoretical map capacity.

#### `map_count`

```c
uint32_t map_count(FIO_MAP_PTR map);
```

The number of objects in the map capacity.

#### `map_reserve`

```c
void map_reserve(FIO_MAP_PTR map, size_t capa);
```

Reserves at minimum the capacity requested for new members. May reserve more than the capacity requested.

### Node Helper Functions

These functions help access data from node pointers returned by `map_get_ptr` or `map_set_ptr`.

#### `map_node2key`

```c
FIO_MAP_KEY map_node2key(map_node_s *node);
```

Returns the key value associated with the node's pointer.

**Parameters:**
- `node` - pointer to a node in the map's internal storage

**Returns:** the key value, or a zeroed key if `node` is NULL.

#### `map_node2hash`

```c
uint64_t map_node2hash(map_node_s *node);
```

Returns the hash value associated with the node's pointer.

**Parameters:**
- `node` - pointer to a node in the map's internal storage

**Returns:** the hash value, or 0 if `node` is NULL.

**Note**: if `FIO_MAP_RECALC_HASH` is set, the hash is recalculated using `FIO_MAP_HASH_FN`.

#### `map_node2val`

```c
FIO_MAP_VALUE map_node2val(map_node_s *node);
/* For Sets (no FIO_MAP_VALUE defined), returns the key instead */
FIO_MAP_KEY map_node2val(map_node_s *node);
```

Returns the value associated with the node's pointer. For Sets (where no `FIO_MAP_VALUE` is defined), this returns the key.

**Parameters:**
- `node` - pointer to a node in the map's internal storage

**Returns:** the value (or key for Sets), or a zeroed value if `node` is NULL.

#### `map_node2key_ptr`

```c
FIO_MAP_KEY_INTERNAL *map_node2key_ptr(map_node_s *node);
```

Returns a pointer to the internal key storage associated with the node.

**Parameters:**
- `node` - pointer to a node in the map's internal storage

**Returns:** pointer to the internal key, or NULL if `node` is NULL.

**Note**: this returns a pointer to the internal storage type, not the external API type.

#### `map_node2val_ptr`

```c
FIO_MAP_VALUE_INTERNAL *map_node2val_ptr(map_node_s *node);
/* For Sets (no FIO_MAP_VALUE defined), returns pointer to key instead */
FIO_MAP_KEY_INTERNAL *map_node2val_ptr(map_node_s *node);
```

Returns a pointer to the internal value storage associated with the node. For Sets (where no `FIO_MAP_VALUE` is defined), this returns a pointer to the key.

**Parameters:**
- `node` - pointer to a node in the map's internal storage

**Returns:** pointer to the internal value (or key for Sets), or NULL if `node` is NULL.

**Note**: this returns a pointer to the internal storage type, not the external API type.

### Adding / Removing Elements from the Map

The signature of some of these functions may change according to the template macors defined. For example, if the `FIO_MAP_HASH_FN(k)` was already defined than the Map's API will not require it as an argument. Also, since Sets do not have a `value` that is not the same as the `key` (unlike Dictionaries), than there is no reason to require an additional `value` argument.

#### `map_get`

```c
MAP_KEY_OR_VAL map_get(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                         uint64_t hash,
#endif
                                         FIO_MAP_KEY key);
```

Gets a value from the map, if exists. For Sets, the `key` is returned (since it is also the value).

#### `map_set`

```c
MAP_KEY_OR_VAL map_set(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                         uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                         FIO_MAP_KEY key,
                         FIO_MAP_VALUE obj,
                         FIO_MAP_VALUE_INTERNAL *old
#else
                         FIO_MAP_KEY key
#endif
                        );
```

Sets a value in the map. Maps / Dictionaries will overwrite existing data if any. Sets never overwrite existing data.

#### `map_set_if_missing`

```c
MAP_KEY_OR_VAL map_set_if_missing(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                    uint64_t hash,
#endif
                                    FIO_MAP_KEY key
#ifdef FIO_MAP_VALUE
                                  , FIO_MAP_VALUE obj
#endif
);
```

Sets a value in the map if not set previously.

#### `map_remove`

```c
int map_remove(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
              uint64_t hash,
#endif
              FIO_MAP_KEY key,
#ifdef FIO_MAP_VALUE
              FIO_MAP_VALUE_INTERNAL *old
#else
              FIO_MAP_KEY_INTERNAL *old
#endif
              );
```

Removes an object in the map, returning -1 if the object couldn't be found or 0 on success.

#### `map_evict`

```c
void map_evict(FIO_MAP_PTR map, size_t number_of_elements);
```

Evicts elements in the order defined by the template:
* If `FIO_MAP_LRU` was defined - evicts the most Least Recently Used (LRU) elements.
* If `FIO_MAP_ORDERED` is true - evicts the first elements inserted (FIFO).
* Otherwise eviction order is undefined. An almost random eviction will occur with neighboring items possibly being evicted together.

#### `map_clear`

```c
void map_clear(FIO_MAP_PTR map);
```

Removes all objects from the map, without releasing the map's resources.

#### `map_compact`

```c
void map_compact(FIO_MAP_PTR map);
```

Attempts to minimize memory use by shrinking the internally allocated memory used for the map.

#### `map_set_ptr`

```c
map_node_s * map_set_ptr(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                         uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                         FIO_MAP_KEY key,
                         FIO_MAP_VALUE val,
                         FIO_MAP_VALUE_INTERNAL *old,
                         int overwrite
#else
                         FIO_MAP_KEY key
#endif
                        );
```

The core set function.

This function returns `NULL` on error (errors are logged).

If the map is a hash map, overwriting the value (while keeping the key) is possible. In this case the `old` pointer is optional, and if set than the old data will be copied to over during an overwrite.

If the Map is a Set (no value is defined), data is never overwritten and a new entry will be created only if missing.

**Note**: the function returns the pointer to the map's internal storage, where objects are stored using the internal types.

#### `map_get_ptr`

```c
map_node_s * map_get_ptr(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                         uint64_t hash,
#endif
                         FIO_MAP_KEY key);
```

The core get function. This function returns `NULL` if the item is missing.

**Note**: the function returns the pointer to the map's internal storage, where objects are stored using the internal types.


### Map Iteration and Traversal

#### `map_get_next`

```c
map_iterator_s map_get_next(FIO_MAP_PTR map, map_iterator_s * current_pos);
```

Returns the next iterator object after `current_pos` or the first if `NULL`.

Note that adding objects to the map or rehashing between iterations could incur performance penalties when re-setting and re-seeking the previous iterator position. Depending on the ordering scheme this may disrupt the percieved order.

Adding objects to, or rehashing, an unordered map could invalidate the iterator object completely as the ordering may have changed and so the "next" object might be any object in the map.

#### `map_get_prev`

```c
map_iterator_s map_get_prev(FIO_MAP_PTR map, map_iterator_s * current_pos);
```

Returns the iterator object **before** `current_pos` or the last iterator if `NULL`.

See notes in `map_get_next`.

#### `map_iterator_is_valid`

```c
int map_iterator_is_valid(map_iterator_s *iterator);
```

Returns 1 if the iterator points to a valid object, otherwise returns 0.

**Note**: the iterator is invalid if it is NULL, if `map_validator` is 0, or if the iterator is out of bounds.

#### `map_iterator2node`

```c
map_node_s *map_iterator2node(FIO_MAP_PTR map, map_iterator_s *iterator);
```

Returns a pointer to the node object in the internal map from an iterator.

**Parameters:**
- `map` - the map being iterated
- `iterator` - a valid iterator object

**Returns:** pointer to the internal node, or NULL if the iterator is invalid.

**Note**: this function validates the iterator before returning the node pointer.

#### `FIO_MAP_EACH`

```c
#define FIO_MAP_EACH(map_name, map_ptr, i)                                     \
  for (FIO_NAME(map_name, iterator_s)                                          \
           i = FIO_NAME(map_name, get_next)(map_ptr, NULL);                    \
       FIO_NAME(map_name, iterator_is_valid)(&i);                              \
       i = FIO_NAME(map_name, get_next)(map_ptr, &i))
```

Iterates through the map using an iterator object.

Example:

```c
FIO_MAP_EACH(dict, &my_map, iter) {
  printf("Key: %s, Value: %s\n", iter.key.buf, iter.value.buf);
}
```

#### `FIO_MAP_EACH_REVERSED`

```c
#define FIO_MAP_EACH_REVERSED(map_name, map_ptr, i)                            \
  for (FIO_NAME(map_name, iterator_s)                                          \
           i = FIO_NAME(map_name, get_prev)(map_ptr, NULL);                    \
       FIO_NAME(map_name, iterator_is_valid)(&i);                              \
       i = FIO_NAME(map_name, get_prev)(map_ptr, &i))
```

Iterates through the map in reverse order using an iterator object.

#### `map_each`

```c
uint32_t map_each(FIO_MAP_PTR map,
                  int (*task)(map_each_s *),
                  void *udata,
                  ssize_t start_at);
```

Iterates through the map using a callback for each element in the map.

The callback task function must accept a `map_each_s` pointer, see detail below.

If the callback must return either `0` or `-1`. If `-1` (non-zero) is returned the loop stops.

Returns the relative "stop" position, i.e., the number of items processed + the starting point.


```c
/** Iteration information structure passed to the callback. */
typedef struct map_each_s {
  /** The being iterated. Once set, cannot be safely changed. */
  FIO_MAP_PTR const parent;
  /** The current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct map_each_s * info);
  /** Opaque user data. */
  void *udata;
#ifdef FIO_MAP_VALUE
  /** The object's value at the current index. */
  FIO_MAP_VALUE value;
#endif
  /** The object's key the current index. */
  FIO_MAP_KEY key;
} map_each_s;
```

-------------------------------------------------------------------------------
## Reference Counting and Type Wrapping

```c
#define FIO_REF_NAME my_type
#define FIO_REF_TYPE my_type_s
#define FIO_REF_CONSTRUCTOR_ONLY
#include "fio-stl.h"
```

If the `FIO_REF_NAME` macro is defined, then reference counting helpers can be defined for any named type.

**Note**: requires the atomic operations to be defined (`FIO_ATOMIC`).

**Note**: if `FIO_PTR_TAG_TYPE` is defined, the reference counting functions will use the tagged pointer type for parameters and return values instead of `FIO_REF_TYPE *`.

### Reference Counting Type Macros

The following setup Macros are supported when setting up the reference counting type helpers:

#### `FIO_REF_TYPE`

```c
#define FIO_REF_TYPE FIO_NAME(FIO_REF_NAME, s)
```

The type to be wrapped and reference counted by the `FIO_REF_NAME` wrapper API.

By default, `FIO_REF_TYPE` will equal `FIO_REF_NAME_s`, using the naming convention in this library.

#### `FIO_REF_INIT`

```c
#define FIO_REF_INIT(obj)                                                      \
  do {                                                                         \
    if (!FIO_MEM_REALLOC_IS_SAFE_)                                             \
      (obj) = (FIO_REF_TYPE){0};                                               \
  } while (0)
```

Sets up the default object initializer.

By default initializes the object's memory to zero, but only if the memory allocator doesn't guarantee zeroed memory (`FIO_MEM_REALLOC_IS_SAFE_`).

If `FIO_REF_FLEX_TYPE` is defined, the variable `members` may be used during initialization. It's value is the same as the value passed on to the `REF_new` function.

**Note**:  `FIO_REF_FLEX_TYPE` should **not** be used when `FIO_MEM_FREE` macro only frees the number of bytes specified (rather than freeing the whole pointer, as `free` might do). The reference counter type does not store the data passed to the flex-`REF_new` function and frees the same number of bytes as a flex length of `0`.

#### `FIO_REF_DESTROY`

```c
#define FIO_REF_DESTROY(obj)
```

Sets up the default object cleanup. By default does nothing.

#### `FIO_REF_CONSTRUCTOR_ONLY`

By default, the reference counter generator will generate the `new2`, `free2` and `dup2` functions.

However, f the `FIO_REF_CONSTRUCTOR_ONLY` macro is defined, the reference counter will name these functions as `new`, `free` and `dup` instead, making them the type's only and primary constructor / destructor.

#### `FIO_REF_FLEX_TYPE`

If the `FIO_REF_FLEX_TYPE` macro is defined, the constructor will allocate a enough memory for both the type and a `FIO_REF_FLEX_TYPE` array consisting of the specified amount of members (as passed to the constructor's `member` argument).

This allows reference objects structures to include a flexible array of type `FIO_REF_FLEX_TYPE` at the end of the `struct`.

The `members` variable passed to the constructor will also be available to the `FIO_REF_INIT` macro.

**Note**: using `FIO_REF_FLEX_TYPE` limits the reference counter to 32 bits (rather then the native word size which **may** be 64 bits).

#### `FIO_REF_METADATA`

If defined, should be type that will be available as "meta data".

A pointer to this type sill be available using the `REF_metadata` function and will allow "hidden" data to be accessible even though it isn't part of the observable object.

#### `FIO_REF_METADATA_INIT`

```c
#define FIO_REF_METADATA_INIT(meta)                                            \
  do {                                                                         \
    if (!FIO_MEM_REALLOC_IS_SAFE_)                                             \
      (meta) = (FIO_REF_METADATA){0};                                          \
  } while (0)
```

Sets up object's meta-data initialization (if any). By default initializes the meta-data object's memory to zero, but only if the memory allocator doesn't guarantee zeroed memory (`FIO_MEM_REALLOC_IS_SAFE_`).

#### `FIO_REF_METADATA_DESTROY`

```c
#define FIO_REF_METADATA_DESTROY(meta)
```

### Reference Counting Generated Functions

Reference counting adds the following functions:

#### `REF_new` / `REF_new2`

```c
FIO_REF_TYPE * REF_new2(void)
// or, if FIO_REF_FLEX_TYPE is defined:
FIO_REF_TYPE * REF_new2(size_t members)


// or, if FIO_REF_CONSTRUCTOR_ONLY is defined
FIO_REF_TYPE * REF_new(void) 
FIO_REF_TYPE * REF_new(size_t members) // for FIO_REF_FLEX_TYPE

```

Allocates a new reference counted object, initializing it using the `FIO_REF_INIT(object)` macro.

If `FIO_REF_METADATA` is defined, than the metadata is initialized using the `FIO_REF_METADATA_INIT(metadata)` macro.

#### `REF_dup` / `REF_dup2`

```c
FIO_REF_TYPE * REF_dup2(FIO_REF_TYPE * wrapped)
// or, if FIO_REF_CONSTRUCTOR_ONLY is defined
FIO_REF_TYPE * REF_dup(FIO_REF_TYPE * wrapped)
```

Increases an object's reference count (an atomic operation, thread-safe).

**Parameters:**
- `wrapped` - pointer to the reference counted object

**Returns:** the same pointer passed in, or `NULL` if the input was `NULL`.

#### `REF_free` / `REF_free2`

```c
void REF_free2(FIO_REF_TYPE * object)
// or, if FIO_REF_CONSTRUCTOR_ONLY is defined
void REF_free(FIO_REF_TYPE * object)
```

Frees an object or decreases it's reference count (an atomic operation, thread-safe).

Before the object is freed, the `FIO_REF_DESTROY(object)` macro will be called.

If `FIO_REF_METADATA` is defined, than the metadata is also destroyed using the `FIO_REF_METADATA_DESTROY(metadata)` macro.

#### `REF_metadata`

```c
FIO_REF_METADATA * REF_metadata(FIO_REF_TYPE * wrapped)
```

If `FIO_REF_METADATA` is defined, then the metadata is accessible using this inlined function.

**Parameters:**
- `wrapped` - pointer to the reference counted object

**Returns:** a pointer to the object's metadata.

#### `REF_metadata_flex_len`

```c
uint32_t REF_metadata_flex_len(FIO_REF_TYPE * wrapped)
```

If `FIO_REF_FLEX_TYPE` is defined, this function returns the number of flex array members that were allocated with the object.

**Parameters:**
- `wrapped` - pointer to the reference counted object

**Returns:** the number of flex array members allocated, or `0` if `wrapped` is `NULL`.

#### `REF_references`

```c
size_t REF_references(FIO_REF_TYPE * wrapped)
```

A debugging helper that returns the current reference count for an object.

**Parameters:**
- `wrapped` - pointer to the reference counted object

**Returns:** the current reference count, or `0` if `wrapped` is `NULL`.

**Note**: the returned value is unstable and should not be used for program logic. It is intended for debugging purposes only.

-------------------------------------------------------------------------------
## FIOBJ Soft Dynamic Types

```c
#define FIO_FIOBJ
#define FIOBJ_MALLOC /* an optional local memory allocator for FIOBJ types */
#include "fio-stl.h"
```

The facil.io library includes a dynamic type system that makes it easy to handle mixed-type tasks, such as JSON object construction.

This soft type system included in the facil.io STL is based on the Core types mentioned above and it shares their API (Dynamic Strings, Dynamic Arrays, and Hash Maps).

The soft type system also offers an (optional) [Local Memory allocator](#local-memory-allocation) for improved performance when defined with the `FIOBJ_MALLOC` macro defined.

The `FIOBJ` API offers type generic functions in addition to the type specific API. An object's underlying type is easily identified using `FIOBJ_TYPE(obj)` or `FIOBJ_TYPE_IS(obj, type)`.

The documentation regarding the `FIOBJ` soft-type system is divided as follows:  

* [`FIOBJ` General Considerations](#fiobj-general-considerations)

* [`FIOBJ` Types and Identification](#fiobj-types-and-identification)

* [`FIOBJ` Core Memory Management](#fiobj-core-memory-management)

* [`FIOBJ` Common Functions](#fiobj-common-functions)

* [Primitive Types](#fiobj-primitive-types)

* [Numbers (Integers)](#fiobj-integers)

* [Floats](#fiobj-floats)

* [Strings](#fiobj-strings)

* [Arrays](#fiobj-arrays)

* [Hash Maps](#fiobj-hash-maps)

* [JSON Helpers](#fiobj-json-helpers)

* [Mustache Helpers](#fiobj-mustache-helpers)

* [How to Extend the `FIOBJ` Type System](#how-to-extend-the-fiobj-type-system)

In the facil.io web application framework, there are extensions to the core `FIOBJ` primitives, including:

* [IO storage](fiobj_io)

* [Mustache](fiobj_mustache)

### `FIOBJ` Configuration Macros

#### `FIOBJ_MAX_NESTING`

```c
#define FIOBJ_MAX_NESTING 512
```

Sets the limit on nesting level traversal by recursive functions.

This affects JSON output/input and the `fiobj_each2` function since they are recursive.

**Note**: this value will **NOT** affect the recursive `fiobj_free` which could (potentially) explode the stack if given malformed input such as cyclic data structures.

Values should be less than 32K.

#### `FIOBJ_JSON_APPEND`

```c
#define FIOBJ_JSON_APPEND 1
```

When set to `1` (default), JSON parsing will append to existing Arrays and Hash Maps when updating. When set to `0`, existing containers are replaced.

### `FIOBJ` General Considerations

1. To use the `FIOBJ` soft types, define the `FIO_FIOBJ` macro and then include the facil.io STL header.

2. To include declarations as globally available symbols (allowing the functions to be called from multiple C files), define `FIO_EXTERN` _before_ including the STL header.

    This also requires that a _single_ C file (translation unit) define `FIO_EXTERN_COMPLETE` _before_ including the header with the `FIO_EXTERN` directive.

3. The `FIOBJ` types use pointer tagging and require that the memory allocator provide allocations on 8 byte memory alignment boundaries (they also assume each byte is 8 bits).

    If the system allocator doesn't provide (at least) 8 byte memory alignment, use the facil.io memory allocator provided (`fio_malloc`).

4. The `FIOBJ` soft type system uses an "**ownership**" memory model.

    This means that Arrays "**own**" their **members** and Hash Maps "**own**" their **values** (but **not** the keys).

    Freeing an Array will free all the objects within the Array. Freeing a Hash Map will free all the values within the Hash Map (but none of the keys).

    Ownership is only transferred if the object is removed from it's container.

    i.e., `fiobj_array_get` does **not** transfer ownership (it just allows temporary "access"). Whereas, `fiobj_array_remove` **does** revoke ownership - either freeing the object or moving the ownership to the pointer provided to hold the `old` value.

### `FIOBJ` Types and Identification

`FIOBJ` objects can contain any number of possible types, including user defined types.

These are the built-in types / classes that the Core `FIOBJ` system includes (before any extensions):

* `FIOBJ_T_INVALID`: indicates an **invalid** type class / type (a `FIOBJ_INVALID` value).

* `FIOBJ_T_PRIMITIVE`: indicates a **Primitive** class / type.

* `FIOBJ_T_NUMBER`: indicates a **Number** class / type.

* `FIOBJ_T_FLOAT`: indicates a **Float** class / type.

* `FIOBJ_T_STRING`: indicates a **String** class / type.

* `FIOBJ_T_ARRAY`: indicates an **Array** class / type.

* `FIOBJ_T_HASH`: indicates a **Hash Map** class / type.

* `FIOBJ_T_OTHER`: (internal) indicates an **Other** class / type. This is designed to indicate an extension / user defined type.

The `FIOBJ_T_PRIMITIVE` class / type resolves to one of the following types:

* `FIOBJ_T_NULL`: indicates a `fiobj_null()` object.

* `FIOBJ_T_TRUE`: indicates a `fiobj_true()` object.

* `FIOBJ_T_FALSE`: indicates a `fiobj_false()` object.

In the facil.io web application framework, there are extensions to the core `FIOBJ` primitives, including:

* [`FIOBJ_T_IO`](fiobj_io)

The following functions / MACROs help identify a `FIOBJ` object's underlying type.

#### `FIOBJ_TYPE(o)`

```c
#define FIOBJ_TYPE(o) fiobj_type(o)
```

#### `FIOBJ_TYPE_IS(o)`

```c
#define FIOBJ_TYPE_IS(o, type) (fiobj_type(o) == type)
```

#### `FIOBJ_TYPE_CLASS(o)`

```c
#define FIOBJ_TYPE_CLASS(o) ((fiobj_class_en)(((uintptr_t)(o)) & 7UL))
```

Returns the object's type class. This is limited to one of the core types. `FIOBJ_T_PRIMITIVE` and `FIOBJ_T_OTHER` may be returned (they aren't expanded to their underlying type).

**Note**: some numbers (`FIOBJ_T_NUMBER` / `FIOBJ_T_FLOAT`) may return `FIOBJ_T_OTHER` when `FIOBJ_TYPE_CLASS` is used, but return their proper type when `FIOBJ_TYPE` is used. This is due to memory optimizations being unavailable for some numerical values.

#### `FIOBJ_IS_INVALID(o)`

```c
#define FIOBJ_IS_INVALID(o) (((uintptr_t)(o) & 7UL) == 0)
```

Tests if the object is (probably) an invalid FIOBJ (returns true if invalid).

**Note**: A valid FIOBJ always has at least one of the lower 3 bits set due to pointer tagging.

#### `FIOBJ_IS_NULL(o)`

```c
#define FIOBJ_IS_NULL(o) (FIOBJ_IS_INVALID(o) || ((o) == FIOBJ_T_NULL))
```

Tests if the object is either a `NULL` `FIOBJ` object or an invalid object.

#### `FIOBJ_PTR_TAG(o, klass)`

```c
#define FIOBJ_PTR_TAG(o, klass) ((uintptr_t)(((uintptr_t)(o)) | (klass)))
```

Adds a `FIOBJ` type tag to a pointer. The `klass` should be one of the `FIOBJ_T_*` type constants.

This is made available for authoring `FIOBJ` extensions and **shouldn't** be normally used.

#### `FIOBJ_PTR_UNTAG(o)`

```c
#define FIOBJ_PTR_UNTAG(o) ((uintptr_t)(((uintptr_t)(o)) & (~7ULL)))
```

Removes the `FIOBJ` type tag from a `FIOBJ` object, allowing access to the underlying pointer and possible type.

This is made available for authoring `FIOBJ` extensions and **shouldn't** be normally used.

#### `fiobj_type`

```c
size_t fiobj_type(FIOBJ o);
```

Returns an objects type. This isn't limited to known types.

Avoid calling this function directly. Use the MACRO instead.

### `FIOBJ` Core Memory Management

`FIOBJ` objects are **copied by reference** (not by value). Once their reference count is reduced to zero, their memory is freed.

This is extremely important to note, especially in multi-threaded environments. This implied that: **access to a dynamic `FIOBJ` object is _NOT_ thread-safe** and `FIOBJ` objects that may be written to (such as Arrays, Strings and Hash Maps) should **not** be shared across threads (unless properly protected).

The `FIOBJ` soft type system uses an "**ownership**" memory model. When placing a **value** in an Array or a Hash Map, the "ownership" is moved. Freeing the Array / Hash Map will free the object (unless `fiobj_dup` was called). Hash Maps "**own**" their _values_ (but **not** the _keys_).

#### `fiobj_dup`

```c
FIOBJ fiobj_dup(FIOBJ o);
```

Increases an object's reference count and returns it.

#### `fiobj_free`

```c
void fiobj_free(FIOBJ o);
```

Decreases an object's reference count or frees it.

**Note**:

This function is **recursive** and could cause a **stack explosion** error.

In addition, recursive object structures may produce unexpected results (for example, objects are always freed).

The `FIOBJ_MAX_NESTING` nesting limit doesn't apply to `fiobj_free`, making it possible to "expload" the stack if misused.

This places the responsibility on the user / developer, not to exceed the maximum nesting limit (or errors may occur).

When accepting external data, consider using the JSON parser, as it protects against this issue, offering a measure of safety against external data attacks.

### `FIOBJ` Common Functions

#### `fiobj_is_eq`

```c
unsigned char fiobj_is_eq(FIOBJ a, FIOBJ b);
```

Compares two objects.

**Note**: this function now supports deep equality checks for Arrays and Hash Maps.

#### `fiobj2cstr`

```c
fio_str_info_s fiobj2cstr(FIOBJ o);
```

Returns a temporary String representation for any FIOBJ object.

For number objects and floats this is thread safe for up to 128 threads.

For printing Arrays and Hash maps, using a JSON representation will provide more information.

#### `fiobj2i`

```c
intptr_t fiobj2i(FIOBJ o);
```

Returns an integer representation for any FIOBJ object.

#### `fiobj2f`

```c
double fiobj2f(FIOBJ o);
```

Returns a float (double) representation for any FIOBJ object.

#### `fiobj_hash` (was `fiobj2hash`)

```c
uint64_t fiobj_hash(FIOBJ o);
```

Calculates an object's hash value for a specific hash map object.

### `FIOBJ` Iteration

#### `fiobj_each_s`

```c
typedef struct fiobj_each_s {
  /** The being iterated. Once set, cannot be safely changed. */
  FIOBJ const parent;
  /** The index to start at / the current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct fiobj_each_s *info);
  /** The argument passed along to the task. */
  void *udata;
  /** The value of the current object in the Array or Hash Map */
  FIOBJ value;
  /* The key, if a Hash Map */
  FIOBJ key;
} fiobj_each_s;
```

Iteration information structure passed to the callback during `fiobj_each1` and `fiobj_each2` operations.

**Members:**
- `parent` - The object being iterated (read-only once set)
- `index` - The current index position
- `task` - The callback function (can be updated mid-iteration)
- `udata` - User data passed to the task
- `value` - The current element's value
- `key` - The current element's key (for Hash Maps only)

#### `fiobj_each1`

```c
uint32_t fiobj_each1(FIOBJ o,
                     int (*task)(fiobj_each_s *info),
                     void *udata,
                     int32_t start_at);
```

Performs a task for each element held by the FIOBJ object **directly** (but **not** itself).

If `task` returns -1, the `each` loop will break (stop).

Returns the "stop" position - the number of elements processed + `start_at`.

**Parameters:**
- `o` - The FIOBJ container to iterate (Array or Hash Map)
- `task` - Callback function receiving a `fiobj_each_s` pointer
- `udata` - User data passed to the callback via `info->udata`
- `start_at` - Starting index for iteration

#### `fiobj_each2`

```c
uint32_t fiobj_each2(FIOBJ o,
                     int (*task)(fiobj_each_s *info),
                     void *udata);
```

Performs a task for the object itself and each element held by the FIOBJ object or any of its elements (a deep task).

The order of performance is by order of appearance, as if all nesting levels were flattened.

If `task` returns -1, the `each` loop will break (stop).

Returns the number of elements processed.

**Parameters:**
- `o` - The FIOBJ object to iterate deeply
- `task` - Callback function receiving a `fiobj_each_s` pointer
- `udata` - User data passed to the callback via `info->udata`

**Note**:

This function is **recursive** and could cause a **stack explosion** error.

The facil.io library attempts to protect against this error by limiting recursive access to `FIOBJ_MAX_NESTING`... however, this also assumes that a user / developer doesn't exceed the maximum nesting limit (or errors may occur).

#### `fiobj_json_find`

```c
FIOBJ fiobj_json_find(FIOBJ object, fio_str_info_s notation);
```

Uses JavaScript (JSON) style notation to find data in an object structure.

For example, `"[0].name"` will return the `"name"` property of the first object in an Array object.

Returns a temporary reference to the object or `FIOBJ_INVALID` on an error.

Use `fiobj_dup` to collect an actual reference to the returned object.

**Note**:

Using the search algorithm with long object names and/or deeper nesting levels might incur a performance penalty due to the fact that the algorithm tests for all possible object name permutations.

i.e., `"name1.name2.name3"` will first be tested as the whole string (`"name1.name2.name3"`), then `"name1.name2" + "name.3"` will be tested, then `"name1" + "name2.name.3"` will be tested for and `"name1" + "name2" + "name3"` will only be attempted last (allowing all permutations to be reviewed rather than assuming a `.` is always a delimiter).

#### `fiobj_json_find2`

```c
#define fiobj_json_find2(object, str, length)                                  \
  fiobj_json_find(object, FIO_STR_INFO2(str, length))
```

A macro helper for [`fiobj_json_find`](#fiobj_json_find).

### `FIOBJ` Primitive Types

The `true`, `false` and `null` primitive type functions (in addition to the common functions) are only their simple static constructor / accessor functions.

The primitive types are immutable.

#### `fiobj_true`

```c
FIOBJ fiobj_true(void);
```

Returns the `true` primitive.

#### `fiobj_false`

```c
FIOBJ fiobj_false(void);
```

Returns the `false` primitive.

#### `fiobj_null`

```c
FIOBJ fiobj_null(void);
```

Returns the `nil` / `null` primitive.


### `FIOBJ` Integers

#### `fiobj_num_new`

```c
FIOBJ fiobj_num_new(intptr_t i);
```

Creates a new Number object.

#### `fiobj_num2i`

```c
intptr_t fiobj_num2i(FIOBJ i);
```

Reads the number from a `FIOBJ` Number.

#### `fiobj_num2f`

```c
double fiobj_num2f(FIOBJ i);
```

Reads the number from a `FIOBJ` Number, fitting it in a double.

#### `fiobj_num2cstr`

```c
fio_str_info_s fiobj_num2cstr(FIOBJ i);
```

Returns a String representation of the number (in base 10).

#### `fiobj_num_free`

```c
void fiobj_num_free(FIOBJ i);
```

Frees a `FIOBJ` number (a type specific `fiobj_free` alternative - use only when the type was validated).


### `FIOBJ` Floats

#### `fiobj_float_new`

```c
FIOBJ fiobj_float_new(double i);
```

Creates a new Float (double) object.

#### `fiobj_float2i`

```c
intptr_t fiobj_float2i(FIOBJ i);
```

Reads the number from a `FIOBJ` Float rounding it to an integer.

#### `fiobj_float2f`

```c
double fiobj_float2f(FIOBJ i);
```

Reads the value from a `FIOBJ` Float, as a double.

#### `fiobj_float2cstr`

```c
fio_str_info_s fiobj_float2cstr(FIOBJ i);
```

Returns a String representation of the float.

#### `fiobj_float_free`

```c
void fiobj_float_free(FIOBJ i);
```

Frees a `FIOBJ` Float (a type specific `fiobj_free` alternative - use only when the type was validated).


### `FIOBJ` Strings

`FIOBJ` Strings are based on the core `STR_x` functions. This means that all these core type functions are available also for this type, using the `fiobj_str` prefix (i.e., [`STR_new`](#str_new) becomes [`fiobj_str_new`](#str_new), [`STR_write`](#str_write) becomes [`fiobj_str_write`](#str_write), etc').

In addition, the following `fiobj_str` functions and MACROs are defined:

#### `fiobj_str_new_cstr`

```c
FIOBJ fiobj_str_new_cstr(const char *ptr, size_t len);
```

Creates a new `FIOBJ` string object, copying the data to the new string.


#### `fiobj_str_new_buf`

```c
FIOBJ fiobj_str_new_buf(size_t capa);
```

Creates a new `FIOBJ` string object with (at least) the requested capacity.


#### `fiobj_str_new_copy`

```c
FIOBJ fiobj_str_new_copy(FIOBJ original);
```

Creates a new `FIOBJ` string object, copying the origin ([`fiobj2cstr`](#fiobj2cstr)).


#### `fiobj_str2cstr`

```c
fio_str_info_s fiobj_str2cstr(FIOBJ s);
```

Returns information about the string. Same as [`fiobj_str_info()`](#str_info).

#### `FIOBJ_STR_TEMP_DESTROY(name)`

```c
#define FIOBJ_STR_TEMP_DESTROY(str_name)  \
  FIO_NAME(fiobj_str, destroy)(str_name);
```

Resets a temporary `FIOBJ` String, freeing and any resources allocated.

See the following `FIOBJ_STR_TEMP_XXX` macros for creating temporary FIOBJ strings on the Stack.

#### `FIOBJ_STR_TEMP_VAR(name)`

```c
#define FIOBJ_STR_TEMP_VAR(str_name)                                   \
  struct {                                                             \
    uint64_t i1;                                                       \
    uint64_t i2;                                                       \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s) s;               \
  } FIO_NAME(str_name, __auto_mem_tmp) = {                             \
      0x7f7f7f7f7f7f7f7fULL, 0x7f7f7f7f7f7f7f7fULL, FIO_STR_INIT};     \
  FIOBJ str_name =                                                     \
      (FIOBJ)(((uintptr_t) & (FIO_NAME(str_name, __auto_mem_tmp).s)) | \
              FIOBJ_T_STRING);
```

Creates a temporary `FIOBJ` String object on the stack.

String data might be allocated dynamically, requiring the use of `FIOBJ_STR_TEMP_DESTROY`.

#### `FIOBJ_STR_TEMP_VAR_STATIC(str_name, buf, len)`

```c
#define FIOBJ_STR_TEMP_VAR_STATIC(str_name, buf_, len_)                        \
  struct {                                                                     \
    uint64_t i1;                                                               \
    uint64_t i2;                                                               \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s) s;                       \
  } FIO_NAME(str_name,                                                         \
             __auto_mem_tmp) = {0x7f7f7f7f7f7f7f7fULL,                         \
                                0x7f7f7f7f7f7f7f7fULL,                         \
                                FIO_STR_INIT_STATIC2((buf_), (len_))};         \
  FIOBJ str_name =                                                             \
      (FIOBJ)(((uintptr_t) & (FIO_NAME(str_name, __auto_mem_tmp).s)) |         \
              FIOBJ_T_STRING);
```

Creates a temporary FIOBJ String object on the stack, initialized with a static string.

Editing the String data **will** cause dynamic memory allocation, use `FIOBJ_STR_TEMP_DESTROY` once done.

This variation will cause memory allocation immediately upon editing the String. The buffer _MAY_ be read only.

#### `FIOBJ_STR_TEMP_VAR_EXISTING(str_name, buf, len, capa)`

```c
#define FIOBJ_STR_TEMP_VAR_EXISTING(str_name, buf_, len_, capa_)               \
  struct {                                                                     \
    uint64_t i1;                                                               \
    uint64_t i2;                                                               \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s) s;                       \
  } FIO_NAME(str_name, __auto_mem_tmp) = {                                     \
      0x7f7f7f7f7f7f7f7fULL,                                                   \
      0x7f7f7f7f7f7f7f7fULL,                                                   \
      FIO_STR_INIT_EXISTING((buf_), (len_), (capa_))};                         \
  FIOBJ str_name =                                                             \
      (FIOBJ)(((uintptr_t) & (FIO_NAME(str_name, __auto_mem_tmp).s)) |         \
              FIOBJ_T_STRING);
```

Creates a temporary FIOBJ String object on the stack for a read/write buffer with the specified capacity.

Editing the String data might cause dynamic memory allocation, use `FIOBJ_STR_TEMP_DESTROY` once done.

Remember to manage the buffer's memory once it was de-linked from the temporary string (as the FIOBJ object does **not** take ownership of the memory).

#### `FIOBJ` Strings - Core Type Functions

In addition, all the functions documented above as `STR_x`, are defined as `fiobj_str_x`:

* [`fiobj_str_new`](#str_new) - creates a new empty string.

* [`fiobj_str_free`](#str_free) - frees a FIOBJ known to be a String object.

* [`fiobj_str_destroy`](#str_destroy) - destroys / clears a String, returning it to an empty state. 

* [`fiobj_str_detach`](#str_detach) - destroys / clears a String, returning a `char *` C-String.

* [`fiobj_str_info`](#str_info) - returns information about the string.

* [`fiobj_str_len`](#str_len) - returns the string's length.

* [`fiobj_str2ptr`](#str2ptr) - returns a pointer to the string's buffer.

* [`fiobj_str_capa`](#str_capa) - returns the string's capacity.

* [`fiobj_str_freeze`](#str_freeze) - freezes a string (a soft flag, enforced only by functions).

* [`fiobj_str_is_frozen`](#str_is_frozen) - returns true if the string is frozen.

* [`fiobj_str_is_eq`](#str_is_eq) - returns true if the strings are equal.

* [`fiobj_str_hash`](#str_hash) - returns a string's Risky Hash.

* [`fiobj_str_resize`](#str_resize) - resizes a string (keeping the current buffer).

* [`fiobj_str_compact`](#str_compact) - attempts to minimize memory usage.

* [`fiobj_str_reserve`](#str_reserve) - reserves memory for future `write` operations.

* [`fiobj_str_utf8_valid`](#str_utf8_valid) - tests in a string is UTF8 valid.

* [`fiobj_str_utf8_len`](#str_utf8_len) - returns a string's length in UTF8 characters.

* [`fiobj_str_utf8_select`](#str_utf8_select) - selects a section of the string using UTF8 offsets.

* [`fiobj_str_write`](#str_write) - writes data to the string.

* [`fiobj_str_write_i`](#str_write_i) - writes a base 10 number to the string.

* [`fiobj_str_write_hex`](#str_write_hex) - writes a base 16 (hex) number to the string.

* [`fiobj_str_concat`](#str_concat-str_join) - writes an existing string to the string.

* [`fiobj_str_replace`](#str_replace) - replaces a section of the string.

* [`fiobj_str_vprintf`](#str_vprintf) - writes formatted data to the string.

* [`fiobj_str_printf`](#str_printf) - writes formatted data to the string.

* [`fiobj_str_readfd`](#str_readfd) - writes data from an open file to the string.

* [`fiobj_str_readfile`](#str_readfile) - writes data from an unopened file to the string.

* [`fiobj_str_write_b64enc`](#str_write_b64enc) - encodes and writes data to the string using base 64.

* [`fiobj_str_write_b64dec`](#str_write_b64dec) - decodes and writes data to the string using base 64.

* [`fiobj_str_write_escape`](#str_write_escape) - writes JSON style escaped data to the string.

* [`fiobj_str_write_unescape`](#str_write_unescape) - writes decoded JSON escaped data to the string.


### `FIOBJ` Arrays

`FIOBJ` Arrays are based on the core `ARY_x` functions. This means that all these core type functions are available also for this type, using the `fiobj_array` prefix (i.e., [`ARY_new`](#ary_new) becomes [`fiobj_array_new`](#ary_new), [`ARY_push`](#ary_push) becomes [`fiobj_array_push`](#ary_push), etc').

These functions include:

* [`fiobj_array_new`](#ary_new)

* [`fiobj_array_free`](#ary_free)

* [`fiobj_array_destroy`](#ary_destroy)

* [`fiobj_array_count`](#ary_count)

* [`fiobj_array_capa`](#ary_capa)

* [`fiobj_array_reserve`](#ary_reserve)

* [`fiobj_array_concat`](#ary_concat)

* [`fiobj_array_set`](#ary_set)

* [`fiobj_array_get`](#ary_get)

* [`fiobj_array_find`](#ary_find)

* [`fiobj_array_remove`](#ary_remove)

* [`fiobj_array_remove2`](#ary_remove2)

* [`fiobj_array_compact`](#ary_compact)

* [`fiobj_array_to_a`](#ary_to_a)

* [`fiobj_array_push`](#ary_push)

* [`fiobj_array_pop`](#ary_pop)

* [`fiobj_array_unshift`](#ary_unshift)

* [`fiobj_array_shift`](#ary_shift)

* [`fiobj_array_each`](#ary_each)

### `FIOBJ` Ordered Hash Maps

`FIOBJ` Ordered Hash Maps are based on the core `MAP_x` functions. This means that all these core type functions are available also for this type, using the `fiobj_hash` prefix (i.e., [`MAP_new`](#map_new) becomes [`fiobj_hash_new`](#map_new), [`MAP_set`](#map_set) becomes [`fiobj_hash_set`](#map_set), etc').

In addition, the following `fiobj_hash` functions and MACROs are defined:

#### `fiobj_hash_set2`

```c
FIOBJ fiobj_hash_set2(FIOBJ hash, const char *key, size_t len, FIOBJ value);
```

Sets a value in a hash map, allocating the key String and automatically calculating the hash value.

**Parameters:**
- `hash` - The hash map to modify
- `key` - Pointer to the key string
- `len` - Length of the key string
- `value` - The FIOBJ value to store

**Returns:** The previous value if the key existed, or `FIOBJ_INVALID`.

#### `fiobj_hash_get2`

```c
FIOBJ fiobj_hash_get2(FIOBJ hash, const char *buf, size_t len);
```

Finds a String value in a hash map, using a temporary String as the key and automatically calculating the hash value.

**Parameters:**
- `hash` - The hash map to search
- `buf` - Pointer to the key string
- `len` - Length of the key string

**Returns:** The value associated with the key, or `FIOBJ_INVALID` if not found.

#### `fiobj_hash_remove2`

```c
int fiobj_hash_remove2(FIOBJ hash, const char *buf, size_t len, FIOBJ *old);
```

Removes a String value in a hash map, using a temporary String as the key and automatically calculating the hash value.

**Parameters:**
- `hash` - The hash map to modify
- `buf` - Pointer to the key string
- `len` - Length of the key string
- `old` - Optional pointer to store the removed value (pass NULL to discard)

**Returns:** 0 on success, -1 if the key was not found.

#### `fiobj_hash_update`

```c
void fiobj_hash_update(FIOBJ dest, FIOBJ src);
```

Updates a hash map using information from another Hash Map.

For nested Hash Maps, the update is recursive (deep merge). For Arrays, elements are concatenated. For other types, values are overwritten.

**Parameters:**
- `dest` - The destination hash map to update
- `src` - The source hash map to copy from

#### `FIOBJ` Hash Map - Core Type Functions

In addition, all the functions documented above as `MAP_x`, are defined as `fiobj_hash_x`:

* [`fiobj_hash_new`](#map_new)

* [`fiobj_hash_free`](#map_free)

* [`fiobj_hash_destroy`](#map_destroy)

* [`fiobj_hash_get`](#map_get-hash-map)

* [`fiobj_hash_get_ptr`](#map_get_ptr)

* [`fiobj_hash_set`](#map_set)

* [`fiobj_hash_set_ptr`](#map_set_ptr)

* [`fiobj_hash_remove`](#map_remove)

* [`fiobj_hash_evict`](#map_evict)

* [`fiobj_hash_count`](#map_count)

* [`fiobj_hash_capa`](#map_capa)

* [`fiobj_hash_reserve`](#map_reserve)

* [`fiobj_hash_compact`](#map_compact)

* [`fiobj_hash_rehash`](#map_rehash)

* [`fiobj_hash_each`](#map_each)

* [`fiobj_hash_each_get_key`](#map_each_get_key)

### `FIOBJ` JSON Helpers

Parsing, editing and outputting JSON in C can be easily accomplished using `FIOBJ` types.

`facil.io` offers the added benefit of complete parsing from JSON to object. This allows the result to be manipulated, updated, sliced or merged with ease. This is in contrast to some parsers that offer a mid-way structures or lazy (delayed) parsing for types such as `true`, `false` and Numbers.

`facil.io` also offers the added benefit of complete formatting from a framework wide object type (`FIOBJ`) to JSON, allowing the same soft type system to be used throughout the project (rather than having a JSON dedicated type system).

This is in addition to `facil.io` support to some JSON extensions such as comments, both C style (both `//` and `/* ... */` and bash style (`#`).

However, there are [faster alternatives as well as slower alternatives out there](json_performance.html) (i.e., the [Qajson4c library](https://github.com/DeHecht/qajson4c) is a wonderful alternative for embedded systems).

#### `fiobj_json` (was `fiobj2json`)

```c
FIOBJ fiobj_json(FIOBJ dest, FIOBJ o, uint8_t beautify);
```

Returns a JSON valid FIOBJ String, representing the object.

If `dest` is an existing String, the formatted JSON data will be appended to the existing string.

**Parameters:**
- `dest` - Destination string (or `FIOBJ_INVALID` to create a new string)
- `o` - The FIOBJ object to convert to JSON
- `beautify` - If non-zero, adds indentation and newlines for readability

**Returns:** A FIOBJ String containing the JSON representation.

```c
FIOBJ result = fiobj_json_parse2("{\"name\":\"John\",\"surname\":\"Smith\",\"ID\":1}",40, NULL);
FIO_ASSERT( fiobj2cstr(fiobj_hash_get2(result, "name", 4)).len == 4 &&
            !memcmp(fiobj2cstr(fiobj_hash_get2(result, "name", 4)).buf, "John", 4), "result error");

FIOBJ_STR_TEMP_VAR(json_str); /* places string on the stack */
fiobj_json(json_str, result, 1);
FIO_LOG_INFO("updated JSON data to look nicer:\n%s", fiobj2cstr(json_str).buf);
fiobj_free(result);
FIOBJ_STR_TEMP_DESTROY(json_str);
```

#### `fiobj_hash_update_json`

```c
size_t fiobj_hash_update_json(FIOBJ hash, fio_str_info_s str);

size_t fiobj_hash_update_json2(FIOBJ hash, char *ptr, size_t len);
```

Updates a Hash using JSON data.

Parsing errors and non-dictionary object JSON data are silently ignored, attempting to update the Hash as much as possible before any errors encountered.

Conflicting Hash data is overwritten (preferring the new over the old).

Returns the number of bytes consumed. On Error, 0 is returned and no data is consumed.

The `fiobj_hash_update_json2` function is a helper function, it calls `fiobj_hash_update_json` with the provided string information.

#### `fiobj_json_parse`

```c
FIOBJ fiobj_json_parse(fio_str_info_s str, size_t *consumed);

#define fiobj_json_parse2(data_, len_, consumed)                               \
  fiobj_json_parse(FIO_STR_INFO2(data_, len_), consumed)
```

Parses a C string for JSON data. If `consumed` is not NULL, the `size_t` variable will contain the number of bytes consumed before the parser stopped (due to either error or end of a valid JSON data segment).

Returns a FIOBJ object matching the JSON valid C string `str`.

If the parsing failed (no complete valid JSON data) `FIOBJ_INVALID` is returned.

`fiobj_json_parse2` is a helper macro, it calls `fiobj_json_parse` with the provided string information.

### `FIOBJ` Mustache Helpers

FIOBJ provides integration with the Mustache templating system, allowing you to render Mustache templates using FIOBJ data structures (typically Hash Maps) as the context.

#### `fiobj_mustache_build`

```c
FIOBJ fiobj_mustache_build(fio_mustache_s *m, FIOBJ ctx);
```

Builds a Mustache template using a FIOBJ context (usually a Hash).

**Parameters:**
- `m` - A compiled Mustache template (see Mustache documentation)
- `ctx` - The FIOBJ context, typically a Hash Map with template variables

**Returns:** A FIOBJ String with the rendered template. May return `FIOBJ_INVALID` if nothing was written.

#### `fiobj_mustache_build2`

```c
FIOBJ fiobj_mustache_build2(fio_mustache_s *m, FIOBJ dest, FIOBJ ctx);
```

Builds a Mustache template using a FIOBJ context (usually a Hash).

Writes output to `dest` string (may be `FIOBJ_INVALID` / `NULL`).

**Parameters:**
- `m` - A compiled Mustache template
- `dest` - Destination string to append to (or `FIOBJ_INVALID` to create new)
- `ctx` - The FIOBJ context, typically a Hash Map with template variables

**Returns:** `dest` (or a new String). May return `FIOBJ_INVALID` if nothing was written and `dest` was empty.

### How to Extend the `FIOBJ` Type System

The `FIOBJ` source code includes two extensions for the `Float` and `Number` types.

In many cases, numbers and floats can be used without memory allocations. However, when memory allocation is required to store the data, the `FIOBJ_T_NUMBER` and `FIOBJ_T_FLOAT` types are extended using the same techniques described here.

#### `FIOBJ` Extension Requirements

To extend the `FIOBJ` soft type system, there are a number of requirements:

1. A **unique** type ID must be computed.

    Type IDs are `size_t` bits in length. Values under 100 are reserved. Values under 40 are illegal (might break implementation).

2. A static virtual function table object (`FIOBJ_class_vtable_s`) must be fully populated (`NULL` values may break cause a segmentation fault).

3. The unique type construct / destructor must be wrapped using the facil.io reference counting wrapper (using `FIO_REF_NAME`).

    The `FIO_REF_METADATA` should be set to a `FIOBJ_class_vtable_s` pointer and initialized for every object.

4. The unique type wrapper must use pointer tagging as described bellow (`FIO_PTR_TAG`).

5. A public API should be presented.

#### `FIOBJ` Pointer Tagging

The `FIOBJ` types is often identified by th a bit "tag" added to the pointer. All extension types **must** be tagged as `FIOBJ_T_OTHER`.

The facil.io memory allocator (`fio_malloc`), as well as most system allocators, promise a 64 bit allocation alignment. The `FIOBJ` types leverage this behavior by utilizing the least significant 3 bits that are always zero. However, this implementation might change in the future, so it's better to use the macros `FIOBJ_PTR_TAG` and `FIOBJ_PTR_UNTAG`.

The following macros should be defined for tagging an extension `FIOBJ` type, allowing the `FIO_REF_NAME` constructor / destructor to manage pointer tagging, reference counting and access to the `FIOBJ` virtual table (see later on).

```c
#define FIO_PTR_TAG(p)   FIOBJ_PTR_TAG(p, FIOBJ_T_OTHER)
#define FIO_PTR_UNTAG(p) FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_TYPE FIOBJ
```

#### `FIOBJ` Virtual Function Tables

`FIOBJ` extensions use a virtual function table that is shared by all the objects of that type/class.

Basically, the virtual function table is a `struct` with the **Type ID** and function pointers.

**Type ID** values under 100 are reserved for facil.io and might cause conflicts with the existing type values if used (i.e., `FIOBJ_T_FALSE == 34`).

All function pointers must be populated (where `each1` is only called if `count` returns a non-zero value).

This is the structure of the virtual table:

```c
/** FIOBJ types can be extended using virtual function tables. */
typedef struct {
  /**
   * MUST return a unique number to identify object type.
   *
   * Numbers (type IDs) under 100 are reserved. Numbers under 40 are illegal.
   */
  size_t type_id;
  /** Test for equality between two objects with the same `type_id` */
  unsigned char (*is_eq)(FIOBJ restrict a, FIOBJ restrict b);
  /** Converts an object to a String */
  fio_str_info_s (*to_s)(FIOBJ o);
  /** Converts an object to an integer */
  intptr_t (*to_i)(FIOBJ o);
  /** Converts an object to a double */
  double (*to_f)(FIOBJ o);
  /** Returns the number of exposed elements held by the object, if any. */
  uint32_t (*count)(FIOBJ o);
  /** Iterates the exposed elements held by the object. See `fiobj_each1`. */
  uint32_t (*each1)(FIOBJ o,
                    int (*task)(fiobj_each_s *e),
                    void *udata,
                    int32_t start_at);
  /**
   * Decreases the reference count and/or frees the object, calling `free2` for
   * any nested objects.
   */
  void (*free2)(FIOBJ o);
} FIOBJ_class_vtable_s;
```

#### `FIOBJ` Extension Example

For our example, let us implement a static string extension type. We will use the Type ID 100 because values under 100 are reserved.

Let's call our example header file `fiobj_static.h`, so we can find it later.

The API for this type and the header might look something like this:

```c
#ifndef FIO_STAT_STRING_HEADER_H
/* *****************************************************************************
FIOBJ Static String Extension Header Example
***************************************************************************** */
#define FIO_STAT_STRING_HEADER_H
/* *****************************************************************************
Perliminaries - include the FIOBJ extension, but not it's implementation
***************************************************************************** */
#define FIO_EXTERN
#define FIOBJ_EXTERN
#define FIO_FIOBJ
#include "fio-stl.h"

/* *****************************************************************************
Defining the Type ID and the API
***************************************************************************** */

/** The Static String Type ID */
#define FIOBJ_T_STATIC_STRING 100UL

/** Returns a new static string object. The string is considered immutable. */
FIOBJ fiobj_static_new(const char *str, size_t len);

/** Returns a pointer to the static string. */
const char *fiobj_static2ptr(FIOBJ s);

/** Returns the static strings length. */
size_t fiobj_static_len(FIOBJ s);

#endif
```

**Note**: The header assumes that _somewhere_ there's a C implementation file that includes the `FIOBJ` implementation. That C file defines the `FIO_EXTERN_COMPLETE` macro **before** including the `fio-stl.h` file (as well as defining `FIO_FIOBJ` and `FIO_EXTERN`).

The implementation may look like this.

```c
/* *****************************************************************************
FIOBJ Static String Extension Implementation Example
***************************************************************************** */
#include <fiobj_static.h> // include the header file here, whatever it's called

/* *****************************************************************************
The Virtual Function Table (definitions and table)
***************************************************************************** */

/** Test for equality between two objects with the same `type_id` */
static unsigned char static_string_is_eq(FIOBJ restrict a, FIOBJ restrict b);
/** Converts an object to a String */
static fio_str_info_s static_string_to_s(FIOBJ o);
/** Converts an object to an integer */
static intptr_t static_string_to_i(FIOBJ o);
/** Converts an object to a double */
static double static_string_to_f(FIOBJ o);
/** Returns the number of exposed elements held by the object, if any. */
static uint32_t static_string_count(FIOBJ o);
/** Iterates the exposed elements held by the object. See `fiobj_each1`. */
static uint32_t static_string_each1(FIOBJ o,
                                    int (*task)(fiobj_each_s *),
                                    void *udata,
                                    int32_t start_at);
/**
 * Decreases the reference count and/or frees the object, calling `free2` for
 * any nested objects (which we don't have for this type).
 */
static void static_string_free2(FIOBJ o);

/** The virtual function table object. */
static const FIOBJ_class_vtable_s FIOBJ___STATIC_STRING_VTABLE = {
    .type_id = FIOBJ_T_STATIC_STRING,
    .is_eq = static_string_is_eq,
    .to_s = static_string_to_s,
    .to_i = static_string_to_i,
    .to_f = static_string_to_f,
    .count = static_string_count,
    .each1 = static_string_each1,
    .free2 = static_string_free2,
};

/* *****************************************************************************
The Static String Type (internal implementation)
***************************************************************************** */

/* leverage the small-string type to hold static string data */
#define FIO_STR_SMALL fiobj_static_string
/* add required pointer tagging */
#define FIO_PTR_TAG(p)   FIOBJ_PTR_TAG(p, FIOBJ_T_OTHER)
#define FIO_PTR_UNTAG(p) FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_TYPE FIOBJ
/* add required reference counter / wrapper type */
#define FIO_REF_NAME fiobj_static_string
#define FIO_REF_CONSTRUCTOR_ONLY
/* initialization - for demonstration purposes, we don't use it here. */
#define FIO_REF_INIT(o)                                                        \
  do {                                                                         \
    o = (fiobj_static_string_s){0};                                            \
    FIOBJ_MARK_MEMORY_ALLOC(); /* mark memory allocation for debugging */      \
  } while (0)
/* cleanup - destroy the object data when the reference count reaches zero. */
#define FIO_REF_DESTROY(o)                                                     \
  do {                                                                         \
    fiobj_static_string_destroy((FIOBJ)&o);                                    \
    FIOBJ_MARK_MEMORY_FREE(); /* mark memory deallocation for debugging */     \
  } while (0)
/* metadata (vtable) definition and initialization. */
#define FIO_REF_METADATA const FIOBJ_class_vtable_s *
/* metadata initialization - required to initialize the vtable. */
#define FIO_REF_METADATA_INIT(m)                                               \
  do {                                                                         \
    m = &FIOBJ___STATIC_STRING_VTABLE;                                         \
  } while (0)
#include <fio-stl.h>

/* *****************************************************************************
The Public API
***************************************************************************** */

/** Returns a new static string object. The string is considered immutable. */
FIOBJ fiobj_static_new(const char *str, size_t len) {
  FIOBJ o = fiobj_static_string_new();
  FIO_ASSERT_ALLOC(FIOBJ_PTR_UNTAG(o));
  fiobj_static_string_init_const(o, str, len);
  return o;
}

/** Returns a pointer to the static string. */
const char *fiobj_static2ptr(FIOBJ o) { return fiobj_static_string2ptr(o); }

/** Returns the static strings length. */
size_t fiobj_static_len(FIOBJ o) { return fiobj_static_string_len(o); }

/* *****************************************************************************
Virtual Function Table Implementation
***************************************************************************** */

/** Test for equality between two objects with the same `type_id` */
static unsigned char static_string_is_eq(FIOBJ a, FIOBJ b) {
  fio_str_info_s ai, bi;
  ai = fiobj_static_string_info(a);
  bi = fiobj_static_string_info(b);
  return (ai.len == bi.len && !memcmp(ai.buf, bi.buf, ai.len));
}
/** Converts an object to a String */
static fio_str_info_s static_string_to_s(FIOBJ o) {
  return fiobj_static_string_info(o);
}
/** Converts an object to an integer */
static intptr_t static_string_to_i(FIOBJ o) {
  fio_str_info_s s = fiobj_static_string_info(o);
  if (s.len)
    return fio_atol(&s.buf);
  return 0;
}
/** Converts an object to a double */
static double static_string_to_f(FIOBJ o) {
  fio_str_info_s s = fiobj_static_string_info(o);
  if (s.len)
    return fio_atof(&s.buf);
  return 0.0L;
}
/** Returns the number of exposed elements held by the object, if any. */
static uint32_t static_string_count(FIOBJ o) {
  return 0;
  (void)o;
}
/** Iterates the exposed elements held by the object. See `fiobj_each1`. */
static uint32_t static_string_each1(FIOBJ o,
                                    int (*task)(fiobj_each_s *),
                                    void *udata,
                                    int32_t start_at) {
  return 0;
  (void)o; (void)start_at; (void)task; (void)udata;
}
/** Decreases the reference count and/or frees the object. */
static void static_string_free2(FIOBJ o) { fiobj_static_string_free(o); }
```

Example usage:

```c
#define FIO_EXTERN_COMPLETE   // we will place the FIOBJ implementation here.
#include "fiobj_static.h"     // include FIOBJ extension type
int main(void) {
  FIOBJ o = fiobj_static_new("my static string", 16);
  /* example test of virtual table redirection */
  FIO_ASSERT(fiobj2cstr(o).buf == fiobj_static2ptr(o) &&
                 fiobj2cstr(o).len == fiobj_static_len(o),
             "vtable redirection error.");
  fprintf(stderr, "allocated: %s\n", fiobj_static2ptr(o));
  fprintf(stderr, "it's %zu byte long\n", fiobj_static_len(o));
  fprintf(stderr, "object type: %zu\n", FIOBJ_TYPE(o));
  fiobj_free(o);
  FIOBJ_MARK_MEMORY_PRINT(); /* only in DEBUG mode */
}
```

-------------------------------------------------------------------------------
## IO Reactor - an Evented, Single-Threaded, IO Reactor

```c
#define FIO_IO
#include FIO_INCLUDE_FILE
```

An IO reactor - evented and single-threaded - is included when `FIO_IO` is defined.

Although many IO API calls are thread safe (they actually schedule events on the main thread), some thread safety concerns still apply.

**Note**: this will automatically include a large amount of the facil.io STL modules, which you may prefer to manually include beforehand in order to choose the appropriate memory allocator per module.

### Time Server Example

The following example uses the `FIO_PUBSUB` module together with the `FIO_IO` module to author a very simplistic time server (with no micro-second accuracy).

the `FIO_PUBSUB` module could have been replaced with a `fio_protocol_each` approach, assuming a single threaded implementation. But this approach is both simpler and (usually) more powerful.

```c
#define FIO_LOG
#define FIO_IO
#define FIO_PUBSUB
#define FIO_TIME
#include "fio-stl/include.h"

/** Called when an IO is attached to a protocol. */
FIO_SFUNC void time_protocol_on_attach(fio_io_s *io) {
  /* .on_message is unnecessary, by default the message is sent to the IO. */
  fio_pubsub_subscribe(.io = io, .channel = FIO_BUF_INFO1("time"));
}

fio_io_protocol_s TIME_PROTOCOL = {
    .on_attach = time_protocol_on_attach,     /* subscribe after connection */
    .on_timeout = fio_io_touch,               /* never times out */
    .on_pubsub = FIO_ON_MESSAGE_SEND_MESSAGE, /* write messages to IO */
};

/* timer callback for publishing time */
static int publish_time(void *ignore1_, void *ignore2_) {
  char buf[32];
  size_t len = fio_time2iso(buf, fio_time_real().tv_sec);
  buf[len++] = '\r';
  buf[len++] = '\n';
  fio_pubsub_publish(.channel = FIO_BUF_INFO1("time"),
              .message = FIO_BUF_INFO2(buf, len));
  return 0;
  (void)ignore1_, (void)ignore2_;
}

int main(void) {
  /* Note: .repetitions = -1 for infinite, 0 means run ONCE */
  fio_io_run_every(.fn = publish_time, .every = 1000, .repetitions = -1);
  /* Listeners can be set up before fio_io_start() */
  FIO_ASSERT(fio_io_listen(.protocol = &TIME_PROTOCOL), "");
  printf("* Time service starting up.\n");
  printf("  Press ^C to stop server and exit.\n");
  fio_io_start(0);
}
```

### IO Compiler Settings

The following macros control the IO reactor's behavior during compile-time.

#### `FIO_IO_BUFFER_PER_WRITE`

```c
#define FIO_IO_BUFFER_PER_WRITE 65536U
```

Control the size of the on-stack buffer used for `write` events.


#### `FIO_IO_THROTTLE_LIMIT`

```c
#define FIO_IO_THROTTLE_LIMIT 2097152U
```

IO will be throttled (no `on_data` events) if outgoing buffer is large.


#### `FIO_IO_TIMEOUT_MAX`

```c
#define FIO_IO_TIMEOUT_MAX 300000
```

Controls the maximum and default timeout in milliseconds (5 minutes).


#### `FIO_IO_SHUTDOWN_TIMEOUT`

```c
#define FIO_IO_SHUTDOWN_TIMEOUT 15000
```

Sets the hard timeout (in milliseconds) for the reactor's shutdown loop.


#### `FIO_IO_COUNT_STORAGE`

```c
#ifdef DEBUG
#define FIO_IO_COUNT_STORAGE 1
#else
#define FIO_IO_COUNT_STORAGE 0
#endif
```

When enabled, reports total number of bytes sent / received by an IO object.

### IO Reactor Types

The following types are at the core of the IO Recator's design choices.

#### `fio_io_protocol_s`

```c
typedef struct fio_io_protocol_s fio_io_protocol_s;

struct fio_io_protocol_s {
  /**
   * Reserved / private data - used by facil.io internally.
   * MUST be initialized to zero.
   */
  struct {
    /* A linked list of currently attached IOs (ordered) - do NOT alter. */
    FIO_LIST_HEAD ios;
    /* A linked list of other protocols used by IO core - do NOT alter. */
    FIO_LIST_NODE protocols;
    /* internal flags - do NOT alter after initial initialization to zero. */
    uintptr_t flags;
  } reserved;
  /** Called when an IO is attached to the protocol. Use for initialization. */
  void (*on_attach)(fio_io_s *io);
  /** Called when a data is available. */
  void (*on_data)(fio_io_s *io);
  /** Called once all pending `fio_write` calls are finished.
   *  NOTE: For client connections (fio_io_connect), this may NOT be called
   *  if the connection is established immediately. Use on_attach instead. */
  void (*on_ready)(fio_io_s *io);

  /**
   * Called when the IO reactor is shutting down, immediately before closing the
   * connection.
   *
   * After the `on_shutdown` callback returns, the socket is marked for closure.
   *
   * Once the socket was marked for closure, facil.io will allow a limited
   * amount of time for data to be sent, after which the socket might be closed
   * even if the client did not consume all buffered data.
   */
  void (*on_shutdown)(fio_io_s *io);
  /**
   * Called when a connection's timeout was reached
   * 
   * Can be set to `fio_io_touch` if timeout is irrelevant (i.e., listening / UDP).
   */
  void (*on_timeout)(fio_io_s *io);
  /** Used as a default `on_message` when an IO object subscribes. */

  /** Called after the connection was closed (once per IO). */
  void (*on_close)(void *iobuf, void *udata);

  void (*on_pubsub)(struct fio_pubsub_msg_s *msg);
  /** Allows user specific protocol agnostic callbacks. */
  void (*on_user1)(fio_io_s *io, void *user_data);
  /** Allows user specific protocol agnostic callbacks. */
  void (*on_user2)(fio_io_s *io, void *user_data);
  /** Allows user specific protocol agnostic callbacks. */
  void (*on_user3)(fio_io_s *io, void *user_data);
  /** Reserved for future protocol agnostic callbacks. */
  void (*on_reserved)(fio_io_s *io, void *user_data);
  /**
   * Defines Transport Layer callbacks that facil.io will treat as non-blocking
   * system calls.
   */
  fio_io_functions_s io_functions;
  /**
   * The timeout value in milliseconds for all connections using this protocol.
   *
   * Limited to FIO_IO_TIMEOUT_MAX seconds. Zero (0) == FIO_IO_TIMEOUT_MAX
   */
  uint32_t timeout;
  /** The number of bytes to allocate for the fio_io_buf buffer. */
  uint32_t buffer_size;
};
```

The Protocol struct defines the callbacks used for a family of connections and sets their behavior. The Protocol struct is part of the IO reactor's core design.

Protocols are usually global objects and the same protocol can be assigned to multiple IO handles. There are, of course, exceptions.

#### `fio_io_functions_s`

```c
typedef struct fio_io_functions_s fio_io_functions_s;

struct fio_io_functions_s {
  /** Helper that converts a `fio_io_tls_s` into the implementation's context.
   */
  void *(*build_context)(fio_io_tls_s *tls, uint8_t is_client);
  /** Helper to free the context built by build_context. */
  void (*free_context)(void *context);
  /** called when a new IO is first attached to a valid protocol. */
  void (*start)(fio_io_s *io);
  /** Called to perform a non-blocking `read`, same as the system call. */
  ssize_t (*read)(int fd, void *buf, size_t len, void *context);
  /** Called to perform a non-blocking `write`, same as the system call. */
  ssize_t (*write)(int fd, const void *buf, size_t len, void *context);
  /** Sends any unsent internal data. Returns 0 only if all data was sent. */
  int (*flush)(int fd, void *context);
  /** Called when the IO object finished sending all data before closure. */
  void (*finish)(int fd, void *context);
  /** Called after the IO object is closed, used to cleanup its `tls` object. */
  void (*cleanup)(void *context);
};
```

The Protocol struct uses IO callbacks to allow an easy way to override the system's IO functions and emulate POSIX style IO functions.

This defines Transport Layer callbacks that facil.io will treat as non-blocking system calls and allows any protocol to easily add a secure (SSL/TLS) flavor if desired.


#### `fio_io_s`

```c
typedef struct fio_io_s fio_io_s;
```

The main IO object type. Should be treated as an opaque pointer.

The IO handle is used instead of the system's file descriptor and protects callbacks and IO operations from sending data to incorrect clients (possible `fd` "recycling").

#### `fio_io_tls_s`

```c
typedef struct fio_io_tls_s fio_io_tls_s;
```

An opaque type used for the SSL/TLS helper functions.

#### `fio_pubsub_msg_s` (Pub/Sub)

```c
typedef struct fio_pubsub_msg_s fio_pubsub_msg_s;

struct fio_pubsub_msg_s {
  /** A connection (if any) to which the subscription belongs. */
  fio_io_s *io;
  /** The `udata` argument associated with the subscription. */
  void *udata;
  /** Message ID. */
  uint64_t id;
  /** Milliseconds since epoch. */
  uint64_t published;
  /**
   * A channel name, allowing for pub/sub patterns.
   *
   * NOTE: this is a shared copy - do NOT mutate the channel name string.
   */
  fio_buf_info_s channel;
  /**
   * The actual message.
   *
   * NOTE: this is a shared copy - do NOT mutate the message payload string.
   **/
  fio_buf_info_s message;
  /** Channel name namespace. Negative values are reserved. */
  int16_t filter;
  /** flag indicating if the message is JSON data or binary/text. */
  uint8_t is_json;
};
```

The pub/sub message structure, as received by the `on_message` subscription callback.

This is detailed in the pub/sub section, but listed here as it is used by the `fio_io_protocol_s` callback for a default pub/sub handler.

#### `fio_io_async_s`

```c
typedef struct fio_io_async_s fio_io_async_s;

struct fio_io_async_s {
  fio_queue_s *q;
  uint32_t count;
  fio_queue_s queue;
  fio_timer_queue_s timers;
  FIO_LIST_NODE node;
};

```

The IO Async Queue type. 

IO Async Queue provides Worker Threads for non-IO tasks and is integrated into the IO reactor's start / stop life cycle.

### Starting / Stopping the IO Reactor


#### `fio_io_stop`
```c
void fio_io_stop(void);
```

Stopping the IO reactor.

#### `fio_io_add_workers`
```c
void fio_io_add_workers(int workers);
```

Adds `workers` amount of workers to the root IO reactor process.

#### `fio_io_start`
```c
void fio_io_start(int workers);
```

Starts the IO reactor, using optional `workers` processes. Will BLOCK!

#### `fio_io_is_running`
```c
int fio_io_is_running(void);
```

Returns true if IO reactor running and 0 if stopped or shutting down.

#### `fio_io_is_master`
```c
int fio_io_is_master(void);
```

Returns true if the current process is the IO reactor's master process.

#### `fio_io_is_worker`
```c
int fio_io_is_worker(void);
```

Returns true if the current process is an IO reactor's worker process.

#### `fio_io_workers`
```c
uint16_t fio_io_workers(int workers_requested);
```

Returns the number or workers the IO reactor will actually run.

#### `fio_io_pid`
```c
int fio_io_pid(void);
```

Returns current process id.

#### `fio_io_root_pid`
```c
int fio_io_root_pid(void);
```

Returns the root / master process id.

#### `fio_io_last_tick`

```c
int64_t fio_io_last_tick(void);
```

Returns the last millisecond when the IO reactor polled for events.

#### `fio_io_restart`

```c
void fio_io_restart(int workers);
```

Retires all existing workers and restarts with the number of workers.

This function is only effective when called from the master process in cluster mode.

#### `fio_io_restart_on_signal`

```c
void fio_io_restart_on_signal(int signal);
```

Sets a signal to listen to for a hot restart (see `fio_io_restart`).

When the specified signal is received, the IO reactor will restart all workers.

#### `fio_io_shutdown_timeout`

```c
size_t fio_io_shutdown_timeout(void);
```

Returns the shutdown timeout for the reactor in milliseconds.

#### `fio_io_shutdown_timeout_set`

```c
size_t fio_io_shutdown_timeout_set(size_t milliseconds);
```

Sets the shutdown timeout for the reactor, returning the new value.

### Listening to Incoming Connections


#### `fio_io_listen`

```c
fio_io_listener_s *fio_io_listen(fio_io_listen_args_s args);
/* Named arguments using macro. */
#define fio_io_listen(...) fio_io_listen((fio_io_listen_args_s){__VA_ARGS__})

typedef struct fio_io_listen_args_s {
  /**
   * The binding address in URL format. Defaults to: tcp://0.0.0.0:3000
   *
   * Note: `.url` accept an optional query for building a TLS context.
   *
   * Possible query values include:
   *
   * - `tls` or `ssl` (no value): sets TLS as active, possibly self-signed.
   * - `tls=` or `ssl=`: value is a prefix for "key.pem" and "cert.pem".
   * - `key=` and `cert=`: file paths for ".pem" files.
   *
   * i.e.:
   *
   *     fio_io_listen(.url = "0.0.0.0:3000/?tls", ...);
   *     fio_io_listen(.url = "0.0.0.0:3000/?tls=./", ...);
   *     // same as:
   *     fio_io_listen(.url = "0.0.0.0:3000/"
   *                            "?key=./key.pem"
   *                            "&cert=./cert.pem", ...);
   */
  const char *url;
  /** The `fio_io_protocol_s` that will be assigned to incoming
   * connections. */
  fio_io_protocol_s *protocol;
  /** The default `udata` set for (new) incoming connections. */
  void *udata;
  /** TLS object used for incoming connections (ownership moved to listener). */
  fio_io_tls_s *tls;
  /**
   * Called when the a listening socket starts to listen.
   *
   * May be called multiple times (i.e., if the IO reactor stops and restarts).
   */
  void (*on_start)(fio_io_protocol_s *protocol, void *udata);
  /**
   * Called during listener cleanup.
   *
   * This will be called separately for every process before exiting.
   */
  void (*on_stop)(fio_io_protocol_s *protocol, void *udata);
  /**
   * Selects a queue that will be used to schedule a pre-accept task.
   * May be used to test user thread stress levels before accepting connections.
   */
  fio_io_async_s *queue_for_accept;
  /** When forking the IO reactor - limits `listen` to the root process. */
  uint8_t on_root;
  /** Hides "started/stopped listening" messages from log (if set). */
  uint8_t hide_from_log;
} fio_io_listen_args_s;
```


Sets up a network service on a listening socket.

Returns a self-destructible listener handle on success or NULL on error.

The function is shadowed by a macro, allowing it to accept named arguments. i.e.:

```c
/* uses default values for everything except the protocol. */
fio_io_listen(.protocol = &MY_PROTOCOL);
```

**Note**: Listeners can and **SHOULD** be set up **BEFORE** calling `fio_io_start()`. The listener will automatically start accepting connections when the IO reactor starts. This is useful for setting up multiple listeners before starting the reactor.

#### `fio_io_listen_stop`

```c
void fio_io_listen_stop(fio_io_listener_s *listener);
```

Notifies a listener to stop listening.

#### `fio_io_listener_is_tls`

```c
int fio_io_listener_is_tls(fio_io_listener_s *listener);
```

Returns true if the listener protocol has an attached TLS context.

#### `fio_io_listener_protocol`

```c
fio_io_protocol_s *fio_io_listener_protocol(fio_io_listener_s *listener);
```

Returns the listener's associated protocol.

#### `fio_io_listener_udata`

```c
void *fio_io_listener_udata(fio_io_listener_s *listener);
```

Returns the listener's associated `udata`.

#### `fio_io_listener_udata_set`

```c
void *fio_io_listener_udata_set(fio_io_listener_s *listener, void *new_udata);
```

Sets the listener's associated `udata`, returning the old value.

#### `fio_io_listener_url`

```c
fio_buf_info_s fio_io_listener_url(fio_io_listener_s *listener);
```

Returns the URL on which the listener is listening.

### Connecting as a Client


```c
fio_io_s *fio_io_connect(fio_io_connect_args_s args);

#define fio_io_connect(url_, ...)                                              \
  fio_io_connect((fio_io_connect_args_s){.url = url_, __VA_ARGS__})

/** Named arguments for fio_io_connect */
typedef struct {
  /** The URL to connect to (may contain TLS hints in query / `tls` scheme). */
  const char *url;
  /** Connection protocol (once connection established). */
  fio_io_protocol_s *protocol;
  /** Called in case of a failed connection, use for cleanup. */
  void (*on_failed)(fio_io_protocol_s *protocol, void *udata);
  /** Opaque user data (set only once connection was established). */
  void *udata;
  /** TLS builder object for TLS connections. */
  fio_io_tls_s *tls;
  /** Connection timeout in milliseconds (defaults to 30 seconds). */
  uint32_t timeout;
} fio_io_connect_args_s;
```

Connects to a specific URL, returning the `fio_io_s` IO object or `NULL`.

When the connection is established, the protocol's `on_attach` will be called. Until then the IO handle is inactive and any IO operations may have unintended results.

**Note**: the protocol's `on_ready` callback may NOT be called if the connection is established immediately (common on localhost or fast networks). Use `on_attach` for any initialization that must occur when the connection is ready, not `on_ready`.

### IO Operations

#### `fio_io_attach_fd`

```c
fio_io_s *fio_io_attach_fd(int fd,
                           fio_io_protocol_s *protocol,
                           void *udata,
                           void *tls);
```

Attaches the socket in `fd` to the facio.io engine (reactor).

* `fd` should point to a valid socket.

* `protocol` may be the existing protocol or NULL (for partial hijack).

* `udata` is opaque user data and may be any value, including NULL.

* `tls` is a context for Transport Layer (Security) and can be used to
  redirect read/write operations, as set by the protocol.

Returns NULL on error. the `fio_io_s` pointer must NOT be used except within proper callbacks.

**Note**: the protocol's `on_attach` will be called once the attachment of the `fd` is complete. Until then the IO handle is inactive and any IO operations may have unintended results.

#### `fio_io_dup`

```c
fio_io_s *fio_io_dup(fio_io_s *io);
```

Increases a IO's reference count, so it won't be automatically destroyed
when all tasks have completed.

Use this function in order to use the IO outside of a scheduled task.

This function is thread-safe.

#### `fio_io_free`

```c
void fio_io_free(fio_io_s *io);
```

Decreases a IO's reference count, so it could be automatically destroyed
when all other tasks have completed.

Use this function once finished with a IO that was `dup`-ed.

This function is thread-safe.

#### `fio_io_protocol_set`

```c
fio_io_protocol_s *fio_io_protocol_set(fio_io_s *io,
                                       fio_io_protocol_s *protocol);
```

Sets a new protocol object. `NULL` is a valid "only-write" protocol.

**Note**: the protocol's `on_attach` will be called once the new protocol is set. Until then the IO handle remains attached to the old protocol.

**Note**: the old protocol's `on_close` is NOT called. If desired, it should be called manually.

#### `fio_io_protocol`

```c
fio_io_protocol_s *fio_io_protocol(fio_io_s *io);
```

Returns a pointer to the current protocol object.

If `protocol` wasn't properly set, the pointer might be NULL or invalid.

If `protocol` wasn't attached yet, may return the previous protocol.

#### `fio_io_buffer`

```c
void *fio_io_buffer(fio_io_s *io);
```

Returns the a pointer to the memory buffer required by the protocol.

#### `fio_io_buffer_len`

```c
size_t fio_io_buffer_len(fio_io_s *io);
```

Returns the length of the `buf` buffer.

#### `fio_io_udata_set`

```c
void *fio_io_udata_set(fio_io_s *io, void *udata);
```

Associates a new `udata` pointer with the IO, returning the old `udata`

#### `fio_io_udata`

```c
void *fio_io_udata(fio_io_s *io);
```

Returns the `udata` pointer associated with the IO.

#### `fio_io_tls_set`

```c
void *fio_io_tls_set(fio_io_s *io, void *tls);
```

Associates a new `tls` pointer with the IO, returning the old `tls`

#### `fio_io_tls`

```c
void *fio_io_tls(fio_io_s *io);
```

Returns the `tls` pointer associated with the IO.

#### `fio_io_fd`

```c
int fio_io_fd(fio_io_s *io);
```

Returns the socket file descriptor (fd) associated with the IO.

#### `fio_io_touch`

```c
void fio_io_touch(fio_io_s *io);
```

Resets a socket's timeout counter.

#### `fio_io_read`

```c
size_t fio_io_read(fio_io_s *io, void *buf, size_t len);
```

Reads data to the buffer, if any data exists. Returns the number of bytes read.

**Note**: zero (`0`) is a valid return value meaning no data was available.

#### `fio_io_write2`

```c
void fio_io_write2(fio_io_s *io, fio_io_write_args_s args);
#define fio_io_write2(io, ...)                                                 \
  fio_io_write2(io, (fio_io_write_args_s){__VA_ARGS__})

typedef struct {
  /** The buffer with the data to send (if no file descriptor) */
  void *buf;
  /** The file descriptor to send (if no buffer) */
  intptr_t fd;
  /** The length of the data to be sent. On files, 0 = the whole file. */
  size_t len;
  /** The length of the data to be sent. On files, 0 = the whole file. */
  size_t offset;
  /**
   * If this is a buffer, the de-allocation function used to free it.
   *
   * If NULL, the buffer will NOT be de-allocated.
   */
  void (*dealloc)(void *);
  /** If non-zero, makes a copy of the buffer or keeps a file open. */
  uint8_t copy;
} fio_io_write_args_s;
```

Writes data to the outgoing buffer and schedules the buffer to be sent.

#### `fio_io_write`

```c
#define fio_io_write(io, buf_, len_)                                           \
  fio_io_write2(io, .buf = (buf_), .len = (len_), .copy = 1)
```

Helper macro for a common fio_io_write2 (copies the buffer).

#### `fio_io_sendfile`

```c
#define fio_io_sendfile(io, source_fd, offset_, bytes)                         \
  fio_io_write2((io),                                                          \
                .fd = (source_fd),                                             \
                .offset = (size_t)(offset_),                                   \
                .len = (bytes))
```

Sends data from a file as if it were a single atomic packet (sends up to length bytes or until EOF is reached).

Once the file was sent, the `source_fd` will be closed using `close`.

The file will be buffered to the socket chunk by chunk, so that memory consumption is capped.

`offset` dictates the starting point for the data to be sent and length sets the maximum amount of data to be sent.

Closes the file on error.

#### `fio_io_close`

```c
void fio_io_close(fio_io_s *io);
```

Marks the IO for closure as soon as scheduled data was sent.

#### `fio_io_close_now`

```c
void fio_io_close_now(fio_io_s *io);
```

Marks the IO for immediate closure.

#### `fio_io_suspend`

```c
void fio_io_suspend(fio_io_s *io);
```

Suspends future `on_data` events for the IO.

#### `fio_io_unsuspend`

```c
void fio_io_unsuspend(fio_io_s *io);
```

Listens for future `on_data` events related to the IO.

#### `fio_io_is_suspended`

```c
int fio_io_is_suspended(fio_io_s *io);
```

Returns 1 if the IO handle was suspended.

#### `fio_io_is_open`

```c
int fio_io_is_open(fio_io_s *io);
```

Returns 1 if the IO handle is marked as open.

#### `fio_io_backlog`

```c
size_t fio_io_backlog(fio_io_s *io);
```

Returns the approximate number of bytes in the outgoing buffer.

#### `fio_io_noop`

```c
void fio_io_noop(fio_io_s *io);
```

Does nothing. This is a no-op function that can be used as a placeholder callback.

### Task Scheduling

#### `fio_io_defer`

```c
void fio_io_defer(void (*task)(void *, void *),
                  void *udata1,
                  void *udata2);
```

Schedules a task for delayed execution. This function is thread-safe.

#### `fio_io_run_every`

```c
void fio_io_run_every(fio_timer_schedule_args_s args);
#define fio_io_run_every(...)                                                  \
  fio_io_run_every((fio_timer_schedule_args_s){__VA_ARGS__})

```

Schedules a timer bound task, see `fio_timer_schedule`.

Possible "named arguments" (`fio_timer_schedule_args_s` members) include:

* The timer function. If it returns a non-zero value, the timer stops:
  `int (*fn)(void *, void *)`
* Opaque user data:
  `void *udata1`
* Opaque user data:
  `void *udata2`
* Called when the timer is done (finished):
  `void (*on_stop)(void *, void *)`
* Timer interval, in milliseconds:
  `uint32_t every`
* The number of times the timer should be performed. -1 == infinity:
  `int32_t repetitions`

**Note**: `.repetitions = 0` means run **ONCE** (not infinite). Use `.repetitions = -1` for infinite repetitions.

#### `fio_queue_perform_all`

```c
size_t fio_queue_perform_all(fio_queue_s *q);
```

Performs all tasks in the queue, returning the number of tasks performed.

This is useful during shutdown or when synchronous task execution is required.

#### `fio_io_queue`

```c
fio_queue_s *fio_io_queue(void);
```

Returns a pointer for the IO reactor's queue.

#### `fio_io_protocol_each`

```c
size_t fio_io_protocol_each(fio_io_protocol_s *protocol,
                            void (*task)(fio_io_s *, void *udata2),
                            void *udata2);
```

Performs a task for each IO in the stated protocol.

### Connection Object Links / Environment

Each IO handle contains an "environment", which is a key-value store where String keys are used to store arbitrary data that gets destroyed along with the `io` handle.

#### `fio_io_env_get`

```c
void *fio_io_env_get(fio_io_s *io, fio_io_env_get_args_s);

#define fio_io_env_get(io, ...)                                                \
  fio_io_env_get(io, (fio_io_env_get_args_s){__VA_ARGS__})

/** Named arguments for the `fio_io_env_get` / `fio_io_env_unset` function. */
typedef struct {
  /** A numerical type filter. Should be the same as used with
   * `fio_io_env_set` */
  intptr_t type;
  /** The name of the object. Should be the same as used with `fio_io_env_set`
   */
  fio_buf_info_s name;
} fio_io_env_get_args_s;
```

Returns the named `udata` associated with the IO object (or `NULL`).

#### `fio_io_env_set`

```c
void fio_io_env_set(fio_io_s *io, fio_io_env_set_args_s);

#define fio_io_env_set(io, ...)                                                \
  fio_io_env_set(io, (fio_io_env_set_args_s){__VA_ARGS__})

/** Named arguments for the `fio_io_env_set` function. */
typedef struct {
  /** A numerical type filter. Defaults to 0. Negative values are reserved. */
  intptr_t type;
  /** The name for the link. The name and type uniquely identify the object. */
  fio_buf_info_s name;
  /** The object being linked to the connection. */
  void *udata;
  /** A callback that will be called once the connection is closed. */
  void (*on_close)(void *data);
  /** Set to true (1) if the name string's life lives as long as the `env` . */
  uint8_t const_name;
} fio_io_env_set_args_s;
```

Links an object to a connection's lifetime / environment.

The `on_close` callback will be called once the connection has died.

If the `io` is NULL, the value will be set for the global environment.

#### `fio_io_env_unset`

```c
int fio_io_env_unset(fio_io_s *io, fio_io_env_get_args_s);
#define fio_io_env_unset(io, ...)                                              \
  fio_io_env_unset(io, (fio_io_env_get_args_s){__VA_ARGS__})
```

Un-links an object from the connection's lifetime, so it's `on_close` callback will NOT be called.

Returns 0 on success and -1 if the object couldn't be found.

#### `fio_io_env_remove`

```c
int fio_io_env_remove(fio_io_s *io, fio_io_env_get_args_s);

#define fio_io_env_remove(io, ...)                                             \
  fio_io_env_remove(io, (fio_io_env_get_args_s){__VA_ARGS__})
```

Removes an object from the connection's lifetime / environment, calling it's `on_close` callback as if the connection was closed.

### TLS Context Helper Types

#### `fio_io_tls_new`

```c
fio_io_tls_s *fio_io_tls_new(void);
```

Performs a `new` operation, returning a new `fio_io_tls_s` context.

#### `fio_io_tls_from_url`

```c
fio_io_tls_s *fio_io_tls_from_url(fio_io_tls_s *target_or_null, fio_url_s url);
```

Takes a parsed URL and optional TLS target and returns a TLS if needed.

#### `fio_io_tls_dup`

```c
fio_io_tls_s *fio_io_tls_dup(fio_io_tls_s *);
```

Performs a `dup` operation, increasing the object's reference count.

#### `fio_io_tls_free`

```c
void fio_io_tls_free(fio_io_tls_s *);
```

Performs a `free` operation, reducing the reference count and freeing.

#### `fio_io_tls_cert_add`

```c
fio_io_tls_s *fio_io_tls_cert_add(fio_io_tls_s *,
                                  const char *server_name,
                                  const char *public_cert_file,
                                  const char *private_key_file,
                                  const char *pk_password);
```

Adds a certificate a new SSL/TLS context / settings object (SNI support).

```c
     fio_io_tls_cert_add(tls, "www.example.com",
                           "public_key.pem",
                           "private_key.pem", NULL );
```

**Note**: Except for the `tls` and `server_name` arguments, all arguments might
be `NULL`, which a context builder (`fio_io_functions_s`) should
treat as a request for a self-signed certificate. It may be silently ignored.

#### `fio_io_tls_alpn_add`

```c
fio_io_tls_s *fio_io_tls_alpn_add(fio_io_tls_s *tls,
                                  const char *protocol_name,
                                  void (*on_selected)(fio_io_s *));
```

Adds an ALPN protocol callback to the SSL/TLS context.

The first protocol added will act as the default protocol to be selected.

A `NULL` protocol name will be silently ignored.

A `NULL` callback (`on_selected`) will be silently replaced with a no-op.

#### `fio_io_tls_alpn_select`

```c
int fio_io_tls_alpn_select(fio_io_tls_s *tls,
                           const char *protocol_name,
                           size_t name_length,
                           fio_io_s *);
```

Calls the `on_selected` callback for the `fio_io_tls_s` object.


#### `fio_io_tls_trust_add`

```c
fio_io_tls_s *fio_io_tls_trust_add(fio_io_tls_s *,
                                   const char *public_cert_file);
```

Adds a certificate to the "trust" list, which automatically adds a peer verification requirement.

If `public_cert_file` is `NULL`, implementation is expected to add the system's default trust registry.

Note: when the `fio_io_tls_s` object is used for server connections, this should limit connections to clients that connect using a trusted certificate.

```c
fio_io_tls_trust_add(tls, "google-ca.pem" );
```


#### `fio_io_tls_cert_count`

```c
uintptr_t fio_io_tls_cert_count(fio_io_tls_s *tls);
```

Returns the number of `fio_io_tls_cert_add` instructions.

This could be used when deciding if to add a NULL instruction (self-signed).

If `fio_io_tls_cert_add` was never called, zero (0) is returned.

#### `fio_io_tls_alpn_count`

```c
uintptr_t fio_io_tls_alpn_count(fio_io_tls_s *tls);
```

Returns the number of registered ALPN protocol names.

This could be used when deciding if protocol selection should be delegated to the ALPN mechanism, or whether a protocol should be immediately assigned.

If no ALPN protocols are registered, zero (0) is returned.

#### `fio_io_tls_trust_count`

```c
uintptr_t fio_io_tls_trust_count(fio_io_tls_s *tls);
```

Returns the number of `fio_io_tls_trust_add` instructions.

This could be used when deciding if to disable peer verification or not.

If `fio_io_tls_trust_add` was never called, zero (0) is returned.

#### `fio_io_tls_each`

```c
int fio_io_tls_each(fio_io_tls_each_s);

#define fio_io_tls_each(tls_, ...)                                             \
  fio_io_tls_each(((fio_io_tls_each_s){.tls = tls_, __VA_ARGS__}))

/** Named arguments (and info) for `fio_io_tls_each`. */
typedef struct fio_io_tls_each_s {
  fio_io_tls_s *tls;
  void *udata;
  void *udata2;
  int (*each_cert)(struct fio_io_tls_each_s *,
                   const char *server_name,
                   const char *public_cert_file,
                   const char *private_key_file,
                   const char *pk_password);
  int (*each_alpn)(struct fio_io_tls_each_s *,
                   const char *protocol_name,
                   void (*on_selected)(fio_io_s *));
  int (*each_trust)(struct fio_io_tls_each_s *, const char *public_cert_file);
} fio_io_tls_each_s;
```

Calls callbacks for certificate, trust certificate and ALPN added.

#### `fio_io_tls_default_functions`

```c
fio_io_functions_s fio_io_tls_default_functions(fio_io_functions_s *);
```

If `NULL` returns current default, otherwise sets it.

### Reactor Lifecycle Callbacks

The IO reactor provides lifecycle callbacks that allow code to be executed at specific points during the reactor's lifecycle.

#### `fio_state_callback_add`

```c
void fio_state_callback_add(fio_state_event_e event,
                            void (*callback)(void *),
                            void *udata);
```

Adds a callback to be executed at a specific lifecycle event.

Available events include:

* `FIO_CALL_PRE_START` - Called before the reactor starts (before workers are spawned).
* `FIO_CALL_BEFORE_FORK` - Called before forking a new worker process.
* `FIO_CALL_AFTER_FORK` - Called after forking (in both parent and child).
* `FIO_CALL_IN_MASTER` - Called in the master process after forking.
* `FIO_CALL_IN_CHILD` - Called in the child/worker process after forking.
* `FIO_CALL_ON_START` - Called when the reactor starts (in workers).
* `FIO_CALL_ON_IDLE` - Called when the reactor is idle (no pending events).
* `FIO_CALL_ON_SHUTDOWN` - Called when the reactor begins shutting down.
* `FIO_CALL_ON_STOP` - Called when the reactor stops.
* `FIO_CALL_ON_CHILD_CRUSH` - Called when a child worker crashes.
* `FIO_CALL_AT_EXIT` - Called at process exit.

#### `fio_state_callback_remove`

```c
int fio_state_callback_remove(fio_state_event_e event,
                              void (*callback)(void *),
                              void *udata);
```

Removes a previously added callback. Returns 0 on success, -1 if not found.

#### `fio_state_callback_force`

```c
void fio_state_callback_force(fio_state_event_e event);
```

Forces all callbacks for a specific event to be executed immediately.

### IO Async Queue - Worker Threads for non-IO tasks

#### `FIO_IO_ASYN_INIT`

```c
#define FIO_IO_ASYN_INIT ((fio_io_async_s){0})
```

Initializes an IO Async Queue (multi-threaded task queue).

The queue automatically spawns threads and shuts down as the IO reactor starts or stops.

It is recommended that the `fio_io_async_s` be allocated as a static variable, as its memory must remain valid throughout the lifetime of the IO reactor's app.

#### `fio_io_async_queue`

```c
fio_queue_s *fio_io_async_queue(fio_io_async_s *q) { return q->q; }
```

Returns the current task queue associated with the IO Async Queue.


#### `fio_io_async_attach`

```c
void fio_io_async_attach(fio_io_async_s *q, uint32_t threads);
```

Attaches an IO Async Queue for use in multi-threaded (non IO) tasks.

This function can be called multiple times for the same (or other) queue, as long as the async queue (`fio_io_async_s`) was previously initialized using `FIO_IO_ASYN_INIT` or zeroed out. i.e.:

```c
static fio_io_async_s SLOW_HTTP_TASKS = FIO_IO_ASYN_INIT;
fio_io_async_attach(&SLOW_HTTP_TASKS, 32);
```

#### `fio_io_async`

```c
#define fio_io_async(q_, ...) fio_queue_push((q_)->q, __VA_ARGS__)
```

Pushes a task to an IO Async Queue (macro helper).

#### `fio_io_async_every`

```c
void fio_io_async_every(fio_io_async_s *q, fio_timer_schedule_args_s args);
#define fio_io_async_every(async, ...)                                         \
  fio_io_async_every(async, (fio_timer_schedule_args_s){__VA_ARGS__})
```

Schedules a timer bound task for the async queue, see `fio_timer_schedule`.

Possible "named arguments" (`fio_timer_schedule_args_s` members) include:

* The timer function. If it returns a non-zero value, the timer stops:
  `int (*fn)(void *, void *)`
* Opaque user data:
  `void *udata1`
* Opaque user data:
  `void *udata2`
* Called when the timer is done (finished):
  `void (*on_stop)(void *, void *)`
* Timer interval, in milliseconds:
  `uint32_t every`
* The number of times the timer should be performed. -1 == infinity:
  `int32_t repetitions`

-------------------------------------------------------------------------------
## OpenSSL TLS Integration

```c
#define FIO_IO
#include "fio-stl/include.h"
```

The OpenSSL module provides TLS (Transport Layer Security) integration for the facil.io IO reactor using OpenSSL 3.x. When OpenSSL is available, this module automatically registers itself as the default TLS implementation.

**Note**: this module requires OpenSSL 3.x or later. It will not compile if `FIO_NO_TLS` is defined or if OpenSSL is unavailable.

**Note**: this module is automatically included when `FIO_IO` is defined and OpenSSL headers are detected (via `HAVE_OPENSSL` or `__has_include("openssl/ssl.h")`).

### Conditional Compilation

The OpenSSL module compiles only when all of the following conditions are met:

- `FIO_IO` is defined (the IO reactor module is included)
- `FIO_NO_TLS` is **not** defined
- OpenSSL 3.x headers are available (`HAVE_OPENSSL` defined or `openssl/ssl.h` exists)

If OpenSSL is detected but the version is older than 3.x, a compiler warning is issued and the module falls back to the default (no-op) TLS functions.

### Features

The OpenSSL integration provides:

- **TLS 1.3 Support**: Automatic TLS protocol negotiation via OpenSSL
- **Self-Signed Certificates**: Automatic generation using ECDSA P-256 for development/testing
- **Certificate Loading**: Load certificates and private keys from PEM files
- **ALPN Protocol Negotiation**: Application-Layer Protocol Negotiation for HTTP/2, etc.
- **Certificate Verification**: Peer verification with configurable trust store
- **Non-Blocking I/O**: Seamless integration with the facil.io event-driven IO reactor

### Usage with the IO Reactor

The OpenSSL module integrates with the IO system through the `fio_io_tls_s` configuration object:

```c
#define FIO_IO
#include "fio-stl.h"

/* Create a TLS configuration object */
fio_io_tls_s *tls = fio_io_tls_new();

/* Optional: load certificates from PEM files */
fio_io_tls_cert_add(tls,
                    "www.example.com",  /* server name (SNI) */
                    "cert.pem",         /* public certificate */
                    "key.pem",          /* private key */
                    NULL);              /* password (if key is encrypted) */

/* Optional: add trusted CA certificates for peer verification */
fio_io_tls_trust_add(tls, "ca.pem");

/* Optional: configure ALPN protocol negotiation */
fio_io_tls_alpn_add(tls, "h2", on_http2_selected);
fio_io_tls_alpn_add(tls, "http/1.1", on_http1_selected);

/* Start listening with TLS */
fio_io_listen(.url = "0.0.0.0:443",
              .protocol = &MY_PROTOCOL,
              .tls = tls);

/* The TLS object can be freed after fio_io_listen (it's reference counted) */
fio_io_tls_free(tls);

/* Start the IO reactor */
fio_io_start(0);
```

### HTTPS Server Example

A complete example of an HTTPS server:

```c
#define FIO_LOG
#define FIO_IO
#include "fio-stl.h"

/* Protocol callbacks */
FIO_SFUNC void on_data(fio_io_s *io) {
  char buf[1024];
  size_t len = fio_io_read(io, buf, sizeof(buf));
  if (len) {
    /* Echo back with HTTP response */
    const char response[] = 
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 13\r\n"
        "Connection: close\r\n"
        "\r\n"
        "Hello, TLS!\n";
    fio_io_write(io, response, sizeof(response) - 1);
    fio_io_close(io);
  }
}

fio_io_protocol_s HTTPS_PROTOCOL = {
    .on_data = on_data,
    .on_timeout = fio_io_touch,
};

int main(void) {
  /* Create TLS context - will use self-signed certificate */
  fio_io_tls_s *tls = fio_io_tls_new();
  
  /* For production, load real certificates:
   * fio_io_tls_cert_add(tls, "example.com", "cert.pem", "key.pem", NULL);
   */
  
  fio_io_listen(.url = "0.0.0.0:8443",
                .protocol = &HTTPS_PROTOCOL,
                .tls = tls);
  
  fio_io_tls_free(tls);
  
  FIO_LOG_INFO("HTTPS server listening on port 8443");
  FIO_LOG_INFO("Test with: curl -k https://localhost:8443/");
  
  fio_io_start(0);
  return 0;
}
```

### Self-Signed Certificates

When no certificate is configured for a server, the OpenSSL module automatically generates a self-signed certificate with the following properties:

| Property | Value |
|----------|-------|
| Algorithm | ECDSA with P-256 curve |
| Security Level | 128-bit (equivalent to RSA-3072) |
| Signature | SHA-256 |
| Validity | 180 days |
| Serial Number | 128-bit cryptographically random |
| Key Generation | ~10ms (vs ~2000ms for RSA-4096) |

**X.509v3 Extensions** (for browser compatibility):

- **Basic Constraints**: `CA:FALSE` (not a CA certificate)
- **Key Usage**: `digitalSignature`, `keyEncipherment`
- **Extended Key Usage**: `serverAuth`
- **Subject Alternative Name (SAN)**: DNS name matching the server name

**Note**: Self-signed certificates are intended for development and testing only. Browsers will show security warnings. Use properly issued certificates from a trusted Certificate Authority (CA) in production.

### API Reference

#### `fio_openssl_io_functions`

```c
fio_io_functions_s fio_openssl_io_functions(void);
```

Returns the OpenSSL IO functions structure for TLS operations.

This function is called automatically during module initialization to register OpenSSL as the default TLS implementation. You typically don't need to call this directly.

**Returns:** A `fio_io_functions_s` structure containing:

- `build_context` - Creates an SSL_CTX from `fio_io_tls_s` configuration
- `free_context` - Frees the SSL_CTX and associated resources
- `start` - Initializes TLS for a new connection (SSL_new, handshake)
- `read` - Non-blocking TLS read (SSL_read)
- `write` - Non-blocking TLS write (SSL_write)
- `flush` - Flushes pending TLS data (no-op for OpenSSL)
- `finish` - Initiates TLS shutdown (SSL_shutdown)
- `cleanup` - Frees per-connection SSL object

### TLS Configuration Functions

The following functions from the IO module are used to configure TLS. See the [IO Reactor documentation](400%20io.md) for complete details.

#### `fio_io_tls_new`

```c
fio_io_tls_s *fio_io_tls_new(void);
```

Creates a new TLS configuration object.

#### `fio_io_tls_free`

```c
void fio_io_tls_free(fio_io_tls_s *tls);
```

Frees a TLS configuration object (reference counted).

#### `fio_io_tls_cert_add`

```c
fio_io_tls_s *fio_io_tls_cert_add(fio_io_tls_s *tls,
                                  const char *server_name,
                                  const char *public_cert_file,
                                  const char *private_key_file,
                                  const char *pk_password);
```

Adds a certificate to the TLS context. Supports SNI (Server Name Indication) for hosting multiple domains.

- `server_name` - The server name for SNI matching
- `public_cert_file` - Path to PEM-encoded certificate (or certificate chain)
- `private_key_file` - Path to PEM-encoded private key
- `pk_password` - Password for encrypted private keys (or NULL)

If `public_cert_file` and `private_key_file` are both NULL, a self-signed certificate is generated.

#### `fio_io_tls_trust_add`

```c
fio_io_tls_s *fio_io_tls_trust_add(fio_io_tls_s *tls,
                                   const char *public_cert_file);
```

Adds a trusted CA certificate for peer verification.

- `public_cert_file` - Path to PEM-encoded CA certificate, or NULL to use system defaults

When trust certificates are added, peer verification is enabled (`SSL_VERIFY_PEER`).

#### `fio_io_tls_alpn_add`

```c
fio_io_tls_s *fio_io_tls_alpn_add(fio_io_tls_s *tls,
                                  const char *protocol_name,
                                  void (*on_selected)(fio_io_s *));
```

Registers an ALPN protocol and its selection callback.

- `protocol_name` - Protocol identifier (e.g., "h2", "http/1.1")
- `on_selected` - Callback invoked when this protocol is negotiated

The first protocol added is the preferred/default protocol.

### Security Considerations

#### Certificate Verification

- **Server Mode**: Certificate verification is typically not enabled (clients don't usually present certificates)

- **Client Mode**: If no trust store is configured, verification is disabled with a security warning logged

```c
/* Enable certificate verification for client connections */
fio_io_tls_s *tls = fio_io_tls_new();
fio_io_tls_trust_add(tls, NULL);  /* Use system trust store */
/* or */
fio_io_tls_trust_add(tls, "ca-bundle.pem");  /* Use specific CA */
```

#### Production Recommendations

1. **Use Real Certificates**: Obtain certificates from a trusted CA (e.g., Let's Encrypt)
2. **Enable Verification**: Always configure trust stores for client connections
3. **Keep OpenSSL Updated**: Security patches are released regularly
4. **Protect Private Keys**: Use appropriate file permissions and consider encrypted keys

#### SIGPIPE Handling

The module automatically monitors `SIGPIPE` signals to prevent OpenSSL from crashing the application when writing to closed connections.

### Non-Blocking I/O Integration

The OpenSSL module configures SSL contexts for non-blocking operation:

- `SSL_MODE_ENABLE_PARTIAL_WRITE` - Allow partial writes
- `SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER` - Buffer can move between writes
- `SSL_MODE_AUTO_RETRY` disabled - Return immediately on would-block

TLS handshakes are performed asynchronously:
- Server connections use `SSL_accept()`
- Client connections use `SSL_connect()`

Both return immediately and complete during subsequent read/write operations.

### Error Handling

OpenSSL errors are logged using the facil.io logging system:

- `FIO_LOG_ERROR` - Critical failures (certificate loading, key generation)
- `FIO_LOG_WARNING` - Non-fatal issues (trust store loading)
- `FIO_LOG_SECURITY` - Security-relevant warnings (verification disabled)
- `FIO_LOG_DEBUG2` - Detailed debugging information

### Memory Management

- SSL contexts (`SSL_CTX`) are reference counted and shared across connections
- Per-connection SSL objects are allocated on connection start and freed on close
- The global ECDSA private key (for self-signed certificates) is freed at program exit
- Context cleanup is deferred to avoid blocking the IO reactor

------------------------------------------------------------
## TLS 1.3 IO Integration

```c
#define FIO_IO
#include "fio-stl/include.h"
```

The TLS 1.3 IO module provides seamless integration between the native TLS 1.3 implementation and the facil.io IO reactor. When OpenSSL is not available, this module automatically registers as the default TLS implementation.

**Note**: This module is automatically included when `FIO_IO` is defined and `FIO_TLS13` is available. It requires the TLS 1.3 module (`190 tls13.h`) and the IO reactor module (`400 io.h`).

------------------------------------------------------------

### Overview

The TLS 1.3 IO integration provides:

- **Drop-in TLS support** - Works with existing `fio_io_tls_s` configuration
- **Automatic fallback** - Used when OpenSSL is not available
- **Self-signed certificates** - Automatic generation for development/testing
- **PEM file loading** - Load certificates and keys from PEM files
- **ALPN support** - Application-Layer Protocol Negotiation
- **Non-blocking I/O** - Seamless integration with the event-driven reactor

### Conditional Compilation

The TLS 1.3 IO module compiles when:

- `FIO_IO` is defined (the IO reactor module is included)
- `FIO_TLS13` is defined (the TLS 1.3 module is included)
- `FIO_NO_TLS` is **not** defined

When OpenSSL is not detected (`HAVE_OPENSSL` not defined and `openssl/ssl.h` not found), the TLS 1.3 module automatically registers as the default TLS implementation.

------------------------------------------------------------

### Features

#### Self-Signed Certificates

When no certificate is configured for a server, the module automatically generates a self-signed certificate:

| Property | Value |
|----------|-------|
| Algorithm | ECDSA with P-256 curve |
| Security Level | 128-bit (equivalent to RSA-3072) |
| Signature | SHA-256 |
| Key Generation | ~10ms (vs ~2000ms for RSA-4096) |

**Note**: Self-signed certificates are intended for development and testing only. Use properly issued certificates from a trusted Certificate Authority (CA) in production.

#### Certificate Loading

The module supports loading certificates and private keys from PEM files:

- **P-256 ECDSA** - 32-byte private key scalar
- **Ed25519** - 32-byte private key seed
- **RSA** - Not yet supported for signing (verification only)

#### ALPN Protocol Negotiation

Application-Layer Protocol Negotiation (RFC 7301) is supported for:

- HTTP/2 (`h2`)
- HTTP/1.1 (`http/1.1`)
- Custom protocols

------------------------------------------------------------

### Usage with the IO Reactor

The TLS 1.3 module integrates with the IO system through the `fio_io_tls_s` configuration object:

```c
#define FIO_IO
#include "fio-stl.h"

/* Create a TLS configuration object */
fio_io_tls_s *tls = fio_io_tls_new();

/* Optional: load certificates from PEM files */
fio_io_tls_cert_add(tls,
                    "www.example.com",  /* server name (SNI) */
                    "cert.pem",         /* public certificate */
                    "key.pem",          /* private key */
                    NULL);              /* password (if key is encrypted) */

/* Optional: configure ALPN protocol negotiation */
fio_io_tls_alpn_add(tls, "h2", on_http2_selected);
fio_io_tls_alpn_add(tls, "http/1.1", on_http1_selected);

/* Start listening with TLS */
fio_io_listen(.url = "0.0.0.0:443",
              .protocol = &MY_PROTOCOL,
              .tls = tls);

/* The TLS object can be freed after fio_io_listen (it's reference counted) */
fio_io_tls_free(tls);

/* Start the IO reactor */
fio_io_start(0);
```

------------------------------------------------------------

### HTTPS Server Example

A complete example of an HTTPS server using the native TLS 1.3 implementation:

```c
#define FIO_LOG
#define FIO_IO
#include "fio-stl.h"

/* Protocol callbacks */
FIO_SFUNC void on_data(fio_io_s *io) {
  char buf[1024];
  size_t len = fio_io_read(io, buf, sizeof(buf));
  if (len) {
    /* Echo back with HTTP response */
    const char response[] = 
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 13\r\n"
        "Connection: close\r\n"
        "\r\n"
        "Hello, TLS!\n";
    fio_io_write(io, response, sizeof(response) - 1);
    fio_io_close(io);
  }
}

fio_io_protocol_s HTTPS_PROTOCOL = {
    .on_data = on_data,
    .on_timeout = fio_io_touch,
};

int main(void) {
  /* Create TLS context - will use self-signed certificate */
  fio_io_tls_s *tls = fio_io_tls_new();
  
  /* For production, load real certificates:
   * fio_io_tls_cert_add(tls, "example.com", "cert.pem", "key.pem", NULL);
   */
  
  fio_io_listen(.url = "0.0.0.0:8443",
                .protocol = &HTTPS_PROTOCOL,
                .tls = tls);
  
  fio_io_tls_free(tls);
  
  FIO_LOG_INFO("HTTPS server listening on port 8443");
  FIO_LOG_INFO("Test with: curl -k https://localhost:8443/");
  
  fio_io_start(0);
  return 0;
}
```

------------------------------------------------------------

### TLS Client Example

Using TLS 1.3 for outgoing connections:

```c
#define FIO_LOG
#define FIO_IO
#include "fio-stl.h"

FIO_SFUNC void on_connect(fio_io_s *io) {
  FIO_LOG_INFO("TLS connection established!");
  
  /* Send HTTP request */
  const char request[] = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
  fio_io_write(io, request, sizeof(request) - 1);
}

FIO_SFUNC void on_data(fio_io_s *io) {
  char buf[4096];
  size_t len = fio_io_read(io, buf, sizeof(buf) - 1);
  if (len) {
    buf[len] = '\0';
    FIO_LOG_INFO("Received: %s", buf);
    fio_io_close(io);
  }
}

fio_io_protocol_s CLIENT_PROTOCOL = {
    .on_attach = on_connect,
    .on_data = on_data,
    .on_timeout = fio_io_touch,
};

int main(void) {
  /* Create TLS context for client */
  fio_io_tls_s *tls = fio_io_tls_new();
  
  /* Add server name for SNI */
  fio_io_tls_cert_add(tls, "example.com", NULL, NULL, NULL);
  
  /* Connect with TLS */
  fio_io_connect(.url = "example.com:443",
                 .protocol = &CLIENT_PROTOCOL,
                 .tls = tls);
  
  fio_io_tls_free(tls);
  
  fio_io_start(0);
  return 0;
}
```

------------------------------------------------------------

### API Reference

#### `fio_tls13_io_functions`

```c
fio_io_functions_s fio_tls13_io_functions(void);
```

Returns the TLS 1.3 IO functions structure for TLS operations.

This function is called automatically during module initialization to register TLS 1.3 as the default TLS implementation (when OpenSSL is not available). You typically don't need to call this directly.

**Returns:** A `fio_io_functions_s` structure containing:

| Function | Purpose |
|----------|---------|
| `build_context` | Creates TLS context from `fio_io_tls_s` configuration |
| `free_context` | Frees the TLS context and associated resources |
| `start` | Initializes TLS for a new connection |
| `read` | Non-blocking TLS read (decryption) |
| `write` | Non-blocking TLS write (encryption) |
| `flush` | Flushes pending handshake data |
| `finish` | Sends close_notify alert |
| `cleanup` | Frees per-connection TLS state |

------------------------------------------------------------

### TLS Configuration Functions

The following functions from the IO module are used to configure TLS. See the [IO Reactor documentation](400%20io.md) for complete details.

#### `fio_io_tls_new`

```c
fio_io_tls_s *fio_io_tls_new(void);
```

Creates a new TLS configuration object.

#### `fio_io_tls_free`

```c
void fio_io_tls_free(fio_io_tls_s *tls);
```

Frees a TLS configuration object (reference counted).

#### `fio_io_tls_cert_add`

```c
fio_io_tls_s *fio_io_tls_cert_add(fio_io_tls_s *tls,
                                  const char *server_name,
                                  const char *public_cert_file,
                                  const char *private_key_file,
                                  const char *pk_password);
```

Adds a certificate to the TLS context.

**Parameters:**
- `server_name` - The server name for SNI matching (client) or certificate selection (server)
- `public_cert_file` - Path to PEM-encoded certificate (or NULL for self-signed)
- `private_key_file` - Path to PEM-encoded private key (or NULL for self-signed)
- `pk_password` - Password for encrypted private keys (or NULL)

**Supported key types:**
- P-256 ECDSA (recommended)
- Ed25519

#### `fio_io_tls_alpn_add`

```c
fio_io_tls_s *fio_io_tls_alpn_add(fio_io_tls_s *tls,
                                  const char *protocol_name,
                                  void (*on_selected)(fio_io_s *));
```

Registers an ALPN protocol and its selection callback.

**Parameters:**
- `protocol_name` - Protocol identifier (e.g., "h2", "http/1.1")
- `on_selected` - Callback invoked when this protocol is negotiated

The first protocol added is the preferred/default protocol.

------------------------------------------------------------

### Internal Architecture

The TLS 1.3 IO integration uses a layered architecture:

```

         Application Layer           
    (fio_io_read, fio_io_write)      

         IO Reactor Layer            
    (fio_io_functions_s callbacks)   

      TLS 1.3 IO Integration         
    (fio___tls13_read/write)         

       TLS 1.3 Record Layer          
  (fio_tls13_record_encrypt/decrypt) 

        AEAD Cipher Layer            
   (AES-GCM, ChaCha20-Poly1305)      

          Socket Layer               
     (fio_sock_read/write)           

```

#### Connection State

Each TLS connection maintains:

| Buffer | Purpose | Size |
|--------|---------|------|
| `recv_buf` | Incoming encrypted data | ~17KB |
| `app_buf` | Decrypted application data | 16KB |
| `send_buf` | Outgoing handshake data | 8KB |
| `enc_buf` | Pre-allocated encryption buffer | ~17KB |

#### Handshake Flow

**Server:**
1. `start` - Initialize server state, wait for ClientHello
2. `read` - Receive ClientHello, send ServerHello..Finished
3. `read` - Receive client Finished
4. Connection established

**Client:**
1. `start` - Initialize client state, send ClientHello
2. `read` - Receive ServerHello..Finished, send client Finished
3. Connection established

------------------------------------------------------------

### Security Considerations

#### Certificate Verification

- **Server Mode**: Certificate verification is typically not enabled (clients don't usually present certificates)
- **Client Mode**: By default, certificate verification is **skipped** with a warning logged

To enable certificate verification for client connections, a trust store must be configured (not yet exposed through the IO API).

#### Production Recommendations

1. **Use Real Certificates**: Obtain certificates from a trusted CA (e.g., Let's Encrypt)
2. **Avoid Self-Signed**: Self-signed certificates should only be used for development
3. **Keep Updated**: Security patches may be released for the TLS implementation
4. **Protect Private Keys**: Use appropriate file permissions

#### Memory Safety

- All sensitive key material is zeroed on cleanup using `fio_secure_zero`
- Connection state is properly freed on close
- Buffer overflows are prevented by size checks

------------------------------------------------------------

### Comparison with OpenSSL

| Feature | TLS 1.3 Native | OpenSSL |
|---------|----------------|---------|
| Dependencies | None | OpenSSL 3.x |
| Binary Size | Smaller | Larger |
| TLS Versions | 1.3 only | 1.0-1.3 |
| Cipher Suites | 3 (TLS 1.3) | Many |
| Certificate Types | P-256, Ed25519 | All |
| Session Resumption | Not yet | Yes |
| 0-RTT | Not yet | Yes |
| OCSP Stapling | No | Yes |
| Client Certificates | Yes | Yes |

**When to use TLS 1.3 Native:**
- Minimal dependencies required
- Only TLS 1.3 clients expected
- Embedded or resource-constrained environments

**When to use OpenSSL:**
- Legacy TLS version support needed
- Full certificate type support required
- Session resumption important
- OCSP stapling required

------------------------------------------------------------

### Error Handling

TLS errors are logged using the facil.io logging system:

| Log Level | Purpose |
|-----------|---------|
| `FIO_LOG_ERROR` | Critical failures (certificate loading, key generation) |
| `FIO_LOG_WARNING` | Non-fatal issues (trust store loading) |
| `FIO_LOG_DEBUG2` | Detailed debugging information |

Connection errors result in the connection being closed with an appropriate TLS alert.

------------------------------------------------------------

### Memory Management

- **Context** (`fio___tls13_context_s`): Shared across connections, reference counted
- **Connection** (`fio___tls13_connection_s`): Per-connection, freed on close
- **Certificates**: Copied to context, freed with context
- **Self-signed key**: Global, freed at program exit

Leak counters are enabled in debug builds to detect memory leaks.

------------------------------------------------------------
## IPC - Inter-Process Communication

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE
```

The IPC module provides secure, high-performance inter-process communication between master and worker processes in the facil.io framework. It enables workers to call functions on the master process, receive streaming replies, and broadcast messages to all workers.

Key features:

- **Worker-to-Master Calls**: Workers can invoke arbitrary code on the master process with reply callbacks
- **Streaming Replies**: Master can send multiple replies before signaling completion
- **Local Broadcasting**: Broadcast messages to all processes on the local machine
- **Cluster Communication**: Send messages to remote machines in a cluster
- **Global Broadcasting**: Execute code on ALL processes on ALL machines
- **Encrypted Transport**: All IPC messages are encrypted with ChaCha20-Poly1305 AEAD
- **Reference Counting**: Messages use reference counting for safe memory management
- **Zero-Copy Buffer Concatenation**: Multiple buffers can be combined without intermediate allocation

### Execution Scope Overview

The IPC module provides functions with different execution scopes:

| Function | Flags Set | Execution Scope |
|----------|-----------|-----------------|
| `fio_ipc_call` | (none) | Master only |
| `fio_ipc_local` | `.workers = 1` | Master + all workers (local machine) |
| `fio_ipc_cluster` | `.cluster = 1` | Master on each remote machine only |
| `fio_ipc_broadcast` | `.workers = 1, .cluster = 1` | ALL processes on ALL machines |
| `fio_ipc_reply` | N/A | Caller only (reply to request) |

**Note**: Use `.exclude = FIO_IPC_EXCLUDE_SELF` to exclude the calling process from execution.

### IPC Message Types

#### `fio_ipc_s`

```c
typedef struct fio_ipc_s {
  fio_io_s *from; /* IO to caller - set by receiver (not transmitted) */
  /* ----- wire format starts here ----- */
  uint32_t len;   /* Length of data[] (AAD - authenticated, unencrypted) */
  uint16_t flags; /* User settable flags (AAD - authenticated, unencrypted) */
  uint16_t routing_flags; /* Internal (AAD - authenticated, unencrypted) */
  uint64_t timestamp;     /* timestamp (unencrypted, used for nonce) */
  uint64_t id;            /* 8 random bytes (unencrypted, used for nonce) */
  union {
    void (*call)(struct fio_ipc_s *); /* function pointer (local IPC) */
    uint32_t opcode;                  /* op-code (cluster RPC) */
  };
  void (*on_reply)(struct fio_ipc_s *); /* run on caller (encrypted) */
  void (*on_done)(struct fio_ipc_s *);  /* run on caller (encrypted) */
  void *udata; /* opaque, valid only in caller (encrypted) */
  char data[]; /* Variable-length data + 16-byte MAC at end (encrypted) */
} fio_ipc_s;
```

The IPC message structure contains all information needed for a request/response cycle. Messages are reference-counted and encrypted before transmission.

**Members:**

- `from` - Pointer to the caller's IO connection (set by receiver, used for replies; not transmitted)
- `len` - Length of the `data[]` payload in bytes (part of authenticated additional data)
- `flags` - User-settable flags, preserved through the call/reply cycle (part of AAD)
- `routing_flags` - Internal routing flags used by the IPC system (do not modify)
- `timestamp` - Millisecond timestamp, used as part of the encryption nonce
- `id` - Random 64-bit identifier, used as part of the encryption nonce
- `call` / `opcode` - Union: function pointer for local IPC, or op-code for cluster RPC
- `on_reply` - Function pointer executed on the caller when a reply is received
- `on_done` - Function pointer executed on the caller when all replies are complete
- `udata` - Opaque user data pointer, valid only in the calling process
- `data` - Flexible array member containing the message payload

**Note**: The `from` field is NOT part of the wire format. The wire format starts at `len`. The `call`/`opcode`, `on_reply`, `on_done`, `udata`, and `data` fields are encrypted during transmission.

#### `fio_ipc_args_s`

```c
typedef struct {
  void (*call)(fio_ipc_s *);     /** Function to execute on target process */
  void (*on_reply)(fio_ipc_s *); /** Callback when reply received */
  void (*on_done)(fio_ipc_s *);  /** Callback when all replies done */
  fio_io_s *exclude;             /** Optional: IO to exclude from delivery */
  uint64_t timestamp;            /** Optional: force timestamp (0 = current time) */
  uint64_t id;                   /** Optional: force ID (0 = random) */
  uint32_t opcode;               /** Replaces `call` with op-code if non-zero */
  uint16_t flags;                /** User-settable flags */
  bool cluster;                  /** If set, intended for all machines in cluster */
  bool workers;                  /** If set, intended for master + workers */
  void *udata;                   /** Opaque user data (caller-side only) */
  fio_buf_info_s *data;          /** Array of buffers for message payload */
} fio_ipc_args_s;
```

Arguments structure for creating IPC messages. Used by `fio_ipc_new` and the main API macros.

**Key Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `call` | `void (*)(fio_ipc_s *)` | Function executed on target. Required for local IPC. |
| `on_reply` | `void (*)(fio_ipc_s *)` | Called when reply received. Optional. |
| `on_done` | `void (*)(fio_ipc_s *)` | Called when all replies done. Optional. |
| `opcode` | `uint32_t` | Op-code for cluster RPC. Replaces `call` if non-zero. |
| `cluster` | `bool` | Send to remote machines in cluster. |
| `workers` | `bool` | Send to master + all workers on local machine. |
| `exclude` | `fio_io_s*` | Exclude IO (if known) / self from execution. |
| `udata` | `void *` | Opaque user data (not transmitted). |
| `data` | `fio_buf_info_s *` | Message payload. Use `FIO_IPC_DATA()` macro. |

#### `fio_ipc_opcode_s`

```c
typedef struct fio_ipc_opcode_s {
  uint32_t opcode;                      /** Unique op-code value */
  void (*call)(struct fio_ipc_s *);     /** Function to call */
  void (*on_reply)(struct fio_ipc_s *); /** Reply callback */
  void (*on_done)(struct fio_ipc_s *);  /** Reply finished callback */
  void *udata;                          /** Opaque user data */
} fio_ipc_opcode_s;
```

Structure for registering op-code handlers for cluster RPC communication.

**Members:**

- `opcode` - Unique non-zero op-code value (values >= `0xFF000000` are reserved)
- `call` - Function executed when message with this op-code is received
- `on_reply` - Function executed when a reply is received
- `on_done` - Function executed when all replies are complete
- `udata` - User data passed to handlers via `ipc->udata`

#### `fio_ipc_reply_args_s`

```c
typedef struct {
  fio_ipc_s *ipc;       /** The IPC message being replied to. Required. */
  fio_buf_info_s *data; /** Array of buffers for reply payload */
  uint64_t timestamp;   /** Optional: override timestamp (0 = current time) */
  uint64_t id;          /** Optional: override ID (0 = original request ID) */
  uint16_t flags;       /** Optional: override flags (0 = original flags) */
  uint8_t done;         /** Set to 1 on final reply to trigger on_done */
  uint8_t flags_set;    /** Set to 1 to use flags value (allows flags=0) */
} fio_ipc_reply_args_s;
```

Arguments structure for sending replies.

### Configuration Macros

#### `FIO_IPC_URL_MAX_LENGTH`

```c
#ifndef FIO_IPC_URL_MAX_LENGTH
#define FIO_IPC_URL_MAX_LENGTH 1024
#endif
```

Maximum length for the IPC socket URL. Default is 1024 characters.

#### `FIO_IPC_MAX_LENGTH`

```c
#ifndef FIO_IPC_MAX_LENGTH
#define FIO_IPC_MAX_LENGTH (128ULL * 1024U * 1024U)
#endif
```

Maximum length for IPC message payloads. Default is 128 MB. Messages exceeding this limit will fail to be created.

### Utility Macros

#### `FIO_IPC_DATA`

```c
#define FIO_IPC_DATA(...)                                                      \
  (fio_buf_info_s[]) {                                                         \
    __VA_ARGS__, { 0 }                                                         \
  }
```

A helper macro for composing multiple buffers into a single IPC message. The macro creates a `fio_buf_info_s` array terminated by a zero-length entry.

This enables zero-copy buffer concatenation - multiple buffers are combined into the IPC message without requiring an intermediate allocation.

Example usage:

```c
/* Combine a string header with binary data */
const char *header = "MSG:";
uint64_t value = 0xDEADBEEF;

fio_ipc_call(.call = my_handler,
             .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)header),
                                  FIO_BUF_INFO2(&value, sizeof(value))));
```

**Note**: Data is copied synchronously when the IPC function is called, before the operation is deferred. Source buffers can be stack-allocated or freed immediately after the call.

**Note**: When sending a struct with a flexible array member, use `offsetof(struct_type, flex_member)` instead of `sizeof(struct_type)` to get the correct size without padding.

#### `FIO_IPC_EXCLUDE_SELF`

```c
#define FIO_IPC_EXCLUDE_SELF ((fio_io_s *)((char *)-1LL))
```

Special value that can be set in `ipc->from` before calling `fio_ipc_send` to exclude the current process from receiving the message. Alternatively, use `.exclude = FIO_IPC_EXCLUDE_SELF` in `fio_ipc_args_s`.

### Main API

The main API consists of four macros that create and send IPC messages with different execution scopes. All macros use named arguments via `fio_ipc_args_s`.

#### `fio_ipc_call`

```c
#define fio_ipc_call(...) fio_ipc_send(fio_ipc_new(__VA_ARGS__))
```

Call arbitrary code on the **master process only** (worker -> master or master -> master).

The `call` function pointer is executed on the master process. When called from a worker, the message is sent over the IPC socket. When called from the master, execution is deferred via `fio_io_defer`.

Replies are sent back to the caller via the `on_reply` callback. When all replies are complete (signaled by `done = 1` in `fio_ipc_reply`), the `on_done` callback is invoked.

```c
/* Worker calls master to process data */
fio_ipc_call(.call = process_on_master,
             .on_reply = handle_reply,
             .on_done = cleanup,
             .udata = my_context,
             .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"request_data")));
```

#### `fio_ipc_local`

```c
#define fio_ipc_local(...) fio_ipc_send(fio_ipc_new(.workers = 1, __VA_ARGS__))
```

Execute a callback on **all processes on the local machine** (master + all workers).

The `call` function pointer is executed on the master and all worker processes.

```c
/* Broadcast to all local processes */
fio_ipc_local(.call = handle_local_broadcast,
              .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"local_data")));

/* Broadcast to all local processes EXCEPT self */
fio_ipc_local(.call = handle_local_broadcast,
              .exclude = FIO_IPC_EXCLUDE_SELF,
              .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"to_others")));
```

**Note**: When called from a worker, the message is sent to the master, which then re-broadcasts to all workers.

#### `fio_ipc_cluster`

```c
#define fio_ipc_cluster(...) fio_ipc_send(fio_ipc_new(.cluster = 1, __VA_ARGS__))
```

Send a message to the **master process on each connected remote machine**. Does **NOT** execute locally.

Requires an op-code (not a function pointer) since function pointers cannot be transmitted across machines.

```c
/* Send to remote machines only (no local execution) */
fio_ipc_cluster(.opcode = OP_SYNC_DATA,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"sync_payload")));
```

**Note**: Use `fio_ipc_broadcast` if you need execution on all machines including local.

#### `fio_ipc_broadcast`

```c
#define fio_ipc_broadcast(...) fio_ipc_send(fio_ipc_new(.workers = 1, .cluster = 1, __VA_ARGS__))
```

Execute an op-code callback on **ALL processes on ALL machines** (local + remote).

The op-code handler executes on:
- All local processes (master + workers) on this machine
- All processes (master + workers) on all connected remote machines

```c
/* Broadcast to ALL processes on ALL machines */
fio_ipc_broadcast(.opcode = OP_CACHE_INVALIDATE,
                  .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"cache_key")));

/* Broadcast to all except current process */
fio_ipc_broadcast(.opcode = OP_CONFIG_UPDATE,
                  .exclude = FIO_IPC_EXCLUDE_SELF,
                  .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"config_data")));
```

**Note**: Requires a registered op-code handler via `fio_ipc_opcode_register()`.

### Reply Function

#### `fio_ipc_reply`

```c
SFUNC void fio_ipc_reply(fio_ipc_reply_args_s args);
/* Named arguments using macro. */
#define fio_ipc_reply(r, ...)                                                  \
  fio_ipc_reply((fio_ipc_reply_args_s){.ipc = (r), __VA_ARGS__})
```

Send a response to the caller process (master -> caller).

Can be called multiple times for streaming responses. Set `done = 1` on the last reply to signal completion and trigger the caller's `on_done` callback.

The function is shadowed by a macro. The first argument is the IPC message being replied to:

```c
/* Master handler sends streaming replies */
void my_handler(fio_ipc_s *msg) {
  /* Send intermediate reply */
  fio_ipc_reply(msg,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"chunk1")),
                .done = 0);
  
  /* Send final reply */
  fio_ipc_reply(msg,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"final")),
                .done = 1);
}
```

**Note**: The reply inherits `call`, `on_reply`, `on_done`, and `udata` from the original request.

### Op-Code Registration

Op-codes enable cluster-wide RPC by mapping integer codes to handler functions. Since function pointers cannot be transmitted across machines, op-codes provide a portable way to invoke remote handlers.

#### `fio_ipc_opcode_register`

```c
SFUNC int fio_ipc_opcode_register(fio_ipc_opcode_s opcode);
/* Named arguments using macro. */
#define fio_ipc_opcode_register(...)                                           \
  fio_ipc_opcode_register((fio_ipc_opcode_s){__VA_ARGS__})
```

Registers an op-code handler for message routing.

There are two types of messages:
1. **Fast Path** - Function pointers in the message payload (local IPC only)
2. **Safe Path** - Op-code in the `call` payload (multi-machine RPC)

```c
/* Define op-codes */
#define OP_SYNC_DATA    1
#define OP_INVALIDATE   2

/* Handler for sync data messages */
void on_sync_data(fio_ipc_s *msg) {
  printf("Received sync data: %.*s\n", (int)msg->len, msg->data);
}

/* Register before starting reactor */
fio_ipc_opcode_register(.opcode = OP_SYNC_DATA,
                        .call = on_sync_data,
                        .udata = NULL);

/* To unregister, set call to NULL */
fio_ipc_opcode_register(.opcode = OP_SYNC_DATA, .call = NULL);
```

**Returns:** 0 on success, -1 on failure.

**Note**: Op-codes MUST be non-zero `uint32_t` values. Values >= `0xFF000000` are reserved for internal use.

**Note**: Thread safety requires this be called **before** `fio_io_start()`.

#### `fio_ipc_opcode`

```c
SFUNC const fio_ipc_opcode_s *fio_ipc_opcode(uint32_t opcode);
```

Returns a pointer to a registered op-code structure, or NULL if not found.

**Parameters:**

- `opcode` - The op-code to look up

**Returns:** Pointer to the registered `fio_ipc_opcode_s`, or NULL if not registered.

```c
const fio_ipc_opcode_s *op = fio_ipc_opcode(OP_SYNC_DATA);
if (op) {
  printf("Op-code %u is registered\n", op->opcode);
}
```

### Core Functions

These functions provide low-level control over IPC message creation and sending.

#### `fio_ipc_new`

```c
SFUNC fio_ipc_s *fio_ipc_new(fio_ipc_args_s args);
/* Named arguments using macro. */
#define fio_ipc_new(...) fio_ipc_new((fio_ipc_args_s){__VA_ARGS__})
```

Authors a message without sending it.

Used internally by the main API macros. Also available for "faking" IPC or when composing a unified code path for local execution.

```c
/* Create a message for manual handling */
fio_ipc_s *msg = fio_ipc_new(.call = my_handler,
                             .on_reply = my_reply_handler,
                             .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"data")));
/* ... use message ... */
fio_ipc_free(msg);
```

**Returns:** A new IPC message, or NULL on allocation failure.

#### `fio_ipc_send`

```c
SFUNC void fio_ipc_send(fio_ipc_s *ipc);
```

Encrypts the IPC message, sends it for execution based on flags, and frees it.

Message routing is determined by the flags set during creation:
- No flags: Send to master only (`fio_ipc_call`)
- `.workers = 1`: Send to master + workers (`fio_ipc_local`)
- `.cluster = 1`: Send to remote masters (`fio_ipc_cluster`)
- `.workers = 1, .cluster = 1`: Send to all (`fio_ipc_broadcast`)

**Parameters:**

- `ipc` - The IPC message to send (ownership transferred)

**Note**: Takes ownership of the message's memory. The message is encrypted and unusable once the call returns.

**Note**: If `ipc->from == FIO_IPC_EXCLUDE_SELF`, the calling process is excluded from execution.

#### `fio_ipc_send_to`

```c
SFUNC void fio_ipc_send_to(fio_io_s *to, fio_ipc_s *ipc);
```

Encrypts the IPC message and sends it directly to a specific IO connection, then frees the message.

**Parameters:**

- `to` - Target IO connection to send the message to
- `ipc` - The IPC message to send (ownership transferred)

**Note**: Takes ownership of the message's memory.

**Note**: If `to` is NULL, the message is freed without sending.

#### `fio_ipc_dup`

```c
SFUNC fio_ipc_s *fio_ipc_dup(fio_ipc_s *msg);
```

Duplicate a message by incrementing its reference count.

Use when storing messages for later processing. Every `fio_ipc_dup()` must be matched with a corresponding `fio_ipc_free()`.

**Returns:** The same pointer with incremented reference count.

```c
void my_handler(fio_ipc_s *msg) {
  /* Store message for async processing */
  fio_ipc_s *stored = fio_ipc_dup(msg);
  schedule_async_work(stored);
}

void async_work_done(fio_ipc_s *msg) {
  /* Process and free */
  process_data(msg->data, msg->len);
  fio_ipc_free(msg);
}
```

#### `fio_ipc_free`

```c
SFUNC void fio_ipc_free(fio_ipc_s *msg);
```

Free a message by decrementing its reference count.

The message is destroyed when the reference count reaches zero.

**Note**: Messages passed to callbacks are automatically freed after the callback returns. Only call `fio_ipc_free` on messages you have explicitly duplicated with `fio_ipc_dup`.

#### `fio_ipc_detach`

```c
SFUNC void fio_ipc_detach(fio_ipc_s *msg);
```

Detaches the IPC message from its originating IO connection.

Call this function if storing the message or performing non-IPC actions using the IPC message. This releases the reference to the `from` IO connection, preventing potential issues if the connection closes while the message is still in use.

**Parameters:**

- `msg` - The IPC message to detach

**Note**: After calling `fio_ipc_detach`, the `msg->from` field will be NULL and replies cannot be sent using this message.

#### `fio_ipc_after_send`

```c
SFUNC void fio_ipc_after_send(fio_ipc_s *ipc,
                              void (*fn)(fio_ipc_s *, void *),
                              void *udata);
```

Set a callback to execute when the last reference is freed (e.g., sending complete).

Use this to prevent race conditions between the encrypted state required for sending and the unencrypted state used for code execution.

**Parameters:**

- `ipc` - The IPC message
- `fn` - Callback function to execute after sending completes
- `udata` - User data passed to the callback

**Note**: This is a one-shot callback.

### Encryption Functions

#### `fio_ipc_encrypt`

```c
SFUNC void fio_ipc_encrypt(fio_ipc_s *m);
```

Encrypt an IPC message before sending.

**Note**: Messages are automatically encrypted by `fio_ipc_send` and `fio_ipc_send_to`. This function is only needed for manual message handling.

**Note**: Encryption is idempotent - calling on an already-encrypted message has no effect.

#### `fio_ipc_decrypt`

```c
FIO_IFUNC int fio_ipc_decrypt(fio_ipc_s *m);
```

Decrypt an IPC message when received.

**Returns:** 0 on success, non-zero on failure (e.g., MAC verification failed).

**Note**: If decryption fails, a security log message is emitted. This may indicate message tampering or an attack.

**Note**: Decryption is idempotent - calling on an already-decrypted message returns 0 immediately.

### Cluster Functions

The cluster subsystem extends IPC to support communication between multiple server instances across machines.

#### `fio_ipc_cluster_listen`

```c
SFUNC fio_io_listener_s *fio_ipc_cluster_listen(uint16_t port);
```

Listens for cluster connections on the specified port and auto-connects to peers via UDP discovery.

All server instances get all `cluster` messages (e.g., pub/sub cluster). Uses the environment's (shared) secret for rudimentary encryption without forward secrecy.

**Parameters:**

- `port` - TCP/UDP port to listen on for cluster connections

**Returns:** A listener handle on success, or NULL on error.

**Note**: Requires a shared secret via the `SECRET` environment variable. Returns NULL if using a random secret.

**Note**: Rotate secrets when possible (requires restart). Good for trusted data centers, Kubernetes pods, etc.

```c
/* Start cluster listener on port 9000 */
fio_io_listener_s *listener = fio_ipc_cluster_listen(9000);
if (!listener) {
  fprintf(stderr, "Failed to start cluster - check SECRET env var\n");
}
```

#### `fio_ipc_cluster_connect`

```c
SFUNC void fio_ipc_cluster_connect(const char *url);
```

Manually connects to a cluster peer.

Usually unnecessary since UDP discovery handles peer connections automatically. Use this for connecting to peers on different subnets or when UDP broadcast is not available.

**Parameters:**

- `url` - URL of the remote peer (e.g., `"tcp://192.168.1.100:9000"`)

```c
/* Manually connect to a peer */
fio_ipc_cluster_connect("tcp://192.168.1.100:9000");
```

#### `fio_ipc_cluster_port`

```c
SFUNC uint16_t fio_ipc_cluster_port(void);
```

Returns the last port number passed to `fio_ipc_cluster_listen`, or zero if cluster listening has not been started.

**Returns:** The cluster port number, or 0 if not listening.

```c
uint16_t port = fio_ipc_cluster_port();
if (port) {
  printf("Cluster listening on port %u\n", (unsigned)port);
}
```

### URL Management Functions

#### `fio_ipc_url`

```c
SFUNC const char *fio_ipc_url(void);
```

Returns the IPC URL used for the listening socket.

**Returns:** The current IPC socket URL string.

```c
const char *url = fio_ipc_url();
printf("IPC socket: %s\n", url);
/* Output: IPC socket: unix://fio_tmp_XXXXXXXXXXXX.sock */
```

#### `fio_ipc_url_set`

```c
SFUNC int fio_ipc_url_set(const char *url);
```

Sets the IPC URL for the listening socket.

Can only be called on the master process and only before the IO reactor starts.

**Parameters:**

- `url` - The URL to use, or NULL to auto-generate

**Returns:** 0 on success, -1 on error.

**Note**: If `url` is NULL or too short, an auto-generated URL of the form `unix://fio_tmp_XXXXXXXXXXXX.sock` is used.

**Note**: URLs ending in `XXX` or `...` will have the suffix replaced with random characters.

```c
/* Set custom IPC socket path */
if (fio_ipc_url_set("unix:///var/run/myapp.sock") != 0) {
  fprintf(stderr, "Failed to set IPC URL\n");
}

/* Or use auto-generated URL */
fio_ipc_url_set(NULL);
```

### Examples

#### Basic Worker-to-Master Call with Reply

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Handler executed on master */
void master_handler(fio_ipc_s *msg) {
  printf("Master received: %.*s\n", (int)msg->len, msg->data);
  
  /* Send reply back to worker */
  const char *reply = "processed";
  fio_ipc_reply(msg,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)reply)),
                .done = 1);
}

/* Called on worker when reply received */
void on_reply(fio_ipc_s *msg) {
  printf("Worker received reply: %.*s\n", (int)msg->len, msg->data);
}

/* Called on worker when all replies done */
void on_done(fio_ipc_s *msg) {
  printf("Request complete\n");
  (void)msg;
}

/* Worker startup */
void worker_start(void *arg) {
  (void)arg;
  if (!fio_io_is_worker())
    return;
  
  const char *request = "hello from worker";
  fio_ipc_call(.call = master_handler,
               .on_reply = on_reply,
               .on_done = on_done,
               .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)request)));
}

int main(void) {
  fio_state_callback_add(FIO_CALL_ON_START, worker_start, NULL);
  fio_io_start(2);  /* Start with 2 workers */
  return 0;
}
```

#### Local Broadcasting to All Workers

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Handler executed on each local process */
void local_handler(fio_ipc_s *msg) {
  printf("Process %d received: %.*s\n",
         fio_io_pid(), (int)msg->len, msg->data);
}

/* Timer callback to trigger local broadcast */
int trigger_local_broadcast(void *arg1, void *arg2) {
  (void)arg1; (void)arg2;
  if (!fio_io_is_master())
    return -1;
  
  const char *data = "config_update";
  fio_ipc_local(.call = local_handler,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)data)));
  return -1;  /* One-shot timer */
}

int main(void) {
  /* Trigger broadcast after 100ms (let workers connect) */
  fio_io_run_every(.fn = trigger_local_broadcast,
                   .every = 100,
                   .repetitions = 1);
  
  fio_io_start(4);  /* Start with 4 workers */
  return 0;
}
```

#### Cluster-Wide Broadcast (All Machines)

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Op-codes */
#define OP_CACHE_INVALIDATE 1
#define OP_CONFIG_UPDATE    2

/* Handler for cache invalidation - runs on ALL processes on ALL machines */
void on_cache_invalidate(fio_ipc_s *msg) {
  printf("[%d] Cache invalidate: %.*s\n",
         fio_io_pid(), (int)msg->len, msg->data);
  /* Invalidate local cache entry */
  cache_remove(msg->data, msg->len);
}

/* Handler for config updates */
void on_config_update(fio_ipc_s *msg) {
  printf("[%d] Config update received\n", fio_io_pid());
  /* Reload configuration */
  config_reload();
  (void)msg;
}

int main(void) {
  /* Register op-codes before starting */
  fio_ipc_opcode_register(.opcode = OP_CACHE_INVALIDATE,
                          .call = on_cache_invalidate);
  fio_ipc_opcode_register(.opcode = OP_CONFIG_UPDATE,
                          .call = on_config_update);
  
  /* Start cluster listener (requires SECRET env var) */
  if (!fio_ipc_cluster_listen(9000)) {
    fprintf(stderr, "Cluster disabled - set SECRET env var for multi-machine support\n");
  }
  
  /* Start IO reactor */
  fio_io_start(4);
  return 0;
}

/* Called elsewhere to broadcast cache invalidation to ALL processes */
void invalidate_cache_cluster_wide(const char *key) {
  /* This executes on ALL processes on ALL machines */
  fio_ipc_broadcast(.opcode = OP_CACHE_INVALIDATE,
                    .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)key)));
}

/* Called elsewhere to notify only remote machines */
void sync_to_remote_machines(const char *data) {
  /* This executes ONLY on remote machine masters */
  fio_ipc_cluster(.opcode = OP_CONFIG_UPDATE,
                  .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)data)));
}
```

#### Using FIO_IPC_DATA for Multi-Buffer Messages

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Message structure */
typedef struct {
  uint32_t type;
  uint32_t sequence;
} msg_header_t;

void master_handler(fio_ipc_s *msg) {
  /* Parse combined data */
  if (msg->len < sizeof(msg_header_t))
    return;
  
  msg_header_t header;
  memcpy(&header, msg->data, sizeof(header));
  
  const char *payload = msg->data + sizeof(header);
  size_t payload_len = msg->len - sizeof(header);
  
  printf("Type: %u, Seq: %u, Payload: %.*s\n",
         header.type, header.sequence,
         (int)payload_len, payload);
}

void send_message(void) {
  msg_header_t header = {.type = 1, .sequence = 42};
  const char *payload = "message payload";
  
  /* Combine header and payload without intermediate buffer */
  fio_ipc_call(.call = master_handler,
               .data = FIO_IPC_DATA(
                   FIO_BUF_INFO2(&header, sizeof(header)),
                   FIO_BUF_INFO1((char *)payload)));
}
```

#### Streaming Replies Pattern

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Master handler that sends streaming replies */
void stream_handler(fio_ipc_s *msg) {
  /* Simulate processing chunks of data */
  for (int i = 0; i < 5; ++i) {
    char chunk[64];
    int len = snprintf(chunk, sizeof(chunk), "chunk_%d", i + 1);
    
    fio_ipc_reply(msg,
                  .data = FIO_IPC_DATA(FIO_BUF_INFO2(chunk, (size_t)len)),
                  .done = (i == 4));  /* Last chunk sets done=1 */
  }
}

/* Worker receives each chunk */
void on_chunk(fio_ipc_s *msg) {
  printf("Received chunk: %.*s\n", (int)msg->len, msg->data);
}

/* Worker notified when streaming complete */
void on_stream_done(fio_ipc_s *msg) {
  printf("Stream complete\n");
  (void)msg;
}

void request_stream(void) {
  fio_ipc_call(.call = stream_handler,
               .on_reply = on_chunk,
               .on_done = on_stream_done,
               .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"start_stream")));
}
```

#### Excluding Self from Broadcast

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

void notify_handler(fio_ipc_s *msg) {
  printf("[%d] Notification: %.*s\n", fio_io_pid(), (int)msg->len, msg->data);
}

/* Method 1: Use .others = true */
void notify_others_method1(const char *data) {
  fio_ipc_local(.call = notify_handler,
                .exclude = FIO_IPC_EXCLUDE_SELF,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)data)));
}

/* Method 2: Set ipc->from = FIO_IPC_EXCLUDE_SELF before sending */
void notify_others_method2(const char *data) {
  fio_ipc_s *msg = fio_ipc_new(.workers = 1,
                               .call = notify_handler,
                               .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)data)));
  msg->from = FIO_IPC_EXCLUDE_SELF;
  fio_ipc_send(msg);
}
```

### Security

All IPC messages are encrypted using ChaCha20-Poly1305 AEAD (Authenticated Encryption with Associated Data):

- **Encrypted fields**: `call`/`opcode`, `on_reply`, `on_done`, `udata`, and `data`
- **Authenticated (AAD)**: `len`, `flags`, `routing_flags`
- **Nonce**: Derived from `timestamp` and `id` fields
- **Key**: Derived from the process secret (set at startup)

The encryption ensures:

1. **Confidentiality**: Message contents cannot be read by external processes
2. **Integrity**: Any tampering is detected and the message is rejected
3. **Authentication**: Only processes with the shared secret can communicate

**Note**: If decryption fails (e.g., due to tampering), a security log message is emitted and the message is discarded.

### Thread Safety

- `fio_ipc_call`, `fio_ipc_reply`, `fio_ipc_local`, `fio_ipc_cluster`, and `fio_ipc_broadcast` are thread-safe and can be called from any thread
- Operations are deferred to the IO thread for actual processing
- Message reference counting (`fio_ipc_dup`/`fio_ipc_free`) is thread-safe

### Memory Management

- Messages are reference-counted using the `FIO_REF` mechanism
- Messages passed to callbacks are automatically freed after the callback returns
- Use `fio_ipc_dup` to retain a message beyond the callback lifetime
- Every `fio_ipc_dup` must be matched with `fio_ipc_free`
- Data buffers passed to `FIO_IPC_DATA` are copied synchronously - they can be freed immediately after the call

------------------------------------------------------------
## OpenSSL TLS Integration

```c
#define FIO_IO
#include "fio-stl/include.h"
```

The OpenSSL module provides TLS (Transport Layer Security) integration for the facil.io IO reactor using OpenSSL 3.x. When OpenSSL is available, this module automatically registers itself as the default TLS implementation.

**Note**: this module requires OpenSSL 3.x or later. It will not compile if `FIO_NO_TLS` is defined or if OpenSSL is unavailable.

**Note**: this module is automatically included when `FIO_IO` is defined and OpenSSL headers are detected (via `HAVE_OPENSSL` or `__has_include("openssl/ssl.h")`).

### Conditional Compilation

The OpenSSL module compiles only when all of the following conditions are met:

- `FIO_IO` is defined (the IO reactor module is included)
- `FIO_NO_TLS` is **not** defined
- OpenSSL 3.x headers are available (`HAVE_OPENSSL` defined or `openssl/ssl.h` exists)

If OpenSSL is detected but the version is older than 3.x, a compiler warning is issued and the module falls back to the default (no-op) TLS functions.

### Features

The OpenSSL integration provides:

- **TLS 1.3 Support**: Automatic TLS protocol negotiation via OpenSSL
- **Self-Signed Certificates**: Automatic generation using ECDSA P-256 for development/testing
- **Certificate Loading**: Load certificates and private keys from PEM files
- **ALPN Protocol Negotiation**: Application-Layer Protocol Negotiation for HTTP/2, etc.
- **Certificate Verification**: Peer verification with configurable trust store
- **Non-Blocking I/O**: Seamless integration with the facil.io event-driven IO reactor

### Usage with the IO Reactor

The OpenSSL module integrates with the IO system through the `fio_io_tls_s` configuration object:

```c
#define FIO_IO
#include "fio-stl.h"

/* Create a TLS configuration object */
fio_io_tls_s *tls = fio_io_tls_new();

/* Optional: load certificates from PEM files */
fio_io_tls_cert_add(tls,
                    "www.example.com",  /* server name (SNI) */
                    "cert.pem",         /* public certificate */
                    "key.pem",          /* private key */
                    NULL);              /* password (if key is encrypted) */

/* Optional: add trusted CA certificates for peer verification */
fio_io_tls_trust_add(tls, "ca.pem");

/* Optional: configure ALPN protocol negotiation */
fio_io_tls_alpn_add(tls, "h2", on_http2_selected);
fio_io_tls_alpn_add(tls, "http/1.1", on_http1_selected);

/* Start listening with TLS */
fio_io_listen(.url = "0.0.0.0:443",
              .protocol = &MY_PROTOCOL,
              .tls = tls);

/* The TLS object can be freed after fio_io_listen (it's reference counted) */
fio_io_tls_free(tls);

/* Start the IO reactor */
fio_io_start(0);
```

### HTTPS Server Example

A complete example of an HTTPS server:

```c
#define FIO_LOG
#define FIO_IO
#include "fio-stl.h"

/* Protocol callbacks */
FIO_SFUNC void on_data(fio_io_s *io) {
  char buf[1024];
  size_t len = fio_io_read(io, buf, sizeof(buf));
  if (len) {
    /* Echo back with HTTP response */
    const char response[] = 
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 13\r\n"
        "Connection: close\r\n"
        "\r\n"
        "Hello, TLS!\n";
    fio_io_write(io, response, sizeof(response) - 1);
    fio_io_close(io);
  }
}

fio_io_protocol_s HTTPS_PROTOCOL = {
    .on_data = on_data,
    .on_timeout = fio_io_touch,
};

int main(void) {
  /* Create TLS context - will use self-signed certificate */
  fio_io_tls_s *tls = fio_io_tls_new();
  
  /* For production, load real certificates:
   * fio_io_tls_cert_add(tls, "example.com", "cert.pem", "key.pem", NULL);
   */
  
  fio_io_listen(.url = "0.0.0.0:8443",
                .protocol = &HTTPS_PROTOCOL,
                .tls = tls);
  
  fio_io_tls_free(tls);
  
  FIO_LOG_INFO("HTTPS server listening on port 8443");
  FIO_LOG_INFO("Test with: curl -k https://localhost:8443/");
  
  fio_io_start(0);
  return 0;
}
```

### Self-Signed Certificates

When no certificate is configured for a server, the OpenSSL module automatically generates a self-signed certificate with the following properties:

| Property | Value |
|----------|-------|
| Algorithm | ECDSA with P-256 curve |
| Security Level | 128-bit (equivalent to RSA-3072) |
| Signature | SHA-256 |
| Validity | 180 days |
| Serial Number | 128-bit cryptographically random |
| Key Generation | ~10ms (vs ~2000ms for RSA-4096) |

**X.509v3 Extensions** (for browser compatibility):

- **Basic Constraints**: `CA:FALSE` (not a CA certificate)
- **Key Usage**: `digitalSignature`, `keyEncipherment`
- **Extended Key Usage**: `serverAuth`
- **Subject Alternative Name (SAN)**: DNS name matching the server name

**Note**: Self-signed certificates are intended for development and testing only. Browsers will show security warnings. Use properly issued certificates from a trusted Certificate Authority (CA) in production.

### API Reference

#### `fio_openssl_io_functions`

```c
fio_io_functions_s fio_openssl_io_functions(void);
```

Returns the OpenSSL IO functions structure for TLS operations.

This function is called automatically during module initialization to register OpenSSL as the default TLS implementation. You typically don't need to call this directly.

**Returns:** A `fio_io_functions_s` structure containing:

- `build_context` - Creates an SSL_CTX from `fio_io_tls_s` configuration
- `free_context` - Frees the SSL_CTX and associated resources
- `start` - Initializes TLS for a new connection (SSL_new, handshake)
- `read` - Non-blocking TLS read (SSL_read)
- `write` - Non-blocking TLS write (SSL_write)
- `flush` - Flushes pending TLS data (no-op for OpenSSL)
- `finish` - Initiates TLS shutdown (SSL_shutdown)
- `cleanup` - Frees per-connection SSL object

### TLS Configuration Functions

The following functions from the IO module are used to configure TLS. See the [IO Reactor documentation](400%20io.md) for complete details.

#### `fio_io_tls_new`

```c
fio_io_tls_s *fio_io_tls_new(void);
```

Creates a new TLS configuration object.

#### `fio_io_tls_free`

```c
void fio_io_tls_free(fio_io_tls_s *tls);
```

Frees a TLS configuration object (reference counted).

#### `fio_io_tls_cert_add`

```c
fio_io_tls_s *fio_io_tls_cert_add(fio_io_tls_s *tls,
                                  const char *server_name,
                                  const char *public_cert_file,
                                  const char *private_key_file,
                                  const char *pk_password);
```

Adds a certificate to the TLS context. Supports SNI (Server Name Indication) for hosting multiple domains.

- `server_name` - The server name for SNI matching
- `public_cert_file` - Path to PEM-encoded certificate (or certificate chain)
- `private_key_file` - Path to PEM-encoded private key
- `pk_password` - Password for encrypted private keys (or NULL)

If `public_cert_file` and `private_key_file` are both NULL, a self-signed certificate is generated.

#### `fio_io_tls_trust_add`

```c
fio_io_tls_s *fio_io_tls_trust_add(fio_io_tls_s *tls,
                                   const char *public_cert_file);
```

Adds a trusted CA certificate for peer verification.

- `public_cert_file` - Path to PEM-encoded CA certificate, or NULL to use system defaults

When trust certificates are added, peer verification is enabled (`SSL_VERIFY_PEER`).

#### `fio_io_tls_alpn_add`

```c
fio_io_tls_s *fio_io_tls_alpn_add(fio_io_tls_s *tls,
                                  const char *protocol_name,
                                  void (*on_selected)(fio_io_s *));
```

Registers an ALPN protocol and its selection callback.

- `protocol_name` - Protocol identifier (e.g., "h2", "http/1.1")
- `on_selected` - Callback invoked when this protocol is negotiated

The first protocol added is the preferred/default protocol.

### Security Considerations

#### Certificate Verification

- **Server Mode**: Certificate verification is typically not enabled (clients don't usually present certificates)

- **Client Mode**: If no trust store is configured, verification is disabled with a security warning logged

```c
/* Enable certificate verification for client connections */
fio_io_tls_s *tls = fio_io_tls_new();
fio_io_tls_trust_add(tls, NULL);  /* Use system trust store */
/* or */
fio_io_tls_trust_add(tls, "ca-bundle.pem");  /* Use specific CA */
```

#### Production Recommendations

1. **Use Real Certificates**: Obtain certificates from a trusted CA (e.g., Let's Encrypt)
2. **Enable Verification**: Always configure trust stores for client connections
3. **Keep OpenSSL Updated**: Security patches are released regularly
4. **Protect Private Keys**: Use appropriate file permissions and consider encrypted keys

#### SIGPIPE Handling

The module automatically monitors `SIGPIPE` signals to prevent OpenSSL from crashing the application when writing to closed connections.

### Non-Blocking I/O Integration

The OpenSSL module configures SSL contexts for non-blocking operation:

- `SSL_MODE_ENABLE_PARTIAL_WRITE` - Allow partial writes
- `SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER` - Buffer can move between writes
- `SSL_MODE_AUTO_RETRY` disabled - Return immediately on would-block

TLS handshakes are performed asynchronously:
- Server connections use `SSL_accept()`
- Client connections use `SSL_connect()`

Both return immediately and complete during subsequent read/write operations.

### Error Handling

OpenSSL errors are logged using the facil.io logging system:

- `FIO_LOG_ERROR` - Critical failures (certificate loading, key generation)
- `FIO_LOG_WARNING` - Non-fatal issues (trust store loading)
- `FIO_LOG_SECURITY` - Security-relevant warnings (verification disabled)
- `FIO_LOG_DEBUG2` - Detailed debugging information

### Memory Management

- SSL contexts (`SSL_CTX`) are reference counted and shared across connections
- Per-connection SSL objects are allocated on connection start and freed on close
- The global ECDSA private key (for self-signed certificates) is freed at program exit
- Context cleanup is deferred to avoid blocking the IO reactor

------------------------------------------------------------
## TLS 1.3 IO Integration

```c
#define FIO_IO
#include "fio-stl/include.h"
```

The TLS 1.3 IO module provides seamless integration between the native TLS 1.3 implementation and the facil.io IO reactor. When OpenSSL is not available, this module automatically registers as the default TLS implementation.

**Note**: This module is automatically included when `FIO_IO` is defined and `FIO_TLS13` is available. It requires the TLS 1.3 module (`190 tls13.h`) and the IO reactor module (`400 io.h`).

------------------------------------------------------------

### Overview

The TLS 1.3 IO integration provides:

- **Drop-in TLS support** - Works with existing `fio_io_tls_s` configuration
- **Automatic fallback** - Used when OpenSSL is not available
- **Self-signed certificates** - Automatic generation for development/testing
- **PEM file loading** - Load certificates and keys from PEM files
- **ALPN support** - Application-Layer Protocol Negotiation
- **Non-blocking I/O** - Seamless integration with the event-driven reactor

### Conditional Compilation

The TLS 1.3 IO module compiles when:

- `FIO_IO` is defined (the IO reactor module is included)
- `FIO_TLS13` is defined (the TLS 1.3 module is included)
- `FIO_NO_TLS` is **not** defined

When OpenSSL is not detected (`HAVE_OPENSSL` not defined and `openssl/ssl.h` not found), the TLS 1.3 module automatically registers as the default TLS implementation.

------------------------------------------------------------

### Features

#### Self-Signed Certificates

When no certificate is configured for a server, the module automatically generates a self-signed certificate:

| Property | Value |
|----------|-------|
| Algorithm | ECDSA with P-256 curve |
| Security Level | 128-bit (equivalent to RSA-3072) |
| Signature | SHA-256 |
| Key Generation | ~10ms (vs ~2000ms for RSA-4096) |

**Note**: Self-signed certificates are intended for development and testing only. Use properly issued certificates from a trusted Certificate Authority (CA) in production.

#### Certificate Loading

The module supports loading certificates and private keys from PEM files:

- **P-256 ECDSA** - 32-byte private key scalar
- **Ed25519** - 32-byte private key seed
- **RSA** - Not yet supported for signing (verification only)

#### ALPN Protocol Negotiation

Application-Layer Protocol Negotiation (RFC 7301) is supported for:

- HTTP/2 (`h2`)
- HTTP/1.1 (`http/1.1`)
- Custom protocols

------------------------------------------------------------

### Usage with the IO Reactor

The TLS 1.3 module integrates with the IO system through the `fio_io_tls_s` configuration object:

```c
#define FIO_IO
#include "fio-stl.h"

/* Create a TLS configuration object */
fio_io_tls_s *tls = fio_io_tls_new();

/* Optional: load certificates from PEM files */
fio_io_tls_cert_add(tls,
                    "www.example.com",  /* server name (SNI) */
                    "cert.pem",         /* public certificate */
                    "key.pem",          /* private key */
                    NULL);              /* password (if key is encrypted) */

/* Optional: configure ALPN protocol negotiation */
fio_io_tls_alpn_add(tls, "h2", on_http2_selected);
fio_io_tls_alpn_add(tls, "http/1.1", on_http1_selected);

/* Start listening with TLS */
fio_io_listen(.url = "0.0.0.0:443",
              .protocol = &MY_PROTOCOL,
              .tls = tls);

/* The TLS object can be freed after fio_io_listen (it's reference counted) */
fio_io_tls_free(tls);

/* Start the IO reactor */
fio_io_start(0);
```

------------------------------------------------------------

### HTTPS Server Example

A complete example of an HTTPS server using the native TLS 1.3 implementation:

```c
#define FIO_LOG
#define FIO_IO
#include "fio-stl.h"

/* Protocol callbacks */
FIO_SFUNC void on_data(fio_io_s *io) {
  char buf[1024];
  size_t len = fio_io_read(io, buf, sizeof(buf));
  if (len) {
    /* Echo back with HTTP response */
    const char response[] = 
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 13\r\n"
        "Connection: close\r\n"
        "\r\n"
        "Hello, TLS!\n";
    fio_io_write(io, response, sizeof(response) - 1);
    fio_io_close(io);
  }
}

fio_io_protocol_s HTTPS_PROTOCOL = {
    .on_data = on_data,
    .on_timeout = fio_io_touch,
};

int main(void) {
  /* Create TLS context - will use self-signed certificate */
  fio_io_tls_s *tls = fio_io_tls_new();
  
  /* For production, load real certificates:
   * fio_io_tls_cert_add(tls, "example.com", "cert.pem", "key.pem", NULL);
   */
  
  fio_io_listen(.url = "0.0.0.0:8443",
                .protocol = &HTTPS_PROTOCOL,
                .tls = tls);
  
  fio_io_tls_free(tls);
  
  FIO_LOG_INFO("HTTPS server listening on port 8443");
  FIO_LOG_INFO("Test with: curl -k https://localhost:8443/");
  
  fio_io_start(0);
  return 0;
}
```

------------------------------------------------------------

### TLS Client Example

Using TLS 1.3 for outgoing connections:

```c
#define FIO_LOG
#define FIO_IO
#include "fio-stl.h"

FIO_SFUNC void on_connect(fio_io_s *io) {
  FIO_LOG_INFO("TLS connection established!");
  
  /* Send HTTP request */
  const char request[] = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
  fio_io_write(io, request, sizeof(request) - 1);
}

FIO_SFUNC void on_data(fio_io_s *io) {
  char buf[4096];
  size_t len = fio_io_read(io, buf, sizeof(buf) - 1);
  if (len) {
    buf[len] = '\0';
    FIO_LOG_INFO("Received: %s", buf);
    fio_io_close(io);
  }
}

fio_io_protocol_s CLIENT_PROTOCOL = {
    .on_attach = on_connect,
    .on_data = on_data,
    .on_timeout = fio_io_touch,
};

int main(void) {
  /* Create TLS context for client */
  fio_io_tls_s *tls = fio_io_tls_new();
  
  /* Add server name for SNI */
  fio_io_tls_cert_add(tls, "example.com", NULL, NULL, NULL);
  
  /* Connect with TLS */
  fio_io_connect(.url = "example.com:443",
                 .protocol = &CLIENT_PROTOCOL,
                 .tls = tls);
  
  fio_io_tls_free(tls);
  
  fio_io_start(0);
  return 0;
}
```

------------------------------------------------------------

### API Reference

#### `fio_tls13_io_functions`

```c
fio_io_functions_s fio_tls13_io_functions(void);
```

Returns the TLS 1.3 IO functions structure for TLS operations.

This function is called automatically during module initialization to register TLS 1.3 as the default TLS implementation (when OpenSSL is not available). You typically don't need to call this directly.

**Returns:** A `fio_io_functions_s` structure containing:

| Function | Purpose |
|----------|---------|
| `build_context` | Creates TLS context from `fio_io_tls_s` configuration |
| `free_context` | Frees the TLS context and associated resources |
| `start` | Initializes TLS for a new connection |
| `read` | Non-blocking TLS read (decryption) |
| `write` | Non-blocking TLS write (encryption) |
| `flush` | Flushes pending handshake data |
| `finish` | Sends close_notify alert |
| `cleanup` | Frees per-connection TLS state |

------------------------------------------------------------

### TLS Configuration Functions

The following functions from the IO module are used to configure TLS. See the [IO Reactor documentation](400%20io.md) for complete details.

#### `fio_io_tls_new`

```c
fio_io_tls_s *fio_io_tls_new(void);
```

Creates a new TLS configuration object.

#### `fio_io_tls_free`

```c
void fio_io_tls_free(fio_io_tls_s *tls);
```

Frees a TLS configuration object (reference counted).

#### `fio_io_tls_cert_add`

```c
fio_io_tls_s *fio_io_tls_cert_add(fio_io_tls_s *tls,
                                  const char *server_name,
                                  const char *public_cert_file,
                                  const char *private_key_file,
                                  const char *pk_password);
```

Adds a certificate to the TLS context.

**Parameters:**
- `server_name` - The server name for SNI matching (client) or certificate selection (server)
- `public_cert_file` - Path to PEM-encoded certificate (or NULL for self-signed)
- `private_key_file` - Path to PEM-encoded private key (or NULL for self-signed)
- `pk_password` - Password for encrypted private keys (or NULL)

**Supported key types:**
- P-256 ECDSA (recommended)
- Ed25519

#### `fio_io_tls_alpn_add`

```c
fio_io_tls_s *fio_io_tls_alpn_add(fio_io_tls_s *tls,
                                  const char *protocol_name,
                                  void (*on_selected)(fio_io_s *));
```

Registers an ALPN protocol and its selection callback.

**Parameters:**
- `protocol_name` - Protocol identifier (e.g., "h2", "http/1.1")
- `on_selected` - Callback invoked when this protocol is negotiated

The first protocol added is the preferred/default protocol.

------------------------------------------------------------

### Internal Architecture

The TLS 1.3 IO integration uses a layered architecture:

```

         Application Layer           
    (fio_io_read, fio_io_write)      

         IO Reactor Layer            
    (fio_io_functions_s callbacks)   

      TLS 1.3 IO Integration         
    (fio___tls13_read/write)         

       TLS 1.3 Record Layer          
  (fio_tls13_record_encrypt/decrypt) 

        AEAD Cipher Layer            
   (AES-GCM, ChaCha20-Poly1305)      

          Socket Layer               
     (fio_sock_read/write)           

```

#### Connection State

Each TLS connection maintains:

| Buffer | Purpose | Size |
|--------|---------|------|
| `recv_buf` | Incoming encrypted data | ~17KB |
| `app_buf` | Decrypted application data | 16KB |
| `send_buf` | Outgoing handshake data | 8KB |
| `enc_buf` | Pre-allocated encryption buffer | ~17KB |

#### Handshake Flow

**Server:**
1. `start` - Initialize server state, wait for ClientHello
2. `read` - Receive ClientHello, send ServerHello..Finished
3. `read` - Receive client Finished
4. Connection established

**Client:**
1. `start` - Initialize client state, send ClientHello
2. `read` - Receive ServerHello..Finished, send client Finished
3. Connection established

------------------------------------------------------------

### Security Considerations

#### Certificate Verification

- **Server Mode**: Certificate verification is typically not enabled (clients don't usually present certificates)
- **Client Mode**: By default, certificate verification is **skipped** with a warning logged

To enable certificate verification for client connections, a trust store must be configured (not yet exposed through the IO API).

#### Production Recommendations

1. **Use Real Certificates**: Obtain certificates from a trusted CA (e.g., Let's Encrypt)
2. **Avoid Self-Signed**: Self-signed certificates should only be used for development
3. **Keep Updated**: Security patches may be released for the TLS implementation
4. **Protect Private Keys**: Use appropriate file permissions

#### Memory Safety

- All sensitive key material is zeroed on cleanup using `fio_secure_zero`
- Connection state is properly freed on close
- Buffer overflows are prevented by size checks

------------------------------------------------------------

### Comparison with OpenSSL

| Feature | TLS 1.3 Native | OpenSSL |
|---------|----------------|---------|
| Dependencies | None | OpenSSL 3.x |
| Binary Size | Smaller | Larger |
| TLS Versions | 1.3 only | 1.0-1.3 |
| Cipher Suites | 3 (TLS 1.3) | Many |
| Certificate Types | P-256, Ed25519 | All |
| Session Resumption | Not yet | Yes |
| 0-RTT | Not yet | Yes |
| OCSP Stapling | No | Yes |
| Client Certificates | Yes | Yes |

**When to use TLS 1.3 Native:**
- Minimal dependencies required
- Only TLS 1.3 clients expected
- Embedded or resource-constrained environments

**When to use OpenSSL:**
- Legacy TLS version support needed
- Full certificate type support required
- Session resumption important
- OCSP stapling required

------------------------------------------------------------

### Error Handling

TLS errors are logged using the facil.io logging system:

| Log Level | Purpose |
|-----------|---------|
| `FIO_LOG_ERROR` | Critical failures (certificate loading, key generation) |
| `FIO_LOG_WARNING` | Non-fatal issues (trust store loading) |
| `FIO_LOG_DEBUG2` | Detailed debugging information |

Connection errors result in the connection being closed with an appropriate TLS alert.

------------------------------------------------------------

### Memory Management

- **Context** (`fio___tls13_context_s`): Shared across connections, reference counted
- **Connection** (`fio___tls13_connection_s`): Per-connection, freed on close
- **Certificates**: Copied to context, freed with context
- **Self-signed key**: Global, freed at program exit

Leak counters are enabled in debug builds to detect memory leaks.

------------------------------------------------------------
## Pub/Sub - Publish/Subscribe Messaging

```c
#define FIO_PUBSUB
#include FIO_INCLUDE_FILE
```

The Pub/Sub module provides a publish/subscribe messaging system for facil.io applications. It enables decoupled communication between components through named channels, with support for pattern matching, message history, and cluster-wide distribution.

**Note**: The Pub/Sub module requires the IPC module (`FIO_IPC`) for inter-process communication. When using `include.h`, this dependency is handled automatically.

### Key Features

- **Channel-based messaging**: Subscribe to named channels and receive messages published to those channels
- **Pattern subscriptions**: Subscribe using glob patterns to match multiple channels
- **Process-local and cluster-wide**: Messages can be distributed to local workers or across all machines in a cluster
- **Message history**: Built-in caching with replay support for late-joining subscribers
- **IO integration**: Subscriptions can be tied to IO connections for automatic cleanup
- **Custom engines**: Extensible architecture for integrating external message brokers

### Pub/Sub Types

#### `fio_pubsub_msg_s`

```c
typedef struct fio_pubsub_msg_s {
  /** A connection (if any) to which the subscription belongs. */
  fio_io_s *io;
  /** The `udata` argument associated with the subscription. */
  void *udata;
  /** Milliseconds since epoch. */
  uint64_t timestamp;
  /** Message ID. */
  uint64_t id;
  /** Channel name (shared copy - do NOT mutate). */
  fio_buf_info_s channel;
  /** Message payload (shared copy - do NOT mutate). */
  fio_buf_info_s message;
  /** Channel namespace. Negative values are reserved. */
  int16_t filter;
} fio_pubsub_msg_s;
```

The message structure received by subscription callbacks.

**Members:**
- `io` - The IO connection associated with the subscription (may be NULL)
- `udata` - User data associated with the subscription
- `timestamp` - Message timestamp in milliseconds since epoch
- `id` - Unique message identifier
- `channel` - Channel name buffer (read-only, do not modify)
- `message` - Message payload buffer (read-only, do not modify)
- `filter` - Numerical namespace filter (negative values reserved for internal use)

**Note**: The `channel` and `message` buffers are shared copies. Do NOT mutate them.

#### `fio_pubsub_subscribe_args_s`

```c
typedef struct {
  /** The subscription owner - if none, the subscription is owned by the system. */
  fio_io_s *io;
  /** A named channel to which the message was sent. */
  fio_buf_info_s channel;
  /** The callback to be called for each message forwarded to the subscription. */
  void (*on_message)(fio_pubsub_msg_s *msg);
  /** An optional callback for when a subscription is canceled. */
  void (*on_unsubscribe)(void *udata);
  /** The opaque udata value is ignored and made available to the callbacks. */
  void *udata;
  /** The queue to which the callbacks should be routed. May be NULL. */
  fio_queue_s *queue;
  /** OPTIONAL: subscription handle return value for manual management. */
  uintptr_t *subscription_handle_ptr;
  /** Replay cached messages (if any) since supplied time in milliseconds. */
  uint64_t replay_since;
  /** A numerical namespace filter subscribers need to match. */
  int16_t filter;
  /** If set, pattern matching will be used (name is a pattern). */
  uint8_t is_pattern;
  /** If set, subscription will be limited to the root / master process. */
  uint8_t master_only;
} fio_pubsub_subscribe_args_s;
```

Arguments for subscribing to a channel.

**Members:**
- `io` - Optional IO connection owner. If set, subscription is cleaned up when the IO closes
- `channel` - Channel name to subscribe to
- `on_message` - Callback invoked for each received message
- `on_unsubscribe` - Optional callback when subscription is canceled
- `udata` - User data passed to callbacks
- `queue` - Optional queue for callback execution (defaults to IO queue)
- `subscription_handle_ptr` - If set, returns handle for manual subscription management
- `replay_since` - Request message replay from history since this timestamp
- `filter` - Numerical namespace filter (must match publisher's filter)
- `is_pattern` - If true, channel name is treated as a glob pattern
- `master_only` - If true, subscription exists only in the master process

**Note**: When `io` is set, only one subscription per channel/filter/pattern combination is allowed per IO. When `io` is NULL, the subscription is global.

#### `fio_pubsub_publish_args_s`

```c
typedef struct {
  struct fio_pubsub_engine_s const *engine;
  fio_io_s *from;
  uint64_t id;
  uint64_t timestamp;
  fio_buf_info_s channel;
  fio_buf_info_s message;
  int16_t filter;
} fio_pubsub_publish_args_s;
```

Arguments for publishing a message.

**Members:**
- `engine` - Publishing engine (NULL = default engine)
- `from` - Optional source IO (excluded from receiving the message)
- `id` - Optional message ID (0 = auto-generate)
- `timestamp` - Optional timestamp (0 = current time)
- `channel` - Channel name to publish to
- `message` - Message payload
- `filter` - Numerical namespace filter

### Subscribe / Unsubscribe

#### `fio_pubsub_subscribe`

```c
void fio_pubsub_subscribe(fio_pubsub_subscribe_args_s args);
#define fio_pubsub_subscribe(...)                                              \
  fio_pubsub_subscribe((fio_pubsub_subscribe_args_s){__VA_ARGS__})
```

Subscribe to a channel.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
/* Simple subscription */
fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("events"),
                     .on_message = handle_event);

/* Subscription tied to an IO connection */
fio_pubsub_subscribe(.io = client_io,
                     .channel = FIO_BUF_INFO1("user:123"),
                     .on_message = handle_user_message,
                     .udata = user_context);

/* Pattern subscription */
fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("chat:*"),
                     .on_message = handle_chat,
                     .is_pattern = 1);

/* Subscription with history replay */
fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("news"),
                     .on_message = handle_news,
                     .replay_since = last_seen_timestamp);
```

**Note**: In worker processes, subscriptions are tracked by the master process for proper message routing.

#### `fio_pubsub_unsubscribe`

```c
int fio_pubsub_unsubscribe(fio_pubsub_subscribe_args_s args);
#define fio_pubsub_unsubscribe(...)                                            \
  fio_pubsub_unsubscribe((fio_pubsub_subscribe_args_s){__VA_ARGS__})
```

Unsubscribe from a channel.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
/* Unsubscribe from a channel */
fio_pubsub_unsubscribe(.io = client_io,
                       .channel = FIO_BUF_INFO1("user:123"),
                       .filter = 0);
```

**Returns:** 0 on success, -1 if subscription not found.

**Note**: The `on_message` callback is ignored during unsubscription. Only `io`, `channel`, `filter`, and `is_pattern` are used for matching.

### Publish

#### `fio_pubsub_publish`

```c
void fio_pubsub_publish(fio_pubsub_publish_args_s args);
#define fio_pubsub_publish(...)                                                \
  fio_pubsub_publish((fio_pubsub_publish_args_s){__VA_ARGS__})
```

Publish a message to a channel.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
/* Simple publish */
fio_pubsub_publish(.channel = FIO_BUF_INFO1("events"),
                   .message = FIO_BUF_INFO1("something happened"));

/* Publish with filter namespace */
fio_pubsub_publish(.channel = FIO_BUF_INFO1("updates"),
                   .message = FIO_BUF_INFO2(data, data_len),
                   .filter = 42);

/* Publish excluding sender */
fio_pubsub_publish(.channel = FIO_BUF_INFO1("chat:room1"),
                   .message = FIO_BUF_INFO1("hello"),
                   .from = sender_io);

/* Publish via cluster engine (all machines) */
fio_pubsub_publish(.engine = fio_pubsub_engine_cluster(),
                   .channel = FIO_BUF_INFO1("global"),
                   .message = FIO_BUF_INFO1("cluster-wide message"));
```

**Note**: The default engine is `fio_pubsub_engine_ipc()` (local machine only). Use `fio_pubsub_engine_cluster()` for cluster-wide distribution.

#### `fio_pubsub_defer`

```c
void fio_pubsub_defer(fio_pubsub_msg_s *msg);
```

Pushes execution of the `on_message` callback to the end of the queue.

Call this from within an `on_message` callback to defer processing:

```c
void handle_message(fio_pubsub_msg_s *msg) {
  if (should_defer()) {
    fio_pubsub_defer(msg);
    return;
  }
  // Process message...
}
```

**Note**: The message and subscription references are automatically managed.

### IO Callback Helper

#### `FIO_ON_MESSAGE_SEND_MESSAGE`

```c
void FIO_ON_MESSAGE_SEND_MESSAGE(fio_pubsub_msg_s *msg);
```

A pre-built callback for IO subscriptions that sends the raw message data to the IO connection.

Use this as the `on_pubsub` callback in your protocol or as the `on_message` callback for subscriptions:

```c
/* In protocol definition */
fio_io_protocol_s MY_PROTOCOL = {
    .on_attach = my_on_attach,
    .on_data = my_on_data,
    .on_pubsub = FIO_ON_MESSAGE_SEND_MESSAGE,  /* Auto-send messages to client */
};

/* Or in subscription */
fio_pubsub_subscribe(.io = client_io,
                     .channel = FIO_BUF_INFO1("updates"),
                     .on_message = FIO_ON_MESSAGE_SEND_MESSAGE);
```

### Engines

Engines control how messages are distributed. The module provides two built-in engines:

#### `fio_pubsub_engine_ipc`

```c
fio_pubsub_engine_s const *fio_pubsub_engine_ipc(void);
```

Returns the built-in engine for publishing to the local process group (master + workers).

Messages are distributed via IPC to all processes on the local machine only.

**Returns:** Pointer to the IPC engine.

#### `fio_pubsub_engine_cluster`

```c
fio_pubsub_engine_s const *fio_pubsub_engine_cluster(void);
```

Returns the built-in engine for multi-machine cluster publishing.

Messages are distributed to all processes on all machines in the cluster. Requires `fio_ipc_cluster_listen()` to be called for cluster connectivity.

**Returns:** Pointer to the cluster engine.

#### `fio_pubsub_engine_default`

```c
fio_pubsub_engine_s const *fio_pubsub_engine_default(void);
```

Returns the current default engine.

**Returns:** Pointer to the current default engine.

**Note**: The default engine is automatically set to the cluster engine when `fio_ipc_cluster_listen()` is called before `fio_io_start()`.

#### `fio_pubsub_engine_default_set`

```c
fio_pubsub_engine_s const *fio_pubsub_engine_default_set(
    fio_pubsub_engine_s const *engine);
```

Sets the default engine for publishing.

**Parameters:**
- `engine` - The engine to use as default (NULL restores to IPC engine)

**Returns:** The engine that was set.

```c
/* Use cluster engine by default */
fio_pubsub_engine_default_set(fio_pubsub_engine_cluster());

/* Restore to local IPC */
fio_pubsub_engine_default_set(NULL);
```

### Custom Engines

#### `fio_pubsub_engine_s`

```c
typedef struct fio_pubsub_engine_s {
  /** Called when engine is detached */
  void (*detached)(const struct fio_pubsub_engine_s *eng);
  /** Called when a subscription is created */
  void (*subscribe)(const struct fio_pubsub_engine_s *eng,
                    const fio_buf_info_s channel,
                    int16_t filter);
  /** Called when a pattern subscription is created */
  void (*psubscribe)(const struct fio_pubsub_engine_s *eng,
                     const fio_buf_info_s channel,
                     int16_t filter);
  /** Called when a subscription is removed */
  void (*unsubscribe)(const struct fio_pubsub_engine_s *eng,
                      const fio_buf_info_s channel,
                      int16_t filter);
  /** Called when a pattern subscription is removed */
  void (*punsubscribe)(const struct fio_pubsub_engine_s *eng,
                       const fio_buf_info_s channel,
                       int16_t filter);
  /** Called when a message is published */
  void (*publish)(const struct fio_pubsub_engine_s *eng,
                  const fio_pubsub_msg_s *msg);
} fio_pubsub_engine_s;
```

Engine structure for external pub/sub backends (e.g., Redis, NATS).

**Callbacks:**
- `detached` - Called when the engine is detached from the system
- `subscribe` - Called when a new channel subscription is created
- `psubscribe` - Called when a new pattern subscription is created
- `unsubscribe` - Called when a channel subscription is removed
- `punsubscribe` - Called when a pattern subscription is removed
- `publish` - Called when a message is published via this engine

**Execution Context:**
- The `publish` callback can be called from any thread/process
- Subscription callbacks are called from the MASTER process only
- Subscription callbacks are called from the main event loop thread
- Callbacks MUST NOT block (defer long operations)

#### `fio_pubsub_engine_attach`

```c
void fio_pubsub_engine_attach(fio_pubsub_engine_s *engine);
```

Attach an engine to the pub/sub system.

**Parameters:**
- `engine` - The engine to attach

The engine will be notified of all existing subscriptions upon attachment.

**Note**: Missing callbacks are automatically filled with no-op defaults.

#### `fio_pubsub_engine_detach`

```c
void fio_pubsub_engine_detach(fio_pubsub_engine_s *engine);
```

Detach an engine from the pub/sub system.

**Parameters:**
- `engine` - The engine to detach

The engine's `detached` callback will be called after removal.

### History Management

The history system allows caching messages for replay to late-joining subscribers.

#### `fio_pubsub_history_s`

```c
typedef struct fio_pubsub_history_s {
  /** Cleanup callback - called when history manager is detached */
  void (*detached)(const struct fio_pubsub_history_s *hist);
  /** Stores a message in history. Returns 0 on success, -1 on error. */
  int (*push)(const struct fio_pubsub_history_s *hist, fio_pubsub_msg_s *msg);
  /** Replay messages since timestamp. Returns 0 if handled, -1 if cannot replay. */
  int (*replay)(const struct fio_pubsub_history_s *hist,
                fio_buf_info_s channel,
                int16_t filter,
                uint64_t since,
                void (*on_message)(fio_pubsub_msg_s *msg, void *udata),
                void (*on_done)(void *udata),
                void *udata);
  /** Get oldest available timestamp. Returns UINT64_MAX if no history. */
  uint64_t (*oldest)(const struct fio_pubsub_history_s *hist,
                     fio_buf_info_s channel,
                     int16_t filter);
} fio_pubsub_history_s;
```

History storage interface for message caching and replay.

**Callbacks:**
- `detached` - Called when the history manager is detached
- `push` - Store a message in history (called on publish)
- `replay` - Replay messages since a timestamp to a callback
- `oldest` - Get the oldest available message timestamp

**Execution Context:**
- All callbacks are called from the MASTER process only
- Callbacks are called from the main event loop thread
- Callbacks MUST NOT block (defer long operations)

#### `fio_pubsub_history_attach`

```c
int fio_pubsub_history_attach(const fio_pubsub_history_s *manager, uint8_t priority);
```

Attach a history manager with the given priority.

**Parameters:**
- `manager` - The history manager to attach
- `priority` - Priority level (higher = tried first for replay)

**Returns:** 0 on success, -1 on error.

Multiple history managers can be attached. All managers receive `push()` calls. For `replay()`, managers are tried in priority order until one handles the request.

#### `fio_pubsub_history_detach`

```c
void fio_pubsub_history_detach(const fio_pubsub_history_s *manager);
```

Detach a history manager.

**Parameters:**
- `manager` - The history manager to detach

#### `fio_pubsub_history_cache`

```c
const fio_pubsub_history_s *fio_pubsub_history_cache(size_t size_limit);
```

Get the built-in in-memory history manager.

**Parameters:**
- `size_limit` - Maximum cache size in bytes (0 = use default)

**Returns:** Pointer to the built-in cache history manager.

The default size limit is determined by:
1. `WEBSITE_MEMORY_LIMIT_MB` environment variable (in MB)
2. `WEBSITE_MEMORY_LIMIT_KB` environment variable (in KB)
3. `WEBSITE_MEMORY_LIMIT` environment variable (in bytes)
4. `FIO_PUBSUB_HISTORY_DEFAULT_CACHE_SIZE_LIMIT` (256 MB)

```c
/* Use built-in cache with 64MB limit */
fio_pubsub_history_attach(fio_pubsub_history_cache(64 * 1024 * 1024), 100);
```

#### `fio_pubsub_history_push_all`

```c
void fio_pubsub_history_push_all(fio_pubsub_msg_s *msg);
```

Pushes a message to all history containers.

Use this from a custom engine if the message needs to be saved to history but is never delivered locally.

**Parameters:**
- `msg` - The message to push to history

### Pattern Matching

#### `fio_pubsub_match_fn_set`

```c
void fio_pubsub_match_fn_set(uint8_t (*match_cb)(fio_str_info_s pattern,
                                                  fio_str_info_s name));
```

Sets the pattern matching function for pattern subscriptions.

**Parameters:**
- `match_cb` - Pattern matching function (NULL restores default)

**Returns:** Nothing.

The default pattern matching function is `fio_glob_match`, which supports:
- `*` - Match any sequence of characters
- `?` - Match any single character
- `[abc]` - Match any character in the set
- `[a-z]` - Match any character in the range

```c
/* Use custom pattern matching */
uint8_t my_matcher(fio_str_info_s pattern, fio_str_info_s name) {
  // Custom matching logic...
  return matches ? 1 : 0;
}
fio_pubsub_match_fn_set(my_matcher);

/* Restore default glob matching */
fio_pubsub_match_fn_set(NULL);
```

### Advanced: IPC Message Access

#### `fio_pubsub_msg2ipc`

```c
fio_ipc_s *fio_pubsub_msg2ipc(fio_pubsub_msg_s *msg);
```

Returns the underlying IPC message buffer carrying the message data.

**Parameters:**
- `msg` - The pub/sub message

**Returns:** Pointer to the underlying IPC message.

This allows message deferral (use `fio_ipc_dup`) and tighter control over the message's lifetime.

**Note**: The IPC message is detached from its originating IO.

#### `fio_pubsub_ipc2msg`

```c
fio_pubsub_msg_s fio_pubsub_ipc2msg(fio_ipc_s *ipc);
```

Extract a pub/sub message from an IPC message.

**Parameters:**
- `ipc` - The IPC message

**Returns:** A `fio_pubsub_msg_s` structure with fields populated from the IPC message.

### Configuration Macros

#### `FIO_PUBSUB_FUTURE_LIMIT_MS`

```c
#ifndef FIO_PUBSUB_FUTURE_LIMIT_MS
#define FIO_PUBSUB_FUTURE_LIMIT_MS 60000ULL
#endif
```

Maximum time in milliseconds to allow "future" messages to be delivered.

Messages with timestamps beyond this limit are not delivered to subscribers but are still pushed to history managers for future delivery.

#### `FIO_PUBSUB_HISTORY_DEFAULT_CACHE_SIZE_LIMIT`

```c
#ifndef FIO_PUBSUB_HISTORY_DEFAULT_CACHE_SIZE_LIMIT
#define FIO_PUBSUB_HISTORY_DEFAULT_CACHE_SIZE_LIMIT (1ULL << 28)
#endif
```

Default cache size limit for the built-in history manager (256 MB).

### Examples

#### Basic Pub/Sub

```c
#define FIO_LOG
#define FIO_PUBSUB
#include FIO_INCLUDE_FILE

void on_message(fio_pubsub_msg_s *msg) {
  printf("Received on '%.*s': %.*s\n",
         (int)msg->channel.len, msg->channel.buf,
         (int)msg->message.len, msg->message.buf);
}

void on_start(void *arg) {
  (void)arg;
  /* Subscribe to channel */
  fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("events"),
                       .on_message = on_message);
}

int publish_event(void *a, void *b) {
  (void)a; (void)b;
  fio_pubsub_publish(.channel = FIO_BUF_INFO1("events"),
                     .message = FIO_BUF_INFO1("hello world"));
  return -1;  /* One-shot timer */
}

int main(void) {
  fio_state_callback_add(FIO_CALL_ON_START, on_start, NULL);
  fio_io_run_every(.fn = publish_event, .every = 100, .repetitions = 1);
  fio_io_start(2);
  return 0;
}
```

#### Time Server with Pub/Sub

```c
#define FIO_LOG
#define FIO_PUBSUB
#define FIO_TIME
#include FIO_INCLUDE_FILE

/* Protocol subscribes clients to time channel */
void time_on_attach(fio_io_s *io) {
  fio_pubsub_subscribe(.io = io,
                       .channel = FIO_BUF_INFO1("time"),
                       .on_message = FIO_ON_MESSAGE_SEND_MESSAGE);
}

fio_io_protocol_s TIME_PROTOCOL = {
    .on_attach = time_on_attach,
    .on_timeout = fio_io_touch,
};

/* Timer publishes current time */
int publish_time(void *a, void *b) {
  (void)a; (void)b;
  char buf[32];
  size_t len = fio_time2iso(buf, fio_time_real().tv_sec);
  buf[len++] = '\r';
  buf[len++] = '\n';
  fio_pubsub_publish(.channel = FIO_BUF_INFO1("time"),
                     .message = FIO_BUF_INFO2(buf, len));
  return 0;
}

int main(void) {
  fio_io_run_every(.fn = publish_time, .every = 1000, .repetitions = -1);
  fio_io_listen(.protocol = &TIME_PROTOCOL);
  fio_io_start(0);
  return 0;
}
```

#### Pattern Subscriptions

```c
#define FIO_PUBSUB
#include FIO_INCLUDE_FILE

void on_chat_message(fio_pubsub_msg_s *msg) {
  printf("Chat [%.*s]: %.*s\n",
         (int)msg->channel.len, msg->channel.buf,
         (int)msg->message.len, msg->message.buf);
}

void setup_subscriptions(void *arg) {
  (void)arg;
  /* Subscribe to all chat rooms using pattern */
  fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("chat:*"),
                       .on_message = on_chat_message,
                       .is_pattern = 1);
}

void send_chat(const char *room, const char *message) {
  char channel[64];
  int len = snprintf(channel, sizeof(channel), "chat:%s", room);
  fio_pubsub_publish(.channel = FIO_BUF_INFO2(channel, (size_t)len),
                     .message = FIO_BUF_INFO1(message));
}

int main(void) {
  fio_state_callback_add(FIO_CALL_ON_START, setup_subscriptions, NULL);
  fio_io_start(2);
  return 0;
}
```

#### Cluster-Wide Pub/Sub

```c
#define FIO_PUBSUB
#include FIO_INCLUDE_FILE

void on_cluster_message(fio_pubsub_msg_s *msg) {
  printf("[%d] Cluster message: %.*s\n",
         fio_io_pid(),
         (int)msg->message.len, msg->message.buf);
}

void setup(void *arg) {
  (void)arg;
  fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("cluster-events"),
                       .on_message = on_cluster_message);
}

int main(void) {
  /* Enable cluster communication */
  fio_ipc_cluster_listen(9999);
  
  /* Default engine will be cluster engine */
  fio_state_callback_add(FIO_CALL_ON_START, setup, NULL);
  fio_io_start(4);
  return 0;
}
```

#### History Replay

```c
#define FIO_PUBSUB
#include FIO_INCLUDE_FILE

void on_message(fio_pubsub_msg_s *msg) {
  printf("[%llu] %.*s\n",
         (unsigned long long)msg->timestamp,
         (int)msg->message.len, msg->message.buf);
}

void late_subscriber(void *arg) {
  (void)arg;
  uint64_t five_minutes_ago = fio_io_last_tick() - (5 * 60 * 1000);
  
  /* Subscribe and replay messages from the last 5 minutes */
  fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("news"),
                       .on_message = on_message,
                       .replay_since = five_minutes_ago);
}

int main(void) {
  /* Attach built-in cache history manager */
  fio_pubsub_history_attach(fio_pubsub_history_cache(0), 100);
  
  fio_state_callback_add(FIO_CALL_ON_START, late_subscriber, NULL);
  fio_io_start(2);
  return 0;
}
```

### Thread Safety and Execution Context

- `fio_pubsub_subscribe`, `fio_pubsub_unsubscribe`, and `fio_pubsub_publish` are thread-safe
- Subscription callbacks (`on_message`, `on_unsubscribe`) execute on the IO reactor thread
- Engine callbacks execute on the MASTER process only
- History manager callbacks execute on the MASTER process only
- Callbacks MUST NOT block - defer long operations using `fio_io_defer`

### Migration from Previous API

The Pub/Sub module was completely rewritten. Key changes:

| Old API | New API |
|---------|---------|
| `fio_msg_s` | `fio_pubsub_msg_s` |
| `msg->published` | `msg->timestamp` |
| `msg->is_json` | Removed (deprecated) |
| `fio_subscribe()` | `fio_pubsub_subscribe()` |
| `fio_unsubscribe()` | `fio_pubsub_unsubscribe()` |
| `fio_publish()` | `fio_pubsub_publish()` |
| `FIO_PUBSUB_ROOT` | Use `fio_pubsub_engine_ipc()` |
| `FIO_PUBSUB_CLUSTER` | Use `fio_pubsub_engine_cluster()` |
| `fio_pubsub_ipc_url_set()` | Use `fio_ipc_url_set()` |
| `fio_pubsub_broadcast_on_port()` | Use `fio_ipc_cluster_listen()` |

------------------------------------------------------------
## Redis Pub/Sub Engine

```c
#define FIO_REDIS
#include FIO_INCLUDE_FILE
```

The Redis module provides a pub/sub engine that integrates with facil.io's pub/sub system, enabling distributed messaging across multiple server instances through Redis.

This module is designed for horizontal scaling scenarios where multiple application instances need to share pub/sub messages. When attached to the facil.io pub/sub system, all subscriptions and publications are automatically synchronized through Redis.

**Note**: This module requires the IO reactor (`FIO_IO`), FIOBJ types (`FIO_FIOBJ`), and RESP3 parser (`FIO_RESP3`) modules, which are automatically included.

**Note**: The engine is only active after the IO reactor starts (`fio_io_start()`). Commands sent before the reactor starts are queued and executed once the connection is established.

### Features

- **Dual Connection Model**: Maintains separate connections for publishing and subscribing to avoid protocol conflicts
- **Automatic Subscription Management**: SUBSCRIBE/PSUBSCRIBE commands are handled internally by the pub/sub engine
- **Command Queue**: Send arbitrary Redis commands with asynchronous callbacks
- **Authentication Support**: Optional AUTH command on connection
- **Automatic Reconnection**: Reconnects automatically on connection loss
- **Ping/Pong Keepalive**: Configurable keepalive interval to detect dead connections
- **Reference Counting**: Safe sharing of engine across multiple owners

### Quick Start

```c
#define FIO_LOG
#define FIO_REDIS
#include FIO_INCLUDE_FILE

/* Message handler */
void on_message(fio_pubsub_msg_s *msg) {
  FIO_LOG_INFO("Received on channel '%.*s': %.*s",
               (int)msg->channel.len, msg->channel.buf,
               (int)msg->message.len, msg->message.buf);
}

int main(void) {
  /* Create Redis engine (ref count = 1) */
  fio_pubsub_engine_s *redis = fio_redis_new(
      .url = "redis://localhost:6379"
  );
  
  /* Attach to pub/sub system (does NOT take ownership) */
  fio_pubsub_engine_attach(redis);
  
  /* Subscribe to a channel */
  fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("my-channel"),
                .on_message = on_message);
  
  /* Start the IO reactor */
  fio_io_start(0);
  
  /* Cleanup - detach before freeing if attached */
  fio_pubsub_engine_detach(redis);
  fio_redis_free(redis);
  return 0;
}
```

------------------------------------------------------------

### Configuration Macros

#### `FIO_REDIS_READ_BUFFER`

```c
#define FIO_REDIS_READ_BUFFER 32768
```

Size of the read buffer for Redis connections in bytes. Default is 32768 (32KB).

Each Redis engine allocates two read buffers (one for each connection), so the total memory usage per engine is `FIO_REDIS_READ_BUFFER * 2` bytes plus overhead.

------------------------------------------------------------

### Types

#### `fio_redis_args_s`

```c
typedef struct {
  /**
   * Redis server URL.
   *
   * Supported formats:
   * - "redis://host:port"
   * - "redis://host" (default port 6379)
   * - "host:port" (no scheme)
   * - "host" (no scheme, default port 6379)
   * - NULL or empty  defaults to "localhost:6379"
   */
  const char *url;
  /** Redis server's password, if any (for AUTH command) */
  const char *auth;
  /** Length of auth string (0 = auto-detect with strlen) */
  size_t auth_len;
  /** Ping interval in seconds (0 = default 30 seconds) */
  uint8_t ping_interval;
} fio_redis_args_s;
```

Arguments for creating a Redis pub/sub engine.

**Members:**
- `url` - Redis server URL. Supports various formats including `redis://host:port`, `host:port`, or just `host`. Defaults to `"localhost:6379"` if NULL or empty.
- `auth` - Optional password for Redis AUTH command. Set to NULL if no authentication is required.
- `auth_len` - Length of the auth string. If 0, `strlen()` is used to determine the length.
- `ping_interval` - Keepalive ping interval in seconds. Defaults to 30 seconds if 0.

------------------------------------------------------------

### Reference Counting

The Redis engine uses reference counting for memory management:

- `fio_redis_new` creates an engine with reference count = 1
- `fio_redis_dup` increments the reference count and returns the engine
- `fio_redis_free` decrements the reference count; frees the engine when count reaches 0

**Important**: `fio_pubsub_engine_attach()` and `fio_pubsub_engine_detach()` do **NOT** affect the reference count. The caller who created the engine is responsible for calling `fio_redis_free()` when done.

```c
/* Example: sharing engine across multiple owners */
fio_pubsub_engine_s *redis = fio_redis_new(.url = "localhost");

/* Share with another component */
fio_pubsub_engine_s *shared = fio_redis_dup(redis);  /* ref = 2 */

/* Attach to pub/sub (does NOT increment ref) */
fio_pubsub_engine_attach(redis);

/* ... later, first owner is done ... */
fio_redis_free(redis);   /* ref = 1, engine still alive */

/* ... later, second owner is done - must detach before final free ... */
fio_pubsub_engine_detach(shared);
fio_redis_free(shared);  /* ref = 0, engine destroyed */
```

------------------------------------------------------------

### API Functions

#### `fio_redis_new`

```c
fio_pubsub_engine_s *fio_redis_new(fio_redis_args_s args);
/* Named arguments using macro. */
#define fio_redis_new(...) fio_redis_new((fio_redis_args_s){__VA_ARGS__})
```

Creates a Redis pub/sub engine with reference count = 1.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_pubsub_engine_s *redis = fio_redis_new(
    .url = "redis://redis.example.com:6379",
    .auth = "secret_password",
    .ping_interval = 30
);
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `url` | `const char *` | Redis server URL; defaults to `"localhost:6379"` |
| `auth` | `const char *` | Optional authentication password |
| `auth_len` | `size_t` | Length of auth string; 0 for auto-detect |
| `ping_interval` | `uint8_t` | Keepalive interval in seconds; defaults to 30 |

**Returns:** A pointer to the pub/sub engine on success, or NULL on error.

**Note**: The engine is only active after the IO reactor starts running (`fio_io_start()`). Connection attempts are deferred until the reactor is running.

**Note**: The caller owns the returned reference and must call `fio_redis_free()` when done. Attaching to pub/sub does NOT transfer ownership.

#### `fio_redis_dup`

```c
fio_pubsub_engine_s *fio_redis_dup(fio_pubsub_engine_s *engine);
```

Increments the reference count and returns the engine.

Use this when you need to share the engine across multiple owners. Each call to `fio_redis_dup()` must be balanced with a corresponding call to `fio_redis_free()`.

**Parameters:**
- `engine` - The Redis engine to duplicate

**Returns:** The same engine pointer with incremented reference count.

```c
/* Share engine with another component */
fio_pubsub_engine_s *shared = fio_redis_dup(redis);
pass_to_other_component(shared);

/* Other component must call fio_redis_free(shared) when done */
```

#### `fio_redis_free`

```c
void fio_redis_free(fio_pubsub_engine_s *engine);
```

Decrements the reference count. When count reaches 0, destroys the engine.

This function:
1. Decrements the reference count
2. If ref reaches 0:
   - Closes both Redis connections (publishing and subscription)
   - Frees any queued commands
   - Releases all allocated memory

**Important**: If the engine was attached to pub/sub via `fio_pubsub_engine_attach()`, you **MUST** call `fio_pubsub_engine_detach()` before calling `fio_redis_free()`.

**Note**: Safe to call with NULL (no-op).

**Note**: Any pending command callbacks will NOT be called after destruction.

#### `fio_redis_send`

```c
int fio_redis_send(fio_pubsub_engine_s *engine,
                   FIOBJ command,
                   void (*callback)(fio_pubsub_engine_s *e,
                                    FIOBJ reply,
                                    void *udata),
                   void *udata);
```

Sends a Redis command through the engine's publishing connection.

The command is sent asynchronously. When a reply is received from Redis, the callback is invoked with the parsed response.

**Parameters:**
- `engine` - The Redis engine returned by `fio_redis_new()`
- `command` - A FIOBJ array containing the command and its arguments
- `callback` - Optional callback function invoked when the reply is received
- `udata` - User data passed to the callback

**Returns:** 0 on success, -1 on error (invalid engine or command).

**Callback Signature:**
```c
void callback(fio_pubsub_engine_s *e, FIOBJ reply, void *udata);
```

The `reply` parameter is a FIOBJ object representing the Redis response:
- Simple strings and bulk strings become `FIOBJ_T_STRING`
- Integers become `FIOBJ_T_NUMBER`
- Arrays become `FIOBJ_T_ARRAY`
- Maps (RESP3) become `FIOBJ_T_HASH`
- Null becomes `fiobj_null()`
- Booleans become `fiobj_true()` or `fiobj_false()`
- Errors become `FIOBJ_T_STRING` (check logs for error messages)

**Warning**: NEVER use `fio_redis_send` for subscription commands (`SUBSCRIBE`, `PSUBSCRIBE`, `UNSUBSCRIBE`, `PUNSUBSCRIBE`). These commands are handled internally by the pub/sub engine through the subscription connection. Using them with `fio_redis_send` will violate the Redis protocol and cause connection errors.

------------------------------------------------------------

### Usage Examples

#### Basic Redis Commands

```c
#define FIO_LOG
#define FIO_REDIS
#include FIO_INCLUDE_FILE

/* Callback for GET command */
void on_get_reply(fio_pubsub_engine_s *e, FIOBJ reply, void *udata) {
  fio_str_info_s value = fiobj2cstr(reply);
  FIO_LOG_INFO("GET result: %.*s", (int)value.len, value.buf);
  (void)e; (void)udata;
}

/* Callback for SET command */
void on_set_reply(fio_pubsub_engine_s *e, FIOBJ reply, void *udata) {
  fio_str_info_s status = fiobj2cstr(reply);
  FIO_LOG_INFO("SET result: %.*s", (int)status.len, status.buf);
  (void)e; (void)udata;
}

/* Callback for INCR command */
void on_incr_reply(fio_pubsub_engine_s *e, FIOBJ reply, void *udata) {
  intptr_t new_value = fiobj2i(reply);
  FIO_LOG_INFO("INCR result: %ld", (long)new_value);
  (void)e; (void)udata;
}

void send_redis_commands(fio_pubsub_engine_s *redis) {
  FIOBJ cmd;
  
  /* SET mykey "Hello, Redis!" */
  cmd = fiobj_array_new();
  fiobj_array_push(cmd, fiobj_str_new_cstr("SET", 3));
  fiobj_array_push(cmd, fiobj_str_new_cstr("mykey", 5));
  fiobj_array_push(cmd, fiobj_str_new_cstr("Hello, Redis!", 13));
  fio_redis_send(redis, cmd, on_set_reply, NULL);
  fiobj_free(cmd);
  
  /* GET mykey */
  cmd = fiobj_array_new();
  fiobj_array_push(cmd, fiobj_str_new_cstr("GET", 3));
  fiobj_array_push(cmd, fiobj_str_new_cstr("mykey", 5));
  fio_redis_send(redis, cmd, on_get_reply, NULL);
  fiobj_free(cmd);
  
  /* INCR counter */
  cmd = fiobj_array_new();
  fiobj_array_push(cmd, fiobj_str_new_cstr("INCR", 4));
  fiobj_array_push(cmd, fiobj_str_new_cstr("counter", 7));
  fio_redis_send(redis, cmd, on_incr_reply, NULL);
  fiobj_free(cmd);
}
```

#### Pub/Sub Integration with facil.io

```c
#define FIO_LOG
#define FIO_REDIS
#include FIO_INCLUDE_FILE

static fio_pubsub_engine_s *redis_engine = NULL;

/* Handle incoming pub/sub messages */
void on_pubsub_message(fio_pubsub_msg_s *msg) {
  FIO_LOG_INFO("Channel: %.*s | Message: %.*s",
               (int)msg->channel.len, msg->channel.buf,
               (int)msg->message.len, msg->message.buf);
}

/* Called when server starts */
void on_start(void *udata) {
  (void)udata;
  
  /* Subscribe to channels - Redis engine handles SUBSCRIBE automatically */
  fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("notifications"),
                .on_message = on_pubsub_message);
  
  fio_pubsub_subscribe(.channel = FIO_BUF_INFO1("events:*"),
                .on_message = on_pubsub_message,
                .is_pattern = 1);  /* Pattern subscription uses PSUBSCRIBE */
  
  FIO_LOG_INFO("Subscribed to channels via Redis");
}

/* Publish a message (from any worker process) */
void broadcast_message(const char *channel, const char *message) {
  fio_pubsub_publish(.channel = FIO_BUF_INFO1(channel),
              .message = FIO_BUF_INFO1(message),
              .engine = FIO_PUBSUB_CLUSTER);  /* Uses Redis if attached */
}

int main(void) {
  /* Create Redis engine (ref count = 1) */
  redis_engine = fio_redis_new(.url = "redis://localhost:6379");
  if (!redis_engine) {
    FIO_LOG_FATAL("Failed to create Redis engine");
    return 1;
  }
  
  /* Attach to pub/sub (does NOT take ownership) */
  fio_pubsub_engine_attach(redis_engine);
  
  /* Register startup callback */
  fio_state_callback_add(FIO_CALL_ON_START, on_start, NULL);
  
  /* Start the server */
  fio_io_start(0);
  
  /* Cleanup - detach before freeing if attached */
  fio_pubsub_engine_detach(redis_engine);
  fio_redis_free(redis_engine);
  return 0;
}
```

#### Authentication

```c
#define FIO_LOG
#define FIO_REDIS
#include FIO_INCLUDE_FILE

int main(void) {
  /* Connect with password authentication */
  fio_pubsub_engine_s *redis = fio_redis_new(
      .url = "redis://redis.example.com:6379",
      .auth = "my_redis_password"
  );
  
  if (!redis) {
    FIO_LOG_ERROR("Failed to create Redis engine");
    return 1;
  }
  
  /* For Redis 6+ ACL authentication (username:password), 
   * you may need to send AUTH command manually after connection */
  
  fio_pubsub_engine_attach(redis);
  fio_io_start(0);
  fio_pubsub_engine_detach(redis);
  fio_redis_free(redis);
  return 0;
}
```

#### Handling Complex Replies

```c
#define FIO_LOG
#define FIO_REDIS
#include FIO_INCLUDE_FILE

/* Handle HGETALL reply (returns array of field-value pairs) */
void on_hgetall_reply(fio_pubsub_engine_s *e, FIOBJ reply, void *udata) {
  if (FIOBJ_TYPE(reply) != FIOBJ_T_ARRAY) {
    FIO_LOG_WARNING("Unexpected reply type");
    return;
  }
  
  size_t count = fiobj_array_count(reply);
  FIO_LOG_INFO("Hash has %zu fields:", count / 2);
  
  for (size_t i = 0; i + 1 < count; i += 2) {
    fio_str_info_s field = fiobj2cstr(fiobj_array_get(reply, (int32_t)i));
    fio_str_info_s value = fiobj2cstr(fiobj_array_get(reply, (int32_t)(i + 1)));
    FIO_LOG_INFO("  %.*s = %.*s",
                 (int)field.len, field.buf,
                 (int)value.len, value.buf);
  }
  (void)e; (void)udata;
}

/* Handle MGET reply (returns array of values) */
void on_mget_reply(fio_pubsub_engine_s *e, FIOBJ reply, void *udata) {
  if (FIOBJ_TYPE(reply) != FIOBJ_T_ARRAY) {
    FIO_LOG_WARNING("Unexpected reply type");
    return;
  }
  
  size_t count = fiobj_array_count(reply);
  for (size_t i = 0; i < count; ++i) {
    FIOBJ item = fiobj_array_get(reply, (int32_t)i);
    if (FIOBJ_TYPE(item) == FIOBJ_T_NULL) {
      FIO_LOG_INFO("Key %zu: (nil)", i);
    } else {
      fio_str_info_s value = fiobj2cstr(item);
      FIO_LOG_INFO("Key %zu: %.*s", i, (int)value.len, value.buf);
    }
  }
  (void)e; (void)udata;
}
```

------------------------------------------------------------

### Architecture Notes

#### Dual Connection Model

The Redis engine maintains two separate TCP connections to the Redis server:

1. **Publishing Connection**: Used for sending commands (`fio_redis_send`) and PUBLISH operations. This connection operates in request-response mode.

2. **Subscription Connection**: Used exclusively for SUBSCRIBE/PSUBSCRIBE operations. Once a connection enters subscription mode, it can only receive pub/sub messages and cannot execute regular commands.

This separation is required by the Redis protocol - a connection in subscription mode cannot execute regular commands, and mixing the two would cause protocol errors.

```

                    facil.io Application                      

                    Redis Pub/Sub Engine                      
       
   Publishing Connection     Subscription Connection      
   - fio_redis_send()       - SUBSCRIBE/PSUBSCRIBE       
   - PUBLISH commands       - Receives pub/sub messages  
   - Regular commands       - Pattern matching           
       

                                             
              
                              
                              
                    
                       Redis Server  
                    
```

#### Ownership and Attach/Detach

The `fio_pubsub_engine_attach()` and `fio_pubsub_engine_detach()` functions do **NOT** transfer ownership of the engine. They simply register or unregister the engine with the pub/sub system.

The caller who created the engine with `fio_redis_new()` is responsible for calling `fio_redis_free()` when the engine is no longer needed. **Important**: If the engine was attached via `fio_pubsub_engine_attach()`, you **MUST** call `fio_pubsub_engine_detach()` before calling `fio_redis_free()`.

#### Command Queue

Commands sent via `fio_redis_send()` are queued internally and sent one at a time, waiting for each reply before sending the next command. This ensures proper correlation between commands and their responses.

The queue is processed in FIFO order. If the connection is lost, queued commands remain in the queue and are sent after reconnection.

------------------------------------------------------------

### Error Handling

#### Connection Loss

When a connection is lost:

1. The engine logs a warning message
2. Automatic reconnection is attempted after a brief delay
3. On the subscription connection, all active subscriptions are re-established via `fio_pubsub_engine_attach()`
4. Queued commands on the publishing connection are sent after reconnection

#### Authentication Failures

If Redis authentication fails, the connection will be closed by Redis. The engine will attempt to reconnect, but authentication will fail again. Check your Redis logs and ensure the correct password is configured.

#### Protocol Errors

If a RESP protocol error is detected (malformed data from Redis), the connection is closed immediately and reconnection is attempted. This typically indicates a network issue or a bug.

#### Logging

The Redis module uses facil.io's logging system:

- `FIO_LOG_DEBUG` - Connection establishment, command sending
- `FIO_LOG_WARNING` - Connection loss, unexpected responses, errors from Redis
- `FIO_LOG_ERROR` - Protocol errors, allocation failures

------------------------------------------------------------

### Thread Safety

The Redis engine is thread-safe. All internal state modifications are delegated to the IO queue using `fio_io_defer()`, ensuring single-threaded execution of state changes. This prevents race conditions without requiring locks.

**Public API thread safety:**
- `fio_redis_new()` - Thread-safe (defers connection to IO thread)
- `fio_redis_dup()` - Thread-safe (uses atomic reference counting)
- `fio_redis_free()` - Thread-safe (defers cleanup to IO thread)
- `fio_redis_send()` - Thread-safe (defers command queuing to IO thread)

**Internal operations that run on the IO thread:**
- Command queue management (add, remove, send)
- Connection state changes (connect, disconnect, reconnect)
- Protocol callbacks (on_attach, on_data, on_close, on_timeout)
- Pub/sub engine callbacks (subscribe, publish, etc.)

The FIOBJ objects passed to callbacks are **not** thread-safe. If you need to share reply data across threads, make a copy of the data within the callback.

**Note**: The pub/sub callbacks (`on_message`) are called from the IO reactor thread. Long-running operations should be deferred to avoid blocking the reactor.

------------------------------------------------------------

### Integration with Pub/Sub Engines

The Redis engine implements the `fio_pubsub_engine_s` interface:

```c
struct fio_pubsub_engine_s {
  void (*detached)(const fio_pubsub_engine_s *eng);
  void (*subscribe)(const fio_pubsub_engine_s *eng, fio_buf_info_s channel, int16_t filter);
  void (*psubscribe)(const fio_pubsub_engine_s *eng, fio_buf_info_s channel, int16_t filter);
  void (*unsubscribe)(const fio_pubsub_engine_s *eng, fio_buf_info_s channel, int16_t filter);
  void (*punsubscribe)(const fio_pubsub_engine_s *eng, fio_buf_info_s channel, int16_t filter);
  void (*publish)(const fio_pubsub_engine_s *eng, fio_pubsub_msg_s *msg);
};
```

When attached via `fio_pubsub_engine_attach()`:

- `subscribe` sends Redis `SUBSCRIBE` command
- `psubscribe` sends Redis `PSUBSCRIBE` command  
- `unsubscribe` sends Redis `UNSUBSCRIBE` command
- `punsubscribe` sends Redis `PUNSUBSCRIBE` command
- `publish` sends Redis `PUBLISH` command via the command queue

Messages received from Redis subscriptions are forwarded to local subscribers via `fio_pubsub_publish()` with `fio_pubsub_engine_ipc()` engine.

**Note**: The `filter` parameter is ignored by the Redis engine. Redis does not support facil.io's numeric filter namespaces.

------------------------------------------------------------

### Limitations

- **Filter Namespaces**: Redis does not support facil.io's numeric filter feature. All Redis pub/sub operates with filter = 0.

- **Message Size**: Limited by Redis's maximum bulk string size and `FIO_REDIS_READ_BUFFER`. Very large messages may require increasing the buffer size.

- **Binary Data**: Channel names and messages can contain binary data, but some Redis tools may not display them correctly.

- **Cluster Mode**: This module connects to a single Redis instance. For Redis Cluster, you would need to connect to the appropriate node or use a Redis proxy.

------------------------------------------------------------
## HTTP Server

### Listening for HTTP / WebSockets and EventSource connections

#### `fio_http_listen`

```c
fio_http_listener_s *fio_http_listen(const char *url, fio_http_settings_s settings);
/* Named arguments using macro. */
#define fio_http_listen(url, ...)                                              \
  fio_http_listen(url, (fio_http_settings_s){__VA_ARGS__})

typedef struct fio_http_settings_s {
  /** Called before body uploads, when a client sends an `Expect` header. */
  void (*pre_http_body)(fio_http_s *h);
  /** Callback for HTTP requests (server) or responses (client). */
  void (*on_http)(fio_http_s *h);
  /** Called when a request / response cycle is finished with no Upgrade. */
  void (*on_finish)(fio_http_s *h);
  /** Authenticate EventSource (SSE) requests, return non-zero to deny.*/
  int (*on_authenticate_sse)(fio_http_s *h);
  /** Authenticate WebSockets Upgrade requests, return non-zero to deny.*/
  int (*on_authenticate_websocket)(fio_http_s *h);
  /** Called once a WebSocket / SSE connection upgrade is complete. */
  void (*on_open)(fio_http_s *h);
  /** Called when a WebSocket message is received. */
  void (*on_message)(fio_http_s *h, fio_buf_info_s msg, uint8_t is_text);
  /** Called when an EventSource event is received. */
  void (*on_eventsource)(fio_http_s *h,
                         fio_buf_info_s id,
                         fio_buf_info_s event,
                         fio_buf_info_s data);
  /** Called when an EventSource reconnect event requests an ID. */
  void (*on_eventsource_reconnect)(fio_http_s *h, fio_buf_info_s id);
  /** Called for WebSocket / SSE connections when outgoing buffer is empty. */
  void (*on_ready)(fio_http_s *h);
  /** Called for open WebSocket / SSE connections during shutting down. */
  void (*on_shutdown)(fio_http_s *h);
  /** Called after a WebSocket / SSE connection is closed (for cleanup). */
  void (*on_close)(fio_http_s *h);
  /** (optional) the callback to be performed when the HTTP service closes. */
  void (*on_stop)(struct fio_http_settings_s *settings);
  /** Default opaque user data for HTTP handles (fio_http_s). */
  void *udata;
  /** Optional SSL/TLS support. */
  fio_io_functions_s *tls_io_func;
  /** Optional SSL/TLS support. */
  fio_io_tls_s *tls;
  /** Optional HTTP task queue (for multi-threading HTTP responses) */
  fio_io_async_s *queue;
  /** A public folder for file transfers - serves static files. */
  fio_str_info_s public_folder;
  /** Max-age value (in seconds) for caching static files. Defaults to 0. */
  size_t max_age;
  /** Maximum total bytes for request string and headers. */
  uint32_t max_header_size;
  /** Maximum bytes allowed per header / request line. */
  uint32_t max_line_len;
  /** Maximum size of an HTTP request's body. */
  size_t max_body_size;
  /** Maximum WebSocket message size/buffer (in bytes). */
  size_t ws_max_msg_size;
  /** reserved for future use. */
  intptr_t reserved1;
  /** reserved for future use. */
  intptr_t reserved2;
  /** HTTP/1.x connection timeout in seconds. */
  uint8_t timeout;
  /** WebSocket connection timeout in seconds. */
  uint8_t ws_timeout;
  /** EventSource (SSE) connection timeout in seconds. */
  uint8_t sse_timeout;
  /** Timeout for client connections (only relevant in client mode). */
  uint8_t connect_timeout;
  /** Logging flag - set to TRUE to log HTTP requests. */
  uint8_t log;
} fio_http_settings_s;
```

Listens to HTTP / WebSockets / SSE connections on `url`.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_http_listener_s *listener = fio_http_listen("0.0.0.0:3000",
                                                .on_http = my_http_handler,
                                                .log = 1);
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `pre_http_body` | `void (*)(fio_http_s *)` | Called before body uploads when client sends `Expect` header |
| `on_http` | `void (*)(fio_http_s *)` | Callback for HTTP requests (server) or responses (client) |
| `on_finish` | `void (*)(fio_http_s *)` | Called when request/response cycle finishes with no Upgrade |
| `on_authenticate_sse` | `int (*)(fio_http_s *)` | Authenticate SSE requests; return non-zero to deny |
| `on_authenticate_websocket` | `int (*)(fio_http_s *)` | Authenticate WebSocket requests; return non-zero to deny |
| `on_open` | `void (*)(fio_http_s *)` | Called once WebSocket/SSE upgrade is complete |
| `on_message` | `void (*)(fio_http_s *, fio_buf_info_s, uint8_t)` | Called when WebSocket message is received |
| `on_eventsource` | `void (*)(...)` | Called when EventSource event is received |
| `on_eventsource_reconnect` | `void (*)(fio_http_s *, fio_buf_info_s)` | Called when SSE reconnect requests an ID |
| `on_ready` | `void (*)(fio_http_s *)` | Called when outgoing buffer is empty (WS/SSE) |
| `on_shutdown` | `void (*)(fio_http_s *)` | Called for open WS/SSE connections during shutdown |
| `on_close` | `void (*)(fio_http_s *)` | Called after WS/SSE connection is closed |
| `on_stop` | `void (*)(fio_http_settings_s *)` | Called when HTTP service closes |
| `udata` | `void *` | Default opaque user data for HTTP handles |
| `tls_io_func` | `fio_io_functions_s *` | Optional SSL/TLS IO functions |
| `tls` | `fio_io_tls_s *` | Optional SSL/TLS support |
| `queue` | `fio_io_async_s *` | Optional HTTP task queue for multi-threading |
| `public_folder` | `fio_str_info_s` | Public folder for static file serving |
| `max_age` | `size_t` | Max-age for static file caching (seconds); defaults to 0 |
| `max_header_size` | `uint32_t` | Max bytes for request + headers; defaults to `FIO_HTTP_DEFAULT_MAX_HEADER_SIZE` |
| `max_line_len` | `uint32_t` | Max bytes per header line; defaults to `FIO_HTTP_DEFAULT_MAX_LINE_LEN` |
| `max_body_size` | `size_t` | Max body size; defaults to `FIO_HTTP_DEFAULT_MAX_BODY_SIZE` |
| `ws_max_msg_size` | `size_t` | Max WebSocket message size; defaults to `FIO_HTTP_DEFAULT_WS_MAX_MSG_SIZE` |
| `timeout` | `uint8_t` | HTTP/1.x timeout in seconds; defaults to `FIO_HTTP_DEFAULT_TIMEOUT` |
| `ws_timeout` | `uint8_t` | WebSocket timeout in seconds; defaults to `FIO_HTTP_DEFAULT_TIMEOUT_LONG` |
| `sse_timeout` | `uint8_t` | SSE timeout in seconds; defaults to `FIO_HTTP_DEFAULT_TIMEOUT_LONG` |
| `connect_timeout` | `uint8_t` | Client connection timeout (client mode only) |
| `log` | `uint8_t` | Set to TRUE to log HTTP requests |

**Returns:** a listener handle (`fio_http_listener_s *`) on success, or NULL on error. The listener can be used with `fio_http_route` to add route-specific handlers.

#### `fio_http_route`

```c
int fio_http_route(fio_http_listener_s *listener,
                   const char *url,
                   fio_http_settings_s settings);
/* Named arguments using macro. */
#define fio_http_route(listener, url, ...)                                     \
  fio_http_route(listener, url, (fio_http_settings_s){__VA_ARGS__})
```

Adds a route prefix to the HTTP handler.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_http_route(listener, "/api",
               .on_http = my_api_handler,
               .log = 1);
```

The order in which `fio_http_route` is called is irrelevant (unless overwriting an existing route).

Matching is performed as a best-prefix match:

- All paths match the route `"/"` (the default prefix).

- Partial URL matches are only valid if the `/` character is the one following the partial match. For example: setting `"/user"` will match `"/user"` and all `"/user/..."` paths but not `"/user..."`

- Setting `"/user/new"` as well as `"/user"` (in whatever order) will route `"/user/new"` and `"/user/new/..."` to `"/user/new"`. Otherwise, the `"/user"` route will continue to behave the same.

**Returns:** 0 on success, -1 on error.

**Note**: the `udata`, `on_finish`, `public_folder` and `log` properties are all inherited (if missing) from the default HTTP settings used to create the listener.

**Note**: TLS options are ignored.

#### `fio_http_route_settings`

```c
fio_http_settings_s *fio_http_route_settings(fio_http_listener_s *listener, const char *url);
```

Returns a link to the settings matching `url`, as set by `fio_http_route`.


#### `fio_http_resource_action`

```c
typedef enum {
  FIO_HTTP_RESOURCE_NONE,
  FIO_HTTP_RESOURCE_INDEX,
  FIO_HTTP_RESOURCE_SHOW,
  FIO_HTTP_RESOURCE_NEW,
  FIO_HTTP_RESOURCE_EDIT,
  FIO_HTTP_RESOURCE_CREATE,
  FIO_HTTP_RESOURCE_UPDATE,
  FIO_HTTP_RESOURCE_DELETE,
} fio_http_resource_action_e;

fio_http_resource_action_e fio_http_resource_action(fio_http_s *h);
```

Returns the resource action expected by the request details in the HTTP handle `h`.

If no REST / CRUD style action is detected, FIO_HTTP_RESOURCE_NONE is returned.

- `FIO_HTTP_RESOURCE_INDEX`: will be returned on `GET` `/`.

    Should show the list of available items.

- `FIO_HTTP_RESOURCE_SHOW`: will be returned on `GET` `/:id`.

    Should show selected item(s).

- `FIO_HTTP_RESOURCE_NEW`: will be returned on `GET` `/new`.

    Should return a form for creating an item.

- `FIO_HTTP_RESOURCE_EDIT`: will be returned on `GET` `/:id/edit`.

    Should show a form for editing the selected item(s).

- `FIO_HTTP_RESOURCE_CREATE`: will be returned on `PUT`/`POST`/`PATCH` `/`.

    Should create **or update** an item (if `id` is provided).

- `FIO_HTTP_RESOURCE_UPDATE`: will be returned on `PUT`/`POST`/`PATCH` `/:id`.

    Should update selected item.

- `FIO_HTTP_RESOURCE_DELETE`: will be returned on `DELETE` `/:id`.

    Should delete selected item.

#### `fio_http_listener_settings`

```c
fio_http_settings_s *fio_http_listener_settings(fio_http_listener_s *listener);
```

Returns a pointer to the HTTP settings associated with the listener.

**Note**: changing the settings for the root path should be performed using `fio_http_route` and not by altering the settings directly.

#### `FIO_HTTP_AUTHENTICATE_ALLOW`

```c
int FIO_HTTP_AUTHENTICATE_ALLOW(fio_http_s *h);
```

Allows all clients to connect to WebSockets / EventSource (SSE) connections (bypasses authentication), to be used with the `.on_authenticate_sse` and `.on_authenticate_websocket` settings options.

#### `fio_http_connect`

```c
fio_io_s *fio_http_connect(const char *url,
                           fio_http_s *h,
                           fio_http_settings_s settings);
/* Named arguments using macro. */
#define fio_http_connect(url, h, ...)                                          \
  fio_http_connect(url, h, (fio_http_settings_s){__VA_ARGS__})
```

Connects to HTTP / WebSockets / SSE connections on `url`.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_io_s *io = fio_http_connect("wss://example.com/ws", NULL,
                                .on_open = my_on_open,
                                .on_message = my_on_message);
```

- `url` - The URL to connect to. Supports `http://`, `https://`, `ws://`, `wss://`, `sse://`, `sses://` schemes.
- `h` - An optional pre-configured HTTP handle. If NULL, a new handle is created.
- `settings` - Connection settings (see `fio_http_settings_s`).

**Returns:** an IO handle (`fio_io_s *`) on success, or NULL on error.

**Note**: For WebSocket connections, use `ws://` or `wss://` scheme. For SSE connections, use `sse://` or `sses://` scheme.

### Creating an HTTP Handle

These are Used internally by the `FIO_HTTP` module.

#### `fio_http_new`

```c
fio_http_s *fio_http_new(void);
```

Create a new `fio_http_s` handle.

#### `fio_http_new_copy_request`

```c
fio_http_s *fio_http_new_copy_request(fio_http_s *old);
```

Creates a copy of an existing handle, copying only its request data.

#### `fio_http_destroy`

```c
fio_http_s *fio_http_destroy(fio_http_s *h);
```

Destroys the HTTP handle object, freeing all allocated resources.

#### `fio_http_start_time_set`

```c
void fio_http_start_time_set(fio_http_s *);
```

Collects an updated timestamp for logging purposes.

### HTTP Reference Counting

#### `fio_http_free`

```c
void fio_http_free(fio_http_s *);
```

Reduces an `fio_http_s` handle's reference count or frees it.

#### `fio_http_dup`

```c
fio_http_s *fio_http_dup(fio_http_s *);
```

Increases an `fio_http_s` handle's reference count.

### HTTP Request / Response Data

#### `fio_http_udata`

```c
void *fio_http_udata(fio_http_s *);
```

Gets the opaque user pointer associated with the HTTP handle.

#### `fio_http_udata_set`

```c
void *fio_http_udata_set(fio_http_s *, void *);
```

Sets the opaque user pointer associated with the HTTP handle.

#### `fio_http_udata2`

```c
void *fio_http_udata2(fio_http_s *);
```

Gets the second opaque user pointer associated with the HTTP handle.

#### `fio_http_udata2_set`

```c
void *fio_http_udata2_set(fio_http_s *, void *);
```

Sets a second opaque user pointer associated with the HTTP handle.

#### `fio_http_cdata`

```c
void *fio_http_cdata(fio_http_s *h);
```

Returns the existing controller data (`void *` pointer).

This is used internally by the HTTP module to store connection-specific data.

#### `fio_http_cdata_set`

```c
void *fio_http_cdata_set(fio_http_s *h, void *cdata);
```

Sets a new controller data (`void *` pointer).

This is used internally by the HTTP module to store connection-specific data.

#### `fio_http_controller`

```c
fio_http_controller_s *fio_http_controller(fio_http_s *h);
```

Gets the HTTP Controller associated with the HTTP handle.

#### `fio_http_controller_set`

```c
fio_http_controller_s *fio_http_controller_set(fio_http_s *h,
                                               fio_http_controller_s *controller);
```

Sets the HTTP Controller associated with the HTTP handle.

#### `fio_http_io`

```c
fio_io_s *fio_http_io(fio_http_s *);
```

Returns the IO object associated with the HTTP object (request only).


#### `fio_http_settings`

```c
fio_http_settings_s *fio_http_settings(fio_http_s *);
```

Returns the HTTP settings associated with the HTTP object, if any.

#### `fio_http_from`

```c
int fio_http_from(fio_str_info_s *dest, const fio_http_s *h);
```

Writes peer address to `dest` starting with the `forwarded` header, with a fallback to actual socket address and a final fallback to `"[unknown]"`.

If `unknown` is returned, the function returns -1. if `dest` capacity is too small, the number of bytes required will be returned.

If all goes well, this function returns 0.

**Note**: to check the actual socket peer address (not merely the address reported by the client), use [`fio_sock_peer_addr`](#fio_sock_peer_addr). If the request was routed using a proxy, this will provide the proxy's address.


### HTTP State

#### `fio_http_is_clean`

```c
int fio_http_is_clean(fio_http_s *);
```

Returns true if no HTTP headers / data was sent (a clean slate).

#### `fio_http_is_finished`

```c
int fio_http_is_finished(fio_http_s *);
```

Returns true if the HTTP handle's response was sent.

#### `fio_http_is_streaming`

```c
int fio_http_is_streaming(fio_http_s *);
```

Returns true if the HTTP handle's response is streaming.

#### `fio_http_is_upgraded`

```c
int fio_http_is_upgraded(fio_http_s *h);
```

Returns true if the HTTP connection was (or should have been) upgraded.

#### `fio_http_is_websocket`

```c
int fio_http_is_websocket(fio_http_s *);
```

Returns true if the HTTP handle refers to a WebSocket connection.

#### `fio_http_is_sse`

```c
int fio_http_is_sse(fio_http_s *);
```

Returns true if the HTTP handle refers to an EventSource connection.

#### `fio_http_is_freeing`

```c
int fio_http_is_freeing(fio_http_s *);
```

Returns true if the HTTP handle is in the process of freeing itself.

### HTTP Request Data

#### `fio_http_received_at`

```c
int64_t fio_http_received_at(fio_http_s *);
```

Gets the received_at timestamp (ms) associated with the HTTP handle.

**Note**: when `FIO_HTTP_EXACT_LOGGING` is true, this will be in micro-seconds (1/1000000), otherwise milliseconds are used (1/1000). 

#### `fio_http_received_at_set`

```c
int64_t fio_http_received_at_set(fio_http_s *, int64_t);
```

Sets the received_at timestamp (ms) associated with the HTTP handle.

**Note**: this is automatically set by the [`fio_http_new`](#fio_http_new) constructor. **There is no need to call this function**.

**Note**: when `FIO_HTTP_EXACT_LOGGING` is true, this should be set in micro-seconds (1/1000000), otherwise milliseconds should be used (1/1000).

#### `fio_http_status`

```c
size_t fio_http_status(fio_http_s *);
```

Gets the status associated with the HTTP handle (response).

#### `fio_http_status_set`

```c
size_t fio_http_status_set(fio_http_s *, size_t status);
```

Sets the status associated with the HTTP handle (response).

#### `fio_http_method`

```c
fio_str_info_s fio_http_method(fio_http_s *);
```

Gets the method information associated with the HTTP handle.

#### `fio_http_method_set`

```c
fio_str_info_s fio_http_method_set(fio_http_s *, fio_str_info_s);
```

Sets the method information associated with the HTTP handle.

#### `fio_http_path`

```c
fio_str_info_s fio_http_path(fio_http_s *);
```

Gets the path information associated with the HTTP handle.

#### `fio_http_path_set`

```c
fio_str_info_s fio_http_path_set(fio_http_s *, fio_str_info_s);
```

Sets the path information associated with the HTTP handle.

#### `fio_http_opath`

```c
fio_str_info_s fio_http_opath(fio_http_s *);
```

Gets the original / first path associated with the HTTP handle.

This is the path before any routing modifications were applied.

#### `fio_http_opath_set`

```c
fio_str_info_s fio_http_opath_set(fio_http_s *, fio_str_info_s);
```

Sets the original / first path associated with the HTTP handle.

#### `FIO_HTTP_PATH_EACH`

```c
#define FIO_HTTP_PATH_EACH(path, pos)
```

Loops over each section of `path`, decoding percent encoding as necessary.

The macro accepts the following:

- `path`: the path string as a `fio_str_info_s` or `fio_buf_info_s` object (see [`fio_http_path(h)`](#fio_http_path)).

- `pos` : the name of the variable to use for accessing the section.

The variable `pos` is a `fio_buf_info_s`.

**Note**: the macro will break if any path's section length is greater than (about) 4063 bytes.

#### `fio_http_query`

```c
fio_str_info_s fio_http_query(fio_http_s *);
```

Gets the query information associated with the HTTP handle.

#### `fio_http_query_set`

```c
fio_str_info_s fio_http_query_set(fio_http_s *, fio_str_info_s);
```

Sets the query information associated with the HTTP handle.

#### `fio_http_version`

```c
fio_str_info_s fio_http_version(fio_http_s *);
```

Gets the version information associated with the HTTP handle.

#### `fio_http_version_set`

```c
fio_str_info_s fio_http_version_set(fio_http_s *, fio_str_info_s);
```

Sets the version information associated with the HTTP handle.

#### `fio_http_request_header`
```c
fio_str_info_s fio_http_request_header(fio_http_s *,
                                       fio_str_info_s name,
                                       size_t index);
```

Gets the header information associated with the HTTP handle.

Since more than a single value may be associated with a header name, the index may be used to collect subsequent values.

An empty value is returned if no header value is available (or index is exceeded).

#### `fio_http_request_header_count`

```c
size_t fio_http_request_header_count(fio_http_s *, fio_str_info_s name);
```

Returns the number of headers named `name` that were received.

If `name` buffer is `NULL`, returns the number of unique headers (not the number of unique values).


#### `fio_http_request_header_set`

```c
fio_str_info_s fio_http_request_header_set(fio_http_s *,
                                           fio_str_info_s name,
                                           fio_str_info_s value);
```

Sets the header information associated with the HTTP handle.

#### `fio_http_request_header_set_if_missing`

```c
fio_str_info_s fio_http_request_header_set_if_missing(fio_http_s *,
                                       fio_str_info_s name,
                                       fio_str_info_s value);
```

Sets the header information associated with the HTTP handle.

#### `fio_http_request_header_add`

```c
fio_str_info_s fio_http_request_header_add(fio_http_s *,
                                           fio_str_info_s name,
                                           fio_str_info_s value);
```

Adds to the header information associated with the HTTP handle.

#### `fio_http_request_header_each`

```c
size_t fio_http_request_header_each(fio_http_s *,
                                    int (*callback)(fio_http_s *,
                                                    fio_str_info_s name,
                                                    fio_str_info_s value,
                                                    void *udata),
                                    void *udata);
```

Iterates through all request headers (except cookies!).

A non-zero return will stop iteration.

Returns the number of iterations performed. If `callback` is `NULL`, returns the number of headers available (multi-value headers are counted as 1).

#### `fio_http_body_length`
```c
size_t fio_http_body_length(fio_http_s *);
```

Gets the body (payload) length associated with the HTTP handle.

#### `fio_http_body_pos`

```c
size_t fio_http_body_pos(fio_http_s *h);
```

Returns the body's reading position.

#### `fio_http_body_seek`
```c
size_t fio_http_body_seek(fio_http_s *, ssize_t pos);
```

Adjusts the body's reading position. Negative values start at the end.

If `pos == SSIZE_MAX`, returns `fio_http_body_pos`.

#### `fio_http_body_read`
```c
fio_str_info_s fio_http_body_read(fio_http_s *, size_t length);
```

Reads up to `length` of data from the body, returns nothing on EOF.

#### `fio_http_body_read_until`

```c
fio_str_info_s fio_http_body_read_until(fio_http_s *,
                                        char token,
                                        size_t limit);
```

Reads from the body until finding `token`, reaching `limit` or EOF.

Note: `limit` is ignored if zero or if the remaining data is lower than limit.

#### `fio_http_body_expect`
```c
void fio_http_body_expect(fio_http_s *, size_t expected_length);
```

Allocates a body (payload) of (at least) the `expected_length`.


#### `fio_http_body_write`
```c
void fio_http_body_write(fio_http_s *, const void *data, size_t len);
```

Writes `data` to the body (payload) associated with the HTTP handle.

#### `fio_http_body_fd`

```c
int fio_http_body_fd(fio_http_s *);
```

If the body is stored in a temporary file, returns the file's handle.

Otherwise returns -1.

### HTTP Body Parsing

#### `fio_http_body_parse`

```c
fio_http_body_parse_result_s fio_http_body_parse(
    fio_http_s *h,
    const fio_http_body_parse_callbacks_s *callbacks,
    void *udata);
```

Parses the HTTP request body, auto-detecting content type.

Supports JSON, URL-encoded, and multipart/form-data bodies. Calls the appropriate callbacks for each element found.

- `h` - The HTTP handle.
- `callbacks` - Parser callbacks (designed to be static const).
- `udata` - User context passed to all callbacks.

**Returns:** Parse result with top-level object and status.

#### `fio_http_body_parse_callbacks_s`

```c
typedef struct {
  /* ===== Primitives ===== */
  /** NULL / nil was detected. Returns new object. */
  void *(*on_null)(void *udata);
  /** TRUE was detected. Returns new object. */
  void *(*on_true)(void *udata);
  /** FALSE was detected. Returns new object. */
  void *(*on_false)(void *udata);
  /** Number was detected. Returns new object. */
  void *(*on_number)(void *udata, int64_t num);
  /** Float was detected. Returns new object. */
  void *(*on_float)(void *udata, double num);
  /** String was detected. Returns new object. */
  void *(*on_string)(void *udata, const void *data, size_t len);

  /* ===== Containers ===== */
  /** Array was detected. Returns context for this array. */
  void *(*on_array)(void *udata, void *parent);
  /** Map / Object was detected. Returns context for this map. */
  void *(*on_map)(void *udata, void *parent);
  /** Push value to array. Returns non-zero on error. */
  int (*array_push)(void *udata, void *array, void *value);
  /** Set key-value pair in map. Returns non-zero on error. */
  int (*map_set)(void *udata, void *map, void *key, void *value);
  /** Called when array parsing is complete. */
  void (*array_done)(void *udata, void *array);
  /** Called when map parsing is complete. */
  void (*map_done)(void *udata, void *map);

  /* ===== File Uploads (multipart) ===== */
  /** Called when a file upload starts. Return NULL to skip this file. */
  void *(*on_file)(void *udata,
                   fio_str_info_s name,
                   fio_str_info_s filename,
                   fio_str_info_s content_type);
  /** Called for each chunk of file data. Return non-zero to abort. */
  int (*on_file_data)(void *udata, void *file, fio_buf_info_s data);
  /** Called when file upload is complete. */
  void (*on_file_done)(void *udata, void *file);

  /* ===== Error Handling ===== */
  /** Called on parse error. `partial` is the incomplete result, if any. */
  void *(*on_error)(void *udata, void *partial);
  /** Called to free an unused object (e.g., key when map_set fails). */
  void (*free_unused)(void *udata, void *obj);
} fio_http_body_parse_callbacks_s;
```

HTTP body parser callbacks. All callbacks receive `udata` as first parameter.

#### `fio_http_body_parse_result_s`

```c
typedef struct {
  /** Top-level parsed object (caller responsible for freeing). */
  void *result;
  /** Number of bytes consumed from body. */
  size_t consumed;
  /** Error code: 0 = success. */
  int err;
} fio_http_body_parse_result_s;
```

HTTP body parse result.

#### HTTP Cookies


#### `fio_http_cookie_set` - `same_site`

```c
typedef enum fio_http_cookie_same_site_e {
  /** allow the browser to dictate this property */
  FIO_HTTP_COOKIE_SAME_SITE_BROWSER_DEFAULT = 0,
  /** The browser sends the cookie with cross-site and same-site requests. */
  FIO_HTTP_COOKIE_SAME_SITE_NONE,
  /**
   * The cookie is withheld on cross-site sub-requests.
   *
   * The cookie is sent when a user navigates to the URL from an external
   * site.
   */
  FIO_HTTP_COOKIE_SAME_SITE_LAX,
  /** The browser sends the cookie only for same-site requests. */
  FIO_HTTP_COOKIE_SAME_SITE_STRICT,
} fio_http_cookie_same_site_e;
```

Possible values for the `same_site` property in the cookie settings.

See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie


#### `fio_http_cookie_set`
```c
int fio_http_cookie_set(fio_http_s *h, fio_http_cookie_args_s);
/** Named arguments helper. See fio_http_cookie_args_s for details. */
#define fio_http_cookie_set(http___handle, ...)                                \
  fio_http_cookie_set((http___handle), (fio_http_cookie_args_s){__VA_ARGS__})

```

Sets a response cookie.

Returns -1 on error and 0 on success.

Note: Long cookie names and long cookie values will be considered a security violation and an error will be returned. Many browsers and proxies impose limits on headers and cookies, cookies often limited to 4Kb in total for both name and value.

```c
typedef struct fio_http_cookie_args_s {
  /** The cookie's name. */
  fio_str_info_s name;
  /** The cookie's value (leave blank to delete cookie). */
  fio_str_info_s value;
  /** The cookie's domain (optional). */
  fio_str_info_s domain;
  /** The cookie's path (optional). */
  fio_str_info_s path;
  /** Max Age (how long should the cookie persist), in seconds (0 == session).*/
  int max_age;
  /** SameSite value. */
  fio_http_cookie_same_site_e same_site;
  /** Limit cookie to secure connections.*/
  unsigned secure : 1;
  /** Limit cookie to HTTP (intended to prevent JavaScript access/hijacking).*/
  unsigned http_only : 1;
  /**
   * Set the Partitioned (third party) cookie flag:
   * https://developer.mozilla.org/en-US/docs/Web/Privacy/Partitioned_cookies
   */
  unsigned partitioned : 1;
} fio_http_cookie_args_s;
```

#### `fio_http_cookie`

```c
fio_str_info_s fio_http_cookie(fio_http_s *,
                               const char *name,
                               size_t name_len);
```

Returns a cookie value (either received of newly set), if any.

#### `fio_http_cookie_each`

```c
size_t fio_http_cookie_each(fio_http_s *,
                            int (*callback)(fio_http_s *,
                                            fio_str_info_s name,
                                            fio_str_info_s value,
                                            void *udata),
                            void *udata);
```

Iterates through all cookies. A non-zero return will stop iteration.

#### fio_http_set_cookie_each

```c
size_t fio_http_set_cookie_each(fio_http_s *h,
                         int (*callback)(fio_http_s *,
                                         fio_str_info_s set_cookie_header,
                                         fio_str_info_s value,
                                         void *udata),
                         void *udata);
```

Iterates through all response set cookies.

A non-zero return value from the callback will stop iteration.

### HTTP Response Data

#### `fio_http_response_header`

```c
fio_str_info_s fio_http_response_header(fio_http_s *,
                                        fio_str_info_s name,
                                        size_t index);
```

Gets the header information associated with the HTTP handle.

Since more than a single value may be associated with a header name, the index may be used to collect subsequent values.

An empty value is returned if no header value is available (or index is exceeded).

If the response headers were already sent, the returned value is always empty.


#### `fio_http_response_header_count`

```c
size_t fio_http_response_header_count(fio_http_s *, fio_str_info_s name);
```

Returns the number of headers named `name` in the response.

If `name` buffer is `NULL`, returns the number of unique headers (not the number of unique values).

#### `fio_http_response_header_set`

```c
fio_str_info_s fio_http_response_header_set(fio_http_s *,
                                            fio_str_info_s name,
                                            fio_str_info_s value);
```

Sets the header information associated with the HTTP handle.

If the response headers were already sent, the returned value is always empty.

#### `fio_http_response_header_set_if_missing`

```c
fio_str_info_s fio_http_response_header_set_if_missing(fio_http_s *,
                                        fio_str_info_s name,
                                        fio_str_info_s value);
```

Sets the header information associated with the HTTP handle.

If the response headers were already sent, the returned value is always empty.

#### `fio_http_response_header_add`

```c
fio_str_info_s fio_http_response_header_add(fio_http_s *,
                                                  fio_str_info_s name,
                                                  fio_str_info_s value);
```

Adds to the header information associated with the HTTP handle.

If the response headers were already sent, the returned value is always empty.

#### `fio_http_response_header_each`

```c
size_t fio_http_response_header_each(fio_http_s *,
                                     int (*callback)(fio_http_s *,
                                                     fio_str_info_s name,
                                                     fio_str_info_s value,
                                                     void *udata),
                                     void *udata);
```

Iterates through all response headers (except cookies!).

A non-zero return will stop iteration.

### HTTP Writing to the Connection

#### `fio_http_write`

```c
void fio_http_write(fio_http_s *, fio_http_write_args_s args);

/** Named arguments helper. See fio_http_write and fio_http_write_args_s. */
#define fio_http_write(http_handle, ...)                                       \
  fio_http_write(http_handle, (fio_http_write_args_s){__VA_ARGS__})
#define fio_http_finish(http_handle) fio_http_write(http_handle, .finish = 1)
```

Writes `data` to the response body associated with the HTTP handle after sending all headers (no further headers may be sent).

Accepts the following (possibly named) arguments:

```c
/** Arguments for the fio_http_write function. */
typedef struct fio_http_write_args_s {
  /** The data to be written. */
  const void *buf;
  /** The length of the data to be written. */
  size_t len;
  /** The offset at which writing should begin. */
  size_t offset;
  /** If streaming a file, set this value. The file is always closed. */
  int fd;
  /** If the data is a buffer, this callback may be set to free it once sent. */
  void (*dealloc)(void *);
  /** If the data is a buffer it will be copied. */
  int copy;
  /**
   * If `finish` is set, this data marks the end of the response.
   *
   * Otherwise the response will stream the data.
   */
  int finish;
} fio_http_write_args_s;
```

**Note**: this function will route to [`fio_http_websocket_write`](#fio_http_websocket_write) and [`fio_http_sse_write`](#fio_http_sse_write) if appropriate. However, for WebSocket connections it may be more prudent to decide if a binary or UTF-8 write operation should be performed by calling [`fio_http_websocket_write`](#fio_http_websocket_write) directly.
  
#### `fio_http_finish`

```c
#define fio_http_finish(http_handle) fio_http_write(http_handle, .finish = 1)
```

Calls [`fio_http_write`](#fio_http_write) without any data to be sent.


#### `fio_http_send_error_response`

```c
int fio_http_send_error_response(fio_http_s *h, size_t status);
```

Sends the requested error message and finishes the response.

**Returns:** 0 on success, -1 on error (e.g., if headers were already sent).

#### `fio_http_etag_is_match`

```c
int fio_http_etag_is_match(fio_http_s *h);
```

Returns true (1) if the ETag response matches an if-none-match request.

#### `fio_http_static_file_response`

```c
int fio_http_static_file_response(fio_http_s *h,
                                  fio_str_info_s root_folder,
                                  fio_str_info_s file_name,
                                  size_t max_age);
```

Attempts to send a static file from the `root` folder.

On success the response is complete and 0 is returned. Otherwise returns -1.

#### `fio_http_status2str`

```c
fio_str_info_s fio_http_status2str(size_t status);
```

Returns a human readable string related to the HTTP status number.

#### `fio_http_write_log`

```c
void fio_http_write_log(fio_http_s *h);
```

Logs an HTTP (response) to STDOUT using common log format:

```txt
[PID] ADDR - - [DATE/TIME] REQ RES_CODE BYTES_SENT TIME_SPENT_IN_APP <(wait PROXY_DELAY)>
```

See also the `FIO_HTTP_LOG_X_REQUEST_START` and `FIO_HTTP_EXACT_LOGGING` compilation flags.

#### `fio_http_date`

```c
fio_str_info_s fio_http_date(uint64_t now_in_seconds);
```

Returns a cached date/time string for HTTP date headers (RFC 7231 format).

The string is cached and updated when the timestamp changes.

#### `fio_http_log_time`

```c
fio_str_info_s fio_http_log_time(uint64_t now_in_seconds);
```

Returns a cached date/time string for HTTP logging.

The string is cached and updated when the timestamp changes.

#### `fio_http_clear_response`

```c
fio_http_s *fio_http_clear_response(fio_http_s *h, bool clear_body);
```

Clears any response data from the HTTP handle.

If `clear_body` is true, also clears the body data.

Returns the HTTP handle.

### HTTP WebSocket / SSE Helpers

#### `fio_http_websocket_requested`

```c
int fio_http_websocket_requested(fio_http_s *);
```

Returns non-zero if request headers ask for a WebSockets Upgrade.

#### `fio_http_websocket_accepted`

```c
int fio_http_websocket_accepted(fio_http_s *h);
```

Returns non-zero if the response accepts a WebSocket upgrade request.

This is useful for client-side code to check if the server accepted the WebSocket upgrade.

#### `fio_http_upgrade_websocket`

```c
void fio_http_upgrade_websocket(fio_http_s *);
```

Sets response data to agree to a WebSockets Upgrade.

#### `fio_http_websocket_set_request`

```c
void fio_http_websocket_set_request(fio_http_s *);
```

Sets request data to request a WebSockets Upgrade.

#### `fio_http_sse_requested`

```c
int fio_http_sse_requested(fio_http_s *);
```

Returns non-zero if request headers ask for an EventSource (SSE) Upgrade.

#### `fio_http_sse_accepted`

```c
int fio_http_sse_accepted(fio_http_s *h);
```

Returns non-zero if the response accepts an SSE request.

This is useful for client-side code to check if the server accepted the SSE upgrade.

#### `fio_http_upgrade_sse`

```c
void fio_http_upgrade_sse(fio_http_s *);
```

Sets response data to agree to an EventSource (SSE) Upgrade.

#### `fio_http_sse_set_request`

```c
void fio_http_sse_set_request(fio_http_s *);
```

Sets request data to request an EventSource (SSE) Upgrade.

#### `fio_http_websocket_write`

```c
int fio_http_websocket_write(fio_http_s *h, const void *buf, size_t len, uint8_t is_text);
```

Writes a WebSocket message. Fails if connection wasn't upgraded yet.

**Note**: calls to the HTTP handle function `fio_http_write` may route to this function after the library performs a best guess attempt at the correct `is_text`.

#### `fio_http_on_message_set`

```c
int fio_http_on_message_set(fio_http_s *h,
                            void (*on_message)(fio_http_s *,
                                               fio_buf_info_s,
                                               uint8_t));
```

Sets a specific `on_message` callback for the WebSocket connection.

Returns `-1` on error (i.e., upgrade still being negotiated).

### EventSource (SSE) Helpers - HTTP Upgraded Connections

#### `fio_http_sse_write`

```c
int fio_http_sse_write(fio_http_s *h, fio_http_sse_write_args_s args);
#define fio_http_sse_write(h, ...)                                             \
  fio_http_sse_write((h), ((fio_http_sse_write_args_s){__VA_ARGS__}))
```

Writes an SSE message (UTF-8). Fails if connection wasn't upgraded yet.

The MACRO shadowing the function enables the used of the named arguments listed in `fio_http_sse_write_args_s`:

```c
/** Named arguments for fio_http_sse_write. */
typedef struct {
  /** The message's `id` data (if any). */
  fio_buf_info_s id;
  /** The message's `event` data (if any). */
  fio_buf_info_s event;
  /** The message's `data` data (if any). */
  fio_buf_info_s data;
} fio_http_sse_write_args_s;
```

**Note**: calls to the HTTP handle function `fio_http_write` may route to this function, in which case both `event` and `id` are omitted.

#### `fio_http_close`

```c
void fio_http_close(fio_http_s *h);
```

Closes a persistent HTTP connection (i.e., if upgraded). 



### HTTP Pub/Sub

#### `fio_http_subscribe`

```c
#define fio_http_subscribe(h, ...)                                             \
  fio_pubsub_subscribe(.io = fio_http_io(h), __VA_ARGS__)
```

Macro helper for HTTP handle pub/sub subscriptions.

This macro wraps `fio_pubsub_subscribe`, automatically setting the `io` argument to the IO object associated with the HTTP handle.

Example:

```c
fio_http_subscribe(h, .channel = FIO_STR_INFO1("chat"),
                      .on_message = my_on_message_callback);
```

#### `FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT`

```c
void FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT(fio_pubsub_msg_s *msg);
```

Optional WebSocket subscription callback that directly writes the content of the published message to the WebSocket connection.

#### `FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_TEXT`

```c
void FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_TEXT(fio_pubsub_msg_s *msg);
```

Optional WebSocket subscription callback that directly writes the content of the published message to the WebSocket connection - this callback assumes that all messages are UTF-8 valid.

#### `FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_BINARY`

```c
void FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_BINARY(fio_pubsub_msg_s *msg);
```

Optional WebSocket subscription callback that directly writes the content of the published message to the WebSocket connection - this callback assumes that all messages are binary (non-UTF-8).

#### `FIO_HTTP_SSE_SUBSCRIBE_DIRECT`

```c
void FIO_HTTP_SSE_SUBSCRIBE_DIRECT(fio_pubsub_msg_s *msg);
```

An optional EventSource subscription callback - messages MUST be UTF-8.

This callback directly calls `fio_http_sse_write`, placing the channel name in the `.event` argument and the published message in the `.data` argument.

### HTTP Header Parsing Helpers

#### `fio_http_response_header_parse`

```c
int fio_http_response_header_parse(fio_http_s *h,
                                   fio_str_info_s *buf_parsed,
                                   fio_str_info_s header_name);
```

Copies all header data, from possibly an array of identical response headers, resulting in a parsed format outputted to `buf_parsed`.

Returns 0 on success or -1 on error (i.e., `buf_parsed.capa` wasn't enough for the parsed output).

Note that the parsed output isn't readable as a string, but is designed to work with the `FIO_HTTP_PARSED_HEADER_EACH` and `FIO_HTTP_HEADER_VALUE_EACH_PROPERTY` property.

See also `fio_http_response_header_parse`.

#### `fio_http_request_header_parse`

```c
int fio_http_request_header_parse(fio_http_s *h,
                                  fio_str_info_s *buf_parsed,
                                  fio_str_info_s header_name);
```
Copies all header data, from possibly an array of identical response headers,
resulting in a parsed format outputted to `buf_parsed`.

Returns 0 on success or -1 on error (i.e., `buf_parsed.capa` wasn't enough
for the parsed output).

Note that the parsed output isn't readable as a string, but is designed to
work with the `FIO_HTTP_PARSED_HEADER_EACH` and
`FIO_HTTP_HEADER_VALUE_EACH_PROPERTY` property.

i.e.:

```c
 FIO_STR_INFO_TMP_VAR(buf, 1023); // tmp buffer for the parsed output
 fio_http_s *h = fio_http_new();  // using a mock HTTP handle
 fio_http_request_header_add(
     h,
     FIO_STR_INFO2("accept", 6),
     FIO_STR_INFO1("text/html, application/json;q=0.9; d=500, image/png"));
 fio_http_request_header_add(h,
                             FIO_STR_INFO2("accept", 6),
                             FIO_STR_INFO1("text/yaml"));
 FIO_ASSERT(  // in production do NOT assert, but route to error instead!
     !fio_http_request_header_parse(h, &buf, FIO_STR_INFO2("accept", 6)),
     "parse returned error!");
 FIO_HTTP_PARSED_HEADER_EACH(buf, value) {
   printf("* processing value (%zu bytes): %s\n", value.len, value.buf);
   FIO_HTTP_HEADER_VALUE_EACH_PROPERTY(value, prop) {
     printf("* for value %s: (%zu,%zu bytes) %s = %s\n",
            value.buf,
            prop.name.len,
            prop.value.len,
            prop.name.buf,
            prop.value.buf);
   }
 }
```

#### `FIO_HTTP_HEADER_EACH_VALUE`
```c
#define FIO_HTTP_HEADER_EACH_VALUE(/* fio_http_s */ http_handle,               \
                                   /* int / bool */ is_request,                \
                                   /* fio_str_info_s */ header_name,           \
                                   /* chosen var named */ value)               \
  for (char fio___buf__##value##__[2048], /* allocate buffer on stack */       \
           *fio___buf__##value##_ptr = NULL;                                   \
       !fio___buf__##value##_ptr;                                              \
       fio___buf__##value##_ptr = fio___buf__##value##__)                      \
    for (fio_str_info_s fio___buf__##value##__str = /* declare buffer var */   \
         FIO_STR_INFO3(fio___buf__##value##__, 0, 2048);                       \
         fio___buf__##value##__str.buf == fio___buf__##value##__;              \
         fio___buf__##value##__str.buf = fio___buf__##value##__ + 1)           \
      if (!((is_request ? fio_http_request_header_parse                        \
                        : fio_http_response_header_parse)(                     \
              http_handle, /* parse headers */                                 \
              &fio___buf__##value##__str,                                      \
              header_name)))                                                   \
  FIO_HTTP_PARSED_HEADER_EACH(fio___buf__##value##__str, value) /* loop */

/** Iterates through the properties associated with a parsed header value. */
#define FIO_HTTP_HEADER_VALUE_EACH_PROPERTY(/* fio_str_info_s   */ value,      \
                                            /* chosen var named */ property)

/** Used internally to iterate over a parsed header buffer. */
#define FIO_HTTP_PARSED_HEADER_EACH(/* fio_str_info_s   */ buf_parsed,         \
                                    /* chosen var named */ value)
```

Parses header for multiple values and properties and iterates over all values.

This MACRO will allocate 2048 bytes on the stack for parsing the header values and properties, if more space is necessary dig deeper.

Use `FIO_HTTP_HEADER_VALUE_EACH_PROPERTY` to iterate over a value's properties.

### HTTP Mime-Type Registry

MIME File Type Helpers - NOT thread safe!

#### `fio_http_mimetype_register`

```c
int fio_http_mimetype_register(char *file_ext,
                               size_t file_ext_len,
                               fio_str_info_s mime_type);
```

Registers a Mime-Type to be associated with the file extension.

#### `fio_http_mimetype`

```c
fio_str_info_s fio_http_mimetype(char *file_ext, size_t file_ext_len);
```

Finds the Mime-Type associated with the file extension (if registered).

### HTTP Controller

The HTTP Controller manages all the callbacks required by the HTTP Handler in order for HTTP responses and requests to be sent.

This allows the HTTP Handler to be somewhat protocol agnostic.

#### `fio_http_controller_s`

```c
struct fio_http_controller_s {
  /* MUST be initialized to zero, used internally by the HTTP Handle. */
  uintptr_t private_flags;
  /** Called when an HTTP handle is freed. */
  void (*on_destroyed)(fio_http_s *h);
  /** Informs the controller that request / response headers must be sent. */
  void (*send_headers)(fio_http_s *h);
  /** called by the HTTP handle for each body chunk, or to finish a response. */
  void (*write_body)(fio_http_s *h, fio_http_write_args_s args);
  /** called once a request / response had finished */
  void (*on_finish)(fio_http_s *h);
  /** called to close an HTTP connection */
  void (*close_io)(fio_http_s *h);
  /** called when the file descriptor is directly required */
  int (*get_fd)(fio_http_s *h);
};
```

**Members:**

- `private_flags` - Internal use only; must be initialized to zero.
- `on_destroyed` - Called when an HTTP handle is freed.
- `send_headers` - Informs the controller that request/response headers must be sent.
- `write_body` - Called by the HTTP handle for each body chunk, or to finish a response.
- `on_finish` - Called once a request/response had finished.
- `close_io` - Called to close an HTTP connection.
- `get_fd` - Called when the file descriptor is directly required.

**Note**: if the controller callbacks aren't thread-safe, then the `fio_http_write` function MUST NOT be called from any thread except the thread that the controller is expecting.

### Compilation Flags and Default HTTP Handle Behavior

#### `FIO_HTTP_EXACT_LOGGING`

```c
#ifndef FIO_HTTP_EXACT_LOGGING
#define FIO_HTTP_EXACT_LOGGING 0
#endif
```

By default, facil.io logs the HTTP request cycle using a fuzzy starting and ending point for the time stamp.

The fuzzy timestamp includes delays that aren't related to the HTTP request and may ignore time passed due to timestamp caching.

On the other hand, `FIO_HTTP_EXACT_LOGGING` collects exact time stamps to measure the time it took to process the HTTP request (excluding time spent reading / writing the data from the network).

Due to the preference to err on the side of higher performance, fuzzy time-stamping is the default.


#### `FIO_HTTP_LOG_X_REQUEST_START`

```c
#ifndef FIO_HTTP_LOG_X_REQUEST_START
#define FIO_HTTP_LOG_X_REQUEST_START 1
#endif
```

If set, logs will react to an `X-Request-Start` header that provides time in milliseconds.

An additional `(wait XXms)` data point will be provided in the logs to inform of the delay between the proxy server's `X-Request-Start` start time and the application's start time.

#### `FIO_HTTP_BODY_RAM_LIMIT`

```c
#ifndef FIO_HTTP_BODY_RAM_LIMIT
#define FIO_HTTP_BODY_RAM_LIMIT (1 << 17)
#endif
```

The HTTP handle automatically switches between RAM storage and file storage once the HTTP body (payload) reaches a certain size. This control this point of transition

#### `FIO_HTTP_CACHE_LIMIT`

```c
#ifndef FIO_HTTP_CACHE_LIMIT
#define FIO_HTTP_CACHE_LIMIT 0 /* ((1UL << 6) + (1UL << 5)) */
#endif
```

Each of the HTTP String Caches will be limited to this String count.

#### `FIO_HTTP_CACHE_STR_MAX_LEN`

```c
#ifndef FIO_HTTP_CACHE_STR_MAX_LEN
#define FIO_HTTP_CACHE_STR_MAX_LEN (1 << 12)
#endif
```

The HTTP handle will avoid caching strings longer than this value.

#### `FIO_HTTP_CACHE_USES_MUTEX`

```c
#ifndef FIO_HTTP_CACHE_USES_MUTEX
#define FIO_HTTP_CACHE_USES_MUTEX 1
#endif
```

The HTTP cache will use a mutex to allow headers to be set concurrently.

#### `FIO_HTTP_PRE_CACHE_KNOWN_HEADERS`

```c
#ifndef FIO_HTTP_PRE_CACHE_KNOWN_HEADERS
#define FIO_HTTP_PRE_CACHE_KNOWN_HEADERS 1
#endif
```

Adds a static cache for common HTTP header names.

#### `FIO_HTTP_DEFAULT_INDEX_FILENAME`

```c
#ifndef FIO_HTTP_DEFAULT_INDEX_FILENAME
#define FIO_HTTP_DEFAULT_INDEX_FILENAME "index"
#endif
```

The default file name when a static file response points to a folder.

#### `FIO_HTTP_STATIC_FILE_COMPLETION`

```c
#ifndef FIO_HTTP_STATIC_FILE_COMPLETION
#define FIO_HTTP_STATIC_FILE_COMPLETION 1
#endif
```

Attempts to auto-complete static file paths with missing extensions.

#### `FIO_HTTP_ENFORCE_LOWERCASE_HEADERS`

```c
#ifndef FIO_HTTP_ENFORCE_LOWERCASE_HEADERS
#define FIO_HTTP_ENFORCE_LOWERCASE_HEADERS 0
#endif
```

If true, the HTTP handle will copy input header names to lower case.

### Compilation Flags and Default HTTP Connection Settings

#### `FIO_HTTP_DEFAULT_MAX_HEADER_SIZE`

```c
#ifndef FIO_HTTP_DEFAULT_MAX_HEADER_SIZE
#define FIO_HTTP_DEFAULT_MAX_HEADER_SIZE 32768 /* (1UL << 15) */
#endif
```
#### `FIO_HTTP_DEFAULT_MAX_LINE_LEN`

```c
#ifndef FIO_HTTP_DEFAULT_MAX_LINE_LEN
#define FIO_HTTP_DEFAULT_MAX_LINE_LEN 8192 /* (1UL << 13) */
#endif
```
#### `FIO_HTTP_DEFAULT_MAX_BODY_SIZE`

```c
#ifndef FIO_HTTP_DEFAULT_MAX_BODY_SIZE
#define FIO_HTTP_DEFAULT_MAX_BODY_SIZE 33554432 /* (1UL << 25) */
#endif
```
#### `FIO_HTTP_DEFAULT_WS_MAX_MSG_SIZE`

```c
#ifndef FIO_HTTP_DEFAULT_WS_MAX_MSG_SIZE
#define FIO_HTTP_DEFAULT_WS_MAX_MSG_SIZE 262144 /* (1UL << 18) */
#endif
```
#### `FIO_HTTP_DEFAULT_TIMEOUT`

```c
#ifndef FIO_HTTP_DEFAULT_TIMEOUT
#define FIO_HTTP_DEFAULT_TIMEOUT 50
#endif
```
#### `FIO_HTTP_DEFAULT_TIMEOUT_LONG`

```c
#ifndef FIO_HTTP_DEFAULT_TIMEOUT_LONG
#define FIO_HTTP_DEFAULT_TIMEOUT_LONG 50
#endif
```

#### `FIO_HTTP_SHOW_CONTENT_LENGTH_HEADER`

```c
#ifndef FIO_HTTP_SHOW_CONTENT_LENGTH_HEADER
#define FIO_HTTP_SHOW_CONTENT_LENGTH_HEADER 0
#endif
```

Adds a "content-length" header to the HTTP handle (usually redundant).

#### `FIO_HTTP_WEBSOCKET_WRITE_VALIDITY_TEST_LIMIT`

```c
#ifndef FIO_HTTP_WEBSOCKET_WRITE_VALIDITY_TEST_LIMIT
#define FIO_HTTP_WEBSOCKET_WRITE_VALIDITY_TEST_LIMIT ((1UL << 16) - 10UL)
#endif
```

UTF-8 validity tests will be performed only for data shorter than this.

#### `FIO_WEBSOCKET_STATS`

```c
#ifndef FIO_WEBSOCKET_STATS
#define FIO_WEBSOCKET_STATS 0
#endif
```

If true, logs longest WebSocket round-trips (using `FIO_LOG_INFO`).

------------------------------------------------------------
## Hash Function Testing

During development I tested the Hash functions using [the SMHasher testing suite (@rurban's fork)](https://github.com/rurban/smhasher). The testing suite is often growing with more tests, so I do not know what the future may bring... but attached are the test results for Risky Hash, Stable Hash (64 and 128 bit variation) as they were at the time of (re)development (March, 2023).
### Risky Hash SMHasher Results

The following results were achieved on my personal computer when testing the facil.io Risky Hash (`fio_risky_hash`).

```txt
------------------------------------------------------------
--- Testing Risky "facil.io Risky Hash" GOOD

[[[ Sanity Tests ]]]

Verification value 0x407D2C05 ....... PASS
Running sanity check 1     .......... PASS
Running AppendedZeroesTest .......... PASS

[[[ Speed Tests ]]]

Bulk speed test - 262144-byte keys
Alignment  7 - 17.861 bytes/cycle - 51100.77 MiB/sec @ 3 ghz
Alignment  6 - 17.833 bytes/cycle - 51019.28 MiB/sec @ 3 ghz
Alignment  5 - 17.832 bytes/cycle - 51018.87 MiB/sec @ 3 ghz
Alignment  4 - 17.853 bytes/cycle - 51077.60 MiB/sec @ 3 ghz
Alignment  3 - 17.844 bytes/cycle - 51051.63 MiB/sec @ 3 ghz
Alignment  2 - 17.854 bytes/cycle - 51080.37 MiB/sec @ 3 ghz
Alignment  1 - 17.912 bytes/cycle - 51245.99 MiB/sec @ 3 ghz
Alignment  0 - 19.064 bytes/cycle - 54541.55 MiB/sec @ 3 ghz
Average      - 18.006 bytes/cycle - 51517.01 MiB/sec @ 3 ghz

Small key speed test -    1-byte keys -    13.90 cycles/hash
Small key speed test -    2-byte keys -    14.59 cycles/hash
Small key speed test -    3-byte keys -    14.27 cycles/hash
Small key speed test -    4-byte keys -    14.32 cycles/hash
Small key speed test -    5-byte keys -    14.81 cycles/hash
Small key speed test -    6-byte keys -    14.99 cycles/hash
Small key speed test -    7-byte keys -    15.00 cycles/hash
Small key speed test -    8-byte keys -    14.00 cycles/hash
Small key speed test -    9-byte keys -    14.15 cycles/hash
Small key speed test -   10-byte keys -    14.00 cycles/hash
Small key speed test -   11-byte keys -    14.00 cycles/hash
Small key speed test -   12-byte keys -    14.00 cycles/hash
Small key speed test -   13-byte keys -    14.00 cycles/hash
Small key speed test -   14-byte keys -    14.11 cycles/hash
Small key speed test -   15-byte keys -    14.00 cycles/hash
Small key speed test -   16-byte keys -    14.72 cycles/hash
Small key speed test -   17-byte keys -    15.74 cycles/hash
Small key speed test -   18-byte keys -    15.62 cycles/hash
Small key speed test -   19-byte keys -    15.60 cycles/hash
Small key speed test -   20-byte keys -    15.66 cycles/hash
Small key speed test -   21-byte keys -    15.83 cycles/hash
Small key speed test -   22-byte keys -    15.69 cycles/hash
Small key speed test -   23-byte keys -    15.73 cycles/hash
Small key speed test -   24-byte keys -    15.63 cycles/hash
Small key speed test -   25-byte keys -    15.67 cycles/hash
Small key speed test -   26-byte keys -    15.66 cycles/hash
Small key speed test -   27-byte keys -    15.76 cycles/hash
Small key speed test -   28-byte keys -    15.67 cycles/hash
Small key speed test -   29-byte keys -    15.68 cycles/hash
Small key speed test -   30-byte keys -    15.65 cycles/hash
Small key speed test -   31-byte keys -    15.64 cycles/hash
Average                                    14.971 cycles/hash

[[[ 'Hashmap' Speed Tests ]]]

std::unordered_map
Init std HashMapTest:     148.866 cycles/op (466569 inserts, 1% deletions)
Running std HashMapTest:  85.492 cycles/op (1.0 stdv, found 461903)

greg7mdp/parallel-hashmap
Init fast HashMapTest:    158.746 cycles/op (466569 inserts, 1% deletions)
Running fast HashMapTest: 74.728 cycles/op (2.5 stdv, found 461903)

facil.io HashMap
Init fast fio_map_s Test:    62.909 cycles/op (466569 inserts, 1% deletions)
Running fast fio_map_s Test: 32.332 cycles/op (0.2 stdv, found 461903)
 ....... PASS

[[[ Avalanche Tests ]]]

Testing   24-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.585333%
Testing   32-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.695333%
Testing   40-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.619333%
Testing   48-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.662667%
Testing   56-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.706000%
Testing   64-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.693333%
Testing   72-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.730667%
Testing   80-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.706667%
Testing   96-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.672000%
Testing  112-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.786667%
Testing  128-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.621333%
Testing  160-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.710000%
Testing  512-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.835333%
Testing 1024-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.800000%

[[[ Keyset 'Sparse' Tests ]]]

Keyset 'Sparse' - 16-bit keys with up to 9 bits set - 50643 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          0.3, actual      0 (0.00x)
Testing collisions (high 19-25 bits) - Worst is 19 bits: 2358/2368 (1.00x)
Testing collisions (low  32-bit) - Expected          0.3, actual      0 (0.00x)
Testing collisions (low  19-25 bits) - Worst is 24 bits: 90/76 (1.18x)
Testing distribution - Worst bias is the 13-bit window at bit 41 - 0.600%

Keyset 'Sparse' - 24-bit keys with up to 8 bits set - 1271626 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        188.2, actual    179 (0.95x)
Testing collisions (high 24-35 bits) - Worst is 25 bits: 23889/23794 (1.00x)
Testing collisions (low  32-bit) - Expected        188.2, actual    215 (1.14x) (27)
Testing collisions (low  24-35 bits) - Worst is 33 bits: 108/94 (1.15x)
Testing distribution - Worst bias is the 17-bit window at bit 16 - 0.075%

Keyset 'Sparse' - 32-bit keys with up to 7 bits set - 4514873 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2372.2, actual   2390 (1.01x) (18)
Testing collisions (high 25-38 bits) - Worst is 34 bits: 602/593 (1.01x)
Testing collisions (low  32-bit) - Expected       2372.2, actual   2313 (0.98x)
Testing collisions (low  25-38 bits) - Worst is 35 bits: 301/296 (1.01x)
Testing distribution - Worst bias is the 19-bit window at bit 15 - 0.051%

Keyset 'Sparse' - 40-bit keys with up to 6 bits set - 4598479 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2460.8, actual   2509 (1.02x) (49)
Testing collisions (high 25-38 bits) - Worst is 38 bits: 42/38 (1.09x)
Testing collisions (low  32-bit) - Expected       2460.8, actual   2449 (1.00x) (-11)
Testing collisions (low  25-38 bits) - Worst is 35 bits: 316/307 (1.03x)
Testing distribution - Worst bias is the 19-bit window at bit 12 - 0.058%

Keyset 'Sparse' - 48-bit keys with up to 6 bits set - 14196869 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      23437.8, actual  23532 (1.00x) (95)
Testing collisions (high 27-42 bits) - Worst is 42 bits: 28/22 (1.22x)
Testing collisions (low  32-bit) - Expected      23437.8, actual  23333 (1.00x) (-104)
Testing collisions (low  27-42 bits) - Worst is 40 bits: 96/91 (1.05x)
Testing distribution - Worst bias is the 20-bit window at bit 16 - 0.020%

Keyset 'Sparse' - 56-bit keys with up to 5 bits set - 4216423 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2069.0, actual   2026 (0.98x)
Testing collisions (high 25-38 bits) - Worst is 34 bits: 518/517 (1.00x)
Testing collisions (low  32-bit) - Expected       2069.0, actual   2139 (1.03x) (71)
Testing collisions (low  25-38 bits) - Worst is 36 bits: 142/129 (1.10x)
Testing distribution - Worst bias is the 19-bit window at bit  8 - 0.043%

Keyset 'Sparse' - 64-bit keys with up to 5 bits set - 8303633 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8021.7, actual   8072 (1.01x) (51)
Testing collisions (high 26-40 bits) - Worst is 40 bits: 37/31 (1.18x)
Testing collisions (low  32-bit) - Expected       8021.7, actual   8035 (1.00x) (14)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 32/31 (1.02x)
Testing distribution - Worst bias is the 20-bit window at bit 37 - 0.039%

Keyset 'Sparse' - 72-bit keys with up to 5 bits set - 15082603 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      26451.8, actual  26268 (0.99x) (-183)
Testing collisions (high 27-42 bits) - Worst is 39 bits: 225/206 (1.09x)
Testing collisions (low  32-bit) - Expected      26451.8, actual  26552 (1.00x) (101)
Testing collisions (low  27-42 bits) - Worst is 35 bits: 3381/3309 (1.02x)
Testing distribution - Worst bias is the 20-bit window at bit 36 - 0.027%

Keyset 'Sparse' - 96-bit keys with up to 4 bits set - 3469497 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1401.0, actual   1392 (0.99x) (-8)
Testing collisions (high 25-38 bits) - Worst is 36 bits: 93/87 (1.06x)
Testing collisions (low  32-bit) - Expected       1401.0, actual   1402 (1.00x) (2)
Testing collisions (low  25-38 bits) - Worst is 37 bits: 48/43 (1.10x)
Testing distribution - Worst bias is the 19-bit window at bit 11 - 0.051%

Keyset 'Sparse' - 160-bit keys with up to 4 bits set - 26977161 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      84546.1, actual  84403 (1.00x) (-143)
Testing collisions (high 28-44 bits) - Worst is 34 bits: 21303/21169 (1.01x)
Testing collisions (low  32-bit) - Expected      84546.1, actual  84679 (1.00x) (133)
Testing collisions (low  28-44 bits) - Worst is 43 bits: 45/41 (1.09x)
Testing distribution - Worst bias is the 20-bit window at bit 49 - 0.014%

Keyset 'Sparse' - 256-bit keys with up to 3 bits set - 2796417 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        910.2, actual    930 (1.02x) (20)
Testing collisions (high 25-37 bits) - Worst is 36 bits: 71/56 (1.25x)
Testing collisions (low  32-bit) - Expected        910.2, actual    922 (1.01x) (12)
Testing collisions (low  25-37 bits) - Worst is 35 bits: 121/113 (1.06x)
Testing distribution - Worst bias is the 19-bit window at bit 52 - 0.094%

Keyset 'Sparse' - 512-bit keys with up to 3 bits set - 22370049 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      58155.4, actual  58001 (1.00x) (-154)
Testing collisions (high 28-43 bits) - Worst is 42 bits: 69/56 (1.21x)
Testing collisions (low  32-bit) - Expected      58155.4, actual  58151 (1.00x) (-4)
Testing collisions (low  28-43 bits) - Worst is 41 bits: 121/113 (1.06x)
Testing distribution - Worst bias is the 20-bit window at bit  3 - 0.015%

Keyset 'Sparse' - 1024-bit keys with up to 2 bits set - 524801 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected         32.1, actual     37 (1.15x) (5)
Testing collisions (high 22-32 bits) - Worst is 31 bits: 75/64 (1.17x)
Testing collisions (low  32-bit) - Expected         32.1, actual     40 (1.25x) (8)
Testing collisions (low  22-32 bits) - Worst is 32 bits: 40/32 (1.25x)
Testing distribution - Worst bias is the 16-bit window at bit 17 - 0.136%

Keyset 'Sparse' - 2048-bit keys with up to 2 bits set - 2098177 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        512.4, actual    551 (1.08x) (39)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1105/1024 (1.08x)
Testing collisions (low  32-bit) - Expected        512.4, actual    526 (1.03x) (14)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 76/64 (1.19x)
Testing distribution - Worst bias is the 18-bit window at bit 52 - 0.103%


[[[ Keyset 'Permutation' Tests ]]]

Combination Lowbits Tests:
Keyset 'Combination' - up to 7 blocks from a set of 8 - 2396744 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        668.6, actual    670 (1.00x) (2)
Testing collisions (high 24-37 bits) - Worst is 37 bits: 28/20 (1.34x)
Testing collisions (low  32-bit) - Expected        668.6, actual    675 (1.01x) (7)
Testing collisions (low  24-37 bits) - Worst is 33 bits: 350/334 (1.05x)
Testing distribution - Worst bias is the 18-bit window at bit  1 - 0.086%


Combination Highbits Tests
Keyset 'Combination' - up to 7 blocks from a set of 8 - 2396744 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        668.6, actual    620 (0.93x)
Testing collisions (high 24-37 bits) - Worst is 36 bits: 45/41 (1.08x)
Testing collisions (low  32-bit) - Expected        668.6, actual    634 (0.95x)
Testing collisions (low  24-37 bits) - Worst is 28 bits: 10778/10667 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 35 - 0.053%


Combination Hi-Lo Tests:
Keyset 'Combination' - up to 6 blocks from a set of 15 - 12204240 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      17322.9, actual  17547 (1.01x) (225)
Testing collisions (high 27-41 bits) - Worst is 38 bits: 283/270 (1.04x)
Testing collisions (low  32-bit) - Expected      17322.9, actual  17096 (0.99x) (-226)
Testing collisions (low  27-41 bits) - Worst is 41 bits: 37/33 (1.09x)
Testing distribution - Worst bias is the 20-bit window at bit 46 - 0.035%


Combination 0x8000000 Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8170 (1.00x) (-16)
Testing collisions (high 26-40 bits) - Worst is 33 bits: 4129/4094 (1.01x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8208 (1.00x) (22)
Testing collisions (low  26-40 bits) - Worst is 33 bits: 4128/4094 (1.01x)
Testing distribution - Worst bias is the 20-bit window at bit 21 - 0.041%


Combination 0x0000001 Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8179 (1.00x) (-7)
Testing collisions (high 26-40 bits) - Worst is 31 bits: 16584/16362 (1.01x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8243 (1.01x) (57)
Testing collisions (low  26-40 bits) - Worst is 37 bits: 270/255 (1.05x)
Testing distribution - Worst bias is the 20-bit window at bit  5 - 0.042%


Combination 0x800000000000000 Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8296 (1.01x) (110)
Testing collisions (high 26-40 bits) - Worst is 39 bits: 74/63 (1.16x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8168 (1.00x) (-18)
Testing collisions (low  26-40 bits) - Worst is 38 bits: 144/127 (1.13x)
Testing distribution - Worst bias is the 20-bit window at bit 55 - 0.035%


Combination 0x000000000000001 Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8186 (1.00x)
Testing collisions (high 26-40 bits) - Worst is 39 bits: 72/63 (1.13x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8238 (1.01x) (52)
Testing collisions (low  26-40 bits) - Worst is 35 bits: 1063/1023 (1.04x)
Testing distribution - Worst bias is the 20-bit window at bit 63 - 0.031%


Combination 16-bytes [0-1] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8212 (1.00x) (26)
Testing collisions (high 26-40 bits) - Worst is 34 bits: 2056/2047 (1.00x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8083 (0.99x) (-103)
Testing collisions (low  26-40 bits) - Worst is 37 bits: 259/255 (1.01x)
Testing distribution - Worst bias is the 20-bit window at bit 46 - 0.037%


Combination 16-bytes [0-last] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8052 (0.98x) (-134)
Testing collisions (high 26-40 bits) - Worst is 39 bits: 66/63 (1.03x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8267 (1.01x) (81)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 39/31 (1.22x)
Testing distribution - Worst bias is the 20-bit window at bit  2 - 0.045%


Combination 32-bytes [0-1] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8136 (0.99x) (-50)
Testing collisions (high 26-40 bits) - Worst is 38 bits: 130/127 (1.02x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8138 (0.99x) (-48)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 20-bit window at bit 58 - 0.044%


Combination 32-bytes [0-last] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   7961 (0.97x)
Testing collisions (high 26-40 bits) - Worst is 40 bits: 40/31 (1.25x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8088 (0.99x) (-98)
Testing collisions (low  26-40 bits) - Worst is 35 bits: 1038/1023 (1.01x)
Testing distribution - Worst bias is the 20-bit window at bit 24 - 0.047%


Combination 64-bytes [0-1] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8054 (0.98x) (-132)
Testing collisions (high 26-40 bits) - Worst is 26 bits: 502359/503108 (1.00x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8309 (1.01x) (123)
Testing collisions (low  26-40 bits) - Worst is 34 bits: 2101/2047 (1.03x)
Testing distribution - Worst bias is the 20-bit window at bit 14 - 0.052%


Combination 64-bytes [0-last] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8247 (1.01x) (61)
Testing collisions (high 26-40 bits) - Worst is 33 bits: 4159/4094 (1.02x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8217 (1.00x) (31)
Testing collisions (low  26-40 bits) - Worst is 39 bits: 71/63 (1.11x)
Testing distribution - Worst bias is the 20-bit window at bit 31 - 0.052%


Combination 128-bytes [0-1] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8076 (0.99x) (-110)
Testing collisions (high 26-40 bits) - Worst is 38 bits: 150/127 (1.17x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8278 (1.01x) (92)
Testing collisions (low  26-40 bits) - Worst is 35 bits: 1069/1023 (1.04x)
Testing distribution - Worst bias is the 20-bit window at bit 36 - 0.041%


Combination 128-bytes [0-last] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8108 (0.99x) (-78)
Testing collisions (high 26-40 bits) - Worst is 40 bits: 39/31 (1.22x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8100 (0.99x) (-86)
Testing collisions (low  26-40 bits) - Worst is 37 bits: 295/255 (1.15x)
Testing distribution - Worst bias is the 20-bit window at bit 55 - 0.049%


[[[ Keyset 'Window' Tests ]]]

Keyset 'Window' -  32-bit key,  25-bit window - 32 tests, 33554432 keys per test
Window at   0 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   1 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   2 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   3 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   4 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   5 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   6 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   7 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   8 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   9 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  10 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  11 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  12 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  13 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  14 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  15 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  16 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  17 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  18 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  19 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  20 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  21 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  22 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  23 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  24 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  25 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  26 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  27 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  28 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  29 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  30 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  31 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  32 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)

[[[ Keyset 'Cyclic' Tests ]]]

Keyset 'Cyclic' - 8 cycles of 8 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    116 (1.00x)
Testing collisions (high 23-34 bits) - Worst is 30 bits: 499/465 (1.07x)
Testing collisions (low  32-bit) - Expected        116.4, actual    102 (0.88x)
Testing collisions (low  23-34 bits) - Worst is 25 bits: 14836/14754 (1.01x)
Testing distribution - Worst bias is the 17-bit window at bit 24 - 0.118%

Keyset 'Cyclic' - 8 cycles of 9 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual     96 (0.82x)
Testing collisions (high 23-34 bits) - Worst is 26 bits: 7398/7413 (1.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    116 (1.00x)
Testing collisions (low  23-34 bits) - Worst is 25 bits: 14917/14754 (1.01x)
Testing distribution - Worst bias is the 17-bit window at bit 46 - 0.104%

Keyset 'Cyclic' - 8 cycles of 10 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    102 (0.88x)
Testing collisions (high 23-34 bits) - Worst is 29 bits: 934/930 (1.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    115 (0.99x) (-1)
Testing collisions (low  23-34 bits) - Worst is 34 bits: 35/29 (1.20x)
Testing distribution - Worst bias is the 17-bit window at bit 39 - 0.070%

Keyset 'Cyclic' - 8 cycles of 11 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    112 (0.96x)
Testing collisions (high 23-34 bits) - Worst is 27 bits: 3790/3716 (1.02x)
Testing collisions (low  32-bit) - Expected        116.4, actual    140 (1.20x) (24)
Testing collisions (low  23-34 bits) - Worst is 34 bits: 36/29 (1.24x)
Testing distribution - Worst bias is the 17-bit window at bit 39 - 0.112%

Keyset 'Cyclic' - 8 cycles of 12 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    115 (0.99x) (-1)
Testing collisions (high 23-34 bits) - Worst is 34 bits: 34/29 (1.17x)
Testing collisions (low  32-bit) - Expected        116.4, actual    115 (0.99x) (-1)
Testing collisions (low  23-34 bits) - Worst is 30 bits: 483/465 (1.04x)
Testing distribution - Worst bias is the 17-bit window at bit 52 - 0.132%

Keyset 'Cyclic' - 8 cycles of 16 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    132 (1.13x) (16)
Testing collisions (high 23-34 bits) - Worst is 34 bits: 36/29 (1.24x)
Testing collisions (low  32-bit) - Expected        116.4, actual    100 (0.86x)
Testing collisions (low  23-34 bits) - Worst is 29 bits: 947/930 (1.02x)
Testing distribution - Worst bias is the 17-bit window at bit 15 - 0.109%


[[[ Keyset 'TwoBytes' Tests ]]]

Keyset 'TwoBytes' - up-to-4-byte keys, 652545 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected         49.6, actual     38 (0.77x)
Testing collisions (high 23-33 bits) - Worst is 23 bits: 24681/24735 (1.00x)
Testing collisions (low  32-bit) - Expected         49.6, actual     44 (0.89x)
Testing collisions (low  23-33 bits) - Worst is 31 bits: 108/99 (1.09x)
Testing distribution - Worst bias is the 16-bit window at bit 22 - 0.120%

Keyset 'TwoBytes' - up-to-8-byte keys, 5471025 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       3483.1, actual   3447 (0.99x) (-36)
Testing collisions (high 26-39 bits) - Worst is 26 bits: 217954/217072 (1.00x)
Testing collisions (low  32-bit) - Expected       3483.1, actual   3344 (0.96x)
Testing collisions (low  26-39 bits) - Worst is 38 bits: 57/54 (1.05x)
Testing distribution - Worst bias is the 20-bit window at bit 10 - 0.087%

Keyset 'TwoBytes' - up-to-12-byte keys, 18616785 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      40289.5, actual  40269 (1.00x) (-20)
Testing collisions (high 27-42 bits) - Worst is 38 bits: 644/630 (1.02x)
Testing collisions (low  32-bit) - Expected      40289.5, actual  40110 (1.00x) (-179)
Testing collisions (low  27-42 bits) - Worst is 42 bits: 41/39 (1.04x)
Testing distribution - Worst bias is the 20-bit window at bit 49 - 0.024%

Keyset 'TwoBytes' - up-to-16-byte keys, 44251425 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected     227182.3, actual 227638 (1.00x) (456)
Testing collisions (high 29-45 bits) - Worst is 39 bits: 1794/1780 (1.01x)
Testing collisions (low  32-bit) - Expected     227182.3, actual 226966 (1.00x) (-216)
Testing collisions (low  29-45 bits) - Worst is 42 bits: 253/222 (1.14x)
Testing distribution - Worst bias is the 20-bit window at bit 46 - 0.009%

Keyset 'TwoBytes' - up-to-20-byte keys, 86536545 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected     865959.1, actual 866176 (1.00x) (217)
Testing collisions (high 30-47 bits) - Worst is 43 bits: 437/425 (1.03x)
Testing collisions (low  32-bit) - Expected     865959.1, actual 865959 (1.00x)
Testing collisions (low  30-47 bits) - Worst is 45 bits: 121/106 (1.14x)
Testing distribution - Worst bias is the 20-bit window at bit 45 - 0.004%


[[[ Keyset 'Text' Tests ]]]

Keyset 'Text' - keys of form "FooXXXXBar" - 14776336 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      25389.0, actual  25652 (1.01x) (263)
Testing collisions (high 27-42 bits) - Worst is 42 bits: 31/24 (1.25x)
Testing collisions (low  32-bit) - Expected      25389.0, actual  25380 (1.00x) (-9)
Testing collisions (low  27-42 bits) - Worst is 38 bits: 412/397 (1.04x)
Testing distribution - Worst bias is the 20-bit window at bit 12 - 0.022%

Keyset 'Text' - keys of form "FooBarXXXX" - 14776336 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      25389.0, actual  25507 (1.00x) (118)
Testing collisions (high 27-42 bits) - Worst is 42 bits: 29/24 (1.17x)
Testing collisions (low  32-bit) - Expected      25389.0, actual  25496 (1.00x) (107)
Testing collisions (low  27-42 bits) - Worst is 39 bits: 204/198 (1.03x)
Testing distribution - Worst bias is the 20-bit window at bit 61 - 0.021%

Keyset 'Text' - keys of form "XXXXFooBar" - 14776336 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      25389.0, actual  25559 (1.01x) (170)
Testing collisions (high 27-42 bits) - Worst is 41 bits: 60/49 (1.21x)
Testing collisions (low  32-bit) - Expected      25389.0, actual  25471 (1.00x) (82)
Testing collisions (low  27-42 bits) - Worst is 42 bits: 35/24 (1.41x)
Testing distribution - Worst bias is the 20-bit window at bit 63 - 0.033%

Keyset 'Words' - 4000000 random keys of len 6-16 from alnum charset
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1862.1, actual   1822 (0.98x)
Testing collisions (high 25-38 bits) - Worst is 38 bits: 30/29 (1.03x)
Testing collisions (low  32-bit) - Expected       1862.1, actual   1837 (0.99x) (-25)
Testing collisions (low  25-38 bits) - Worst is 25 bits: 229258/229220 (1.00x)
Testing distribution - Worst bias is the 19-bit window at bit 42 - 0.071%

Keyset 'Words' - 4000000 random keys of len 6-16 from password charset
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1862.1, actual   1827 (0.98x) (-35)
Testing collisions (high 25-38 bits) - Worst is 36 bits: 131/116 (1.13x)
Testing collisions (low  32-bit) - Expected       1862.1, actual   1832 (0.98x) (-30)
Testing collisions (low  25-38 bits) - Worst is 38 bits: 32/29 (1.10x)
Testing distribution - Worst bias is the 19-bit window at bit 24 - 0.069%

Keyset 'Words' - 466569 dict words
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected         25.3, actual     27 (1.07x) (2)
Testing collisions (high 22-32 bits) - Worst is 32 bits: 27/25 (1.07x)
Testing collisions (low  32-bit) - Expected         25.3, actual     26 (1.03x) (1)
Testing collisions (low  22-32 bits) - Worst is 30 bits: 120/101 (1.18x)
Testing distribution - Worst bias is the 16-bit window at bit 48 - 0.155%


[[[ Keyset 'Zeroes' Tests ]]]

Keyset 'Zeroes' - 204800 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          4.9, actual      4 (0.82x)
Testing collisions (high 21-29 bits) - Worst is 28 bits: 83/78 (1.06x)
Testing collisions (low  32-bit) - Expected          4.9, actual      2 (0.41x)
Testing collisions (low  21-29 bits) - Worst is 27 bits: 169/156 (1.08x)
Testing distribution - Worst bias is the 15-bit window at bit 31 - 0.261%


[[[ Keyset 'Seed' Tests ]]]

Keyset 'Seed' - 5000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2909.3, actual   2808 (0.97x)
Testing collisions (high 26-39 bits) - Worst is 37 bits: 93/90 (1.02x)
Testing collisions (low  32-bit) - Expected       2909.3, actual   3032 (1.04x) (123)
Testing collisions (low  26-39 bits) - Worst is 38 bits: 64/45 (1.41x)
Testing distribution - Worst bias is the 19-bit window at bit 63 - 0.044%


[[[ Keyset 'PerlinNoise' Tests ]]]

Testing 16777216 coordinates (L2) : 
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      32725.4, actual  32777 (1.00x) (52)
Testing collisions (high 27-42 bits) - Worst is 42 bits: 37/31 (1.16x)
Testing collisions (low  32-bit) - Expected      32725.4, actual  32511 (0.99x) (-214)
Testing collisions (low  27-42 bits) - Worst is 42 bits: 36/31 (1.13x)

Testing AV variant, 128 count with 4 spacing, 4-12:
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1116.2, actual   1087 (0.97x)
Testing collisions (high 25-37 bits) - Worst is 27 bits: 35400/35452 (1.00x)
Testing collisions (low  32-bit) - Expected       1116.2, actual   1067 (0.96x)
Testing collisions (low  25-37 bits) - Worst is 34 bits: 280/279 (1.00x)


[[[ Diff 'Differential' Tests ]]]

Testing 8303632 up-to-5-bit differentials in 64-bit keys -> 64 bit hashes.
1000 reps, 8303632000 total tests, expecting 0.00 random collisions..........
0 total collisions, of which 0 single collisions were ignored

Testing 11017632 up-to-4-bit differentials in 128-bit keys -> 64 bit hashes.
1000 reps, 11017632000 total tests, expecting 0.00 random collisions..........
0 total collisions, of which 0 single collisions were ignored

Testing 2796416 up-to-3-bit differentials in 256-bit keys -> 64 bit hashes.
1000 reps, 2796416000 total tests, expecting 0.00 random collisions..........
0 total collisions, of which 0 single collisions were ignored


[[[ DiffDist 'Differential Distribution' Tests ]]]

Testing bit 0
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    526 (1.03x) (15)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 38/31 (1.19x)
Testing collisions (low  32-bit) - Expected        511.9, actual    495 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit  3 - 0.118%

Testing bit 1
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    514 (1.00x) (3)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 132/127 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    496 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 25 bits: 64220/64191 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 60 - 0.077%

Testing bit 2
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    520 (1.02x) (9)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 35/31 (1.09x)
Testing collisions (low  32-bit) - Expected        511.9, actual    494 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 15 - 0.078%

Testing bit 3
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    538 (1.05x) (27)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1083/1023 (1.06x)
Testing collisions (low  32-bit) - Expected        511.9, actual    470 (0.92x)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2093/2046 (1.02x)
Testing distribution - Worst bias is the 18-bit window at bit 42 - 0.069%

Testing bit 4
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    514 (1.00x) (3)
Testing collisions (high 24-36 bits) - Worst is 28 bits: 8315/8170 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    549 (1.07x) (38)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 78/63 (1.22x)
Testing distribution - Worst bias is the 18-bit window at bit 52 - 0.081%

Testing bit 5
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    499 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing collisions (low  32-bit) - Expected        511.9, actual    528 (1.03x) (17)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 44/31 (1.38x)
Testing distribution - Worst bias is the 18-bit window at bit 40 - 0.116%

Testing bit 6
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    510 (1.00x) (-1)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 266/255 (1.04x)
Testing collisions (low  32-bit) - Expected        511.9, actual    513 (1.00x) (2)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 73/63 (1.14x)
Testing distribution - Worst bias is the 18-bit window at bit 14 - 0.106%

Testing bit 7
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    528 (1.03x) (17)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing collisions (low  32-bit) - Expected        511.9, actual    553 (1.08x) (42)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 38/31 (1.19x)
Testing distribution - Worst bias is the 18-bit window at bit 42 - 0.095%

Testing bit 8
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    526 (1.03x) (15)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing collisions (low  32-bit) - Expected        511.9, actual    513 (1.00x) (2)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 513/511 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 27 - 0.075%

Testing bit 9
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 76/63 (1.19x)
Testing collisions (low  32-bit) - Expected        511.9, actual    519 (1.01x) (8)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 73/63 (1.14x)
Testing distribution - Worst bias is the 18-bit window at bit 15 - 0.113%

Testing bit 10
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    494 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 71/63 (1.11x)
Testing collisions (low  32-bit) - Expected        511.9, actual    483 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 26 bits: 32540/32429 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 40 - 0.099%

Testing bit 11
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    497 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 132/127 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    504 (0.98x) (-7)
Testing collisions (low  24-36 bits) - Worst is 26 bits: 32534/32429 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 19 - 0.059%

Testing bit 12
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    495 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 136/127 (1.06x)
Testing collisions (low  32-bit) - Expected        511.9, actual    537 (1.05x) (26)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 46/31 (1.44x)
Testing distribution - Worst bias is the 18-bit window at bit 10 - 0.058%

Testing bit 13
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    501 (0.98x)
Testing collisions (high 24-36 bits) - Worst is 28 bits: 8316/8170 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    553 (1.08x) (42)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 72/63 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 41 - 0.054%

Testing bit 14
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    525 (1.03x) (14)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing collisions (low  32-bit) - Expected        511.9, actual    488 (0.95x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 69/63 (1.08x)
Testing distribution - Worst bias is the 18-bit window at bit 43 - 0.088%

Testing bit 15
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    532 (1.04x) (21)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 281/255 (1.10x)
Testing collisions (low  32-bit) - Expected        511.9, actual    555 (1.08x) (44)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 74/63 (1.16x)
Testing distribution - Worst bias is the 18-bit window at bit 50 - 0.079%

Testing bit 16
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2084/2046 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    520 (1.02x) (9)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 520/511 (1.02x)
Testing distribution - Worst bias is the 18-bit window at bit 58 - 0.076%

Testing bit 17
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    518 (1.01x) (7)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 260/255 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 138/127 (1.08x)
Testing distribution - Worst bias is the 17-bit window at bit 54 - 0.068%

Testing bit 18
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    514 (1.00x) (3)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2114/2046 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    513 (1.00x) (2)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 132/127 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 62 - 0.083%

Testing bit 19
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 529/511 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    501 (0.98x)
Testing collisions (low  24-36 bits) - Worst is 27 bits: 16419/16298 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 29 - 0.080%

Testing bit 20
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    504 (0.98x) (-7)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1040/1023 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    507 (0.99x) (-4)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 18-bit window at bit 50 - 0.092%

Testing bit 21
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    510 (1.00x) (-1)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (low  24-36 bits) - Worst is 31 bits: 1062/1023 (1.04x)
Testing distribution - Worst bias is the 18-bit window at bit 34 - 0.079%

Testing bit 22
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    505 (0.99x) (-6)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 260/255 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    466 (0.91x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 47 - 0.077%

Testing bit 23
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    515 (1.01x) (4)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 44/31 (1.38x)
Testing collisions (low  32-bit) - Expected        511.9, actual    500 (0.98x)
Testing collisions (low  24-36 bits) - Worst is 26 bits: 32370/32429 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 57 - 0.064%

Testing bit 24
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    507 (0.99x) (-4)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 272/255 (1.06x)
Testing collisions (low  32-bit) - Expected        511.9, actual    495 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 27 bits: 16412/16298 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 46 - 0.057%

Testing bit 25
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    512 (1.00x) (1)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 269/255 (1.05x)
Testing collisions (low  32-bit) - Expected        511.9, actual    549 (1.07x) (38)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 549/511 (1.07x)
Testing distribution - Worst bias is the 18-bit window at bit 39 - 0.089%

Testing bit 26
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    508 (0.99x) (-3)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1036/1023 (1.01x)
Testing collisions (low  32-bit) - Expected        511.9, actual    481 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit  1 - 0.065%

Testing bit 27
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    527 (1.03x) (16)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 69/63 (1.08x)
Testing collisions (low  32-bit) - Expected        511.9, actual    465 (0.91x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing distribution - Worst bias is the 18-bit window at bit 13 - 0.101%

Testing bit 28
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    484 (0.95x)
Testing collisions (high 24-36 bits) - Worst is 25 bits: 64180/64191 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    536 (1.05x) (25)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 78/63 (1.22x)
Testing distribution - Worst bias is the 18-bit window at bit  8 - 0.130%

Testing bit 29
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    511 (1.00x)
Testing collisions (high 24-36 bits) - Worst is 24 bits: 126329/125777 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    498 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 31 bits: 1036/1023 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit  3 - 0.059%

Testing bit 30
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    519 (1.01x) (8)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2107/2046 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    478 (0.93x)
Testing collisions (low  24-36 bits) - Worst is 25 bits: 64338/64191 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit  4 - 0.078%

Testing bit 31
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    506 (0.99x) (-5)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 74/63 (1.16x)
Testing collisions (low  32-bit) - Expected        511.9, actual    493 (0.96x)
Testing collisions (low  24-36 bits) - Worst is 24 bits: 125635/125777 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 50 - 0.072%

Testing bit 32
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    508 (0.99x) (-3)
Testing collisions (high 24-36 bits) - Worst is 24 bits: 125444/125777 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    514 (1.00x) (3)
Testing collisions (low  24-36 bits) - Worst is 29 bits: 4149/4090 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 12 - 0.094%

Testing bit 33
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    546 (1.07x) (35)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 546/511 (1.07x)
Testing collisions (low  32-bit) - Expected        511.9, actual    546 (1.07x) (35)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 139/127 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 45 - 0.069%

Testing bit 34
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    505 (0.99x) (-6)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    503 (0.98x) (-8)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 142/127 (1.11x)
Testing distribution - Worst bias is the 18-bit window at bit 52 - 0.133%

Testing bit 35
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    506 (0.99x) (-5)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 71/63 (1.11x)
Testing collisions (low  32-bit) - Expected        511.9, actual    483 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 72/63 (1.13x)
Testing distribution - Worst bias is the 17-bit window at bit 31 - 0.062%

Testing bit 36
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    519 (1.01x) (8)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 519/511 (1.01x)
Testing collisions (low  32-bit) - Expected        511.9, actual    496 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2121/2046 (1.04x)
Testing distribution - Worst bias is the 18-bit window at bit 37 - 0.119%

Testing bit 37
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    525 (1.03x) (14)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 77/63 (1.20x)
Testing collisions (low  32-bit) - Expected        511.9, actual    465 (0.91x)
Testing collisions (low  24-36 bits) - Worst is 29 bits: 4123/4090 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 23 - 0.082%

Testing bit 38
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    542 (1.06x) (31)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 70/63 (1.09x)
Testing collisions (low  32-bit) - Expected        511.9, actual    507 (0.99x) (-4)
Testing collisions (low  24-36 bits) - Worst is 31 bits: 1065/1023 (1.04x)
Testing distribution - Worst bias is the 18-bit window at bit 23 - 0.058%

Testing bit 39
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    523 (1.02x) (12)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1056/1023 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    479 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 24 bits: 125933/125777 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 11 - 0.066%

Testing bit 40
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    528 (1.03x) (17)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 47/31 (1.47x)
Testing collisions (low  32-bit) - Expected        511.9, actual    532 (1.04x) (21)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 134/127 (1.05x)
Testing distribution - Worst bias is the 18-bit window at bit 39 - 0.109%

Testing bit 41
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    474 (0.93x)
Testing collisions (high 24-36 bits) - Worst is 27 bits: 16336/16298 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (low  24-36 bits) - Worst is 31 bits: 1038/1023 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 62 - 0.067%

Testing bit 42
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    511 (1.00x)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 137/127 (1.07x)
Testing collisions (low  32-bit) - Expected        511.9, actual    510 (1.00x) (-1)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 72/63 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit  5 - 0.079%

Testing bit 43
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    503 (0.98x) (-8)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing collisions (low  32-bit) - Expected        511.9, actual    528 (1.03x) (17)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 74/63 (1.16x)
Testing distribution - Worst bias is the 18-bit window at bit 38 - 0.089%

Testing bit 44
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    497 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 43/31 (1.34x)
Testing collisions (low  32-bit) - Expected        511.9, actual    511 (1.00x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 71/63 (1.11x)
Testing distribution - Worst bias is the 18-bit window at bit 51 - 0.073%

Testing bit 45
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 529/511 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    535 (1.05x) (24)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 276/255 (1.08x)
Testing distribution - Worst bias is the 18-bit window at bit 47 - 0.092%

Testing bit 46
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    534 (1.04x) (23)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 143/127 (1.12x)
Testing collisions (low  32-bit) - Expected        511.9, actual    507 (0.99x) (-4)
Testing collisions (low  24-36 bits) - Worst is 29 bits: 4172/4090 (1.02x)
Testing distribution - Worst bias is the 18-bit window at bit  9 - 0.073%

Testing bit 47
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 263/255 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    560 (1.09x) (49)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 18-bit window at bit 24 - 0.073%

Testing bit 48
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    514 (1.00x) (3)
Testing collisions (high 24-36 bits) - Worst is 29 bits: 4230/4090 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    512 (1.00x) (1)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 18-bit window at bit 15 - 0.069%

Testing bit 49
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    527 (1.03x) (16)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 265/255 (1.04x)
Testing collisions (low  32-bit) - Expected        511.9, actual    491 (0.96x)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 132/127 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 49 - 0.077%

Testing bit 50
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing collisions (low  32-bit) - Expected        511.9, actual    516 (1.01x) (5)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 39/31 (1.22x)
Testing distribution - Worst bias is the 18-bit window at bit 53 - 0.088%

Testing bit 51
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    461 (0.90x)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2065/2046 (1.01x)
Testing collisions (low  32-bit) - Expected        511.9, actual    502 (0.98x) (-9)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2045/2046 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit  2 - 0.073%

Testing bit 52
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    527 (1.03x) (16)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 527/511 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    532 (1.04x) (21)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 140/127 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 20 - 0.083%

Testing bit 53
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    491 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 41/31 (1.28x)
Testing collisions (low  32-bit) - Expected        511.9, actual    498 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 24 bits: 126008/125777 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 18 - 0.083%

Testing bit 54
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    534 (1.04x) (23)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 146/127 (1.14x)
Testing collisions (low  32-bit) - Expected        511.9, actual    544 (1.06x) (33)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 544/511 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 49 - 0.052%

Testing bit 55
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    454 (0.89x)
Testing collisions (high 24-36 bits) - Worst is 24 bits: 125990/125777 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    504 (0.98x) (-7)
Testing collisions (low  24-36 bits) - Worst is 28 bits: 8220/8170 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 21 - 0.108%

Testing bit 56
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    561 (1.10x) (50)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 148/127 (1.16x)
Testing collisions (low  32-bit) - Expected        511.9, actual    526 (1.03x) (15)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 526/511 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 15 - 0.067%

Testing bit 57
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    468 (0.91x)
Testing collisions (high 24-36 bits) - Worst is 26 bits: 32528/32429 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 43/31 (1.34x)
Testing distribution - Worst bias is the 18-bit window at bit 46 - 0.111%

Testing bit 58
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    534 (1.04x) (23)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 48/31 (1.50x)
Testing collisions (low  32-bit) - Expected        511.9, actual    509 (0.99x) (-2)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 264/255 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 39 - 0.080%

Testing bit 59
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    516 (1.01x) (5)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2078/2046 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    492 (0.96x)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2113/2046 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 57 - 0.088%

Testing bit 60
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    465 (0.91x)
Testing collisions (high 24-36 bits) - Worst is 28 bits: 8183/8170 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    516 (1.01x) (5)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 69/63 (1.08x)
Testing distribution - Worst bias is the 18-bit window at bit 38 - 0.067%

Testing bit 61
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    537 (1.05x) (26)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 142/127 (1.11x)
Testing collisions (low  32-bit) - Expected        511.9, actual    502 (0.98x) (-9)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 68/63 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 19 - 0.075%

Testing bit 62
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    572 (1.12x) (61)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 304/255 (1.19x)
Testing collisions (low  32-bit) - Expected        511.9, actual    514 (1.00x) (3)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 38/31 (1.19x)
Testing distribution - Worst bias is the 18-bit window at bit 19 - 0.068%

Testing bit 63
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    495 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing collisions (low  32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 529/511 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 39 - 0.089%


[[[ MomentChi2 Tests ]]]

Analyze hashes produced from a serie of linearly increasing numbers of 32-bit, using a step of 2 ... 
Target values to approximate : 38918200.000000 - 273633.333333 
Popcount 1 stats : 38919570.005124 - 273658.703091
Popcount 0 stats : 38918319.622388 - 273636.624134
MomentChi2 for bits 1 :   3.42946 
MomentChi2 for bits 0 :  0.0261471 

Derivative stats (transition from 2 consecutive values) : 
Popcount 1 stats : 38919286.374871 - 273651.807467
Popcount 0 stats : 38918700.222160 - 273641.544934
MomentChi2 for deriv b1 :   2.15648 
MomentChi2 for deriv b0 :  0.457215 

  Great 


[[[ Prng Tests ]]]

Generating 33554432 random numbers : 
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected     130731.3, actual 130706 (1.00x) (-25)
Testing collisions (high 28-44 bits) - Worst is 44 bits: 38/31 (1.19x)
Testing collisions (low  32-bit) - Expected     130731.3, actual 130394 (1.00x) (-337)
Testing collisions (low  28-44 bits) - Worst is 41 bits: 261/255 (1.02x)

[[[ BadSeeds Tests ]]]

0x0 PASS


Input vcode 0x00000001, Output vcode 0x00000001, Result vcode 0x00000001
Verification value is 0x00000001 - Testing took 681.305909 seconds
------------------------------------------------------------
```

------------------------------------------------------------
### Stable Hash 64bit SMHasher Results

The following results were achieved on my personal computer when testing the 64bit variant of the facil.io Stable Hash (`fio_stable_hash`).

```txt
------------------------------------------------------------
--- Testing Stable "facil.io Stable Hash 64bit" GOOD

[[[ Sanity Tests ]]]

Verification value 0x6993BB92 ....... PASS
Running sanity check 1     .......... PASS
Running AppendedZeroesTest .......... PASS

[[[ Speed Tests ]]]

Bulk speed test - 262144-byte keys
Alignment  7 - 12.548 bytes/cycle - 35899.15 MiB/sec @ 3 ghz
Alignment  6 - 12.560 bytes/cycle - 35934.05 MiB/sec @ 3 ghz
Alignment  5 - 12.554 bytes/cycle - 35917.07 MiB/sec @ 3 ghz
Alignment  4 - 12.560 bytes/cycle - 35935.44 MiB/sec @ 3 ghz
Alignment  3 - 12.559 bytes/cycle - 35931.79 MiB/sec @ 3 ghz
Alignment  2 - 12.557 bytes/cycle - 35926.78 MiB/sec @ 3 ghz
Alignment  1 - 12.561 bytes/cycle - 35936.39 MiB/sec @ 3 ghz
Alignment  0 - 12.678 bytes/cycle - 36273.41 MiB/sec @ 3 ghz
Average      - 12.572 bytes/cycle - 35969.26 MiB/sec @ 3 ghz

Small key speed test -    1-byte keys -    20.57 cycles/hash
Small key speed test -    2-byte keys -    21.00 cycles/hash
Small key speed test -    3-byte keys -    21.00 cycles/hash
Small key speed test -    4-byte keys -    20.99 cycles/hash
Small key speed test -    5-byte keys -    21.00 cycles/hash
Small key speed test -    6-byte keys -    21.00 cycles/hash
Small key speed test -    7-byte keys -    22.00 cycles/hash
Small key speed test -    8-byte keys -    21.00 cycles/hash
Small key speed test -    9-byte keys -    21.00 cycles/hash
Small key speed test -   10-byte keys -    21.00 cycles/hash
Small key speed test -   11-byte keys -    21.00 cycles/hash
Small key speed test -   12-byte keys -    21.00 cycles/hash
Small key speed test -   13-byte keys -    21.00 cycles/hash
Small key speed test -   14-byte keys -    21.00 cycles/hash
Small key speed test -   15-byte keys -    21.00 cycles/hash
Small key speed test -   16-byte keys -    21.00 cycles/hash
Small key speed test -   17-byte keys -    22.88 cycles/hash
Small key speed test -   18-byte keys -    22.92 cycles/hash
Small key speed test -   19-byte keys -    22.94 cycles/hash
Small key speed test -   20-byte keys -    22.93 cycles/hash
Small key speed test -   21-byte keys -    22.94 cycles/hash
Small key speed test -   22-byte keys -    22.92 cycles/hash
Small key speed test -   23-byte keys -    22.89 cycles/hash
Small key speed test -   24-byte keys -    22.89 cycles/hash
Small key speed test -   25-byte keys -    22.93 cycles/hash
Small key speed test -   26-byte keys -    22.90 cycles/hash
Small key speed test -   27-byte keys -    23.03 cycles/hash
Small key speed test -   28-byte keys -    22.81 cycles/hash
Small key speed test -   29-byte keys -    22.89 cycles/hash
Small key speed test -   30-byte keys -    23.13 cycles/hash
Small key speed test -   31-byte keys -    22.99 cycles/hash
Average                                    21.953 cycles/hash

[[[ 'Hashmap' Speed Tests ]]]

std::unordered_map
Init std HashMapTest:     155.249 cycles/op (466569 inserts, 1% deletions)
Running std HashMapTest:  93.391 cycles/op (1.6 stdv, found 461903)

greg7mdp/parallel-hashmap
Init fast HashMapTest:    143.332 cycles/op (466569 inserts, 1% deletions)
Running fast HashMapTest: 93.590 cycles/op (1.3 stdv, found 461903)

facil.io HashMap
Init fast fio_map_s Test:    87.173 cycles/op (466569 inserts, 1% deletions)
Running fast fio_map_s Test: 49.115 cycles/op (0.5 stdv, found 461903)
 ....... PASS

[[[ Avalanche Tests ]]]

Testing   24-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.632667%
Testing   32-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.712000%
Testing   40-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.704000%
Testing   48-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.696667%
Testing   56-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.686000%
Testing   64-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.712000%
Testing   72-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.636000%
Testing   80-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.630667%
Testing   96-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.690667%
Testing  112-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.670667%
Testing  128-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.760667%
Testing  160-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.773333%
Testing  512-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.825333%
Testing 1024-bit keys ->  64-bit hashes, 300000 reps.......... worst bias is 0.753333%

[[[ Keyset 'Sparse' Tests ]]]

Keyset 'Sparse' - 16-bit keys with up to 9 bits set - 50643 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          0.3, actual      0 (0.00x)
Testing collisions (high 19-25 bits) - Worst is 23 bits: 171/152 (1.12x)
Testing collisions (low  32-bit) - Expected          0.3, actual      0 (0.00x)
Testing collisions (low  19-25 bits) - Worst is 21 bits: 602/606 (0.99x)
Testing distribution - Worst bias is the 13-bit window at bit 31 - 0.586%

Keyset 'Sparse' - 24-bit keys with up to 8 bits set - 1271626 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        188.2, actual    197 (1.05x) (9)
Testing collisions (high 24-35 bits) - Worst is 33 bits: 100/94 (1.06x)
Testing collisions (low  32-bit) - Expected        188.2, actual    170 (0.90x)
Testing collisions (low  24-35 bits) - Worst is 26 bits: 12071/11972 (1.01x)
Testing distribution - Worst bias is the 17-bit window at bit 48 - 0.087%

Keyset 'Sparse' - 32-bit keys with up to 7 bits set - 4514873 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2372.2, actual   2345 (0.99x) (-27)
Testing collisions (high 25-38 bits) - Worst is 38 bits: 47/37 (1.27x)
Testing collisions (low  32-bit) - Expected       2372.2, actual   2374 (1.00x) (2)
Testing collisions (low  25-38 bits) - Worst is 30 bits: 9492/9478 (1.00x)
Testing distribution - Worst bias is the 19-bit window at bit 35 - 0.057%

Keyset 'Sparse' - 40-bit keys with up to 6 bits set - 4598479 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2460.8, actual   2380 (0.97x)
Testing collisions (high 25-38 bits) - Worst is 36 bits: 163/153 (1.06x)
Testing collisions (low  32-bit) - Expected       2460.8, actual   2490 (1.01x) (30)
Testing collisions (low  25-38 bits) - Worst is 38 bits: 45/38 (1.17x)
Testing distribution - Worst bias is the 19-bit window at bit 50 - 0.061%

Keyset 'Sparse' - 48-bit keys with up to 6 bits set - 14196869 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      23437.8, actual  23277 (0.99x) (-160)
Testing collisions (high 27-42 bits) - Worst is 42 bits: 28/22 (1.22x)
Testing collisions (low  32-bit) - Expected      23437.8, actual  23272 (0.99x) (-165)
Testing collisions (low  27-42 bits) - Worst is 30 bits: 93648/93442 (1.00x)
Testing distribution - Worst bias is the 20-bit window at bit 29 - 0.022%

Keyset 'Sparse' - 56-bit keys with up to 5 bits set - 4216423 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2069.0, actual   2065 (1.00x) (-3)
Testing collisions (high 25-38 bits) - Worst is 38 bits: 37/32 (1.14x)
Testing collisions (low  32-bit) - Expected       2069.0, actual   2042 (0.99x) (-26)
Testing collisions (low  25-38 bits) - Worst is 38 bits: 40/32 (1.24x)
Testing distribution - Worst bias is the 19-bit window at bit 37 - 0.050%

Keyset 'Sparse' - 64-bit keys with up to 5 bits set - 8303633 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8021.7, actual   8020 (1.00x) (-1)
Testing collisions (high 26-40 bits) - Worst is 40 bits: 36/31 (1.15x)
Testing collisions (low  32-bit) - Expected       8021.7, actual   8038 (1.00x) (17)
Testing collisions (low  26-40 bits) - Worst is 31 bits: 16101/16033 (1.00x)
Testing distribution - Worst bias is the 20-bit window at bit 43 - 0.043%

Keyset 'Sparse' - 72-bit keys with up to 5 bits set - 15082603 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      26451.8, actual  26679 (1.01x) (228)
Testing collisions (high 27-42 bits) - Worst is 39 bits: 218/206 (1.05x)
Testing collisions (low  32-bit) - Expected      26451.8, actual  26434 (1.00x) (-17)
Testing collisions (low  27-42 bits) - Worst is 35 bits: 3324/3309 (1.00x)
Testing distribution - Worst bias is the 20-bit window at bit 26 - 0.028%

Keyset 'Sparse' - 96-bit keys with up to 4 bits set - 3469497 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1401.0, actual   1462 (1.04x) (62)
Testing collisions (high 25-38 bits) - Worst is 37 bits: 53/43 (1.21x)
Testing collisions (low  32-bit) - Expected       1401.0, actual   1406 (1.00x) (6)
Testing collisions (low  25-38 bits) - Worst is 37 bits: 60/43 (1.37x)
Testing distribution - Worst bias is the 19-bit window at bit 12 - 0.088%

Keyset 'Sparse' - 160-bit keys with up to 4 bits set - 26977161 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      84546.1, actual  84527 (1.00x) (-19)
Testing collisions (high 28-44 bits) - Worst is 44 bits: 29/20 (1.40x)
Testing collisions (low  32-bit) - Expected      84546.1, actual  84586 (1.00x) (40)
Testing collisions (low  28-44 bits) - Worst is 41 bits: 172/165 (1.04x)
Testing distribution - Worst bias is the 20-bit window at bit 39 - 0.017%

Keyset 'Sparse' - 256-bit keys with up to 3 bits set - 2796417 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        910.2, actual    947 (1.04x) (37)
Testing collisions (high 25-37 bits) - Worst is 36 bits: 63/56 (1.11x)
Testing collisions (low  32-bit) - Expected        910.2, actual    925 (1.02x) (15)
Testing collisions (low  25-37 bits) - Worst is 33 bits: 473/455 (1.04x)
Testing distribution - Worst bias is the 19-bit window at bit 50 - 0.082%

Keyset 'Sparse' - 512-bit keys with up to 3 bits set - 22370049 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      58155.4, actual  57664 (0.99x) (-491)
Testing collisions (high 28-43 bits) - Worst is 38 bits: 924/910 (1.02x)
Testing collisions (low  32-bit) - Expected      58155.4, actual  58193 (1.00x) (38)
Testing collisions (low  28-43 bits) - Worst is 39 bits: 498/455 (1.09x)
Testing distribution - Worst bias is the 20-bit window at bit 23 - 0.017%

Keyset 'Sparse' - 1024-bit keys with up to 2 bits set - 524801 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected         32.1, actual     30 (0.94x)
Testing collisions (high 22-32 bits) - Worst is 28 bits: 518/512 (1.01x)
Testing collisions (low  32-bit) - Expected         32.1, actual     23 (0.72x)
Testing collisions (low  22-32 bits) - Worst is 29 bits: 294/256 (1.15x)
Testing distribution - Worst bias is the 16-bit window at bit 48 - 0.155%

Keyset 'Sparse' - 2048-bit keys with up to 2 bits set - 2098177 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        512.4, actual    499 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 29 bits: 4139/4094 (1.01x)
Testing collisions (low  32-bit) - Expected        512.4, actual    529 (1.03x) (17)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 143/128 (1.12x)
Testing distribution - Worst bias is the 18-bit window at bit 30 - 0.057%


[[[ Keyset 'Permutation' Tests ]]]

Combination Lowbits Tests:
Keyset 'Combination' - up to 7 blocks from a set of 8 - 2396744 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        668.6, actual    670 (1.00x) (2)
Testing collisions (high 24-37 bits) - Worst is 36 bits: 44/41 (1.05x)
Testing collisions (low  32-bit) - Expected        668.6, actual    655 (0.98x)
Testing collisions (low  24-37 bits) - Worst is 34 bits: 173/167 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit  9 - 0.080%


Combination Highbits Tests
Keyset 'Combination' - up to 7 blocks from a set of 8 - 2396744 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        668.6, actual    657 (0.98x) (-11)
Testing collisions (high 24-37 bits) - Worst is 37 bits: 24/20 (1.15x)
Testing collisions (low  32-bit) - Expected        668.6, actual    691 (1.03x) (23)
Testing collisions (low  24-37 bits) - Worst is 33 bits: 362/334 (1.08x)
Testing distribution - Worst bias is the 18-bit window at bit  9 - 0.047%


Combination Hi-Lo Tests:
Keyset 'Combination' - up to 6 blocks from a set of 15 - 12204240 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      17322.9, actual  17106 (0.99x) (-216)
Testing collisions (high 27-41 bits) - Worst is 41 bits: 37/33 (1.09x)
Testing collisions (low  32-bit) - Expected      17322.9, actual  17214 (0.99x) (-108)
Testing collisions (low  27-41 bits) - Worst is 28 bits: 273805/273271 (1.00x)
Testing distribution - Worst bias is the 20-bit window at bit  3 - 0.030%


Combination 0x8000000 Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8288 (1.01x) (102)
Testing collisions (high 26-40 bits) - Worst is 40 bits: 41/31 (1.28x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8135 (0.99x) (-51)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 39/31 (1.22x)
Testing distribution - Worst bias is the 20-bit window at bit 52 - 0.038%


Combination 0x0000001 Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8207 (1.00x) (21)
Testing collisions (high 26-40 bits) - Worst is 40 bits: 36/31 (1.13x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8100 (0.99x) (-86)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 20-bit window at bit 43 - 0.036%


Combination 0x800000000000000 Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   7983 (0.98x)
Testing collisions (high 26-40 bits) - Worst is 40 bits: 34/31 (1.06x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8152 (1.00x) (-34)
Testing collisions (low  26-40 bits) - Worst is 36 bits: 525/511 (1.03x)
Testing distribution - Worst bias is the 20-bit window at bit  4 - 0.054%


Combination 0x000000000000001 Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8201 (1.00x) (15)
Testing collisions (high 26-40 bits) - Worst is 39 bits: 66/63 (1.03x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8064 (0.99x) (-122)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 39/31 (1.22x)
Testing distribution - Worst bias is the 20-bit window at bit 49 - 0.040%


Combination 16-bytes [0-1] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8156 (1.00x) (-30)
Testing collisions (high 26-40 bits) - Worst is 28 bits: 130239/129717 (1.00x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8355 (1.02x) (169)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 39/31 (1.22x)
Testing distribution - Worst bias is the 20-bit window at bit 44 - 0.040%


Combination 16-bytes [0-last] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8046 (0.98x) (-140)
Testing collisions (high 26-40 bits) - Worst is 36 bits: 550/511 (1.07x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8034 (0.98x) (-152)
Testing collisions (low  26-40 bits) - Worst is 37 bits: 265/255 (1.04x)
Testing distribution - Worst bias is the 20-bit window at bit 24 - 0.042%


Combination 32-bytes [0-1] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8155 (1.00x) (-31)
Testing collisions (high 26-40 bits) - Worst is 39 bits: 84/63 (1.31x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8295 (1.01x) (109)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 41/31 (1.28x)
Testing distribution - Worst bias is the 20-bit window at bit  4 - 0.036%


Combination 32-bytes [0-last] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8248 (1.01x) (62)
Testing collisions (high 26-40 bits) - Worst is 37 bits: 279/255 (1.09x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8246 (1.01x) (60)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 20-bit window at bit 51 - 0.040%


Combination 64-bytes [0-1] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8174 (1.00x) (-12)
Testing collisions (high 26-40 bits) - Worst is 38 bits: 136/127 (1.06x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8053 (0.98x) (-133)
Testing collisions (low  26-40 bits) - Worst is 37 bits: 269/255 (1.05x)
Testing distribution - Worst bias is the 20-bit window at bit 46 - 0.043%


Combination 64-bytes [0-last] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8175 (1.00x) (-11)
Testing collisions (high 26-40 bits) - Worst is 39 bits: 68/63 (1.06x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8116 (0.99x) (-70)
Testing collisions (low  26-40 bits) - Worst is 40 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 20-bit window at bit 10 - 0.042%


Combination 128-bytes [0-1] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8223 (1.00x) (37)
Testing collisions (high 26-40 bits) - Worst is 38 bits: 130/127 (1.02x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8294 (1.01x) (108)
Testing collisions (low  26-40 bits) - Worst is 38 bits: 149/127 (1.16x)
Testing distribution - Worst bias is the 20-bit window at bit 55 - 0.045%


Combination 128-bytes [0-last] Tests:
Keyset 'Combination' - up to 22 blocks from a set of 2 - 8388606 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8186.7, actual   8163 (1.00x) (-23)
Testing collisions (high 26-40 bits) - Worst is 40 bits: 38/31 (1.19x)
Testing collisions (low  32-bit) - Expected       8186.7, actual   8198 (1.00x) (12)
Testing collisions (low  26-40 bits) - Worst is 35 bits: 1055/1023 (1.03x)
Testing distribution - Worst bias is the 20-bit window at bit 45 - 0.041%


[[[ Keyset 'Window' Tests ]]]

Keyset 'Window' -  32-bit key,  25-bit window - 32 tests, 33554432 keys per test
Window at   0 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   1 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   2 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   3 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   4 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   5 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   6 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   7 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   8 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at   9 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  10 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  11 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  12 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  13 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  14 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  15 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  16 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  17 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  18 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  19 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  20 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  21 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  22 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  23 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  24 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  25 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  26 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  27 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  28 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  29 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  30 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  31 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Window at  32 - Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)

[[[ Keyset 'Cyclic' Tests ]]]

Keyset 'Cyclic' - 8 cycles of 8 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    104 (0.89x)
Testing collisions (high 23-34 bits) - Worst is 24 bits: 29355/29218 (1.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    107 (0.92x)
Testing collisions (low  23-34 bits) - Worst is 34 bits: 34/29 (1.17x)
Testing distribution - Worst bias is the 17-bit window at bit 20 - 0.156%

Keyset 'Cyclic' - 8 cycles of 9 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    117 (1.01x) (1)
Testing collisions (high 23-34 bits) - Worst is 32 bits: 117/116 (1.01x)
Testing collisions (low  32-bit) - Expected        116.4, actual    111 (0.95x)
Testing collisions (low  23-34 bits) - Worst is 34 bits: 36/29 (1.24x)
Testing distribution - Worst bias is the 17-bit window at bit 40 - 0.129%

Keyset 'Cyclic' - 8 cycles of 10 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual     95 (0.82x)
Testing collisions (high 23-34 bits) - Worst is 24 bits: 29375/29218 (1.01x)
Testing collisions (low  32-bit) - Expected        116.4, actual    136 (1.17x) (20)
Testing collisions (low  23-34 bits) - Worst is 34 bits: 36/29 (1.24x)
Testing distribution - Worst bias is the 17-bit window at bit 12 - 0.166%

Keyset 'Cyclic' - 8 cycles of 11 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    110 (0.94x)
Testing collisions (high 23-34 bits) - Worst is 23 bits: 57228/57305 (1.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    128 (1.10x) (12)
Testing collisions (low  23-34 bits) - Worst is 34 bits: 34/29 (1.17x)
Testing distribution - Worst bias is the 17-bit window at bit 40 - 0.096%

Keyset 'Cyclic' - 8 cycles of 12 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    102 (0.88x)
Testing collisions (high 23-34 bits) - Worst is 34 bits: 30/29 (1.03x)
Testing collisions (low  32-bit) - Expected        116.4, actual    111 (0.95x)
Testing collisions (low  23-34 bits) - Worst is 24 bits: 29234/29218 (1.00x)
Testing distribution - Worst bias is the 17-bit window at bit 27 - 0.099%

Keyset 'Cyclic' - 8 cycles of 16 bytes - 1000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    128 (1.10x) (12)
Testing collisions (high 23-34 bits) - Worst is 34 bits: 36/29 (1.24x)
Testing collisions (low  32-bit) - Expected        116.4, actual    115 (0.99x) (-1)
Testing collisions (low  23-34 bits) - Worst is 29 bits: 930/930 (1.00x)
Testing distribution - Worst bias is the 17-bit window at bit 30 - 0.148%


[[[ Keyset 'TwoBytes' Tests ]]]

Keyset 'TwoBytes' - up-to-4-byte keys, 652545 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected         49.6, actual     47 (0.95x)
Testing collisions (high 23-33 bits) - Worst is 33 bits: 29/24 (1.17x)
Testing collisions (low  32-bit) - Expected         49.6, actual     47 (0.95x)
Testing collisions (low  23-33 bits) - Worst is 33 bits: 27/24 (1.09x)
Testing distribution - Worst bias is the 16-bit window at bit 16 - 0.189%

Keyset 'TwoBytes' - up-to-8-byte keys, 5471025 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       3483.1, actual   3504 (1.01x) (21)
Testing collisions (high 26-39 bits) - Worst is 39 bits: 31/27 (1.14x)
Testing collisions (low  32-bit) - Expected       3483.1, actual   3493 (1.00x) (10)
Testing collisions (low  26-39 bits) - Worst is 39 bits: 38/27 (1.40x)
Testing distribution - Worst bias is the 20-bit window at bit 52 - 0.096%

Keyset 'TwoBytes' - up-to-12-byte keys, 18616785 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      40289.5, actual  40041 (0.99x) (-248)
Testing collisions (high 27-42 bits) - Worst is 42 bits: 45/39 (1.14x)
Testing collisions (low  32-bit) - Expected      40289.5, actual  40866 (1.01x) (577)
Testing collisions (low  27-42 bits) - Worst is 40 bits: 177/157 (1.12x)
Testing distribution - Worst bias is the 20-bit window at bit 18 - 0.021%

Keyset 'TwoBytes' - up-to-16-byte keys, 44251425 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected     227182.3, actual 227276 (1.00x) (94)
Testing collisions (high 29-45 bits) - Worst is 40 bits: 938/890 (1.05x)
Testing collisions (low  32-bit) - Expected     227182.3, actual 227236 (1.00x) (54)
Testing collisions (low  29-45 bits) - Worst is 45 bits: 37/27 (1.33x)
Testing distribution - Worst bias is the 20-bit window at bit 18 - 0.006%

Keyset 'TwoBytes' - up-to-20-byte keys, 86536545 total keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected     865959.1, actual 866307 (1.00x) (348)
Testing collisions (high 30-47 bits) - Worst is 37 bits: 27622/27237 (1.01x)
Testing collisions (low  32-bit) - Expected     865959.1, actual 865094 (1.00x) (-865)
Testing collisions (low  30-47 bits) - Worst is 46 bits: 68/53 (1.28x)
Testing distribution - Worst bias is the 20-bit window at bit 37 - 0.004%


[[[ Keyset 'Text' Tests ]]]

Keyset 'Text' - keys of form "FooXXXXBar" - 14776336 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      25389.0, actual  25376 (1.00x) (-13)
Testing collisions (high 27-42 bits) - Worst is 42 bits: 26/24 (1.05x)
Testing collisions (low  32-bit) - Expected      25389.0, actual  25263 (1.00x) (-126)
Testing collisions (low  27-42 bits) - Worst is 38 bits: 425/397 (1.07x)
Testing distribution - Worst bias is the 19-bit window at bit 27 - 0.018%

Keyset 'Text' - keys of form "FooBarXXXX" - 14776336 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      25389.0, actual  25364 (1.00x) (-25)
Testing collisions (high 27-42 bits) - Worst is 42 bits: 27/24 (1.09x)
Testing collisions (low  32-bit) - Expected      25389.0, actual  25570 (1.01x) (181)
Testing collisions (low  27-42 bits) - Worst is 42 bits: 30/24 (1.21x)
Testing distribution - Worst bias is the 20-bit window at bit 13 - 0.031%

Keyset 'Text' - keys of form "XXXXFooBar" - 14776336 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      25389.0, actual  25556 (1.01x) (167)
Testing collisions (high 27-42 bits) - Worst is 41 bits: 63/49 (1.27x)
Testing collisions (low  32-bit) - Expected      25389.0, actual  25622 (1.01x) (233)
Testing collisions (low  27-42 bits) - Worst is 39 bits: 212/198 (1.07x)
Testing distribution - Worst bias is the 20-bit window at bit 54 - 0.031%

Keyset 'Words' - 4000000 random keys of len 6-16 from alnum charset
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1862.1, actual   1859 (1.00x) (-3)
Testing collisions (high 25-38 bits) - Worst is 37 bits: 70/58 (1.20x)
Testing collisions (low  32-bit) - Expected       1862.1, actual   1926 (1.03x) (64)
Testing collisions (low  25-38 bits) - Worst is 38 bits: 36/29 (1.24x)
Testing distribution - Worst bias is the 19-bit window at bit 30 - 0.067%

Keyset 'Words' - 4000000 random keys of len 6-16 from password charset
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1862.1, actual   1860 (1.00x) (-2)
Testing collisions (high 25-38 bits) - Worst is 27 bits: 59197/59016 (1.00x)
Testing collisions (low  32-bit) - Expected       1862.1, actual   1829 (0.98x) (-33)
Testing collisions (low  25-38 bits) - Worst is 25 bits: 228540/229220 (1.00x)
Testing distribution - Worst bias is the 19-bit window at bit  7 - 0.042%

Keyset 'Words' - 466569 dict words
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected         25.3, actual     31 (1.22x) (6)
Testing collisions (high 22-32 bits) - Worst is 32 bits: 31/25 (1.22x)
Testing collisions (low  32-bit) - Expected         25.3, actual     20 (0.79x)
Testing collisions (low  22-32 bits) - Worst is 26 bits: 1650/1618 (1.02x)
Testing distribution - Worst bias is the 16-bit window at bit  1 - 0.220%


[[[ Keyset 'Zeroes' Tests ]]]

Keyset 'Zeroes' - 204800 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          4.9, actual      5 (1.02x) (1)
Testing collisions (high 21-29 bits) - Worst is 29 bits: 44/39 (1.13x)
Testing collisions (low  32-bit) - Expected          4.9, actual      4 (0.82x)
Testing collisions (low  21-29 bits) - Worst is 29 bits: 49/39 (1.25x)
Testing distribution - Worst bias is the 15-bit window at bit 29 - 0.313%


[[[ Keyset 'Seed' Tests ]]]

Keyset 'Seed' - 5000000 keys
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2909.3, actual   2994 (1.03x) (85)
Testing collisions (high 26-39 bits) - Worst is 37 bits: 103/90 (1.13x)
Testing collisions (low  32-bit) - Expected       2909.3, actual   2973 (1.02x) (64)
Testing collisions (low  26-39 bits) - Worst is 39 bits: 36/22 (1.58x)
Testing distribution - Worst bias is the 19-bit window at bit 10 - 0.042%


[[[ Keyset 'PerlinNoise' Tests ]]]

Testing 16777216 coordinates (L2) : 
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      32725.4, actual  32957 (1.01x) (232)
Testing collisions (high 27-42 bits) - Worst is 41 bits: 71/63 (1.11x)
Testing collisions (low  32-bit) - Expected      32725.4, actual  32857 (1.00x) (132)
Testing collisions (low  27-42 bits) - Worst is 41 bits: 69/63 (1.08x)

Testing AV variant, 128 count with 4 spacing, 4-12:
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1116.2, actual   1110 (0.99x) (-6)
Testing collisions (high 25-37 bits) - Worst is 31 bits: 2271/2231 (1.02x)
Testing collisions (low  32-bit) - Expected       1116.2, actual   1068 (0.96x)
Testing collisions (low  25-37 bits) - Worst is 37 bits: 42/34 (1.20x)


[[[ Diff 'Differential' Tests ]]]

Testing 8303632 up-to-5-bit differentials in 64-bit keys -> 64 bit hashes.
1000 reps, 8303632000 total tests, expecting 0.00 random collisions..........
0 total collisions, of which 0 single collisions were ignored

Testing 11017632 up-to-4-bit differentials in 128-bit keys -> 64 bit hashes.
1000 reps, 11017632000 total tests, expecting 0.00 random collisions..........
0 total collisions, of which 0 single collisions were ignored

Testing 2796416 up-to-3-bit differentials in 256-bit keys -> 64 bit hashes.
1000 reps, 2796416000 total tests, expecting 0.00 random collisions..........
0 total collisions, of which 0 single collisions were ignored


[[[ DiffDist 'Differential Distribution' Tests ]]]

Testing bit 0
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    473 (0.92x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 38/31 (1.19x)
Testing collisions (low  32-bit) - Expected        511.9, actual    515 (1.01x) (4)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 145/127 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 23 - 0.095%

Testing bit 1
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    503 (0.98x) (-8)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 42/31 (1.31x)
Testing collisions (low  32-bit) - Expected        511.9, actual    499 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 17-bit window at bit 23 - 0.077%

Testing bit 2
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    479 (0.94x)
Testing collisions (high 24-36 bits) - Worst is 28 bits: 8185/8170 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    538 (1.05x) (27)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 136/127 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 26 - 0.062%

Testing bit 3
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    490 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2047/2046 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    500 (0.98x)
Testing collisions (low  24-36 bits) - Worst is 28 bits: 8326/8170 (1.02x)
Testing distribution - Worst bias is the 18-bit window at bit 10 - 0.061%

Testing bit 4
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    515 (1.01x) (4)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 142/127 (1.11x)
Testing collisions (low  32-bit) - Expected        511.9, actual    463 (0.90x)
Testing collisions (low  24-36 bits) - Worst is 25 bits: 64159/64191 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 26 - 0.076%

Testing bit 5
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    501 (0.98x)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 135/127 (1.05x)
Testing collisions (low  32-bit) - Expected        511.9, actual    534 (1.04x) (23)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 70/63 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 58 - 0.071%

Testing bit 6
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    503 (0.98x) (-8)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 39/31 (1.22x)
Testing collisions (low  32-bit) - Expected        511.9, actual    537 (1.05x) (26)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 140/127 (1.09x)
Testing distribution - Worst bias is the 17-bit window at bit 28 - 0.054%

Testing bit 7
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    553 (1.08x) (42)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 278/255 (1.09x)
Testing collisions (low  32-bit) - Expected        511.9, actual    533 (1.04x) (22)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 142/127 (1.11x)
Testing distribution - Worst bias is the 17-bit window at bit 60 - 0.058%

Testing bit 8
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    519 (1.01x) (8)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 73/63 (1.14x)
Testing collisions (low  32-bit) - Expected        511.9, actual    519 (1.01x) (8)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 519/511 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 41 - 0.088%

Testing bit 9
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    527 (1.03x) (16)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 269/255 (1.05x)
Testing collisions (low  32-bit) - Expected        511.9, actual    546 (1.07x) (35)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 147/127 (1.15x)
Testing distribution - Worst bias is the 18-bit window at bit 29 - 0.063%

Testing bit 10
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 131/127 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    533 (1.04x) (22)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 50 - 0.081%

Testing bit 11
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing collisions (low  32-bit) - Expected        511.9, actual    492 (0.96x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 67/63 (1.05x)
Testing distribution - Worst bias is the 17-bit window at bit 45 - 0.064%

Testing bit 12
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    539 (1.05x) (28)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing collisions (low  32-bit) - Expected        511.9, actual    565 (1.10x) (54)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 79/63 (1.23x)
Testing distribution - Worst bias is the 18-bit window at bit 16 - 0.086%

Testing bit 13
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 517/511 (1.01x)
Testing collisions (low  32-bit) - Expected        511.9, actual    471 (0.92x)
Testing collisions (low  24-36 bits) - Worst is 24 bits: 125649/125777 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 29 - 0.071%

Testing bit 14
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    494 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 66/63 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    502 (0.98x) (-9)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 76/63 (1.19x)
Testing distribution - Worst bias is the 18-bit window at bit 54 - 0.104%

Testing bit 15
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    513 (1.00x) (2)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 513/511 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    513 (1.00x) (2)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2182/2046 (1.07x)
Testing distribution - Worst bias is the 18-bit window at bit  7 - 0.062%

Testing bit 16
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    521 (1.02x) (10)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2094/2046 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    497 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 132/127 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 48 - 0.103%

Testing bit 17
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    480 (0.94x)
Testing collisions (high 24-36 bits) - Worst is 25 bits: 64414/64191 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    480 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 69/63 (1.08x)
Testing distribution - Worst bias is the 18-bit window at bit 30 - 0.090%

Testing bit 18
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    513 (1.00x) (2)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 142/127 (1.11x)
Testing collisions (low  32-bit) - Expected        511.9, actual    535 (1.05x) (24)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 44/31 (1.38x)
Testing distribution - Worst bias is the 18-bit window at bit 41 - 0.072%

Testing bit 19
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    556 (1.09x) (45)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 144/127 (1.13x)
Testing collisions (low  32-bit) - Expected        511.9, actual    488 (0.95x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 72/63 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 45 - 0.055%

Testing bit 20
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    502 (0.98x) (-9)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 283/255 (1.11x)
Testing collisions (low  32-bit) - Expected        511.9, actual    548 (1.07x) (37)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 38/31 (1.19x)
Testing distribution - Worst bias is the 18-bit window at bit 35 - 0.061%

Testing bit 21
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    489 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 29 bits: 4170/4090 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    498 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 26 - 0.063%

Testing bit 22
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    494 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    535 (1.05x) (24)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 135/127 (1.05x)
Testing distribution - Worst bias is the 18-bit window at bit 35 - 0.111%

Testing bit 23
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    486 (0.95x)
Testing collisions (high 24-36 bits) - Worst is 28 bits: 8215/8170 (1.01x)
Testing collisions (low  32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 266/255 (1.04x)
Testing distribution - Worst bias is the 18-bit window at bit 42 - 0.096%

Testing bit 24
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    511 (1.00x)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 139/127 (1.09x)
Testing collisions (low  32-bit) - Expected        511.9, actual    488 (0.95x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 48 - 0.085%

Testing bit 25
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    484 (0.95x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 35/31 (1.09x)
Testing collisions (low  32-bit) - Expected        511.9, actual    532 (1.04x) (21)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing distribution - Worst bias is the 18-bit window at bit  2 - 0.072%

Testing bit 26
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    521 (1.02x) (10)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1046/1023 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 144/127 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 44 - 0.060%

Testing bit 27
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    521 (1.02x) (10)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing collisions (low  32-bit) - Expected        511.9, actual    513 (1.00x) (2)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 18-bit window at bit 12 - 0.067%

Testing bit 28
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    491 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    492 (0.96x)
Testing collisions (low  24-36 bits) - Worst is 31 bits: 1027/1023 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 44 - 0.072%

Testing bit 29
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    560 (1.09x) (49)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 153/127 (1.20x)
Testing collisions (low  32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 132/127 (1.03x)
Testing distribution - Worst bias is the 17-bit window at bit 59 - 0.067%

Testing bit 30
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    484 (0.95x)
Testing collisions (high 24-36 bits) - Worst is 29 bits: 4102/4090 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    516 (1.01x) (5)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 516/511 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 16 - 0.084%

Testing bit 31
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    549 (1.07x) (38)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 549/511 (1.07x)
Testing collisions (low  32-bit) - Expected        511.9, actual    509 (0.99x) (-2)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 144/127 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit  6 - 0.070%

Testing bit 32
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 138/127 (1.08x)
Testing collisions (low  32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 31 - 0.086%

Testing bit 33
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    536 (1.05x) (25)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 271/255 (1.06x)
Testing collisions (low  32-bit) - Expected        511.9, actual    568 (1.11x) (57)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 79/63 (1.23x)
Testing distribution - Worst bias is the 18-bit window at bit  9 - 0.075%

Testing bit 34
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    510 (1.00x) (-1)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing collisions (low  32-bit) - Expected        511.9, actual    512 (1.00x) (1)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 257/255 (1.00x)
Testing distribution - Worst bias is the 17-bit window at bit 24 - 0.047%

Testing bit 35
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 38/31 (1.19x)
Testing collisions (low  32-bit) - Expected        511.9, actual    530 (1.04x) (19)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 17-bit window at bit 28 - 0.061%

Testing bit 36
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    506 (0.99x) (-5)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 43/31 (1.34x)
Testing collisions (low  32-bit) - Expected        511.9, actual    501 (0.98x)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2062/2046 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 16 - 0.092%

Testing bit 37
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    509 (0.99x) (-2)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing collisions (low  32-bit) - Expected        511.9, actual    527 (1.03x) (16)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 140/127 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 42 - 0.085%

Testing bit 38
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    489 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    556 (1.09x) (45)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 556/511 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 50 - 0.045%

Testing bit 39
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    535 (1.05x) (24)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 73/63 (1.14x)
Testing collisions (low  32-bit) - Expected        511.9, actual    539 (1.05x) (28)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 282/255 (1.10x)
Testing distribution - Worst bias is the 18-bit window at bit 27 - 0.081%

Testing bit 40
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    512 (1.00x) (1)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing collisions (low  32-bit) - Expected        511.9, actual    459 (0.90x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 26 - 0.095%

Testing bit 41
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 135/127 (1.05x)
Testing collisions (low  32-bit) - Expected        511.9, actual    537 (1.05x) (26)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 270/255 (1.05x)
Testing distribution - Worst bias is the 18-bit window at bit 31 - 0.100%

Testing bit 42
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    515 (1.01x) (4)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1041/1023 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    477 (0.93x)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2094/2046 (1.02x)
Testing distribution - Worst bias is the 18-bit window at bit 50 - 0.080%

Testing bit 43
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    525 (1.03x) (14)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 41/31 (1.28x)
Testing collisions (low  32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 276/255 (1.08x)
Testing distribution - Worst bias is the 18-bit window at bit 20 - 0.091%

Testing bit 44
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 39/31 (1.22x)
Testing collisions (low  32-bit) - Expected        511.9, actual    483 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2095/2046 (1.02x)
Testing distribution - Worst bias is the 18-bit window at bit 48 - 0.088%

Testing bit 45
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    559 (1.09x) (48)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 39/31 (1.22x)
Testing collisions (low  32-bit) - Expected        511.9, actual    558 (1.09x) (47)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 38/31 (1.19x)
Testing distribution - Worst bias is the 18-bit window at bit  4 - 0.073%

Testing bit 46
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    528 (1.03x) (17)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 39/31 (1.22x)
Testing collisions (low  32-bit) - Expected        511.9, actual    533 (1.04x) (22)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 271/255 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 50 - 0.073%

Testing bit 47
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    472 (0.92x)
Testing collisions (high 24-36 bits) - Worst is 24 bits: 125700/125777 (1.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    519 (1.01x) (8)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing distribution - Worst bias is the 18-bit window at bit 11 - 0.084%

Testing bit 48
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    492 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 26 bits: 32601/32429 (1.01x)
Testing collisions (low  32-bit) - Expected        511.9, actual    512 (1.00x) (1)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 139/127 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 46 - 0.053%

Testing bit 49
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    502 (0.98x) (-9)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1046/1023 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    544 (1.06x) (33)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 74/63 (1.16x)
Testing distribution - Worst bias is the 18-bit window at bit  5 - 0.074%

Testing bit 50
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    558 (1.09x) (47)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 71/63 (1.11x)
Testing collisions (low  32-bit) - Expected        511.9, actual    483 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 66/63 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 56 - 0.061%

Testing bit 51
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    496 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 132/127 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    500 (0.98x)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 266/255 (1.04x)
Testing distribution - Worst bias is the 18-bit window at bit 62 - 0.079%

Testing bit 52
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    499 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 28 bits: 8213/8170 (1.01x)
Testing collisions (low  32-bit) - Expected        511.9, actual    477 (0.93x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 28 - 0.110%

Testing bit 53
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 35/31 (1.09x)
Testing collisions (low  32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 39/31 (1.22x)
Testing distribution - Worst bias is the 18-bit window at bit  7 - 0.073%

Testing bit 54
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    546 (1.07x) (35)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 283/255 (1.11x)
Testing collisions (low  32-bit) - Expected        511.9, actual    518 (1.01x) (7)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit  5 - 0.079%

Testing bit 55
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    497 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 270/255 (1.05x)
Testing collisions (low  32-bit) - Expected        511.9, actual    527 (1.03x) (16)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 42/31 (1.31x)
Testing distribution - Worst bias is the 18-bit window at bit 54 - 0.066%

Testing bit 56
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    495 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 29 bits: 4143/4090 (1.01x)
Testing collisions (low  32-bit) - Expected        511.9, actual    520 (1.02x) (9)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 41/31 (1.28x)
Testing distribution - Worst bias is the 18-bit window at bit 17 - 0.112%

Testing bit 57
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    515 (1.01x) (4)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 71/63 (1.11x)
Testing collisions (low  32-bit) - Expected        511.9, actual    539 (1.05x) (28)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 140/127 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 57 - 0.142%

Testing bit 58
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    496 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 131/127 (1.02x)
Testing collisions (low  32-bit) - Expected        511.9, actual    528 (1.03x) (17)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 269/255 (1.05x)
Testing distribution - Worst bias is the 18-bit window at bit 20 - 0.091%

Testing bit 59
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 41/31 (1.28x)
Testing collisions (low  32-bit) - Expected        511.9, actual    541 (1.06x) (30)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 146/127 (1.14x)
Testing distribution - Worst bias is the 18-bit window at bit  4 - 0.056%

Testing bit 60
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    497 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 82/63 (1.28x)
Testing collisions (low  32-bit) - Expected        511.9, actual    488 (0.95x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 15 - 0.083%

Testing bit 61
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    545 (1.06x) (34)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 545/511 (1.06x)
Testing collisions (low  32-bit) - Expected        511.9, actual    526 (1.03x) (15)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 526/511 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 12 - 0.083%

Testing bit 62
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    509 (0.99x) (-2)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 75/63 (1.17x)
Testing collisions (low  32-bit) - Expected        511.9, actual    530 (1.04x) (19)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 35/31 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 37 - 0.095%

Testing bit 63
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    525 (1.03x) (14)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 264/255 (1.03x)
Testing collisions (low  32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 68/63 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit  8 - 0.077%


[[[ MomentChi2 Tests ]]]

Analyze hashes produced from a serie of linearly increasing numbers of 32-bit, using a step of 2 ... 
Target values to approximate : 38918200.000000 - 273633.333333 
Popcount 1 stats : 38918998.920034 - 273638.558723
Popcount 0 stats : 38918770.531038 - 273645.996303
MomentChi2 for bits 1 :   1.16628 
MomentChi2 for bits 0 :  0.594771 

Derivative stats (transition from 2 consecutive values) : 
Popcount 1 stats : 38919257.619283 - 273628.012809
Popcount 0 stats : 38918472.697479 - 273650.071385
MomentChi2 for deriv b1 :   2.04392 
MomentChi2 for deriv b0 :  0.135878 

  Great 


[[[ Prng Tests ]]]

Generating 33554432 random numbers : 
Testing collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected     130731.3, actual 130884 (1.00x) (153)
Testing collisions (high 28-44 bits) - Worst is 43 bits: 75/63 (1.17x)
Testing collisions (low  32-bit) - Expected     130731.3, actual 131211 (1.00x) (480)
Testing collisions (low  28-44 bits) - Worst is 43 bits: 68/63 (1.06x)

[[[ BadSeeds Tests ]]]

0x0 PASS


Input vcode 0x00000001, Output vcode 0x00000001, Result vcode 0x00000001
Verification value is 0x00000001 - Testing took 755.424002 seconds
------------------------------------------------------------
```

------------------------------------------------------------
### Stable Hash 128bit SMHasher Results

The following results were achieved on my personal computer when testing the 128bit variant of the facil.io Stable Hash (`fio_stable_hash128`).

```txt
------------------------------------------------------------
--- Testing Stable128 "facil.io Stable Hash 128bit" GOOD

[[[ Sanity Tests ]]]

Verification value 0x97D1AB52 ....... PASS
Running sanity check 1     .......... PASS
Running AppendedZeroesTest .......... PASS

[[[ Speed Tests ]]]

Bulk speed test - 262144-byte keys
Alignment  7 - 12.633 bytes/cycle - 36143.93 MiB/sec @ 3 ghz
Alignment  6 - 12.651 bytes/cycle - 36193.49 MiB/sec @ 3 ghz
Alignment  5 - 12.646 bytes/cycle - 36179.39 MiB/sec @ 3 ghz
Alignment  4 - 12.644 bytes/cycle - 36174.76 MiB/sec @ 3 ghz
Alignment  3 - 12.656 bytes/cycle - 36208.15 MiB/sec @ 3 ghz
Alignment  2 - 12.650 bytes/cycle - 36192.29 MiB/sec @ 3 ghz
Alignment  1 - 12.644 bytes/cycle - 36175.29 MiB/sec @ 3 ghz
Alignment  0 - 12.797 bytes/cycle - 36612.89 MiB/sec @ 3 ghz
Average      - 12.665 bytes/cycle - 36235.02 MiB/sec @ 3 ghz

Small key speed test -    1-byte keys -    21.00 cycles/hash
Small key speed test -    2-byte keys -    21.81 cycles/hash
Small key speed test -    3-byte keys -    22.97 cycles/hash
Small key speed test -    4-byte keys -    21.99 cycles/hash
Small key speed test -    5-byte keys -    22.69 cycles/hash
Small key speed test -    6-byte keys -    22.00 cycles/hash
Small key speed test -    7-byte keys -    23.92 cycles/hash
Small key speed test -    8-byte keys -    21.98 cycles/hash
Small key speed test -    9-byte keys -    21.99 cycles/hash
Small key speed test -   10-byte keys -    21.99 cycles/hash
Small key speed test -   11-byte keys -    21.99 cycles/hash
Small key speed test -   12-byte keys -    21.99 cycles/hash
Small key speed test -   13-byte keys -    21.99 cycles/hash
Small key speed test -   14-byte keys -    21.99 cycles/hash
Small key speed test -   15-byte keys -    21.99 cycles/hash
Small key speed test -   16-byte keys -    22.00 cycles/hash
Small key speed test -   17-byte keys -    23.98 cycles/hash
Small key speed test -   18-byte keys -    23.98 cycles/hash
Small key speed test -   19-byte keys -    23.98 cycles/hash
Small key speed test -   20-byte keys -    23.98 cycles/hash
Small key speed test -   21-byte keys -    23.97 cycles/hash
Small key speed test -   22-byte keys -    23.98 cycles/hash
Small key speed test -   23-byte keys -    23.98 cycles/hash
Small key speed test -   24-byte keys -    23.97 cycles/hash
Small key speed test -   25-byte keys -    23.97 cycles/hash
Small key speed test -   26-byte keys -    23.97 cycles/hash
Small key speed test -   27-byte keys -    23.97 cycles/hash
Small key speed test -   28-byte keys -    23.97 cycles/hash
Small key speed test -   29-byte keys -    23.97 cycles/hash
Small key speed test -   30-byte keys -    23.98 cycles/hash
Small key speed test -   31-byte keys -    24.18 cycles/hash
Average                                    23.037 cycles/hash

[[[ 'Hashmap' Speed Tests ]]]

std::unordered_map
Init std HashMapTest:     151.297 cycles/op (466569 inserts, 1% deletions)
Running std HashMapTest:  93.079 cycles/op (1.2 stdv, found 461903)

greg7mdp/parallel-hashmap
Init fast HashMapTest:    145.520 cycles/op (466569 inserts, 1% deletions)
Running fast HashMapTest: 91.867 cycles/op (0.7 stdv, found 461903)

facil.io HashMap
Init fast fio_map_s Test:    84.812 cycles/op (466569 inserts, 1% deletions)
Running fast fio_map_s Test: 48.436 cycles/op (0.4 stdv, found 461903)
 ....... PASS

[[[ Avalanche Tests ]]]

Testing   24-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.659333%
Testing   32-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.712000%
Testing   40-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.723333%
Testing   48-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.696667%
Testing   56-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.694000%
Testing   64-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.712000%
Testing   72-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.676000%
Testing   80-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.704667%
Testing   96-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.690667%
Testing  112-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.721333%
Testing  128-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.760667%
Testing  160-bit keys -> 128-bit hashes, 300000 reps.......... worst bias is 0.773333%

[[[ Keyset 'Sparse' Tests ]]]

Keyset 'Sparse' - 16-bit keys with up to 9 bits set - 50643 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          0.3, actual      0 (0.00x)
Testing collisions (high 19-25 bits) - Worst is 23 bits: 161/152 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          0.3, actual      0 (0.00x)
Testing collisions (low  19-25 bits) - Worst is 21 bits: 602/606 (0.99x)
Testing distribution - Worst bias is the 13-bit window at bit 31 - 0.586%

Keyset 'Sparse' - 24-bit keys with up to 8 bits set - 1271626 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        188.2, actual    190 (1.01x) (2)
Testing collisions (high 24-35 bits) - Worst is 32 bits: 190/188 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        188.2, actual    170 (0.90x)
Testing collisions (low  24-35 bits) - Worst is 26 bits: 12071/11972 (1.01x)
Testing distribution - Worst bias is the 17-bit window at bit 35 - 0.080%

Keyset 'Sparse' - 32-bit keys with up to 7 bits set - 4514873 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2372.2, actual   2355 (0.99x) (-17)
Testing collisions (high 25-38 bits) - Worst is 38 bits: 39/37 (1.05x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       2372.2, actual   2374 (1.00x) (2)
Testing collisions (low  25-38 bits) - Worst is 30 bits: 9492/9478 (1.00x)
Testing distribution - Worst bias is the 19-bit window at bit 74 - 0.065%

Keyset 'Sparse' - 40-bit keys with up to 6 bits set - 4598479 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2460.8, actual   2429 (0.99x) (-31)
Testing collisions (high 25-38 bits) - Worst is 29 bits: 19779/19637 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       2460.8, actual   2490 (1.01x) (30)
Testing collisions (low  25-38 bits) - Worst is 38 bits: 45/38 (1.17x)
Testing distribution - Worst bias is the 19-bit window at bit 82 - 0.051%

Keyset 'Sparse' - 48-bit keys with up to 6 bits set - 14196869 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      23437.8, actual  23636 (1.01x) (199)
Testing collisions (high 27-42 bits) - Worst is 42 bits: 24/22 (1.05x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected      23437.8, actual  23272 (0.99x) (-165)
Testing collisions (low  27-42 bits) - Worst is 30 bits: 93648/93442 (1.00x)
Testing distribution - Worst bias is the 20-bit window at bit 74 - 0.028%

Keyset 'Sparse' - 56-bit keys with up to 5 bits set - 4216423 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2069.0, actual   2045 (0.99x) (-23)
Testing collisions (high 25-38 bits) - Worst is 38 bits: 33/32 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       2069.0, actual   2042 (0.99x) (-26)
Testing collisions (low  25-38 bits) - Worst is 38 bits: 40/32 (1.24x)
Testing distribution - Worst bias is the 19-bit window at bit 96 - 0.061%

Keyset 'Sparse' - 64-bit keys with up to 5 bits set - 8303633 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       8021.7, actual   8104 (1.01x) (83)
Testing collisions (high 26-40 bits) - Worst is 40 bits: 39/31 (1.24x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       8021.7, actual   8038 (1.00x) (17)
Testing collisions (low  26-40 bits) - Worst is 31 bits: 16101/16033 (1.00x)
Testing distribution - Worst bias is the 20-bit window at bit 43 - 0.043%

Keyset 'Sparse' - 72-bit keys with up to 5 bits set - 15082603 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      26451.8, actual  26433 (1.00x) (-18)
Testing collisions (high 27-42 bits) - Worst is 41 bits: 55/51 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected      26451.8, actual  26434 (1.00x) (-17)
Testing collisions (low  27-42 bits) - Worst is 35 bits: 3324/3309 (1.00x)
Testing distribution - Worst bias is the 20-bit window at bit 26 - 0.028%

Keyset 'Sparse' - 96-bit keys with up to 4 bits set - 3469497 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1401.0, actual   1326 (0.95x)
Testing collisions (high 25-38 bits) - Worst is 38 bits: 22/21 (1.00x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       1401.0, actual   1406 (1.00x) (6)
Testing collisions (low  25-38 bits) - Worst is 37 bits: 60/43 (1.37x)
Testing distribution - Worst bias is the 19-bit window at bit 12 - 0.088%

Keyset 'Sparse' - 160-bit keys with up to 4 bits set - 26977161 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      84546.1, actual  84181 (1.00x) (-365)
Testing collisions (high 28-44 bits) - Worst is 43 bits: 54/41 (1.31x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected      84546.1, actual  84586 (1.00x) (40)
Testing collisions (low  28-44 bits) - Worst is 41 bits: 172/165 (1.04x)
Testing distribution - Worst bias is the 20-bit window at bit 39 - 0.017%

Keyset 'Sparse' - 256-bit keys with up to 3 bits set - 2796417 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        910.2, actual    920 (1.01x) (10)
Testing collisions (high 25-37 bits) - Worst is 36 bits: 65/56 (1.14x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        910.2, actual    925 (1.02x) (15)
Testing collisions (low  25-37 bits) - Worst is 33 bits: 473/455 (1.04x)
Testing distribution - Worst bias is the 19-bit window at bit 73 - 0.096%


[[[ Keyset 'Permutation' Tests ]]]

Combination Lowbits Tests:
Keyset 'Combination' - up to 7 blocks from a set of 8 - 2396744 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        668.6, actual    735 (1.10x) (67)
Testing collisions (high 24-37 bits) - Worst is 34 bits: 207/167 (1.24x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        668.6, actual    655 (0.98x)
Testing collisions (low  24-37 bits) - Worst is 34 bits: 173/167 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit  9 - 0.080%


Combination Highbits Tests
Keyset 'Combination' - up to 7 blocks from a set of 8 - 2396744 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        668.6, actual    681 (1.02x) (13)
Testing collisions (high 24-37 bits) - Worst is 37 bits: 26/20 (1.24x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        668.6, actual    691 (1.03x) (23)
Testing collisions (low  24-37 bits) - Worst is 33 bits: 362/334 (1.08x)
Testing distribution - Worst bias is the 18-bit window at bit 68 - 0.091%


Combination Hi-Lo Tests:
Keyset 'Combination' - up to 6 blocks from a set of 15 - 12204240 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      17322.9, actual  17433 (1.01x) (111)
Testing collisions (high 27-41 bits) - Worst is 34 bits: 4416/4333 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected      17322.9, actual  17214 (0.99x) (-108)
Testing collisions (low  27-41 bits) - Worst is 28 bits: 273805/273271 (1.00x)
Testing distribution - Worst bias is the 20-bit window at bit  3 - 0.030%


Combination 0x8000000 Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      9 (1.13x) (2)
Testing collisions (high 21-30 bits) - Worst is 28 bits: 135/127 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual     12 (1.50x) (5)
Testing collisions (low  21-30 bits) - Worst is 30 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 15-bit window at bit 48 - 0.268%


Combination 0x0000001 Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      9 (1.13x) (2)
Testing collisions (high 21-30 bits) - Worst is 26 bits: 537/511 (1.05x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual      8 (1.00x) (1)
Testing collisions (low  21-30 bits) - Worst is 29 bits: 73/63 (1.14x)
Testing distribution - Worst bias is the 15-bit window at bit 119 - 0.328%


Combination 0x800000000000000 Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      1 (0.13x)
Testing collisions (high 21-30 bits) - Worst is 24 bits: 2103/2037 (1.03x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual      8 (1.00x) (1)
Testing collisions (low  21-30 bits) - Worst is 30 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 15-bit window at bit 15 - 0.279%


Combination 0x000000000000001 Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      9 (1.13x) (2)
Testing collisions (high 21-30 bits) - Worst is 29 bits: 72/63 (1.13x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual     10 (1.25x) (3)
Testing collisions (low  21-30 bits) - Worst is 24 bits: 2041/2037 (1.00x)
Testing distribution - Worst bias is the 15-bit window at bit  2 - 0.203%


Combination 16-bytes [0-1] Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      3 (0.38x)
Testing collisions (high 21-30 bits) - Worst is 30 bits: 33/31 (1.03x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual     15 (1.88x) (8)
Testing collisions (low  21-30 bits) - Worst is 27 bits: 262/255 (1.02x)
Testing distribution - Worst bias is the 15-bit window at bit 21 - 0.203%


Combination 16-bytes [0-last] Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      7 (0.88x)
Testing collisions (high 21-30 bits) - Worst is 28 bits: 132/127 (1.03x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual      7 (0.88x)
Testing collisions (low  21-30 bits) - Worst is 25 bits: 1037/1021 (1.02x)
Testing distribution - Worst bias is the 15-bit window at bit 47 - 0.252%


Combination 32-bytes [0-1] Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual     13 (1.63x) (6)
Testing collisions (high 21-30 bits) - Worst is 30 bits: 41/31 (1.28x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual      6 (0.75x)
Testing collisions (low  21-30 bits) - Worst is 25 bits: 1034/1021 (1.01x)
Testing distribution - Worst bias is the 15-bit window at bit 43 - 0.259%


Combination 32-bytes [0-last] Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      5 (0.63x)
Testing collisions (high 21-30 bits) - Worst is 29 bits: 67/63 (1.05x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual      4 (0.50x)
Testing collisions (low  21-30 bits) - Worst is 29 bits: 70/63 (1.09x)
Testing distribution - Worst bias is the 15-bit window at bit 24 - 0.293%


Combination 64-bytes [0-1] Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      8 (1.00x) (1)
Testing collisions (high 21-30 bits) - Worst is 22 bits: 8144/8023 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual      3 (0.38x)
Testing collisions (low  21-30 bits) - Worst is 28 bits: 151/127 (1.18x)
Testing distribution - Worst bias is the 15-bit window at bit 74 - 0.329%


Combination 64-bytes [0-last] Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      8 (1.00x) (1)
Testing collisions (high 21-30 bits) - Worst is 27 bits: 286/255 (1.12x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual      4 (0.50x)
Testing collisions (low  21-30 bits) - Worst is 24 bits: 2098/2037 (1.03x)
Testing distribution - Worst bias is the 15-bit window at bit 118 - 0.211%


Combination 128-bytes [0-1] Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual      7 (0.88x)
Testing collisions (high 21-30 bits) - Worst is 26 bits: 553/511 (1.08x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual      7 (0.88x)
Testing collisions (low  21-30 bits) - Worst is 29 bits: 78/63 (1.22x)
Testing distribution - Worst bias is the 15-bit window at bit 57 - 0.323%


Combination 128-bytes [0-last] Tests:
Keyset 'Combination' - up to 17 blocks from a set of 2 - 262142 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          8.0, actual     11 (1.38x) (4)
Testing collisions (high 21-30 bits) - Worst is 28 bits: 136/127 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          8.0, actual     13 (1.63x) (6)
Testing collisions (low  21-30 bits) - Worst is 30 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 15-bit window at bit 125 - 0.223%


[[[ Keyset 'Window' Tests ]]]

Keyset 'Window' -  32-bit key,  25-bit window - 32 tests, 33554432 keys per test
Window at   0 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at   1 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at   2 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at   3 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at   4 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at   5 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at   6 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at   7 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at   8 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at   9 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  10 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  11 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  12 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  13 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  14 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  15 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  16 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  17 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  18 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  19 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  20 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  21 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  22 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  23 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  24 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  25 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  26 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  27 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  28 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  29 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  30 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  31 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Window at  32 - Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)

[[[ Keyset 'Cyclic' Tests ]]]

Keyset 'Cyclic' - 8 cycles of 16 bytes - 1000000 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    115 (0.99x) (-1)
Testing collisions (high 23-34 bits) - Worst is 33 bits: 63/58 (1.08x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    115 (0.99x) (-1)
Testing collisions (low  23-34 bits) - Worst is 29 bits: 930/930 (1.00x)
Testing distribution - Worst bias is the 17-bit window at bit 30 - 0.148%

Keyset 'Cyclic' - 8 cycles of 17 bytes - 1000000 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    115 (0.99x) (-1)
Testing collisions (high 23-34 bits) - Worst is 28 bits: 1937/1860 (1.04x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    123 (1.06x) (7)
Testing collisions (low  23-34 bits) - Worst is 31 bits: 264/232 (1.13x)
Testing distribution - Worst bias is the 17-bit window at bit 38 - 0.131%

Keyset 'Cyclic' - 8 cycles of 18 bytes - 1000000 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    104 (0.89x)
Testing collisions (high 23-34 bits) - Worst is 28 bits: 1911/1860 (1.03x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    113 (0.97x)
Testing collisions (low  23-34 bits) - Worst is 31 bits: 240/232 (1.03x)
Testing distribution - Worst bias is the 17-bit window at bit 58 - 0.123%

Keyset 'Cyclic' - 8 cycles of 19 bytes - 1000000 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    116 (1.00x)
Testing collisions (high 23-34 bits) - Worst is 34 bits: 33/29 (1.13x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    100 (0.86x)
Testing collisions (low  23-34 bits) - Worst is 28 bits: 1891/1860 (1.02x)
Testing distribution - Worst bias is the 17-bit window at bit  4 - 0.103%

Keyset 'Cyclic' - 8 cycles of 20 bytes - 1000000 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual     97 (0.83x)
Testing collisions (high 23-34 bits) - Worst is 28 bits: 1903/1860 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    125 (1.07x) (9)
Testing collisions (low  23-34 bits) - Worst is 34 bits: 36/29 (1.24x)
Testing distribution - Worst bias is the 17-bit window at bit 32 - 0.172%

Keyset 'Cyclic' - 8 cycles of 24 bytes - 1000000 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        116.4, actual    116 (1.00x)
Testing collisions (high 23-34 bits) - Worst is 34 bits: 32/29 (1.10x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        116.4, actual    131 (1.13x) (15)
Testing collisions (low  23-34 bits) - Worst is 34 bits: 38/29 (1.31x)
Testing distribution - Worst bias is the 17-bit window at bit 11 - 0.148%


[[[ Keyset 'TwoBytes' Tests ]]]

Keyset 'TwoBytes' - up-to-4-byte keys, 652545 total keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected         49.6, actual     50 (1.01x) (1)
Testing collisions (high 23-33 bits) - Worst is 33 bits: 27/24 (1.09x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected         49.6, actual     47 (0.95x)
Testing collisions (low  23-33 bits) - Worst is 33 bits: 27/24 (1.09x)
Testing distribution - Worst bias is the 16-bit window at bit 16 - 0.189%

Keyset 'TwoBytes' - up-to-8-byte keys, 5471025 total keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       3483.1, actual   3479 (1.00x) (-4)
Testing collisions (high 26-39 bits) - Worst is 35 bits: 484/435 (1.11x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       3483.1, actual   3493 (1.00x) (10)
Testing collisions (low  26-39 bits) - Worst is 39 bits: 38/27 (1.40x)
Testing distribution - Worst bias is the 20-bit window at bit 11 - 0.064%

Keyset 'TwoBytes' - up-to-12-byte keys, 18616785 total keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      40289.5, actual  39913 (0.99x) (-376)
Testing collisions (high 27-42 bits) - Worst is 41 bits: 81/78 (1.03x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected      40289.5, actual  40866 (1.01x) (577)
Testing collisions (low  27-42 bits) - Worst is 40 bits: 177/157 (1.12x)
Testing distribution - Worst bias is the 20-bit window at bit 18 - 0.021%


[[[ Keyset 'Text' Tests ]]]

Keyset 'Text' - keys of form "FooXXXXBar" - 14776336 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      25389.0, actual  25586 (1.01x) (197)
Testing collisions (high 27-42 bits) - Worst is 38 bits: 422/397 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected      25389.0, actual  25263 (1.00x) (-126)
Testing collisions (low  27-42 bits) - Worst is 38 bits: 425/397 (1.07x)
Testing distribution - Worst bias is the 20-bit window at bit 57 - 0.021%

Keyset 'Text' - keys of form "FooBarXXXX" - 14776336 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      25389.0, actual  25629 (1.01x) (240)
Testing collisions (high 27-42 bits) - Worst is 34 bits: 6431/6352 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected      25389.0, actual  25570 (1.01x) (181)
Testing collisions (low  27-42 bits) - Worst is 42 bits: 30/24 (1.21x)
Testing distribution - Worst bias is the 20-bit window at bit 13 - 0.031%

Keyset 'Text' - keys of form "XXXXFooBar" - 14776336 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      25389.0, actual  25481 (1.00x) (92)
Testing collisions (high 27-42 bits) - Worst is 40 bits: 111/99 (1.12x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected      25389.0, actual  25622 (1.01x) (233)
Testing collisions (low  27-42 bits) - Worst is 39 bits: 212/198 (1.07x)
Testing distribution - Worst bias is the 20-bit window at bit 110 - 0.026%

Keyset 'Words' - 4000000 random keys of len 6-16 from alnum charset
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1862.1, actual   1878 (1.01x) (16)
Testing collisions (high 25-38 bits) - Worst is 34 bits: 490/465 (1.05x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       1862.1, actual   1926 (1.03x) (64)
Testing collisions (low  25-38 bits) - Worst is 38 bits: 36/29 (1.24x)
Testing distribution - Worst bias is the 19-bit window at bit 30 - 0.067%

Keyset 'Words' - 4000000 random keys of len 6-16 from password charset
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1862.1, actual   1898 (1.02x) (36)
Testing collisions (high 25-38 bits) - Worst is 36 bits: 138/116 (1.19x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       1862.1, actual   1829 (0.98x) (-33)
Testing collisions (low  25-38 bits) - Worst is 25 bits: 228540/229220 (1.00x)
Testing distribution - Worst bias is the 19-bit window at bit 110 - 0.058%

Keyset 'Words' - 466569 dict words
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected         25.3, actual     34 (1.34x) (9)
Testing collisions (high 22-32 bits) - Worst is 32 bits: 34/25 (1.34x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected         25.3, actual     20 (0.79x)
Testing collisions (low  22-32 bits) - Worst is 26 bits: 1650/1618 (1.02x)
Testing distribution - Worst bias is the 16-bit window at bit  1 - 0.220%


[[[ Keyset 'Zeroes' Tests ]]]

Keyset 'Zeroes' - 204800 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected          4.9, actual      7 (1.43x) (3)
Testing collisions (high 21-29 bits) - Worst is 29 bits: 48/39 (1.23x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected          4.9, actual      4 (0.82x)
Testing collisions (low  21-29 bits) - Worst is 29 bits: 49/39 (1.25x)
Testing distribution - Worst bias is the 15-bit window at bit 29 - 0.313%


[[[ Keyset 'Seed' Tests ]]]

Keyset 'Seed' - 5000000 keys
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       2909.3, actual   2778 (0.95x)
Testing collisions (high 26-39 bits) - Worst is 37 bits: 96/90 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       2909.3, actual   2973 (1.02x) (64)
Testing collisions (low  26-39 bits) - Worst is 39 bits: 36/22 (1.58x)
Testing distribution - Worst bias is the 19-bit window at bit 79 - 0.055%


[[[ Keyset 'PerlinNoise' Tests ]]]

Testing 16777216 coordinates (L2) : 
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected      32725.4, actual  32905 (1.01x) (180)
Testing collisions (high 27-42 bits) - Worst is 40 bits: 142/127 (1.11x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected      32725.4, actual  32857 (1.00x) (132)
Testing collisions (low  27-42 bits) - Worst is 41 bits: 69/63 (1.08x)

Testing AV variant, 128 count with 4 spacing, 4-12:
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected       1116.2, actual   1102 (0.99x) (-14)
Testing collisions (high 25-37 bits) - Worst is 36 bits: 83/69 (1.19x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected       1116.2, actual   1068 (0.96x)
Testing collisions (low  25-37 bits) - Worst is 37 bits: 42/34 (1.20x)


[[[ Diff 'Differential' Tests ]]]

Testing 8303632 up-to-5-bit differentials in 64-bit keys -> 128 bit hashes.
1000 reps, 8303632000 total tests, expecting 0.00 random collisions..........
0 total collisions, of which 0 single collisions were ignored

Testing 11017632 up-to-4-bit differentials in 128-bit keys -> 128 bit hashes.
1000 reps, 11017632000 total tests, expecting 0.00 random collisions..........
0 total collisions, of which 0 single collisions were ignored

Testing 2796416 up-to-3-bit differentials in 256-bit keys -> 128 bit hashes.
1000 reps, 2796416000 total tests, expecting 0.00 random collisions..........
0 total collisions, of which 0 single collisions were ignored


[[[ DiffDist 'Differential Distribution' Tests ]]]

Testing bit 0
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    544 (1.06x) (33)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 71/63 (1.11x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    515 (1.01x) (4)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 145/127 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 79 - 0.123%

Testing bit 1
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    515 (1.01x) (4)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2065/2046 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    499 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 18-bit window at bit 99 - 0.092%

Testing bit 2
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    442 (0.86x)
Testing collisions (high 24-36 bits) - Worst is 29 bits: 4169/4090 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    538 (1.05x) (27)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 136/127 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 107 - 0.080%

Testing bit 3
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    515 (1.01x) (4)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 266/255 (1.04x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    500 (0.98x)
Testing collisions (low  24-36 bits) - Worst is 28 bits: 8326/8170 (1.02x)
Testing distribution - Worst bias is the 18-bit window at bit 113 - 0.077%

Testing bit 4
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    501 (0.98x)
Testing collisions (high 24-36 bits) - Worst is 29 bits: 4107/4090 (1.00x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    463 (0.90x)
Testing collisions (low  24-36 bits) - Worst is 25 bits: 64159/64191 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 26 - 0.076%

Testing bit 5
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    482 (0.94x)
Testing collisions (high 24-36 bits) - Worst is 28 bits: 8318/8170 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    534 (1.04x) (23)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 70/63 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 82 - 0.070%

Testing bit 6
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    518 (1.01x) (7)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 73/63 (1.14x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    537 (1.05x) (26)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 140/127 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 127 - 0.104%

Testing bit 7
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    483 (0.94x)
Testing collisions (high 24-36 bits) - Worst is 27 bits: 16399/16298 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    533 (1.04x) (22)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 142/127 (1.11x)
Testing distribution - Worst bias is the 18-bit window at bit 106 - 0.081%

Testing bit 8
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 276/255 (1.08x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    519 (1.01x) (8)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 519/511 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 41 - 0.088%

Testing bit 9
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    565 (1.10x) (54)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 148/127 (1.16x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    546 (1.07x) (35)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 147/127 (1.15x)
Testing distribution - Worst bias is the 18-bit window at bit 123 - 0.110%

Testing bit 10
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    533 (1.04x) (22)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 89 - 0.083%

Testing bit 11
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    502 (0.98x) (-9)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 75/63 (1.17x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    492 (0.96x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 67/63 (1.05x)
Testing distribution - Worst bias is the 18-bit window at bit 68 - 0.087%

Testing bit 12
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    499 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 79/63 (1.23x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    565 (1.10x) (54)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 79/63 (1.23x)
Testing distribution - Worst bias is the 18-bit window at bit 126 - 0.095%

Testing bit 13
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    498 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 68/63 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    471 (0.92x)
Testing collisions (low  24-36 bits) - Worst is 24 bits: 125649/125777 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 119 - 0.082%

Testing bit 14
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    532 (1.04x) (21)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 83/63 (1.30x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    502 (0.98x) (-9)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 76/63 (1.19x)
Testing distribution - Worst bias is the 18-bit window at bit 53 - 0.073%

Testing bit 15
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    501 (0.98x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    513 (1.00x) (2)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2182/2046 (1.07x)
Testing distribution - Worst bias is the 18-bit window at bit 126 - 0.104%

Testing bit 16
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 277/255 (1.08x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    497 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 132/127 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 108 - 0.101%

Testing bit 17
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    520 (1.02x) (9)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    480 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 69/63 (1.08x)
Testing distribution - Worst bias is the 18-bit window at bit 30 - 0.090%

Testing bit 18
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 73/63 (1.14x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    535 (1.05x) (24)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 44/31 (1.38x)
Testing distribution - Worst bias is the 18-bit window at bit 81 - 0.101%

Testing bit 19
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    563 (1.10x) (52)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    488 (0.95x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 72/63 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 54 - 0.106%

Testing bit 20
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    507 (0.99x) (-4)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1041/1023 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    548 (1.07x) (37)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 38/31 (1.19x)
Testing distribution - Worst bias is the 18-bit window at bit 61 - 0.071%

Testing bit 21
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    511 (1.00x)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 271/255 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    498 (0.97x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 121 - 0.092%

Testing bit 22
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    507 (0.99x) (-4)
Testing collisions (high 24-36 bits) - Worst is 25 bits: 63947/64191 (1.00x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    535 (1.05x) (24)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 135/127 (1.05x)
Testing distribution - Worst bias is the 18-bit window at bit 35 - 0.111%

Testing bit 23
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    555 (1.08x) (44)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 555/511 (1.08x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 266/255 (1.04x)
Testing distribution - Worst bias is the 18-bit window at bit 42 - 0.096%

Testing bit 24
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    486 (0.95x)
Testing collisions (high 24-36 bits) - Worst is 25 bits: 64468/64191 (1.00x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    488 (0.95x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 79 - 0.109%

Testing bit 25
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    493 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    532 (1.04x) (21)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing distribution - Worst bias is the 18-bit window at bit 53 - 0.081%

Testing bit 26
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    485 (0.95x)
Testing collisions (high 24-36 bits) - Worst is 27 bits: 16451/16298 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    524 (1.02x) (13)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 144/127 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 75 - 0.093%

Testing bit 27
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    516 (1.01x) (5)
Testing collisions (high 24-36 bits) - Worst is 27 bits: 16466/16298 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    513 (1.00x) (2)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 40/31 (1.25x)
Testing distribution - Worst bias is the 18-bit window at bit 107 - 0.098%

Testing bit 28
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    514 (1.00x) (3)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1060/1023 (1.04x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    492 (0.96x)
Testing collisions (low  24-36 bits) - Worst is 31 bits: 1027/1023 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 80 - 0.107%

Testing bit 29
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    507 (0.99x) (-4)
Testing collisions (high 24-36 bits) - Worst is 24 bits: 126291/125777 (1.00x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 132/127 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 126 - 0.088%

Testing bit 30
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    477 (0.93x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 35/31 (1.09x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    516 (1.01x) (5)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 516/511 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 16 - 0.084%

Testing bit 31
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    525 (1.03x) (14)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 140/127 (1.09x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    509 (0.99x) (-2)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 144/127 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit  6 - 0.070%

Testing bit 32
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    499 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2072/2046 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 31 - 0.086%

Testing bit 33
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    521 (1.02x) (10)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 147/127 (1.15x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    568 (1.11x) (57)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 79/63 (1.23x)
Testing distribution - Worst bias is the 18-bit window at bit 99 - 0.097%

Testing bit 34
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    495 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 41/31 (1.28x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    512 (1.00x) (1)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 257/255 (1.00x)
Testing distribution - Worst bias is the 18-bit window at bit 79 - 0.087%

Testing bit 35
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    508 (0.99x) (-3)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 269/255 (1.05x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    530 (1.04x) (19)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 96 - 0.066%

Testing bit 36
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    501 (0.98x)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 77/63 (1.20x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    501 (0.98x)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2062/2046 (1.01x)
Testing distribution - Worst bias is the 18-bit window at bit 53 - 0.121%

Testing bit 37
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    502 (0.98x) (-9)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    527 (1.03x) (16)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 140/127 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 121 - 0.093%

Testing bit 38
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    508 (0.99x) (-3)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1045/1023 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    556 (1.09x) (45)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 556/511 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 123 - 0.077%

Testing bit 39
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    470 (0.92x)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 83/63 (1.30x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    539 (1.05x) (28)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 282/255 (1.10x)
Testing distribution - Worst bias is the 18-bit window at bit 27 - 0.081%

Testing bit 40
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    493 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 27 bits: 16404/16298 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    459 (0.90x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 26 - 0.095%

Testing bit 41
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    505 (0.99x) (-6)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 136/127 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    537 (1.05x) (26)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 270/255 (1.05x)
Testing distribution - Worst bias is the 18-bit window at bit 31 - 0.100%

Testing bit 42
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    529 (1.03x) (18)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 42/31 (1.31x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    477 (0.93x)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2094/2046 (1.02x)
Testing distribution - Worst bias is the 18-bit window at bit 99 - 0.076%

Testing bit 43
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    475 (0.93x)
Testing collisions (high 24-36 bits) - Worst is 24 bits: 125780/125777 (1.00x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 276/255 (1.08x)
Testing distribution - Worst bias is the 18-bit window at bit 20 - 0.091%

Testing bit 44
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    508 (0.99x) (-3)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    483 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 30 bits: 2095/2046 (1.02x)
Testing distribution - Worst bias is the 18-bit window at bit 19 - 0.068%

Testing bit 45
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 271/255 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    558 (1.09x) (47)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 38/31 (1.19x)
Testing distribution - Worst bias is the 18-bit window at bit 117 - 0.078%

Testing bit 46
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1087/1023 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    533 (1.04x) (22)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 271/255 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 51 - 0.104%

Testing bit 47
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    491 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2085/2046 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    519 (1.01x) (8)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing distribution - Worst bias is the 18-bit window at bit 82 - 0.085%

Testing bit 48
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    523 (1.02x) (12)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 78/63 (1.22x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    512 (1.00x) (1)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 139/127 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 73 - 0.081%

Testing bit 49
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    527 (1.03x) (16)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2143/2046 (1.05x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    544 (1.06x) (33)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 74/63 (1.16x)
Testing distribution - Worst bias is the 18-bit window at bit 66 - 0.099%

Testing bit 50
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    494 (0.97x)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 41/31 (1.28x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    483 (0.94x)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 66/63 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 119 - 0.103%

Testing bit 51
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    502 (0.98x) (-9)
Testing collisions (high 24-36 bits) - Worst is 35 bits: 75/63 (1.17x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    500 (0.98x)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 266/255 (1.04x)
Testing distribution - Worst bias is the 18-bit window at bit 78 - 0.090%

Testing bit 52
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    504 (0.98x) (-7)
Testing collisions (high 24-36 bits) - Worst is 30 bits: 2076/2046 (1.01x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    477 (0.93x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 36/31 (1.13x)
Testing distribution - Worst bias is the 18-bit window at bit 28 - 0.110%

Testing bit 53
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    517 (1.01x) (6)
Testing collisions (high 24-36 bits) - Worst is 34 bits: 138/127 (1.08x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 39/31 (1.22x)
Testing distribution - Worst bias is the 18-bit window at bit  7 - 0.073%

Testing bit 54
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    518 (1.01x) (7)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    518 (1.01x) (7)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 33/31 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 71 - 0.098%

Testing bit 55
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    527 (1.03x) (16)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 42/31 (1.31x)
Testing distribution - Worst bias is the 18-bit window at bit 87 - 0.087%

Testing bit 56
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    546 (1.07x) (35)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 45/31 (1.41x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    520 (1.02x) (9)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 41/31 (1.28x)
Testing distribution - Worst bias is the 18-bit window at bit 17 - 0.112%

Testing bit 57
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    475 (0.93x)
Testing collisions (high 24-36 bits) - Worst is 24 bits: 126113/125777 (1.00x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    539 (1.05x) (28)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 140/127 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 49 - 0.089%

Testing bit 58
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    557 (1.09x) (46)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 37/31 (1.16x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    528 (1.03x) (17)
Testing collisions (low  24-36 bits) - Worst is 33 bits: 269/255 (1.05x)
Testing distribution - Worst bias is the 18-bit window at bit 20 - 0.091%

Testing bit 59
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    518 (1.01x) (7)
Testing collisions (high 24-36 bits) - Worst is 31 bits: 1082/1023 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    541 (1.06x) (30)
Testing collisions (low  24-36 bits) - Worst is 34 bits: 146/127 (1.14x)
Testing distribution - Worst bias is the 18-bit window at bit 55 - 0.065%

Testing bit 60
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    508 (0.99x) (-3)
Testing collisions (high 24-36 bits) - Worst is 33 bits: 260/255 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    488 (0.95x)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 34/31 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit 15 - 0.083%

Testing bit 61
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    521 (1.02x) (10)
Testing collisions (high 24-36 bits) - Worst is 36 bits: 48/31 (1.50x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    526 (1.03x) (15)
Testing collisions (low  24-36 bits) - Worst is 32 bits: 526/511 (1.03x)
Testing distribution - Worst bias is the 18-bit window at bit 12 - 0.083%

Testing bit 62
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    492 (0.96x)
Testing collisions (high 24-36 bits) - Worst is 24 bits: 126044/125777 (1.00x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    530 (1.04x) (19)
Testing collisions (low  24-36 bits) - Worst is 36 bits: 35/31 (1.09x)
Testing distribution - Worst bias is the 18-bit window at bit 37 - 0.095%

Testing bit 63
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected        511.9, actual    543 (1.06x) (32)
Testing collisions (high 24-36 bits) - Worst is 32 bits: 543/511 (1.06x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected        511.9, actual    522 (1.02x) (11)
Testing collisions (low  24-36 bits) - Worst is 35 bits: 68/63 (1.06x)
Testing distribution - Worst bias is the 18-bit window at bit  8 - 0.077%


[[[ MomentChi2 Tests ]]]

Analyze hashes produced from a serie of linearly increasing numbers of 32-bit, using a step of 2 ... 
Target values to approximate : 38918200.000000 - 273633.333333 
Popcount 1 stats : 38918998.920034 - 273638.558723
Popcount 0 stats : 38918770.531038 - 273645.996303
MomentChi2 for bits 1 :   1.16628 
MomentChi2 for bits 0 :  0.594771 

Derivative stats (transition from 2 consecutive values) : 
Popcount 1 stats : 38919257.619283 - 273628.012809
Popcount 0 stats : 38918472.697479 - 273650.071385
MomentChi2 for deriv b1 :   2.04392 
MomentChi2 for deriv b0 :  0.135878 

  Great 


[[[ Prng Tests ]]]

Generating 33554432 random numbers : 
Testing collisions (128-bit) - Expected    0.0, actual      0 (0.00x)
Testing collisions (high 64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (high 32-bit) - Expected     130731.3, actual 131029 (1.00x) (298)
Testing collisions (high 28-44 bits) - Worst is 37 bits: 4158/4095 (1.02x)
Testing collisions (low  64-bit) - Expected          0.0, actual      0 (0.00x)
Testing collisions (low  32-bit) - Expected     130731.3, actual 130672 (1.00x) (-59)
Testing collisions (low  28-44 bits) - Worst is 43 bits: 85/63 (1.33x)

[[[ BadSeeds Tests ]]]

0x0 PASS


Input vcode 0x00000001, Output vcode 0x00000001, Result vcode 0x00000001
Verification value is 0x00000001 - Testing took 1063.513065 seconds
------------------------------------------------------------
```

------------------------------------------------------------
## Pseudo-Random Function Testing

Testing the Pseudo-Random Number Generator (PRNG) Functions isn't somewhat of a chore, as a complete test could take a week or so to complete and my laptop wasn't designed for such long running intensive tasks.

Tests were conducted by utilizing [PractRand](https://pracrand.sourceforge.net) as well as some tests adopted from the [xoshiro](http://xoshiro.di.unimi.it/hwd.php) testing code, running both up to 2TB of random data (which took about 1 night for PractRand).

Results are as follows:

------------------------------------------------------------
### `fio_rand`

The following are the tests for the core  `fio_rand64` and `fio_rand_bytes` functions provided when using `FIO_RAND`.

**The `PractRand` results**:

```txt
# ./tmp/rnd -p fio | RNG_test stdin
RNG_test using PractRand version 0.95
RNG = RNG_stdin, seed = unknown
test set = core, folding = standard(unknown format)

rng=RNG_stdin, seed=unknown
length= 256 megabytes (2^28 bytes), time= 3.0 seconds
  no anomalies in 217 test result(s)

rng=RNG_stdin, seed=unknown
length= 512 megabytes (2^29 bytes), time= 6.5 seconds
  no anomalies in 232 test result(s)

rng=RNG_stdin, seed=unknown
length= 1 gigabyte (2^30 bytes), time= 13.0 seconds
  no anomalies in 251 test result(s)

rng=RNG_stdin, seed=unknown
length= 2 gigabytes (2^31 bytes), time= 25.2 seconds
  no anomalies in 269 test result(s)

rng=RNG_stdin, seed=unknown
length= 4 gigabytes (2^32 bytes), time= 48.2 seconds
  no anomalies in 283 test result(s)

rng=RNG_stdin, seed=unknown
length= 8 gigabytes (2^33 bytes), time= 96.5 seconds
  Test Name                         Raw       Processed     Evaluation
  BCFN(2+7,13-2,T)                  R=  -9.1  p =1-3.9e-5   unusual          
  ...and 299 test result(s) without anomalies

rng=RNG_stdin, seed=unknown
length= 16 gigabytes (2^34 bytes), time= 190 seconds
  no anomalies in 315 test result(s)

rng=RNG_stdin, seed=unknown
length= 32 gigabytes (2^35 bytes), time= 376 seconds
  no anomalies in 328 test result(s)

rng=RNG_stdin, seed=unknown
length= 64 gigabytes (2^36 bytes), time= 752 seconds
  no anomalies in 344 test result(s)

rng=RNG_stdin, seed=unknown
length= 128 gigabytes (2^37 bytes), time= 1498 seconds
  no anomalies in 359 test result(s)

rng=RNG_stdin, seed=unknown
length= 256 gigabytes (2^38 bytes), time= 2978 seconds
  no anomalies in 372 test result(s)

rng=RNG_stdin, seed=unknown
length= 512 gigabytes (2^39 bytes), time= 9897 seconds
  no anomalies in 387 test result(s)

rng=RNG_stdin, seed=unknown
length= 1 terabyte (2^40 bytes), time= 21004 seconds
  no anomalies in 401 test result(s)

rng=RNG_stdin, seed=unknown
length= 2 terabytes (2^41 bytes), time= 43108 seconds
  no anomalies in 413 test result(s)
```

**The tests adopted from the `xoshiro` code base**:


```txt
# ./tmp/random fio
mix3 extreme = 1.80533 (sig = 00100000) weight 1 (16), p-value = 0.692
mix3 extreme = 2.35650 (sig = 00000102) weight 2 (112), p-value = 0.876
mix3 extreme = 3.33991 (sig = 20002100) weight 3 (448), p-value = 0.313
mix3 extreme = 4.30088 (sig = 02210200) weight 4 (1120), p-value = 0.0189
mix3 extreme = 4.03228 (sig = 01002212) weight >=5 (4864), p-value = 0.236
bits per word = 64 (analyzing bits); min category p-value = 0.0189

processed 1.11e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:21 2025

p = 0.0909
------

mix3 extreme = 1.84047 (sig = 20000000) weight 1 (16), p-value = 0.663
mix3 extreme = 3.12258 (sig = 00000102) weight 2 (112), p-value = 0.182
mix3 extreme = 3.47031 (sig = 20002100) weight 3 (448), p-value = 0.208
mix3 extreme = 3.61471 (sig = 12000101) weight 4 (1120), p-value = 0.286
mix3 extreme = 3.76213 (sig = 10111202) weight >=5 (4864), p-value = 0.559
bits per word = 64 (analyzing bits); min category p-value = 0.182

processed 1.29e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:21 2025

p = 0.634
------

mix3 extreme = 1.65805 (sig = 00000002) weight 1 (16), p-value = 0.806
mix3 extreme = 3.09464 (sig = 00000102) weight 2 (112), p-value = 0.198
mix3 extreme = 3.53210 (sig = 00102010) weight 3 (448), p-value = 0.169
mix3 extreme = 3.35900 (sig = 02210200) weight 4 (1120), p-value = 0.584
mix3 extreme = 3.58826 (sig = 02011101) weight >=5 (4864), p-value = 0.802
bits per word = 64 (analyzing bits); min category p-value = 0.169

processed 1.66e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:21 2025

p = 0.603
------

mix3 extreme = 1.75332 (sig = 00000001) weight 1 (16), p-value = 0.735
mix3 extreme = 2.97345 (sig = 00000102) weight 2 (112), p-value = 0.281
mix3 extreme = 3.21121 (sig = 20002100) weight 3 (448), p-value = 0.447
mix3 extreme = 2.99207 (sig = 10102020) weight 4 (1120), p-value = 0.955
mix3 extreme = 3.53616 (sig = 21120101) weight >=5 (4864), p-value = 0.861
bits per word = 64 (analyzing bits); min category p-value = 0.281

processed 1.85e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:21 2025

p = 0.808
------

mix3 extreme = 1.83225 (sig = 00000100) weight 1 (16), p-value = 0.67
mix3 extreme = 3.10258 (sig = 00000102) weight 2 (112), p-value = 0.194
mix3 extreme = 3.03291 (sig = 20002100) weight 3 (448), p-value = 0.663
mix3 extreme = 3.09549 (sig = 10200022) weight 4 (1120), p-value = 0.89
mix3 extreme = 3.76428 (sig = 02011101) weight >=5 (4864), p-value = 0.556
bits per word = 64 (analyzing bits); min category p-value = 0.194

processed 2.03e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:21 2025

p = 0.659
------

mix3 extreme = 1.84289 (sig = 00000100) weight 1 (16), p-value = 0.661
mix3 extreme = 3.57529 (sig = 00000102) weight 2 (112), p-value = 0.0384
mix3 extreme = 3.46502 (sig = 20002010) weight 3 (448), p-value = 0.211
mix3 extreme = 3.25764 (sig = 00220201) weight 4 (1120), p-value = 0.716
mix3 extreme = 4.19914 (sig = 11222212) weight >=5 (4864), p-value = 0.122
bits per word = 64 (analyzing bits); min category p-value = 0.0384

processed 2.59e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:21 2025

p = 0.178
------

mix3 extreme = 2.19203 (sig = 00000002) weight 1 (16), p-value = 0.369
mix3 extreme = 3.04970 (sig = 00000102) weight 2 (112), p-value = 0.227
mix3 extreme = 3.44778 (sig = 20002010) weight 3 (448), p-value = 0.224
mix3 extreme = 3.66866 (sig = 22110000) weight 4 (1120), p-value = 0.239
mix3 extreme = 3.58667 (sig = 02021021) weight >=5 (4864), p-value = 0.804
bits per word = 64 (analyzing bits); min category p-value = 0.224

processed 3.14e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:21 2025

p = 0.718
------

mix3 extreme = 2.51064 (sig = 00000002) weight 1 (16), p-value = 0.176
mix3 extreme = 2.57871 (sig = 20010000) weight 2 (112), p-value = 0.672
mix3 extreme = 3.85273 (sig = 20002010) weight 3 (448), p-value = 0.051
mix3 extreme = 3.18862 (sig = 01101010) weight 4 (1120), p-value = 0.799
mix3 extreme = 3.60146 (sig = 22121010) weight >=5 (4864), p-value = 0.785
bits per word = 64 (analyzing bits); min category p-value = 0.051

processed 4.07e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:21 2025

p = 0.23
------

mix3 extreme = 1.89834 (sig = 00000002) weight 1 (16), p-value = 0.613
mix3 extreme = 2.27677 (sig = 00100200) weight 2 (112), p-value = 0.924
mix3 extreme = 3.52766 (sig = 20000022) weight 3 (448), p-value = 0.171
mix3 extreme = 3.50133 (sig = 11000102) weight 4 (1120), p-value = 0.405
mix3 extreme = 3.47778 (sig = 11121011) weight >=5 (4864), p-value = 0.915
bits per word = 64 (analyzing bits); min category p-value = 0.171

processed 5.18e+08 bytes in 1 seconds (0.5177 GB/s, 1.864 TB/h). Fri Feb 21 23:22:22 2025

p = 0.609
------

mix3 extreme = 1.99814 (sig = 00000001) weight 1 (16), p-value = 0.527
mix3 extreme = 2.43362 (sig = 00100200) weight 2 (112), p-value = 0.815
mix3 extreme = 3.46309 (sig = 20002010) weight 3 (448), p-value = 0.213
mix3 extreme = 3.67295 (sig = 20110001) weight 4 (1120), p-value = 0.236
mix3 extreme = 3.50848 (sig = 00222210) weight >=5 (4864), p-value = 0.888
bits per word = 64 (analyzing bits); min category p-value = 0.213

processed 6.1e+08 bytes in 1 seconds (0.6101 GB/s, 2.196 TB/h). Fri Feb 21 23:22:22 2025

p = 0.698
------

mix3 extreme = 1.78022 (sig = 00000002) weight 1 (16), p-value = 0.713
mix3 extreme = 2.64570 (sig = 10000001) weight 2 (112), p-value = 0.6
mix3 extreme = 3.55344 (sig = 20002010) weight 3 (448), p-value = 0.157
mix3 extreme = 3.15383 (sig = 11000102) weight 4 (1120), p-value = 0.836
mix3 extreme = 4.03858 (sig = 11121011) weight >=5 (4864), p-value = 0.23
bits per word = 64 (analyzing bits); min category p-value = 0.157

processed 7.03e+08 bytes in 1 seconds (0.7026 GB/s, 2.529 TB/h). Fri Feb 21 23:22:22 2025

p = 0.573
------

mix3 extreme = 1.83987 (sig = 00000002) weight 1 (16), p-value = 0.663
mix3 extreme = 2.43194 (sig = 00000110) weight 2 (112), p-value = 0.816
mix3 extreme = 3.40962 (sig = 20000022) weight 3 (448), p-value = 0.253
mix3 extreme = 3.02964 (sig = 02012200) weight 4 (1120), p-value = 0.936
mix3 extreme = 3.75207 (sig = 20222201) weight >=5 (4864), p-value = 0.574
bits per word = 64 (analyzing bits); min category p-value = 0.253

processed 8.5e+08 bytes in 1 seconds (0.8505 GB/s, 3.062 TB/h). Fri Feb 21 23:22:22 2025

p = 0.767
------

mix3 extreme = 2.03491 (sig = 00000002) weight 1 (16), p-value = 0.496
mix3 extreme = 2.48334 (sig = 00001002) weight 2 (112), p-value = 0.769
mix3 extreme = 3.15042 (sig = 10200002) weight 3 (448), p-value = 0.519
mix3 extreme = 3.19215 (sig = 21200001) weight 4 (1120), p-value = 0.795
mix3 extreme = 3.68390 (sig = 20222201) weight >=5 (4864), p-value = 0.673
bits per word = 64 (analyzing bits); min category p-value = 0.496

processed 1.02e+09 bytes in 1 seconds (1.017 GB/s, 3.661 TB/h). Fri Feb 21 23:22:22 2025

p = 0.967
------

mix3 extreme = 1.98184 (sig = 00000001) weight 1 (16), p-value = 0.541
mix3 extreme = 2.49397 (sig = 01001000) weight 2 (112), p-value = 0.759
mix3 extreme = 2.98386 (sig = 02000011) weight 3 (448), p-value = 0.721
mix3 extreme = 3.29022 (sig = 20200220) weight 4 (1120), p-value = 0.674
mix3 extreme = 4.30382 (sig = 11122011) weight >=5 (4864), p-value = 0.0784
bits per word = 64 (analyzing bits); min category p-value = 0.0784

processed 1.26e+09 bytes in 1 seconds (1.257 GB/s, 4.526 TB/h). Fri Feb 21 23:22:22 2025

p = 0.335
------

mix3 extreme = 2.33599 (sig = 00000001) weight 1 (16), p-value = 0.27
mix3 extreme = 2.45643 (sig = 00000110) weight 2 (112), p-value = 0.795
mix3 extreme = 2.84156 (sig = 00022100) weight 3 (448), p-value = 0.867
mix3 extreme = 3.61210 (sig = 01100202) weight 4 (1120), p-value = 0.288
mix3 extreme = 3.51573 (sig = 21101210) weight >=5 (4864), p-value = 0.882
bits per word = 64 (analyzing bits); min category p-value = 0.27

processed 1.52e+09 bytes in 1 seconds (1.516 GB/s, 5.458 TB/h). Fri Feb 21 23:22:22 2025

p = 0.793
------

mix3 extreme = 2.57590 (sig = 00000001) weight 1 (16), p-value = 0.149
mix3 extreme = 2.18056 (sig = 10000002) weight 2 (112), p-value = 0.964
mix3 extreme = 2.94943 (sig = 20102000) weight 3 (448), p-value = 0.76
mix3 extreme = 3.39387 (sig = 11010002) weight 4 (1120), p-value = 0.538
mix3 extreme = 3.85744 (sig = 22210212) weight >=5 (4864), p-value = 0.427
bits per word = 64 (analyzing bits); min category p-value = 0.149

processed 1.76e+09 bytes in 1 seconds (1.756 GB/s, 6.323 TB/h). Fri Feb 21 23:22:22 2025

p = 0.552
------

mix3 extreme = 2.64879 (sig = 00000001) weight 1 (16), p-value = 0.122
mix3 extreme = 2.69778 (sig = 10000002) weight 2 (112), p-value = 0.544
mix3 extreme = 3.15759 (sig = 20102000) weight 3 (448), p-value = 0.51
mix3 extreme = 3.41194 (sig = 11010002) weight 4 (1120), p-value = 0.515
mix3 extreme = 4.19052 (sig = 11122011) weight >=5 (4864), p-value = 0.127
bits per word = 64 (analyzing bits); min category p-value = 0.122

processed 2.02e+09 bytes in 1 seconds (2.015 GB/s, 7.255 TB/h). Fri Feb 21 23:22:22 2025

p = 0.477
------

mix3 extreme = 2.10150 (sig = 00000001) weight 1 (16), p-value = 0.44
mix3 extreme = 2.31937 (sig = 00100100) weight 2 (112), p-value = 0.9
mix3 extreme = 2.98427 (sig = 20102000) weight 3 (448), p-value = 0.721
mix3 extreme = 3.62790 (sig = 21200001) weight 4 (1120), p-value = 0.274
mix3 extreme = 3.47379 (sig = 22011100) weight >=5 (4864), p-value = 0.918
bits per word = 64 (analyzing bits); min category p-value = 0.274

processed 2.51e+09 bytes in 1 seconds (2.514 GB/s, 9.052 TB/h). Fri Feb 21 23:22:22 2025

p = 0.798
------

mix3 extreme = 2.20184 (sig = 00100000) weight 1 (16), p-value = 0.362
mix3 extreme = 2.44576 (sig = 00100100) weight 2 (112), p-value = 0.804
mix3 extreme = 2.66267 (sig = 10200002) weight 3 (448), p-value = 0.969
mix3 extreme = 3.76139 (sig = 21200001) weight 4 (1120), p-value = 0.172
mix3 extreme = 3.82048 (sig = 20222201) weight >=5 (4864), p-value = 0.477
bits per word = 64 (analyzing bits); min category p-value = 0.172

processed 3.01e+09 bytes in 2 seconds (1.507 GB/s, 5.425 TB/h). Fri Feb 21 23:22:23 2025

p = 0.612
------

mix3 extreme = 2.18426 (sig = 00100000) weight 1 (16), p-value = 0.375
mix3 extreme = 2.65062 (sig = 20002000) weight 2 (112), p-value = 0.595
mix3 extreme = 2.92917 (sig = 01100200) weight 3 (448), p-value = 0.782
mix3 extreme = 3.89526 (sig = 21200001) weight 4 (1120), p-value = 0.104
mix3 extreme = 3.78679 (sig = 20220022) weight >=5 (4864), p-value = 0.524
bits per word = 64 (analyzing bits); min category p-value = 0.104

processed 4.01e+09 bytes in 2 seconds (2.006 GB/s, 7.222 TB/h). Fri Feb 21 23:22:23 2025

p = 0.423
------

mix3 extreme = 2.46216 (sig = 20000000) weight 1 (16), p-value = 0.199
mix3 extreme = 2.30564 (sig = 20002000) weight 2 (112), p-value = 0.909
mix3 extreme = 2.97563 (sig = 00100220) weight 3 (448), p-value = 0.731
mix3 extreme = 3.70435 (sig = 20110001) weight 4 (1120), p-value = 0.211
mix3 extreme = 3.47865 (sig = 22100011) weight >=5 (4864), p-value = 0.914
bits per word = 64 (analyzing bits); min category p-value = 0.199

processed 5.01e+09 bytes in 2 seconds (2.505 GB/s, 9.019 TB/h). Fri Feb 21 23:22:23 2025

p = 0.671
------

mix3 extreme = 2.48402 (sig = 00100000) weight 1 (16), p-value = 0.189
mix3 extreme = 2.32620 (sig = 00000012) weight 2 (112), p-value = 0.896
mix3 extreme = 3.13986 (sig = 00120200) weight 3 (448), p-value = 0.531
mix3 extreme = 3.56935 (sig = 20110001) weight 4 (1120), p-value = 0.33
mix3 extreme = 3.62670 (sig = 01210201) weight >=5 (4864), p-value = 0.753
bits per word = 64 (analyzing bits); min category p-value = 0.189

processed 6.01e+09 bytes in 3 seconds (2.003 GB/s, 7.211 TB/h). Fri Feb 21 23:22:24 2025

p = 0.649
------

mix3 extreme = 2.07995 (sig = 00100000) weight 1 (16), p-value = 0.458
mix3 extreme = 2.14438 (sig = 00002010) weight 2 (112), p-value = 0.974
mix3 extreme = 3.12213 (sig = 00120200) weight 3 (448), p-value = 0.553
mix3 extreme = 3.59330 (sig = 20110001) weight 4 (1120), p-value = 0.306
mix3 extreme = 3.93490 (sig = 01210201) weight >=5 (4864), p-value = 0.333
bits per word = 64 (analyzing bits); min category p-value = 0.306

processed 7.01e+09 bytes in 3 seconds (2.336 GB/s, 8.409 TB/h). Fri Feb 21 23:22:24 2025

p = 0.839
------

mix3 extreme = 1.82939 (sig = 20000000) weight 1 (16), p-value = 0.672
mix3 extreme = 2.04212 (sig = 00002010) weight 2 (112), p-value = 0.991
mix3 extreme = 3.40400 (sig = 00120200) weight 3 (448), p-value = 0.257
mix3 extreme = 3.20336 (sig = 12020002) weight 4 (1120), p-value = 0.782
mix3 extreme = 4.26991 (sig = 01210201) weight >=5 (4864), p-value = 0.0907
bits per word = 64 (analyzing bits); min category p-value = 0.0907

processed 8.5e+09 bytes in 4 seconds (2.126 GB/s, 7.654 TB/h). Fri Feb 21 23:22:25 2025

p = 0.378
------

mix3 extreme = 1.82510 (sig = 00100000) weight 1 (16), p-value = 0.676
mix3 extreme = 2.69933 (sig = 00002020) weight 2 (112), p-value = 0.542
mix3 extreme = 2.78787 (sig = 02020200) weight 3 (448), p-value = 0.908
mix3 extreme = 3.06049 (sig = 00001122) weight 4 (1120), p-value = 0.916
mix3 extreme = 4.40242 (sig = 01210201) weight >=5 (4864), p-value = 0.0507
bits per word = 64 (analyzing bits); min category p-value = 0.0507

processed 1e+10 bytes in 4 seconds (2.501 GB/s, 9.002 TB/h). Fri Feb 21 23:22:25 2025

p = 0.229
------

mix3 extreme = 2.20665 (sig = 00100000) weight 1 (16), p-value = 0.358
mix3 extreme = 2.66682 (sig = 00002020) weight 2 (112), p-value = 0.577
mix3 extreme = 3.18173 (sig = 02200010) weight 3 (448), p-value = 0.481
mix3 extreme = 3.39020 (sig = 01202100) weight 4 (1120), p-value = 0.543
mix3 extreme = 3.99569 (sig = 01210201) weight >=5 (4864), p-value = 0.269
bits per word = 64 (analyzing bits); min category p-value = 0.269

processed 1.25e+10 bytes in 5 seconds (2.503 GB/s, 9.012 TB/h). Fri Feb 21 23:22:26 2025

p = 0.792
------

mix3 extreme = 1.60923 (sig = 00000002) weight 1 (16), p-value = 0.838
mix3 extreme = 2.73755 (sig = 02000001) weight 2 (112), p-value = 0.501
mix3 extreme = 3.23640 (sig = 00101200) weight 3 (448), p-value = 0.419
mix3 extreme = 3.31439 (sig = 21220000) weight 4 (1120), p-value = 0.643
mix3 extreme = 3.57996 (sig = 21001101) weight >=5 (4864), p-value = 0.812
bits per word = 64 (analyzing bits); min category p-value = 0.419

processed 1.5e+10 bytes in 6 seconds (2.502 GB/s, 9.008 TB/h). Fri Feb 21 23:22:27 2025

p = 0.934
------

mix3 extreme = 1.91785 (sig = 00000002) weight 1 (16), p-value = 0.596
mix3 extreme = 2.60874 (sig = 02000001) weight 2 (112), p-value = 0.64
mix3 extreme = 3.38156 (sig = 00101200) weight 3 (448), p-value = 0.276
mix3 extreme = 3.24044 (sig = 21220000) weight 4 (1120), p-value = 0.737
mix3 extreme = 3.69590 (sig = 12211201) weight >=5 (4864), p-value = 0.656
bits per word = 64 (analyzing bits); min category p-value = 0.276

processed 1.75e+10 bytes in 7 seconds (2.501 GB/s, 9.004 TB/h). Fri Feb 21 23:22:28 2025

p = 0.801
------

mix3 extreme = 1.80532 (sig = 00000001) weight 1 (16), p-value = 0.692
mix3 extreme = 2.54416 (sig = 00020010) weight 2 (112), p-value = 0.709
mix3 extreme = 3.15400 (sig = 00101200) weight 3 (448), p-value = 0.514
mix3 extreme = 3.33906 (sig = 21220000) weight 4 (1120), p-value = 0.61
mix3 extreme = 3.56547 (sig = 00012112) weight >=5 (4864), p-value = 0.829
bits per word = 64 (analyzing bits); min category p-value = 0.514

processed 2e+10 bytes in 8 seconds (2.501 GB/s, 9.002 TB/h). Fri Feb 21 23:22:29 2025

p = 0.973
------

mix3 extreme = 1.94039 (sig = 00000002) weight 1 (16), p-value = 0.577
mix3 extreme = 2.27077 (sig = 01010000) weight 2 (112), p-value = 0.928
mix3 extreme = 3.19342 (sig = 00120200) weight 3 (448), p-value = 0.468
mix3 extreme = 3.51655 (sig = 21220000) weight 4 (1120), p-value = 0.387
mix3 extreme = 3.56607 (sig = 20122012) weight >=5 (4864), p-value = 0.828
bits per word = 64 (analyzing bits); min category p-value = 0.387

processed 2.5e+10 bytes in 10 seconds (2.502 GB/s, 9.005 TB/h). Fri Feb 21 23:22:31 2025

p = 0.914
------

mix3 extreme = 1.89200 (sig = 01000000) weight 1 (16), p-value = 0.619
mix3 extreme = 2.24801 (sig = 01010000) weight 2 (112), p-value = 0.938
mix3 extreme = 2.88784 (sig = 02000210) weight 3 (448), p-value = 0.825
mix3 extreme = 3.34758 (sig = 21220000) weight 4 (1120), p-value = 0.599
mix3 extreme = 3.45248 (sig = 11200111) weight >=5 (4864), p-value = 0.933
bits per word = 64 (analyzing bits); min category p-value = 0.599

processed 3e+10 bytes in 12 seconds (2.501 GB/s, 9.002 TB/h). Fri Feb 21 23:22:33 2025

p = 0.99
------

mix3 extreme = 1.56396 (sig = 00000200) weight 1 (16), p-value = 0.865
mix3 extreme = 1.97760 (sig = 00000022) weight 2 (112), p-value = 0.996
mix3 extreme = 3.23027 (sig = 20021000) weight 3 (448), p-value = 0.426
mix3 extreme = 3.36856 (sig = 21021000) weight 4 (1120), p-value = 0.571
mix3 extreme = 4.27622 (sig = 20122012) weight >=5 (4864), p-value = 0.0883
bits per word = 64 (analyzing bits); min category p-value = 0.0883

processed 4e+10 bytes in 16 seconds (2.501 GB/s, 9.002 TB/h). Fri Feb 21 23:22:37 2025

p = 0.37
------

mix3 extreme = 1.89666 (sig = 00000100) weight 1 (16), p-value = 0.615
mix3 extreme = 2.70819 (sig = 20000010) weight 2 (112), p-value = 0.532
mix3 extreme = 3.11747 (sig = 20021000) weight 3 (448), p-value = 0.559
mix3 extreme = 2.83492 (sig = 21021000) weight 4 (1120), p-value = 0.994
mix3 extreme = 3.73280 (sig = 20122012) weight >=5 (4864), p-value = 0.602
bits per word = 64 (analyzing bits); min category p-value = 0.532

processed 5e+10 bytes in 20 seconds (2.501 GB/s, 9.002 TB/h). Fri Feb 21 23:22:41 2025

p = 0.978
------

mix3 extreme = 1.60871 (sig = 00000001) weight 1 (16), p-value = 0.838
mix3 extreme = 2.92820 (sig = 20000010) weight 2 (112), p-value = 0.318
mix3 extreme = 3.30722 (sig = 20021000) weight 3 (448), p-value = 0.344
mix3 extreme = 3.12534 (sig = 12100002) weight 4 (1120), p-value = 0.863
mix3 extreme = 3.90592 (sig = 21101011) weight >=5 (4864), p-value = 0.367
bits per word = 64 (analyzing bits); min category p-value = 0.318

processed 6e+10 bytes in 24 seconds (2.501 GB/s, 9.002 TB/h). Fri Feb 21 23:22:45 2025

p = 0.852
------

mix3 extreme = 1.48010 (sig = 02000000) weight 1 (16), p-value = 0.909
mix3 extreme = 2.48996 (sig = 20000010) weight 2 (112), p-value = 0.763
mix3 extreme = 3.17803 (sig = 20021000) weight 3 (448), p-value = 0.486
mix3 extreme = 3.17420 (sig = 20101010) weight 4 (1120), p-value = 0.814
mix3 extreme = 3.79968 (sig = 21101011) weight >=5 (4864), p-value = 0.506
bits per word = 64 (analyzing bits); min category p-value = 0.486

processed 7e+10 bytes in 28 seconds (2.501 GB/s, 9.002 TB/h). Fri Feb 21 23:22:49 2025

p = 0.964
------

mix3 extreme = 2.31418 (sig = 02000000) weight 1 (16), p-value = 0.284
mix3 extreme = 2.75073 (sig = 02000001) weight 2 (112), p-value = 0.487
mix3 extreme = 3.22184 (sig = 20021000) weight 3 (448), p-value = 0.435
mix3 extreme = 2.99913 (sig = 12100002) weight 4 (1120), p-value = 0.952
mix3 extreme = 4.17272 (sig = 21101011) weight >=5 (4864), p-value = 0.136
bits per word = 64 (analyzing bits); min category p-value = 0.136

processed 8.5e+10 bytes in 35 seconds (2.429 GB/s, 8.744 TB/h). Fri Feb 21 23:22:56 2025

p = 0.519
------

mix3 extreme = 2.96167 (sig = 02000000) weight 1 (16), p-value = 0.0478
mix3 extreme = 2.15955 (sig = 02000001) weight 2 (112), p-value = 0.97
mix3 extreme = 3.37730 (sig = 20021000) weight 3 (448), p-value = 0.28
mix3 extreme = 3.52700 (sig = 12100002) weight 4 (1120), p-value = 0.376
mix3 extreme = 4.04580 (sig = 21101011) weight >=5 (4864), p-value = 0.224
bits per word = 64 (analyzing bits); min category p-value = 0.0478

processed 1e+11 bytes in 41 seconds (2.439 GB/s, 8.781 TB/h). Fri Feb 21 23:23:02 2025

p = 0.217
------

mix3 extreme = 2.47196 (sig = 02000000) weight 1 (16), p-value = 0.195
mix3 extreme = 2.51373 (sig = 02000001) weight 2 (112), p-value = 0.74
mix3 extreme = 3.39366 (sig = 20021000) weight 3 (448), p-value = 0.266
mix3 extreme = 3.21456 (sig = 12100002) weight 4 (1120), p-value = 0.769
mix3 extreme = 3.77086 (sig = 12221021) weight >=5 (4864), p-value = 0.547
bits per word = 64 (analyzing bits); min category p-value = 0.195

processed 1.25e+11 bytes in 51 seconds (2.451 GB/s, 8.824 TB/h). Fri Feb 21 23:23:12 2025

p = 0.661
------

mix3 extreme = 2.48207 (sig = 02000000) weight 1 (16), p-value = 0.19
mix3 extreme = 2.29109 (sig = 20020000) weight 2 (112), p-value = 0.917
mix3 extreme = 3.01591 (sig = 20021000) weight 3 (448), p-value = 0.683
mix3 extreme = 3.36633 (sig = 20200101) weight 4 (1120), p-value = 0.574
mix3 extreme = 3.40749 (sig = 02222012) weight >=5 (4864), p-value = 0.959
bits per word = 64 (analyzing bits); min category p-value = 0.19

processed 1.5e+11 bytes in 61 seconds (2.459 GB/s, 8.853 TB/h). Fri Feb 21 23:23:22 2025

p = 0.651
------

mix3 extreme = 2.14788 (sig = 02000000) weight 1 (16), p-value = 0.403
mix3 extreme = 2.23188 (sig = 01000002) weight 2 (112), p-value = 0.945
mix3 extreme = 3.01619 (sig = 20100002) weight 3 (448), p-value = 0.683
mix3 extreme = 3.35531 (sig = 22020010) weight 4 (1120), p-value = 0.589
mix3 extreme = 3.90091 (sig = 20120120) weight >=5 (4864), p-value = 0.373
bits per word = 64 (analyzing bits); min category p-value = 0.373

processed 1.75e+11 bytes in 71 seconds (2.465 GB/s, 8.874 TB/h). Fri Feb 21 23:23:32 2025

p = 0.903
------

mix3 extreme = 2.56990 (sig = 00010000) weight 1 (16), p-value = 0.151
mix3 extreme = 2.15879 (sig = 20020000) weight 2 (112), p-value = 0.97
mix3 extreme = 3.11637 (sig = 20100002) weight 3 (448), p-value = 0.56
mix3 extreme = 3.75031 (sig = 20200101) weight 4 (1120), p-value = 0.179
mix3 extreme = 3.82089 (sig = 11022021) weight >=5 (4864), p-value = 0.476
bits per word = 64 (analyzing bits); min category p-value = 0.151

processed 2e+11 bytes in 81 seconds (2.469 GB/s, 8.889 TB/h). Fri Feb 21 23:23:42 2025

p = 0.559
------

mix3 extreme = 2.68286 (sig = 00010000) weight 1 (16), p-value = 0.111
mix3 extreme = 2.03612 (sig = 01000002) weight 2 (112), p-value = 0.992
mix3 extreme = 2.72508 (sig = 01110000) weight 3 (448), p-value = 0.944
mix3 extreme = 3.29533 (sig = 20200101) weight 4 (1120), p-value = 0.668
mix3 extreme = 3.94062 (sig = 11101011) weight >=5 (4864), p-value = 0.327
bits per word = 64 (analyzing bits); min category p-value = 0.111

processed 2.5e+11 bytes in 102 seconds (2.451 GB/s, 8.824 TB/h). Fri Feb 21 23:24:03 2025

p = 0.444
------

mix3 extreme = 3.02806 (sig = 00010000) weight 1 (16), p-value = 0.0387
mix3 extreme = 2.64241 (sig = 12000000) weight 2 (112), p-value = 0.604
mix3 extreme = 3.14107 (sig = 12001000) weight 3 (448), p-value = 0.53
mix3 extreme = 3.10292 (sig = 10202002) weight 4 (1120), p-value = 0.883
mix3 extreme = 3.78800 (sig = 11122221) weight >=5 (4864), p-value = 0.522
bits per word = 64 (analyzing bits); min category p-value = 0.0387

processed 3e+11 bytes in 122 seconds (2.459 GB/s, 8.853 TB/h). Fri Feb 21 23:24:23 2025

p = 0.179
------

mix3 extreme = 2.11373 (sig = 00010000) weight 1 (16), p-value = 0.43
mix3 extreme = 2.53673 (sig = 00010020) weight 2 (112), p-value = 0.716
mix3 extreme = 3.82566 (sig = 01000220) weight 3 (448), p-value = 0.0568
mix3 extreme = 3.94266 (sig = 22020010) weight 4 (1120), p-value = 0.0863
mix3 extreme = 3.38864 (sig = 02212120) weight >=5 (4864), p-value = 0.967
bits per word = 64 (analyzing bits); min category p-value = 0.0568

processed 4e+11 bytes in 163 seconds (2.454 GB/s, 8.834 TB/h). Fri Feb 21 23:25:04 2025

p = 0.253
------

mix3 extreme = 2.02087 (sig = 02000000) weight 1 (16), p-value = 0.507
mix3 extreme = 3.38282 (sig = 00010020) weight 2 (112), p-value = 0.0772
mix3 extreme = 3.77275 (sig = 01000220) weight 3 (448), p-value = 0.0698
mix3 extreme = 3.96045 (sig = 22020010) weight 4 (1120), p-value = 0.0804
mix3 extreme = 3.96698 (sig = 10212100) weight >=5 (4864), p-value = 0.298
bits per word = 64 (analyzing bits); min category p-value = 0.0698

processed 5e+11 bytes in 204 seconds (2.451 GB/s, 8.824 TB/h). Fri Feb 21 23:25:45 2025

p = 0.304
------

mix3 extreme = 2.11460 (sig = 02000000) weight 1 (16), p-value = 0.429
mix3 extreme = 3.45081 (sig = 00010020) weight 2 (112), p-value = 0.0607
mix3 extreme = 4.11176 (sig = 01000220) weight 3 (448), p-value = 0.0174
mix3 extreme = 3.90641 (sig = 22020010) weight 4 (1120), p-value = 0.0996
mix3 extreme = 3.86051 (sig = 10110212) weight >=5 (4864), p-value = 0.423
bits per word = 64 (analyzing bits); min category p-value = 0.0174

processed 6e+11 bytes in 244 seconds (2.459 GB/s, 8.853 TB/h). Fri Feb 21 23:26:25 2025

p = 0.0842
------

mix3 extreme = 2.19471 (sig = 02000000) weight 1 (16), p-value = 0.367
mix3 extreme = 3.42206 (sig = 00010020) weight 2 (112), p-value = 0.0673
mix3 extreme = 3.76615 (sig = 01000220) weight 3 (448), p-value = 0.0716
mix3 extreme = 3.59051 (sig = 22020010) weight 4 (1120), p-value = 0.309
mix3 extreme = 3.55018 (sig = 20012221) weight >=5 (4864), p-value = 0.846
bits per word = 64 (analyzing bits); min category p-value = 0.0673

processed 7e+11 bytes in 285 seconds (2.456 GB/s, 8.842 TB/h). Fri Feb 21 23:27:06 2025

p = 0.294
------

mix3 extreme = 2.08568 (sig = 02000000) weight 1 (16), p-value = 0.453
mix3 extreme = 2.70372 (sig = 00010020) weight 2 (112), p-value = 0.537
mix3 extreme = 3.67441 (sig = 20021000) weight 3 (448), p-value = 0.101
mix3 extreme = 3.40600 (sig = 22020010) weight 4 (1120), p-value = 0.522
mix3 extreme = 3.74169 (sig = 10110212) weight >=5 (4864), p-value = 0.589
bits per word = 64 (analyzing bits); min category p-value = 0.101

processed 8.5e+11 bytes in 346 seconds (2.457 GB/s, 8.844 TB/h). Fri Feb 21 23:28:07 2025

p = 0.414
------

mix3 extreme = 1.70943 (sig = 00000100) weight 1 (16), p-value = 0.768
mix3 extreme = 3.16917 (sig = 00010020) weight 2 (112), p-value = 0.157
mix3 extreme = 3.64671 (sig = 02000201) weight 3 (448), p-value = 0.112
mix3 extreme = 3.82262 (sig = 11010200) weight 4 (1120), p-value = 0.137
mix3 extreme = 3.64758 (sig = 00222021) weight >=5 (4864), p-value = 0.724
bits per word = 64 (analyzing bits); min category p-value = 0.112

processed 1e+12 bytes in 407 seconds (2.457 GB/s, 8.845 TB/h). Fri Feb 21 23:29:08 2025

p = 0.448
------

mix3 extreme = 1.76773 (sig = 20000000) weight 1 (16), p-value = 0.723
mix3 extreme = 3.14942 (sig = 00002020) weight 2 (112), p-value = 0.168
mix3 extreme = 3.45782 (sig = 02000201) weight 3 (448), p-value = 0.217
mix3 extreme = 3.68367 (sig = 11010200) weight 4 (1120), p-value = 0.227
mix3 extreme = 4.05225 (sig = 00222021) weight >=5 (4864), p-value = 0.219
bits per word = 64 (analyzing bits); min category p-value = 0.168

processed 1.25e+12 bytes in 509 seconds (2.456 GB/s, 8.841 TB/h). Fri Feb 21 23:30:50 2025

p = 0.6
------

mix3 extreme = 1.78446 (sig = 00000001) weight 1 (16), p-value = 0.709
mix3 extreme = 3.00030 (sig = 00002020) weight 2 (112), p-value = 0.261
mix3 extreme = 3.68239 (sig = 02000201) weight 3 (448), p-value = 0.0983
mix3 extreme = 3.38984 (sig = 11010020) weight 4 (1120), p-value = 0.543
mix3 extreme = 4.00734 (sig = 02221002) weight >=5 (4864), p-value = 0.258
bits per word = 64 (analyzing bits); min category p-value = 0.0983

processed 1.5e+12 bytes in 611 seconds (2.455 GB/s, 8.838 TB/h). Fri Feb 21 23:32:32 2025

p = 0.404
------

mix3 extreme = 1.49970 (sig = 02000000) weight 1 (16), p-value = 0.899
mix3 extreme = 2.64430 (sig = 20000020) weight 2 (112), p-value = 0.602
mix3 extreme = 3.85954 (sig = 02000201) weight 3 (448), p-value = 0.0496
mix3 extreme = 3.76326 (sig = 11010020) weight 4 (1120), p-value = 0.171
mix3 extreme = 3.91001 (sig = 00222021) weight >=5 (4864), p-value = 0.362
bits per word = 64 (analyzing bits); min category p-value = 0.0496

processed 1.75e+12 bytes in 713 seconds (2.454 GB/s, 8.836 TB/h). Fri Feb 21 23:34:14 2025

p = 0.225
------

mix3 extreme = 1.64313 (sig = 02000000) weight 1 (16), p-value = 0.816
mix3 extreme = 3.02382 (sig = 02100000) weight 2 (112), p-value = 0.244
mix3 extreme = 3.21441 (sig = 02000201) weight 3 (448), p-value = 0.443
mix3 extreme = 4.07811 (sig = 11010020) weight 4 (1120), p-value = 0.0496
mix3 extreme = 4.50737 (sig = 00222021) weight >=5 (4864), p-value = 0.0314
bits per word = 64 (analyzing bits); min category p-value = 0.0314

processed 2e+12 bytes in 815 seconds (2.454 GB/s, 8.834 TB/h). Fri Feb 21 23:35:56 2025

p = 0.148
------

mix3 extreme = 1.57884 (sig = 20000000) weight 1 (16), p-value = 0.857
mix3 extreme = 2.68908 (sig = 00001002) weight 2 (112), p-value = 0.553
mix3 extreme = 3.22275 (sig = 01000220) weight 3 (448), p-value = 0.434
mix3 extreme = 3.84110 (sig = 11010020) weight 4 (1120), p-value = 0.128
mix3 extreme = 3.89955 (sig = 10020112) weight >=5 (4864), p-value = 0.374
bits per word = 64 (analyzing bits); min category p-value = 0.128

processed 2.5e+12 bytes in 1.02e+03 seconds (2.456 GB/s, 8.841 TB/h). Fri Feb 21 23:39:19 2025

p = 0.496
------

mix3 extreme = 1.67736 (sig = 00001000) weight 1 (16), p-value = 0.792
mix3 extreme = 2.62488 (sig = 00001002) weight 2 (112), p-value = 0.623
mix3 extreme = 3.38419 (sig = 02002002) weight 3 (448), p-value = 0.274
mix3 extreme = 3.80757 (sig = 11010020) weight 4 (1120), p-value = 0.145
mix3 extreme = 3.95015 (sig = 00211221) weight >=5 (4864), p-value = 0.316
bits per word = 64 (analyzing bits); min category p-value = 0.145

processed 3e+12 bytes in 1.22e+03 seconds (2.451 GB/s, 8.824 TB/h). Fri Feb 21 23:42:45 2025

p = 0.544
------

mix3 extreme = 1.79534 (sig = 00002000) weight 1 (16), p-value = 0.701
mix3 extreme = 2.76965 (sig = 00001002) weight 2 (112), p-value = 0.468
mix3 extreme = 3.58785 (sig = 01000220) weight 3 (448), p-value = 0.139
mix3 extreme = 3.25341 (sig = 20200012) weight 4 (1120), p-value = 0.721
mix3 extreme = 3.65576 (sig = 12111122) weight >=5 (4864), p-value = 0.713
bits per word = 64 (analyzing bits); min category p-value = 0.139

processed 4e+12 bytes in 1.63e+03 seconds (2.448 GB/s, 8.813 TB/h). Fri Feb 21 23:49:35 2025

p = 0.526
------
```

------------------------------------------------------------
### `FIO_DEFINE_RANDOM128_FN`

The following are the tests for the built-in `FIO_DEFINE_RANDOM128_FN` macro using the deterministic PRNG (where the auto-reseeding `reseed_log` is set to `0`).

**Note**: setting `reseed_log` to any practical value (such as `31`) would improve randomness make the PRNG non-deterministic, improving the security of the result.

**The `PractRand` results**:

```txt
# ./tmp/rnd -p M128 | RNG_test stdin
RNG_test using PractRand version 0.95
RNG = RNG_stdin, seed = unknown
test set = core, folding = standard(unknown format)

rng=RNG_stdin, seed=unknown
length= 256 megabytes (2^28 bytes), time= 2.4 seconds
  no anomalies in 217 test result(s)

rng=RNG_stdin, seed=unknown
length= 512 megabytes (2^29 bytes), time= 5.0 seconds
  no anomalies in 232 test result(s)

rng=RNG_stdin, seed=unknown
length= 1 gigabyte (2^30 bytes), time= 10.1 seconds
  no anomalies in 251 test result(s)

rng=RNG_stdin, seed=unknown
length= 2 gigabytes (2^31 bytes), time= 20.6 seconds
  no anomalies in 269 test result(s)

rng=RNG_stdin, seed=unknown
length= 4 gigabytes (2^32 bytes), time= 41.2 seconds
  no anomalies in 283 test result(s)

rng=RNG_stdin, seed=unknown
length= 8 gigabytes (2^33 bytes), time= 83.9 seconds
  no anomalies in 300 test result(s)

rng=RNG_stdin, seed=unknown
length= 16 gigabytes (2^34 bytes), time= 167 seconds
  no anomalies in 315 test result(s)

rng=RNG_stdin, seed=unknown
length= 32 gigabytes (2^35 bytes), time= 330 seconds
  no anomalies in 328 test result(s)

rng=RNG_stdin, seed=unknown
length= 64 gigabytes (2^36 bytes), time= 665 seconds
  no anomalies in 344 test result(s)

rng=RNG_stdin, seed=unknown
length= 128 gigabytes (2^37 bytes), time= 1329 seconds
  no anomalies in 359 test result(s)

rng=RNG_stdin, seed=unknown
length= 256 gigabytes (2^38 bytes), time= 2630 seconds
  no anomalies in 372 test result(s)

rng=RNG_stdin, seed=unknown
length= 512 gigabytes (2^39 bytes), time= 6846 seconds
  no anomalies in 387 test result(s)

rng=RNG_stdin, seed=unknown
length= 1 terabyte (2^40 bytes), time= 18633 seconds
  no anomalies in 401 test result(s)

rng=RNG_stdin, seed=unknown
length= 2 terabytes (2^41 bytes), time= 39061 seconds
  no anomalies in 413 test result(s)
```

**The tests adopted from the `xoshiro` code base**:


```txt
# ./tmp/random m128
mix3 extreme = 1.90403 (sig = 00020000) weight 1 (16), p-value = 0.608
mix3 extreme = 2.78422 (sig = 01000001) weight 2 (112), p-value = 0.453
mix3 extreme = 2.98802 (sig = 00001220) weight 3 (448), p-value = 0.716
mix3 extreme = 3.51263 (sig = 22110000) weight 4 (1120), p-value = 0.392
mix3 extreme = 3.86128 (sig = 22110200) weight >=5 (4864), p-value = 0.422
bits per word = 64 (analyzing bits); min category p-value = 0.392

processed 1.11e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.917
------

mix3 extreme = 2.33512 (sig = 00020000) weight 1 (16), p-value = 0.271
mix3 extreme = 2.60631 (sig = 00000011) weight 2 (112), p-value = 0.643
mix3 extreme = 3.20941 (sig = 00001220) weight 3 (448), p-value = 0.449
mix3 extreme = 3.23491 (sig = 10000221) weight 4 (1120), p-value = 0.744
mix3 extreme = 3.98181 (sig = 12101200) weight >=5 (4864), p-value = 0.283
bits per word = 64 (analyzing bits); min category p-value = 0.271

processed 1.29e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.794
------

mix3 extreme = 2.09795 (sig = 00020000) weight 1 (16), p-value = 0.443
mix3 extreme = 2.59859 (sig = 00000011) weight 2 (112), p-value = 0.651
mix3 extreme = 3.16919 (sig = 00020012) weight 3 (448), p-value = 0.496
mix3 extreme = 3.32522 (sig = 01002210) weight 4 (1120), p-value = 0.628
mix3 extreme = 3.87995 (sig = 20211102) weight >=5 (4864), p-value = 0.398
bits per word = 64 (analyzing bits); min category p-value = 0.398

processed 1.66e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.921
------

mix3 extreme = 1.97959 (sig = 00020000) weight 1 (16), p-value = 0.543
mix3 extreme = 2.47936 (sig = 00000011) weight 2 (112), p-value = 0.773
mix3 extreme = 3.25629 (sig = 02000022) weight 3 (448), p-value = 0.397
mix3 extreme = 3.20819 (sig = 20001012) weight 4 (1120), p-value = 0.776
mix3 extreme = 3.85604 (sig = 21111101) weight >=5 (4864), p-value = 0.429
bits per word = 64 (analyzing bits); min category p-value = 0.397

processed 1.85e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.92
------

mix3 extreme = 2.14920 (sig = 00020000) weight 1 (16), p-value = 0.402
mix3 extreme = 2.58549 (sig = 00000011) weight 2 (112), p-value = 0.665
mix3 extreme = 2.97421 (sig = 02000022) weight 3 (448), p-value = 0.732
mix3 extreme = 2.92783 (sig = 00112001) weight 4 (1120), p-value = 0.978
mix3 extreme = 3.95789 (sig = 22110200) weight >=5 (4864), p-value = 0.308
bits per word = 64 (analyzing bits); min category p-value = 0.308

processed 2.03e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.841
------

mix3 extreme = 1.47529 (sig = 00001000) weight 1 (16), p-value = 0.911
mix3 extreme = 2.73432 (sig = 10000100) weight 2 (112), p-value = 0.505
mix3 extreme = 2.85412 (sig = 00220100) weight 3 (448), p-value = 0.856
mix3 extreme = 3.71866 (sig = 20200011) weight 4 (1120), p-value = 0.201
mix3 extreme = 3.82703 (sig = 12212021) weight >=5 (4864), p-value = 0.468
bits per word = 64 (analyzing bits); min category p-value = 0.201

processed 2.59e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.674
------

mix3 extreme = 1.48360 (sig = 20000000) weight 1 (16), p-value = 0.907
mix3 extreme = 2.46121 (sig = 00002002) weight 2 (112), p-value = 0.79
mix3 extreme = 2.87026 (sig = 20000201) weight 3 (448), p-value = 0.841
mix3 extreme = 3.86069 (sig = 20200011) weight 4 (1120), p-value = 0.119
mix3 extreme = 3.76155 (sig = 21201200) weight >=5 (4864), p-value = 0.56
bits per word = 64 (analyzing bits); min category p-value = 0.119

processed 3.14e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.469
------

mix3 extreme = 1.84311 (sig = 20000000) weight 1 (16), p-value = 0.661
mix3 extreme = 2.57296 (sig = 10001000) weight 2 (112), p-value = 0.679
mix3 extreme = 3.19014 (sig = 20000201) weight 3 (448), p-value = 0.471
mix3 extreme = 3.98985 (sig = 20200011) weight 4 (1120), p-value = 0.0714
mix3 extreme = 3.85549 (sig = 22121010) weight >=5 (4864), p-value = 0.43
bits per word = 64 (analyzing bits); min category p-value = 0.0714

processed 4.07e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.309
------

mix3 extreme = 1.41079 (sig = 20000000) weight 1 (16), p-value = 0.937
mix3 extreme = 3.04738 (sig = 10001000) weight 2 (112), p-value = 0.228
mix3 extreme = 3.74043 (sig = 00220100) weight 3 (448), p-value = 0.079
mix3 extreme = 3.82980 (sig = 00101210) weight 4 (1120), p-value = 0.134
mix3 extreme = 3.95613 (sig = 12012120) weight >=5 (4864), p-value = 0.31
bits per word = 64 (analyzing bits); min category p-value = 0.079

processed 5.18e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.337
------

mix3 extreme = 1.46023 (sig = 00020000) weight 1 (16), p-value = 0.917
mix3 extreme = 2.75344 (sig = 00200100) weight 2 (112), p-value = 0.484
mix3 extreme = 3.35270 (sig = 20000201) weight 3 (448), p-value = 0.301
mix3 extreme = 3.74339 (sig = 02102100) weight 4 (1120), p-value = 0.184
mix3 extreme = 3.75002 (sig = 12012120) weight >=5 (4864), p-value = 0.577
bits per word = 64 (analyzing bits); min category p-value = 0.184

processed 6.1e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.638
------

mix3 extreme = 1.50237 (sig = 00000020) weight 1 (16), p-value = 0.898
mix3 extreme = 2.42220 (sig = 00200100) weight 2 (112), p-value = 0.825
mix3 extreme = 2.96916 (sig = 20000201) weight 3 (448), p-value = 0.738
mix3 extreme = 3.78954 (sig = 02102100) weight 4 (1120), p-value = 0.156
mix3 extreme = 3.66917 (sig = 10010121) weight >=5 (4864), p-value = 0.694
bits per word = 64 (analyzing bits); min category p-value = 0.156

processed 7.03e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.571
------

mix3 extreme = 1.78774 (sig = 00000020) weight 1 (16), p-value = 0.707
mix3 extreme = 2.70149 (sig = 00010100) weight 2 (112), p-value = 0.54
mix3 extreme = 3.27303 (sig = 01120000) weight 3 (448), p-value = 0.379
mix3 extreme = 4.21573 (sig = 02102100) weight 4 (1120), p-value = 0.0275
mix3 extreme = 3.70578 (sig = 12100210) weight >=5 (4864), p-value = 0.641
bits per word = 64 (analyzing bits); min category p-value = 0.0275

processed 8.5e+08 bytes in 0 seconds (inf GB/s, inf TB/h). Fri Feb 21 23:22:45 2025

p = 0.13
------

mix3 extreme = 2.31948 (sig = 10000000) weight 1 (16), p-value = 0.281
mix3 extreme = 2.44934 (sig = 00010100) weight 2 (112), p-value = 0.801
mix3 extreme = 3.53130 (sig = 01120000) weight 3 (448), p-value = 0.169
mix3 extreme = 4.28717 (sig = 02102100) weight 4 (1120), p-value = 0.0201
mix3 extreme = 3.66277 (sig = 12100210) weight >=5 (4864), p-value = 0.703
bits per word = 64 (analyzing bits); min category p-value = 0.0201

processed 1.02e+09 bytes in 1 seconds (1.017 GB/s, 3.661 TB/h). Fri Feb 21 23:22:46 2025

p = 0.0964
------

mix3 extreme = 2.60876 (sig = 00000020) weight 1 (16), p-value = 0.136
mix3 extreme = 2.67150 (sig = 22000000) weight 2 (112), p-value = 0.572
mix3 extreme = 3.39462 (sig = 01120000) weight 3 (448), p-value = 0.265
mix3 extreme = 3.62549 (sig = 02200120) weight 4 (1120), p-value = 0.276
mix3 extreme = 3.63707 (sig = 12100021) weight >=5 (4864), p-value = 0.739
bits per word = 64 (analyzing bits); min category p-value = 0.136

processed 1.26e+09 bytes in 1 seconds (1.257 GB/s, 4.526 TB/h). Fri Feb 21 23:22:46 2025

p = 0.518
------

mix3 extreme = 2.15590 (sig = 00000020) weight 1 (16), p-value = 0.397
mix3 extreme = 2.80570 (sig = 00001010) weight 2 (112), p-value = 0.431
mix3 extreme = 3.40481 (sig = 02020001) weight 3 (448), p-value = 0.257
mix3 extreme = 3.36693 (sig = 01100012) weight 4 (1120), p-value = 0.573
mix3 extreme = 3.51384 (sig = 12012120) weight >=5 (4864), p-value = 0.883
bits per word = 64 (analyzing bits); min category p-value = 0.257

processed 1.52e+09 bytes in 1 seconds (1.516 GB/s, 5.458 TB/h). Fri Feb 21 23:22:46 2025

p = 0.773
------

mix3 extreme = 1.90047 (sig = 00000020) weight 1 (16), p-value = 0.611
mix3 extreme = 3.23402 (sig = 00001010) weight 2 (112), p-value = 0.128
mix3 extreme = 2.96881 (sig = 20001001) weight 3 (448), p-value = 0.739
mix3 extreme = 3.52470 (sig = 01012002) weight 4 (1120), p-value = 0.378
mix3 extreme = 3.72569 (sig = 22111101) weight >=5 (4864), p-value = 0.612
bits per word = 64 (analyzing bits); min category p-value = 0.128

processed 1.76e+09 bytes in 1 seconds (1.756 GB/s, 6.323 TB/h). Fri Feb 21 23:22:46 2025

p = 0.495
------

mix3 extreme = 1.57279 (sig = 00000010) weight 1 (16), p-value = 0.86
mix3 extreme = 2.81387 (sig = 00001010) weight 2 (112), p-value = 0.423
mix3 extreme = 3.18715 (sig = 02002010) weight 3 (448), p-value = 0.475
mix3 extreme = 3.33070 (sig = 00101120) weight 4 (1120), p-value = 0.621
mix3 extreme = 4.16820 (sig = 20122202) weight >=5 (4864), p-value = 0.139
bits per word = 64 (analyzing bits); min category p-value = 0.139

processed 2.02e+09 bytes in 1 seconds (2.015 GB/s, 7.255 TB/h). Fri Feb 21 23:22:46 2025

p = 0.526
------

mix3 extreme = 1.53157 (sig = 00000020) weight 1 (16), p-value = 0.883
mix3 extreme = 2.71599 (sig = 00001010) weight 2 (112), p-value = 0.524
mix3 extreme = 3.16021 (sig = 02002010) weight 3 (448), p-value = 0.507
mix3 extreme = 3.26824 (sig = 00101120) weight 4 (1120), p-value = 0.703
mix3 extreme = 4.01251 (sig = 22021002) weight >=5 (4864), p-value = 0.253
bits per word = 64 (analyzing bits); min category p-value = 0.253

processed 2.51e+09 bytes in 1 seconds (2.514 GB/s, 9.052 TB/h). Fri Feb 21 23:22:46 2025

p = 0.768
------

mix3 extreme = 1.74122 (sig = 00000020) weight 1 (16), p-value = 0.744
mix3 extreme = 2.86200 (sig = 00010100) weight 2 (112), p-value = 0.377
mix3 extreme = 3.41797 (sig = 02002010) weight 3 (448), p-value = 0.246
mix3 extreme = 3.48775 (sig = 00101120) weight 4 (1120), p-value = 0.421
mix3 extreme = 4.32378 (sig = 22021002) weight >=5 (4864), p-value = 0.0719
bits per word = 64 (analyzing bits); min category p-value = 0.0719

processed 3.01e+09 bytes in 1 seconds (3.014 GB/s, 10.85 TB/h). Fri Feb 21 23:22:46 2025

p = 0.311
------

mix3 extreme = 1.61472 (sig = 00000020) weight 1 (16), p-value = 0.835
mix3 extreme = 3.22143 (sig = 00010100) weight 2 (112), p-value = 0.133
mix3 extreme = 3.34281 (sig = 02002010) weight 3 (448), p-value = 0.31
mix3 extreme = 3.41424 (sig = 10011100) weight 4 (1120), p-value = 0.512
mix3 extreme = 3.68273 (sig = 00122011) weight >=5 (4864), p-value = 0.675
bits per word = 64 (analyzing bits); min category p-value = 0.133

processed 4.01e+09 bytes in 1 seconds (4.012 GB/s, 14.44 TB/h). Fri Feb 21 23:22:46 2025

p = 0.511
------

mix3 extreme = 2.08971 (sig = 00000020) weight 1 (16), p-value = 0.45
mix3 extreme = 3.03226 (sig = 00010100) weight 2 (112), p-value = 0.238
mix3 extreme = 3.22814 (sig = 00010102) weight 3 (448), p-value = 0.428
mix3 extreme = 3.27577 (sig = 10011100) weight 4 (1120), p-value = 0.693
mix3 extreme = 3.67641 (sig = 12012120) weight >=5 (4864), p-value = 0.684
bits per word = 64 (analyzing bits); min category p-value = 0.238

processed 5.01e+09 bytes in 2 seconds (2.505 GB/s, 9.019 TB/h). Fri Feb 21 23:22:47 2025

p = 0.744
------

mix3 extreme = 1.91894 (sig = 10000000) weight 1 (16), p-value = 0.595
mix3 extreme = 2.77625 (sig = 00010100) weight 2 (112), p-value = 0.461
mix3 extreme = 3.06382 (sig = 00011001) weight 3 (448), p-value = 0.625
mix3 extreme = 3.14390 (sig = 21020200) weight 4 (1120), p-value = 0.846
mix3 extreme = 3.59615 (sig = 00122011) weight >=5 (4864), p-value = 0.792
bits per word = 64 (analyzing bits); min category p-value = 0.461

processed 6.01e+09 bytes in 2 seconds (3.004 GB/s, 10.82 TB/h). Fri Feb 21 23:22:47 2025

p = 0.954
------

mix3 extreme = 1.86597 (sig = 00000020) weight 1 (16), p-value = 0.641
mix3 extreme = 2.61078 (sig = 00010100) weight 2 (112), p-value = 0.638
mix3 extreme = 3.42404 (sig = 00011001) weight 3 (448), p-value = 0.242
mix3 extreme = 3.40741 (sig = 00020122) weight 4 (1120), p-value = 0.52
mix3 extreme = 3.89941 (sig = 00122011) weight >=5 (4864), p-value = 0.374
bits per word = 64 (analyzing bits); min category p-value = 0.242

processed 7.01e+09 bytes in 2 seconds (3.504 GB/s, 12.61 TB/h). Fri Feb 21 23:22:47 2025

p = 0.749
------

mix3 extreme = 1.73399 (sig = 00000020) weight 1 (16), p-value = 0.75
mix3 extreme = 2.96016 (sig = 20000200) weight 2 (112), p-value = 0.292
mix3 extreme = 3.09543 (sig = 02000022) weight 3 (448), p-value = 0.586
mix3 extreme = 3.42588 (sig = 10101001) weight 4 (1120), p-value = 0.497
mix3 extreme = 3.66808 (sig = 10110201) weight >=5 (4864), p-value = 0.695
bits per word = 64 (analyzing bits); min category p-value = 0.292

processed 8.5e+09 bytes in 3 seconds (2.835 GB/s, 10.21 TB/h). Fri Feb 21 23:22:48 2025

p = 0.822
------

mix3 extreme = 1.52914 (sig = 00200000) weight 1 (16), p-value = 0.885
mix3 extreme = 3.81757 (sig = 20000200) weight 2 (112), p-value = 0.015
mix3 extreme = 3.07953 (sig = 02201000) weight 3 (448), p-value = 0.605
mix3 extreme = 3.26619 (sig = 01102001) weight 4 (1120), p-value = 0.705
mix3 extreme = 3.73963 (sig = 02122020) weight >=5 (4864), p-value = 0.592
bits per word = 64 (analyzing bits); min category p-value = 0.015

processed 1e+10 bytes in 3 seconds (3.334 GB/s, 12 TB/h). Fri Feb 21 23:22:48 2025

p = 0.0727
------

mix3 extreme = 2.00898 (sig = 00020000) weight 1 (16), p-value = 0.518
mix3 extreme = 2.73872 (sig = 20000200) weight 2 (112), p-value = 0.5
mix3 extreme = 2.89865 (sig = 22000200) weight 3 (448), p-value = 0.814
mix3 extreme = 3.51139 (sig = 10002220) weight 4 (1120), p-value = 0.393
mix3 extreme = 3.46747 (sig = 21020120) weight >=5 (4864), p-value = 0.922
bits per word = 64 (analyzing bits); min category p-value = 0.393

processed 1.25e+10 bytes in 4 seconds (3.129 GB/s, 11.27 TB/h). Fri Feb 21 23:22:49 2025

p = 0.918
------

mix3 extreme = 2.54743 (sig = 00020000) weight 1 (16), p-value = 0.16
mix3 extreme = 2.66976 (sig = 00020200) weight 2 (112), p-value = 0.574
mix3 extreme = 3.21302 (sig = 02020010) weight 3 (448), p-value = 0.445
mix3 extreme = 3.17616 (sig = 10002220) weight 4 (1120), p-value = 0.812
mix3 extreme = 4.08852 (sig = 00122011) weight >=5 (4864), p-value = 0.19
bits per word = 64 (analyzing bits); min category p-value = 0.16

processed 1.5e+10 bytes in 5 seconds (3.003 GB/s, 10.81 TB/h). Fri Feb 21 23:22:50 2025

p = 0.582
------

mix3 extreme = 2.32339 (sig = 00020000) weight 1 (16), p-value = 0.278
mix3 extreme = 2.41362 (sig = 00001010) weight 2 (112), p-value = 0.832
mix3 extreme = 3.50336 (sig = 02020010) weight 3 (448), p-value = 0.186
mix3 extreme = 3.13576 (sig = 20221000) weight 4 (1120), p-value = 0.854
mix3 extreme = 4.28795 (sig = 00122011) weight >=5 (4864), p-value = 0.084
bits per word = 64 (analyzing bits); min category p-value = 0.084

processed 1.75e+10 bytes in 5 seconds (3.502 GB/s, 12.61 TB/h). Fri Feb 21 23:22:50 2025

p = 0.355
------

mix3 extreme = 2.55481 (sig = 00020000) weight 1 (16), p-value = 0.157
mix3 extreme = 2.72892 (sig = 00001010) weight 2 (112), p-value = 0.51
mix3 extreme = 3.28466 (sig = 11000001) weight 3 (448), p-value = 0.367
mix3 extreme = 3.42088 (sig = 01020102) weight 4 (1120), p-value = 0.503
mix3 extreme = 4.05525 (sig = 00122011) weight >=5 (4864), p-value = 0.216
bits per word = 64 (analyzing bits); min category p-value = 0.157

processed 2e+10 bytes in 6 seconds (3.334 GB/s, 12 TB/h). Fri Feb 21 23:22:51 2025

p = 0.575
------

mix3 extreme = 2.46488 (sig = 00020000) weight 1 (16), p-value = 0.198
mix3 extreme = 2.44365 (sig = 20000200) weight 2 (112), p-value = 0.806
mix3 extreme = 3.31277 (sig = 02020010) weight 3 (448), p-value = 0.339
mix3 extreme = 3.81631 (sig = 01020102) weight 4 (1120), p-value = 0.141
mix3 extreme = 4.12544 (sig = 00122011) weight >=5 (4864), p-value = 0.165
bits per word = 64 (analyzing bits); min category p-value = 0.141

processed 2.5e+10 bytes in 8 seconds (3.127 GB/s, 11.26 TB/h). Fri Feb 21 23:22:53 2025

p = 0.532
------

mix3 extreme = 2.18715 (sig = 00020000) weight 1 (16), p-value = 0.373
mix3 extreme = 2.10006 (sig = 20000020) weight 2 (112), p-value = 0.983
mix3 extreme = 3.08063 (sig = 00210002) weight 3 (448), p-value = 0.604
mix3 extreme = 3.66924 (sig = 02110010) weight 4 (1120), p-value = 0.239
mix3 extreme = 4.35154 (sig = 00122011) weight >=5 (4864), p-value = 0.0636
bits per word = 64 (analyzing bits); min category p-value = 0.0636

processed 3e+10 bytes in 9 seconds (3.334 GB/s, 12 TB/h). Fri Feb 21 23:22:54 2025

p = 0.28
------

mix3 extreme = 1.43572 (sig = 00020000) weight 1 (16), p-value = 0.927
mix3 extreme = 2.41760 (sig = 02000020) weight 2 (112), p-value = 0.829
mix3 extreme = 3.16026 (sig = 02100020) weight 3 (448), p-value = 0.507
mix3 extreme = 3.44650 (sig = 02220002) weight 4 (1120), p-value = 0.471
mix3 extreme = 4.35459 (sig = 00221220) weight >=5 (4864), p-value = 0.0628
bits per word = 64 (analyzing bits); min category p-value = 0.0628

processed 4e+10 bytes in 12 seconds (3.334 GB/s, 12 TB/h). Fri Feb 21 23:22:57 2025

p = 0.277
------

mix3 extreme = 1.73103 (sig = 02000000) weight 1 (16), p-value = 0.752
mix3 extreme = 2.59948 (sig = 02000020) weight 2 (112), p-value = 0.65
mix3 extreme = 3.24793 (sig = 02020010) weight 3 (448), p-value = 0.406
mix3 extreme = 3.18550 (sig = 00022021) weight 4 (1120), p-value = 0.802
mix3 extreme = 4.36307 (sig = 00122011) weight >=5 (4864), p-value = 0.0605
bits per word = 64 (analyzing bits); min category p-value = 0.0605

processed 5e+10 bytes in 15 seconds (3.334 GB/s, 12 TB/h). Fri Feb 21 23:23:00 2025

p = 0.268
------

mix3 extreme = 1.69245 (sig = 02000000) weight 1 (16), p-value = 0.781
mix3 extreme = 2.90012 (sig = 02000020) weight 2 (112), p-value = 0.342
mix3 extreme = 3.04010 (sig = 02100020) weight 3 (448), p-value = 0.654
mix3 extreme = 3.18726 (sig = 11012000) weight 4 (1120), p-value = 0.8
mix3 extreme = 4.13605 (sig = 00122011) weight >=5 (4864), p-value = 0.158
bits per word = 64 (analyzing bits); min category p-value = 0.158

processed 6e+10 bytes in 18 seconds (3.334 GB/s, 12 TB/h). Fri Feb 21 23:23:03 2025

p = 0.577
------

mix3 extreme = 2.02538 (sig = 02000000) weight 1 (16), p-value = 0.504
mix3 extreme = 2.69836 (sig = 20000020) weight 2 (112), p-value = 0.543
mix3 extreme = 2.74898 (sig = 00200110) weight 3 (448), p-value = 0.932
mix3 extreme = 3.09844 (sig = 11012000) weight 4 (1120), p-value = 0.887
mix3 extreme = 4.04079 (sig = 20022201) weight >=5 (4864), p-value = 0.228
bits per word = 64 (analyzing bits); min category p-value = 0.228

processed 7e+10 bytes in 21 seconds (3.334 GB/s, 12 TB/h). Fri Feb 21 23:23:06 2025

p = 0.726
------

mix3 extreme = 2.00762 (sig = 00020000) weight 1 (16), p-value = 0.519
mix3 extreme = 2.67485 (sig = 20000020) weight 2 (112), p-value = 0.569
mix3 extreme = 2.98340 (sig = 00110100) weight 3 (448), p-value = 0.722
mix3 extreme = 3.30873 (sig = 12210000) weight 4 (1120), p-value = 0.65
mix3 extreme = 4.04171 (sig = 20022201) weight >=5 (4864), p-value = 0.227
bits per word = 64 (analyzing bits); min category p-value = 0.227

processed 8.5e+10 bytes in 25 seconds (3.4 GB/s, 12.24 TB/h). Fri Feb 21 23:23:10 2025

p = 0.725
------

mix3 extreme = 1.98503 (sig = 00100000) weight 1 (16), p-value = 0.538
mix3 extreme = 2.83929 (sig = 20000020) weight 2 (112), p-value = 0.398
mix3 extreme = 3.24294 (sig = 00110100) weight 3 (448), p-value = 0.412
mix3 extreme = 3.26307 (sig = 00022012) weight 4 (1120), p-value = 0.709
mix3 extreme = 3.82851 (sig = 20212120) weight >=5 (4864), p-value = 0.466
bits per word = 64 (analyzing bits); min category p-value = 0.398

processed 1e+11 bytes in 30 seconds (3.333 GB/s, 12 TB/h). Fri Feb 21 23:23:15 2025

p = 0.921
------

mix3 extreme = 1.80847 (sig = 00000001) weight 1 (16), p-value = 0.69
mix3 extreme = 2.36679 (sig = 00001020) weight 2 (112), p-value = 0.868
mix3 extreme = 3.12962 (sig = 00110100) weight 3 (448), p-value = 0.544
mix3 extreme = 3.41207 (sig = 00022012) weight 4 (1120), p-value = 0.514
mix3 extreme = 3.50238 (sig = 01120021) weight >=5 (4864), p-value = 0.894
bits per word = 64 (analyzing bits); min category p-value = 0.514

processed 1.25e+11 bytes in 37 seconds (3.378 GB/s, 12.16 TB/h). Fri Feb 21 23:23:22 2025

p = 0.973
------

mix3 extreme = 1.61617 (sig = 01000000) weight 1 (16), p-value = 0.834
mix3 extreme = 2.75953 (sig = 10002000) weight 2 (112), p-value = 0.478
mix3 extreme = 3.01768 (sig = 22000200) weight 3 (448), p-value = 0.681
mix3 extreme = 3.12351 (sig = 20120020) weight 4 (1120), p-value = 0.865
mix3 extreme = 3.88895 (sig = 01201202) weight >=5 (4864), p-value = 0.387
bits per word = 64 (analyzing bits); min category p-value = 0.387

processed 1.5e+11 bytes in 45 seconds (3.334 GB/s, 12 TB/h). Fri Feb 21 23:23:30 2025

p = 0.914
------

mix3 extreme = 1.77082 (sig = 10000000) weight 1 (16), p-value = 0.721
mix3 extreme = 3.16452 (sig = 20000020) weight 2 (112), p-value = 0.16
mix3 extreme = 3.33010 (sig = 22000200) weight 3 (448), p-value = 0.322
mix3 extreme = 3.30032 (sig = 10202001) weight 4 (1120), p-value = 0.661
mix3 extreme = 3.71439 (sig = 01201202) weight >=5 (4864), p-value = 0.629
bits per word = 64 (analyzing bits); min category p-value = 0.16

processed 1.75e+11 bytes in 52 seconds (3.366 GB/s, 12.12 TB/h). Fri Feb 21 23:23:37 2025

p = 0.581
------

mix3 extreme = 1.63286 (sig = 10000000) weight 1 (16), p-value = 0.823
mix3 extreme = 3.04031 (sig = 20000020) weight 2 (112), p-value = 0.233
mix3 extreme = 3.07386 (sig = 00020120) weight 3 (448), p-value = 0.612
mix3 extreme = 3.25670 (sig = 20200101) weight 4 (1120), p-value = 0.717
mix3 extreme = 3.86559 (sig = 02121212) weight >=5 (4864), p-value = 0.417
bits per word = 64 (analyzing bits); min category p-value = 0.233

processed 2e+11 bytes in 59 seconds (3.39 GB/s, 12.2 TB/h). Fri Feb 21 23:23:44 2025

p = 0.734
------

mix3 extreme = 1.16364 (sig = 00000010) weight 1 (16), p-value = 0.989
mix3 extreme = 3.24185 (sig = 20000020) weight 2 (112), p-value = 0.125
mix3 extreme = 3.33043 (sig = 00020120) weight 3 (448), p-value = 0.322
mix3 extreme = 3.08521 (sig = 01100011) weight 4 (1120), p-value = 0.898
mix3 extreme = 3.38515 (sig = 20222110) weight >=5 (4864), p-value = 0.969
bits per word = 64 (analyzing bits); min category p-value = 0.125

processed 2.5e+11 bytes in 74 seconds (3.378 GB/s, 12.16 TB/h). Fri Feb 21 23:23:59 2025

p = 0.486
------

mix3 extreme = 1.51793 (sig = 02000000) weight 1 (16), p-value = 0.89
mix3 extreme = 3.13632 (sig = 02000020) weight 2 (112), p-value = 0.175
mix3 extreme = 4.30962 (sig = 00020120) weight 3 (448), p-value = 0.0073
mix3 extreme = 3.03490 (sig = 01000212) weight 4 (1120), p-value = 0.933
mix3 extreme = 3.69122 (sig = 12111112) weight >=5 (4864), p-value = 0.662
bits per word = 64 (analyzing bits); min category p-value = 0.0073

processed 3e+11 bytes in 89 seconds (3.371 GB/s, 12.14 TB/h). Fri Feb 21 23:24:14 2025

p = 0.036
------

mix3 extreme = 1.90308 (sig = 00002000) weight 1 (16), p-value = 0.609
mix3 extreme = 2.65558 (sig = 00022000) weight 2 (112), p-value = 0.589
mix3 extreme = 3.65368 (sig = 00020120) weight 3 (448), p-value = 0.109
mix3 extreme = 3.49934 (sig = 01000212) weight 4 (1120), p-value = 0.407
mix3 extreme = 3.96134 (sig = 12111112) weight >=5 (4864), p-value = 0.304
bits per word = 64 (analyzing bits); min category p-value = 0.109

processed 4e+11 bytes in 119 seconds (3.361 GB/s, 12.1 TB/h). Fri Feb 21 23:24:44 2025

p = 0.44
------

mix3 extreme = 2.01103 (sig = 00000010) weight 1 (16), p-value = 0.516
mix3 extreme = 2.75092 (sig = 20000020) weight 2 (112), p-value = 0.487
mix3 extreme = 3.58533 (sig = 00020120) weight 3 (448), p-value = 0.14
mix3 extreme = 3.00752 (sig = 00101101) weight 4 (1120), p-value = 0.948
mix3 extreme = 3.78108 (sig = 20222110) weight >=5 (4864), p-value = 0.532
bits per word = 64 (analyzing bits); min category p-value = 0.14

processed 5e+11 bytes in 148 seconds (3.378 GB/s, 12.16 TB/h). Fri Feb 21 23:25:13 2025

p = 0.53
------

mix3 extreme = 2.46075 (sig = 00000010) weight 1 (16), p-value = 0.2
mix3 extreme = 3.05595 (sig = 10001000) weight 2 (112), p-value = 0.222
mix3 extreme = 3.57444 (sig = 00020120) weight 3 (448), p-value = 0.146
mix3 extreme = 3.08460 (sig = 02100120) weight 4 (1120), p-value = 0.898
mix3 extreme = 3.57242 (sig = 21020202) weight >=5 (4864), p-value = 0.821
bits per word = 64 (analyzing bits); min category p-value = 0.146

processed 6e+11 bytes in 178 seconds (3.371 GB/s, 12.14 TB/h). Fri Feb 21 23:25:43 2025

p = 0.544
------

mix3 extreme = 2.39889 (sig = 00010000) weight 1 (16), p-value = 0.233
mix3 extreme = 3.05936 (sig = 20000020) weight 2 (112), p-value = 0.22
mix3 extreme = 3.35611 (sig = 00020120) weight 3 (448), p-value = 0.298
mix3 extreme = 3.06385 (sig = 12002002) weight 4 (1120), p-value = 0.914
mix3 extreme = 3.77731 (sig = 21020202) weight >=5 (4864), p-value = 0.538
bits per word = 64 (analyzing bits); min category p-value = 0.22

processed 7e+11 bytes in 207 seconds (3.382 GB/s, 12.17 TB/h). Fri Feb 21 23:26:12 2025

p = 0.712
------

mix3 extreme = 2.44670 (sig = 00010000) weight 1 (16), p-value = 0.207
mix3 extreme = 3.17448 (sig = 00101000) weight 2 (112), p-value = 0.155
mix3 extreme = 3.94606 (sig = 00020120) weight 3 (448), p-value = 0.035
mix3 extreme = 3.39578 (sig = 12002002) weight 4 (1120), p-value = 0.535
mix3 extreme = 3.46995 (sig = 22000212) weight >=5 (4864), p-value = 0.921
bits per word = 64 (analyzing bits); min category p-value = 0.035

processed 8.5e+11 bytes in 252 seconds (3.373 GB/s, 12.14 TB/h). Fri Feb 21 23:26:57 2025

p = 0.163
------

mix3 extreme = 2.60423 (sig = 00000200) weight 1 (16), p-value = 0.138
mix3 extreme = 4.14356 (sig = 02000020) weight 2 (112), p-value = 0.00382
mix3 extreme = 3.30244 (sig = 00210010) weight 3 (448), p-value = 0.349
mix3 extreme = 2.92058 (sig = 00111100) weight 4 (1120), p-value = 0.98
mix3 extreme = 3.64298 (sig = 21221022) weight >=5 (4864), p-value = 0.73
bits per word = 64 (analyzing bits); min category p-value = 0.00382

processed 1e+12 bytes in 296 seconds (3.378 GB/s, 12.16 TB/h). Fri Feb 21 23:27:41 2025

p = 0.019
------

mix3 extreme = 2.39411 (sig = 00000200) weight 1 (16), p-value = 0.236
mix3 extreme = 3.86207 (sig = 02000020) weight 2 (112), p-value = 0.0125
mix3 extreme = 3.43732 (sig = 00210010) weight 3 (448), p-value = 0.231
mix3 extreme = 3.30612 (sig = 10010102) weight 4 (1120), p-value = 0.654
mix3 extreme = 3.69570 (sig = 02122102) weight >=5 (4864), p-value = 0.656
bits per word = 64 (analyzing bits); min category p-value = 0.0125

processed 1.25e+12 bytes in 370 seconds (3.378 GB/s, 12.16 TB/h). Fri Feb 21 23:28:55 2025

p = 0.061
------

mix3 extreme = 1.91917 (sig = 00000200) weight 1 (16), p-value = 0.595
mix3 extreme = 2.88512 (sig = 10001000) weight 2 (112), p-value = 0.355
mix3 extreme = 3.79690 (sig = 00210010) weight 3 (448), p-value = 0.0635
mix3 extreme = 3.81192 (sig = 10010102) weight 4 (1120), p-value = 0.143
mix3 extreme = 3.94746 (sig = 20221222) weight >=5 (4864), p-value = 0.319
bits per word = 64 (analyzing bits); min category p-value = 0.0635

processed 1.5e+12 bytes in 444 seconds (3.378 GB/s, 12.16 TB/h). Fri Feb 21 23:30:09 2025

p = 0.28
------

mix3 extreme = 1.91653 (sig = 00000200) weight 1 (16), p-value = 0.598
mix3 extreme = 3.17062 (sig = 02000020) weight 2 (112), p-value = 0.157
mix3 extreme = 3.50267 (sig = 00210010) weight 3 (448), p-value = 0.186
mix3 extreme = 4.12447 (sig = 10010102) weight 4 (1120), p-value = 0.0408
mix3 extreme = 4.27098 (sig = 20221222) weight >=5 (4864), p-value = 0.0903
bits per word = 64 (analyzing bits); min category p-value = 0.0408

processed 1.75e+12 bytes in 518 seconds (3.378 GB/s, 12.16 TB/h). Fri Feb 21 23:31:23 2025

p = 0.188
------

mix3 extreme = 1.81906 (sig = 00000200) weight 1 (16), p-value = 0.681
mix3 extreme = 3.06798 (sig = 10100000) weight 2 (112), p-value = 0.215
mix3 extreme = 3.71332 (sig = 02020200) weight 3 (448), p-value = 0.0876
mix3 extreme = 4.23944 (sig = 10010102) weight 4 (1120), p-value = 0.0248
mix3 extreme = 4.44624 (sig = 20221222) weight >=5 (4864), p-value = 0.0416
bits per word = 64 (analyzing bits); min category p-value = 0.0248

processed 2e+12 bytes in 592 seconds (3.378 GB/s, 12.16 TB/h). Fri Feb 21 23:32:37 2025

p = 0.118
------

mix3 extreme = 1.53717 (sig = 01000000) weight 1 (16), p-value = 0.88
mix3 extreme = 3.32377 (sig = 10100000) weight 2 (112), p-value = 0.0947
mix3 extreme = 3.12416 (sig = 02200001) weight 3 (448), p-value = 0.55
mix3 extreme = 3.46863 (sig = 02110100) weight 4 (1120), p-value = 0.443
mix3 extreme = 4.84658 (sig = 20221222) weight >=5 (4864), p-value = 0.00609
bits per word = 64 (analyzing bits); min category p-value = 0.00609

processed 2.5e+12 bytes in 740 seconds (3.378 GB/s, 12.16 TB/h). Fri Feb 21 23:35:05 2025

p = 0.0301
------

mix3 extreme = 1.61173 (sig = 00000200) weight 1 (16), p-value = 0.837
mix3 extreme = 3.37008 (sig = 10100000) weight 2 (112), p-value = 0.0807
mix3 extreme = 3.93348 (sig = 00202100) weight 3 (448), p-value = 0.0368
mix3 extreme = 3.29910 (sig = 02200021) weight 4 (1120), p-value = 0.663
mix3 extreme = 4.29826 (sig = 20221222) weight >=5 (4864), p-value = 0.0803
bits per word = 64 (analyzing bits); min category p-value = 0.0368

processed 3e+12 bytes in 887 seconds (3.382 GB/s, 12.18 TB/h). Fri Feb 21 23:37:32 2025

p = 0.171
------

mix3 extreme = 2.09163 (sig = 00000200) weight 1 (16), p-value = 0.448
mix3 extreme = 2.61382 (sig = 01100000) weight 2 (112), p-value = 0.635
mix3 extreme = 3.98155 (sig = 00202100) weight 3 (448), p-value = 0.0302
mix3 extreme = 3.38573 (sig = 00002211) weight 4 (1120), p-value = 0.549
mix3 extreme = 4.15291 (sig = 20211110) weight >=5 (4864), p-value = 0.148
bits per word = 64 (analyzing bits); min category p-value = 0.0302

processed 4e+12 bytes in 1.18e+03 seconds (3.381 GB/s, 12.17 TB/h). Fri Feb 21 23:42:28 2025

p = 0.142
------
```

------------------------------------------------------------

------------------------------------------------------------
