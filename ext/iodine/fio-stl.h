/* *****************************************************************************
Copyright: Boaz Segev, 2019-2026
License: ISC / MIT (choose your license)

Feel free to copy, use and enjoy according to the license provided.
********************************************************************************

********************************************************************************


            THE fio-stl.h FILE IS AUTO-GENERATED, DO NOT EDIT

                    https://github.com/facil-io/cstl


***************************************************************************** */

/* *****************************************************************************

**Notes**:

- The functions defined using this file default to `static` or `static
  inline`.

  To create an externally visible API, define the `FIO_EXTERN`. Define the
  `FIO_EXTERN_COMPLETE` macro to include the API's implementation as well.

- Documentation can be found at https://github.com/facil-io/cstl where you will
  be able to post PRs or submit issues.

***************************************************************************** */
#ifndef H___FIO_CSTL_COMBINED___H
#define H___FIO_CSTL_COMBINED___H
#endif /* H___FIO_CSTL_COMBINED___H */
#ifndef FIO_INCLUDE_FILE
#define FIO_INCLUDE_FILE "fio-stl.h"
#endif
/* *****************************************************************************




                    Core Header - Stuff required by everything


Note:

The core header can't be well ordered due to cascading dependencies.
Please refer to the core documentation in the Markdown File.
***************************************************************************** */
#ifndef H___FIO_CORE___H
#define H___FIO_CORE___H

/** An empty macro, adding white space. Used to avoid function like macros. */
#define FIO_NOOP

/** An empty macro, adding white space. Used to avoid function like macros. */
#define FIO_NOOP_FN(...)

/** Macro for a No-Op function name (void). */
#define FIO_NOOP_FN_NAME (void)

/* *****************************************************************************
Version Macros

The facil.io C STL library follows [semantic versioning](https://semver.org) and
supports macros that will help detect and validate it's version.
***************************************************************************** */

/** MAJOR version: API/ABI breaking changes. */
#define FIO_VERSION_MAJOR 0
/** MINOR version: Deprecation, or significant features added. May break ABI. */
#define FIO_VERSION_MINOR 8
/** PATCH version: Bug fixes, minor features may be added. */
#define FIO_VERSION_PATCH 0
/** Build version: optional build info (string), i.e. "beta.02" */
#define FIO_VERSION_BUILD "alpha.10"

#ifdef FIO_VERSION_BUILD
/** Version as a String literal (MACRO). */
#define FIO_VERSION_STRING                                                     \
  FIO_MACRO2STR(FIO_VERSION_MAJOR)                                             \
  "." FIO_MACRO2STR(FIO_VERSION_MINOR) "." FIO_MACRO2STR(                      \
      FIO_VERSION_PATCH) "-" FIO_VERSION_BUILD
#else
/** Version as a String literal (MACRO). */
#define FIO_VERSION_STRING                                                     \
  FIO_MACRO2STR(FIO_VERSION_MAJOR)                                             \
  "." FIO_MACRO2STR(FIO_VERSION_MINOR) "." FIO_MACRO2STR(FIO_VERSION_PATCH)
#define FIO_VERSION_BUILD ""
#endif

#ifndef FIO_LEAK_COUNTER
/** Enables memory leak detection. Disable by setting this to zero. */
#define FIO_LEAK_COUNTER 1
#endif
/* *****************************************************************************
Settings - Behavioral defaults
***************************************************************************** */

#ifndef FIO_USE_THREAD_MUTEX
/** Selects between facio.io's spinlocks (false) and OS mutexes (true) */
#define FIO_USE_THREAD_MUTEX 0
#endif

#ifndef FIO_UNALIGNED_ACCESS
/** Allows facil.io to attempt unaligned memory access on *some* CPU systems. */
#define FIO_UNALIGNED_ACCESS 1
#endif

#ifndef FIO_LIMIT_INTRINSIC_BUFFER
/* limits register consumption on some pseudo-intrinsics, using more loops */
#define FIO_LIMIT_INTRINSIC_BUFFER 1
#endif

#ifndef FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT
/* Memory allocations should be secure by default (facil.io allocators only) */
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT 1
#endif

#ifndef FIO_MEM_PAGE_SIZE_LOG
#define FIO_MEM_PAGE_SIZE_LOG 12 /* assumes 4096 bytes per page */
#endif

#if defined(FIO_NO_LOG) && defined(FIO_LEAK_COUNTER)
#error FIO_NO_LOG and FIO_LEAK_COUNTER are exclusive, as memory leaks print to log.
#endif

/* *****************************************************************************
C++ extern start
***************************************************************************** */
/* support C++ */
#ifdef __cplusplus
extern "C" {
/* C++ keyword was deprecated */
#ifndef register
#define register
#endif
/* C keyword - unavailable in C++ */
#ifndef restrict
#define restrict
#endif
/* C keyword - unavailable in C++ */
#ifndef _Bool
#define _Bool bool
#endif

#endif

/* *****************************************************************************
Compiler detection, GCC / CLang features and OS dependent included files
***************************************************************************** */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#if !defined(__GNUC__) && !defined(__clang__) && !defined(GNUC_BYPASS)
#ifndef __attribute__
#define __attribute__(...)
#endif
#ifndef __has_include
#define __has_include(...) 0
#endif
#ifndef __has_builtin
#define __has_builtin(...) 0
#endif
#ifndef __has_attribute
#define __has_attribute(...) 0
#endif
#define GNUC_BYPASS 1
#elif !defined(__clang__) && !defined(__has_builtin)
/* E.g: GCC < 6.0 doesn't support __has_builtin */
#define __has_builtin(...) 0
#define GNUC_BYPASS        1
#endif

#ifndef __has_include
#define __has_include(...) 0
#define GNUC_BYPASS        1
#endif

/* *****************************************************************************
Compiler Helpers - Deprecation, Alignment, Inlining, Memory Barriers
***************************************************************************** */

#ifndef DEPRECATED
#if defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5))
/* GCC < 4.5 doesn't support deprecation reason string */
#define DEPRECATED(reason) __attribute__((deprecated))
#else
#define DEPRECATED(reason) __attribute__((deprecated(reason)))
#endif
#endif

#if defined(__GNUC__) || defined(__clang__)
#define FIO_ALIGN(bytes) __attribute__((aligned(bytes)))
#elif defined(__INTEL_COMPILER) || defined(_MSC_VER)
#define FIO_ALIGN(bytes)
// #define FIO_ALIGN(bytes) __declspec(align(bytes))
#else
#define FIO_ALIGN(bytes)
#endif

#if defined(_MSC_VER) && _MSC_VER

#undef _CRT_SECURE_NO_WARNINGS
/** We define this because Microsoft's naming scheme isn't portable */
#define _CRT_SECURE_NO_WARNINGS 1

#define inline   __inline
#define __thread __declspec(thread)
#elif !defined(__clang__) && !defined(__GNUC__)
#define __thread _Thread_local
#endif

#if defined(__clang__) || defined(__GNUC__)
/** Clobber CPU registers and prevent compiler reordering optimizations. */
#define FIO_COMPILER_GUARD             __asm__ volatile("" ::: "memory")
#define FIO_COMPILER_GUARD_INSTRUCTION __asm__ volatile("" :::)
#elif defined(_MSC_VER)
#include <intrin.h>
/** Clobber CPU registers and prevent compiler reordering optimizations. */
#define FIO_COMPILER_GUARD             _ReadWriteBarrier()
#define FIO_COMPILER_GUARD_INSTRUCTION _WriteBarrier()
#pragma message("Warning: Windows deprecated it's low-level C memory barrier.")
#else
#warning Unknown OS / compiler, some macros are poorly defined and errors might occur.
#define FIO_COMPILER_GUARD             asm volatile("" ::: "memory")
#define FIO_COMPILER_GUARD_INSTRUCTION asm volatile("" :::)
#endif

/* *****************************************************************************
Address Sanitizer Detection
***************************************************************************** */

/* Address Sanitizer Detection */
#if defined(__SANITIZE_ADDRESS__)
#define FIO___ASAN_DETECTED 1
#elif defined(__has_feature)
#if __has_feature(address_sanitizer)
#define FIO___ASAN_DETECTED 1
#endif
#endif /* address_sanitizer */

#ifdef FIO___ASAN_DETECTED
#if defined(_MSC_VER)
#define FIO___ASAN_AVOID __declspec(no_sanitize_address)
#else
#define FIO___ASAN_AVOID                                                       \
  __attribute__((no_sanitize_address)) __attribute__((no_sanitize("address")))
#endif
#else
#define FIO___ASAN_AVOID
#endif

/* *****************************************************************************
Intrinsic Availability Flags
***************************************************************************** */
#if !defined(DEBUG) && !defined(NO_INTRIN) /* Allow Intrinsic / SIMD / Neon */
#if defined(__ARM_FEATURE_CRYPTO) &&                                           \
    (defined(__ARM_NEON) || defined(__ARM_NEON__)) &&                          \
    __has_include("arm_acle.h") && __has_include("arm_neon.h")
#include <arm_acle.h>
#include <arm_neon.h>
#define FIO___HAS_ARM_INTRIN 1
#elif defined(__x86_64) && __has_include("immintrin.h") /* x64 Intrinsics? */
#define FIO___HAS_X86_INTRIN 1
#include <immintrin.h>
#if defined(__SHA__) /* SHA-NI extension available */
#define FIO___HAS_X86_SHA_INTRIN 1
#endif
#endif

#endif

/* *****************************************************************************
Aligned Memory Access Selectors
***************************************************************************** */

#ifndef FIO_UNALIGNED_MEMORY_ACCESS_ENABLED
#if FIO_UNALIGNED_ACCESS &&                                                    \
    (defined(__amd64) || defined(__amd64__) || defined(__x86_64) ||            \
     defined(__x86_64__) || defined(__i386) || defined(__aarch64__) ||         \
     defined(_M_IX86) || defined(_M_X64) || defined(_M_ARM64) ||               \
     defined(__ARM_FEATURE_UNALIGNED))
/** True when unaligned memory is allowed. */
#define FIO_UNALIGNED_MEMORY_ACCESS_ENABLED 1
#else
#define FIO_UNALIGNED_MEMORY_ACCESS_ENABLED 0
#endif
#endif /* FIO_UNALIGNED_MEMORY_ACCESS_ENABLED */

/* *****************************************************************************
OS Specific includes and Macros
***************************************************************************** */
#define FIO_OS_POSIX 0
#define FIO_OS_WIN   0

#if defined(__unix__) || defined(__linux__) || defined(__APPLE__)
#undef FIO_OS_POSIX
#define FIO_HAVE_UNIX_TOOLS 1
#define FIO_OS_POSIX        1
#define FIO___KILL_SELF()   kill(0, SIGINT)
#define fio_getpid          getpid

#elif defined(_WIN32) || defined(_WIN64) || defined(WIN32) ||                  \
    defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)
#undef FIO_OS_WIN
#define FIO_OS_WIN     1
#define POSIX_C_SOURCE 200809L
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS 1
#undef _CRT_NONSTDC_NO_WARNINGS
#define _CRT_NONSTDC_NO_WARNINGS 1
#ifndef UNICODE
#define UNICODE 1
#endif
#include <windows.h>
#endif /* WIN32_LEAN_AND_MEAN */

#include <fcntl.h>
#include <io.h>
#include <process.h>
#include <processthreadsapi.h>
#include <sys/types.h>

#include <sys/stat.h>
#include <sysinfoapi.h>
#include <time.h>
#include <winsock2.h> /* struct timeval is here... why? Microsoft. */

#define fio_getpid _getpid

#define FIO___KILL_SELF() TerminateProcess(GetCurrentProcess(), 1)

#if defined(__MINGW32__)
/* Mingw supports */
#define FIO_HAVE_UNIX_TOOLS    2
#define __USE_MINGW_ANSI_STDIO 1
#define FIO___PRINTF_STYLE(string_index, check_index)                          \
  __attribute__((format(__MINGW_PRINTF_FORMAT, string_index, check_index)))
#elif defined(__CYGWIN__)
/* TODO: cygwin support */
#define FIO_HAVE_UNIX_TOOLS    3
#define __USE_MINGW_ANSI_STDIO 1
#define FIO___PRINTF_STYLE(string_index, check_index)                          \
  __attribute__((format(__MINGW_PRINTF_FORMAT, string_index, check_index)))
#else
/* Pure MSVC (not MinGW/Cygwin) */
#define FIO_HAVE_UNIX_TOOLS 0
typedef SSIZE_T ssize_t;
/* MSVC doesn't support __attribute__, use empty macro */
#define FIO___PRINTF_STYLE(string_index, check_index)
#endif /* __CYGWIN__ __MINGW32__ */

#if _MSC_VER
#pragma message("Warning: (Windows) some functionality enabled by patchwork.")
#else
#warning some functionality is enabled by patchwork.
#endif

#else
#define FIO_HAVE_UNIX_TOOLS 0
#warning Unknown OS / compiler, some macros are poorly defined and errors might occur.
#endif /* OS / Compiler detection */

#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <time.h>

#ifndef CLOCK_REALTIME
#define CLOCK_REALTIME 0
#endif
#ifndef CLOCK_MONOTONIC
#define CLOCK_MONOTONIC 0
#endif

#if FIO_HAVE_UNIX_TOOLS
#include <sched.h>
#include <sys/param.h>
#include <unistd.h>
#endif

/* assume GCC / Clang style if no specific style provided. */
#ifndef FIO___PRINTF_STYLE
#define FIO___PRINTF_STYLE(string_index, check_index)                          \
  __attribute__((format(printf, string_index, check_index)))
#endif

#ifndef SSIZE_MAX
#define SSIZE_MAX ((ssize_t)((~(size_t)0) >> 1))
#endif
#ifndef SSIZE_MIN
#define SSIZE_MIN ((ssize_t)(~((~(size_t)0) >> 1)))
#endif
/* *****************************************************************************
Function Attributes
***************************************************************************** */

#if __has_attribute(unused) || defined(__GNUC__) || defined(__clang__)
#define FIO_MAYBE_UNUSED __attribute__((unused))
#else
#define FIO_MAYBE_UNUSED
#endif

#ifndef FIO_SFUNC
#define FIO_SFUNC static FIO_MAYBE_UNUSED
#endif

#ifndef FIO_IFUNC
/** Marks a function as `static`, `inline` and possibly unused. */
#define FIO_IFUNC FIO_SFUNC inline
#endif

#ifndef FIO_WARN_UNUSED
/** Attribute for functions whose return value should not be ignored. */
#if __has_attribute(warn_unused_result) || defined(__GNUC__) ||                \
    defined(__clang__)
#define FIO_WARN_UNUSED __attribute__((warn_unused_result))
#else
#define FIO_WARN_UNUSED
#endif
#endif

#ifndef FIO_MIFN
/** Marks a function as inline with warn_unused_result (for math functions). */
#define FIO_MIFN FIO_IFUNC FIO_WARN_UNUSED
#endif

/** Marks a function as const (no side effects, result depends only on args) */
#ifndef FIO_CONST
#if __has_attribute(const) || defined(__GNUC__)
#define FIO_CONST __attribute__((const))
#else
#define FIO_CONST
#endif
#endif

/** Marks a function as pure (no side effects, may read global memory) */
#ifndef FIO_PURE
#if __has_attribute(pure) || defined(__GNUC__)
#define FIO_PURE __attribute__((pure))
#else
#define FIO_PURE
#endif
#endif

#ifndef FIO_WEAK
/** Marks a function as weak */
#define FIO_WEAK __attribute__((weak))
#endif

#ifndef FIO_DEF_GET_SET
/** Defines a "get" function for a field within a struct / union. */
#define FIO_DEF_GET_FUNC_DEF(static, namespace, T_type, F_type, field_name)    \
  /** Returns current value of property within the struct / union. */          \
  static F_type FIO_NAME(namespace, field_name)(T_type * o);

/** Defines a "get" function for a field within a struct / union. */
#define FIO_DEF_GET_FUNC(static, namespace, T_type, F_type, field_name)        \
  /** Returns current value of property within the struct / union. */          \
  static F_type FIO_NAME(namespace, field_name)(T_type * o) {                  \
    FIO_ASSERT_DEBUG(o, "NULL " FIO_MACRO2STR(namespace) " pointer @ `get`!"); \
    return o->field_name;                                                      \
  }

/** Defines a "set" function for a field within a struct / union. */
#define FIO_DEF_SET_FUNC_DEF(static, namespace, T_type, F_type, F_name)        \
  /** Sets a new value, returning the old one */                               \
  static F_type FIO_NAME(FIO_NAME(namespace, F_name), set)(T_type * o,         \
                                                           F_type new_value);

/** Defines a "set" function for a field within a struct / union. */
#define FIO_DEF_SET_FUNC(static, namespace, T_type, F_type, F_name, on_set)    \
  /** Sets a new value, returning the old one */                               \
  static F_type FIO_NAME(FIO_NAME(namespace, F_name), set)(T_type * o,         \
                                                           F_type new_value) { \
    FIO_ASSERT_DEBUG(o, "NULL " FIO_MACRO2STR(namespace) " pointer @ `set`!"); \
    F_type old_value = o->F_name;                                              \
    o->F_name = new_value;                                                     \
    on_set(o);                                                                 \
    return old_value;                                                          \
  }
/** Defines get/set functions for a field within a struct / union. */
#define FIO_DEF_GETSET_FUNC(static, namespace, T_type, F_type, F_name, on_set) \
  FIO_DEF_GET_FUNC(static, namespace, T_type, F_type, F_name)                  \
  FIO_DEF_SET_FUNC(static, namespace, T_type, F_type, F_name, on_set)

/** Defines get/set functions for a field within a struct / union. */
#define FIO_DEF_GETSET_FUNC_DEF(static, namespace, T_type, F_type, F_name)     \
  FIO_DEF_GET_FUNC_DEF(static, namespace, T_type, F_type, F_name)              \
  FIO_DEF_SET_FUNC_DEF(static, namespace, T_type, F_type, F_name)

#endif

#ifndef FIO_IFUNC_DEF_GETSET
/** Defines a "get" function for a field within a struct / union. */
#define FIO_IFUNC_DEF_GET(namespace, T_type, F_type, field_name)               \
  FIO_DEF_GET_FUNC(FIO_IFUNC, namespace, T_type, F_type, field_name)

/** Defines a "set" function for a field within a struct / union. */
#define FIO_IFUNC_DEF_SET(namespace, T_type, F_type, F_name, on_set)           \
  FIO_DEF_SET_FUNC(FIO_IFUNC, namespace, T_type, F_type, F_name, on_set)

/** Defines get/set functions for a field within a struct / union. */
#define FIO_IFUNC_DEF_GETSET(namespace, T_type, F_type, F_name, on_set)        \
  FIO_IFUNC_DEF_GET(namespace, T_type, F_type, F_name)                         \
  FIO_IFUNC_DEF_SET(namespace, T_type, F_type, F_name, on_set)

#endif /* FIO_IFUNC_DEF_GETSET */
/* *****************************************************************************
Constructors and Destructors
***************************************************************************** */

#if defined(_MSC_VER) && _MSC_VER

#define FIO___COUNTER_RUNNER()                                                 \
  __COUNTER__ + __COUNTER__ + __COUNTER__ + __COUNTER__ + __COUNTER__ +        \
      __COUNTER__ + __COUNTER__ + __COUNTER__ + __COUNTER__ + __COUNTER__
/* counter is used for ordering, so we need a consistent number of digits */
FIO_SFUNC int fio___msv_run_counter_macro_to_3_digits(void) {
  return FIO___COUNTER_RUNNER() + FIO___COUNTER_RUNNER() +
         FIO___COUNTER_RUNNER() + FIO___COUNTER_RUNNER() +
         FIO___COUNTER_RUNNER() + FIO___COUNTER_RUNNER() +
         FIO___COUNTER_RUNNER() + FIO___COUNTER_RUNNER() +
         FIO___COUNTER_RUNNER() + FIO___COUNTER_RUNNER();
}
#undef FIO___COUNTER_RUNNER

#pragma section(".CRT$XCU", read)
/** Marks a function as a constructor - if supported. */
#if _WIN64 /* MSVC linker uses different name mangling on 32bit systems */
/* clang-format off */
#define FIO_CONSTRUCTOR(fname)                                                 \
  static void fname(void);                                                     \
  __declspec(allocate(".CRT$XCU")) void (*FIO_NAME(fio___constructor, __COUNTER__))(void) = fname; \
  static void fname(void)
#else
#define FIO_CONSTRUCTOR(fname)                                                 \
  static void fname(void);                                                     \
  __declspec(allocate(".CRT$XCU")) void (*FIO_NAME(fio___constructor, __COUNTER__))(void) = fname; \
  static void fname(void)
#endif /* _WIN64 */
#define FIO_DESTRUCTOR(fname)                                                  \
  static void fname(void);                                                     \
  FIO_CONSTRUCTOR(fname##__hook) { atexit(fname); }                            \
  static void fname(void)
/* clang-format on */

#else
/** Marks a function as a constructor - if supported. */
#define FIO_CONSTRUCTOR(fname)                                                 \
  static __attribute__((constructor)) void fname(void)
/** Marks a function as a destructor - if supported. Consider using atexit() */
#define FIO_DESTRUCTOR(fname)                                                  \
  static __attribute__((destructor)) void fname(void)
#endif

/* *****************************************************************************
Conditional Likelihood
***************************************************************************** */
#if defined(__clang__) || defined(__GNUC__)
#define FIO_LIKELY(cond)   __builtin_expect((cond), 1)
#define FIO_UNLIKELY(cond) __builtin_expect((cond), 0)
#else
#define FIO_LIKELY(cond)   (cond)
#define FIO_UNLIKELY(cond) (cond)
#endif

/* *****************************************************************************
Cache Prefetch Hints
***************************************************************************** */
/**
 * Cache prefetch macros - hint to CPU to load data into cache before use.
 *
 * FIO_PREFETCH(ptr)      - Prefetch for read, all cache levels, temporal
 * FIO_PREFETCH_W(ptr)    - Prefetch for write (exclusive access)
 * FIO_PREFETCH_NT(ptr)   - Prefetch non-temporal (streaming, minimize
 * pollution)
 *
 * These are hints only - they do nothing if prefetching is unavailable.
 * Typical prefetch distance is 1-2 cache lines (64-128 bytes) ahead.
 */
#if __has_builtin(__builtin_prefetch)
/** Prefetch data for reading into all cache levels. */
#define FIO_PREFETCH(ptr) __builtin_prefetch((ptr), 0, 3)
/** Prefetch data for writing (exclusive cache line ownership). */
#define FIO_PREFETCH_W(ptr) __builtin_prefetch((ptr), 1, 3)
/** Prefetch non-temporal (streaming data, minimize cache pollution). */
#define FIO_PREFETCH_NT(ptr) __builtin_prefetch((ptr), 0, 0)
#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))
#include <intrin.h>
#define FIO_PREFETCH(ptr)    _mm_prefetch((const char *)(ptr), _MM_HINT_T0)
#define FIO_PREFETCH_W(ptr)  _mm_prefetch((const char *)(ptr), _MM_HINT_T0)
#define FIO_PREFETCH_NT(ptr) _mm_prefetch((const char *)(ptr), _MM_HINT_NTA)
#else
#define FIO_PREFETCH(ptr)    ((void)(ptr))
#define FIO_PREFETCH_W(ptr)  ((void)(ptr))
#define FIO_PREFETCH_NT(ptr) ((void)(ptr))
#endif

/* *****************************************************************************
Macro Stringifier
***************************************************************************** */
#ifndef FIO_MACRO2STR
#define FIO_MACRO2STR_STEP2(macro) #macro
/** Converts a macro's content to a string literal. */
#define FIO_MACRO2STR(macro) FIO_MACRO2STR_STEP2(macro)
#endif

/* *****************************************************************************
Naming Macros
***************************************************************************** */
/* Used for naming functions and types */
#define FIO_NAME_FROM_MACRO_STEP2(prefix, postfix, div) prefix##div##postfix
#define FIO_NAME_FROM_MACRO_STEP1(prefix, postfix, div)                        \
  FIO_NAME_FROM_MACRO_STEP2(prefix, postfix, div)

/** Used for naming functions and variables resulting in: prefix_postfix */
#define FIO_NAME(prefix, postfix) FIO_NAME_FROM_MACRO_STEP1(prefix, postfix, _)

/** Sets naming convention for conversion functions, i.e.: foo2bar */
#define FIO_NAME2(prefix, postfix) FIO_NAME_FROM_MACRO_STEP1(prefix, postfix, 2)

/** Sets naming convention for boolean testing functions, i.e.: foo_is_true */
#define FIO_NAME_BL(prefix, postfix)                                           \
  FIO_NAME_FROM_MACRO_STEP1(prefix, postfix, _is_)

/** Used internally to name test functions. */
#define FIO_NAME_TEST(prefix, postfix)                                         \
  FIO_NAME(fio___test, FIO_NAME(prefix, postfix))

/* *****************************************************************************
Pointer Math
***************************************************************************** */

/** Masks a pointer's left-most bits, returning the right bits. */
#define FIO_PTR_MATH_LMASK(T_type, ptr, bits)                                  \
  ((T_type *)(((uintptr_t)(ptr)) & (((uintptr_t)1ULL << (bits)) - 1)))

/** Masks a pointer's right-most bits, returning the left bits. */
#define FIO_PTR_MATH_RMASK(T_type, ptr, bits)                                  \
  ((T_type *)(((uintptr_t)(ptr)) & ((~(uintptr_t)0ULL) << (bits))))

/** Add offset bytes to pointer, updating the pointer's type. */
#define FIO_PTR_MATH_ADD(T_type, ptr, offset)                                  \
  ((T_type *)((uintptr_t)(ptr) + (uintptr_t)(offset)))

/** Subtract X bytes from pointer, updating the pointer's type. */
#define FIO_PTR_MATH_SUB(T_type, ptr, offset)                                  \
  ((T_type *)((uintptr_t)(ptr) - (uintptr_t)(offset)))

/** Find the root object (of a struct) from it's field (with sanitizer fix). */
#define FIO_PTR_FROM_FIELD(T_type, field, ptr)                                 \
  FIO_PTR_MATH_SUB(T_type,                                                     \
                   ptr,                                                        \
                   (uintptr_t)(&((T_type *)0xFF00)->field) - 0xFF00)

/* *****************************************************************************
Sleep / Thread Scheduling Macros
***************************************************************************** */

#ifndef FIO_THREAD_WAIT
#if FIO_OS_WIN
/** Calls NtDelayExecution with the requested nano-second count. */
#define FIO_THREAD_WAIT(nano_sec)                                              \
  do {                                                                         \
    Sleep(((nano_sec) / 1000000) ? ((nano_sec) / 1000000) : 1);                \
  } while (0)
// https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep

#elif FIO_OS_POSIX
/** Calls nanonsleep with the requested nano-second count. */
#define FIO_THREAD_WAIT(nano_sec)                                              \
  do {                                                                         \
    const struct timespec tm = {.tv_sec = (time_t)((nano_sec) / 1000000000),   \
                                .tv_nsec = ((long)(nano_sec) % 1000000000)};   \
    nanosleep(&tm, (struct timespec *)NULL);                                   \
  } while (0)

#endif
#endif

#ifndef FIO_THREAD_RESCHEDULE
#if (defined(__x86_64__) || defined(__i386__)) &&                              \
    (defined(__GNUC__) || defined(__clang__))
/** Yields the thread, hinting to the processor about spinlock loop. */
#define FIO_THREAD_YIELD() __asm__ __volatile__("pause" ::: "memory")
#elif (defined(__aarch64__) || defined(__arm__)) &&                            \
    (defined(__GNUC__) || defined(__clang__))
/** Yields the thread, hinting to the processor about spinlock loop. */
#define FIO_THREAD_YIELD() __asm__ __volatile__("yield" ::: "memory")
#elif defined(_MSC_VER)
#define FIO_THREAD_YIELD() YieldProcessor()
#else /* FIO_OS_POSIX */
/** Yields the thread, hinting to the processor about spinlock loop. */
#define FIO_THREAD_YIELD() sched_yield()
#endif

/**
 * Reschedules the thread by calling nanosleeps for nano-seconds.
 *
 * In practice, the thread will probably sleep for 60ns or more.
 *
 * Seems to be faster then thread_yield, perhaps it prevents de-prioritization
 * of the thread.
 */
#define FIO_THREAD_RESCHEDULE() FIO_THREAD_WAIT(4)

#endif /* FIO_THREAD_RESCHEDULE */

/* *****************************************************************************




                            Atomic Operations



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */

/* C11 Atomics are defined? */
#if defined(__ATOMIC_RELAXED)
/** An atomic load operation, returns value in pointer. */
#define fio_atomic_load(dest, p_obj)                                           \
  do {                                                                         \
    dest = __atomic_load_n((p_obj), __ATOMIC_SEQ_CST);                         \
  } while (0)

// clang-format off

/** An atomic compare and exchange operation, returns true if an exchange occured. `p_expected` MAY be overwritten with the existing value (system specific). */
#define fio_atomic_compare_exchange_p(p_obj, p_expected, p_desired) __atomic_compare_exchange((p_obj), (p_expected), (p_desired), 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)
/** An atomic exchange operation, returns previous value */
#define fio_atomic_exchange(p_obj, value) __atomic_exchange_n((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic addition operation, returns previous value */
#define fio_atomic_add(p_obj, value) __atomic_fetch_add((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic subtraction operation, returns previous value */
#define fio_atomic_sub(p_obj, value) __atomic_fetch_sub((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic AND (&) operation, returns previous value */
#define fio_atomic_and(p_obj, value) __atomic_fetch_and((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic XOR (^) operation, returns previous value */
#define fio_atomic_xor(p_obj, value) __atomic_fetch_xor((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic OR (|) operation, returns previous value */
#define fio_atomic_or(p_obj, value) __atomic_fetch_or((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic NOT AND ((~)&) operation, returns previous value */
#define fio_atomic_nand(p_obj, value) __atomic_fetch_nand((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic addition operation, returns new value */
#define fio_atomic_add_fetch(p_obj, value) __atomic_add_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic subtraction operation, returns new value */
#define fio_atomic_sub_fetch(p_obj, value) __atomic_sub_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic AND (&) operation, returns new value */
#define fio_atomic_and_fetch(p_obj, value) __atomic_and_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic XOR (^) operation, returns new value */
#define fio_atomic_xor_fetch(p_obj, value) __atomic_xor_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic OR (|) operation, returns new value */
#define fio_atomic_or_fetch(p_obj, value) __atomic_or_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic NOT AND ((~)&) operation, returns new value */
#define fio_atomic_nand_fetch(p_obj, value) __atomic_nand_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/* note: __ATOMIC_SEQ_CST may be safer and __ATOMIC_ACQ_REL may be faster */

/* Select the correct compiler builtin method. */
#elif __has_builtin(__sync_add_and_fetch) || (__GNUC__ > 3) /* Atomic Implementation Selector */
/** An atomic load operation, returns value in pointer. */
#define fio_atomic_load(dest, p_obj)                                           \
  do {                                                                         \
    dest = *(p_obj);                                                           \
  } while (!__sync_bool_compare_and_swap((p_obj), dest, dest))


/** An atomic compare and exchange operation, returns true if an exchange occured. `p_expected` MAY be overwritten with the existing value (system specific). */
#define fio_atomic_compare_exchange_p(p_obj, p_expected, p_desired) __sync_bool_compare_and_swap((p_obj), (p_expected), *(p_desired))
/** An atomic exchange operation, ruturns previous value */
#define fio_atomic_exchange(p_obj, value) __sync_val_compare_and_swap((p_obj), *(p_obj), (value))
/** An atomic addition operation, returns new value */
#define fio_atomic_add(p_obj, value) __sync_fetch_and_add((p_obj), (value))
/** An atomic subtraction operation, returns new value */
#define fio_atomic_sub(p_obj, value) __sync_fetch_and_sub((p_obj), (value))
/** An atomic AND (&) operation, returns new value */
#define fio_atomic_and(p_obj, value) __sync_fetch_and_and((p_obj), (value))
/** An atomic XOR (^) operation, returns new value */
#define fio_atomic_xor(p_obj, value) __sync_fetch_and_xor((p_obj), (value))
/** An atomic OR (|) operation, returns new value */
#define fio_atomic_or(p_obj, value) __sync_fetch_and_or((p_obj), (value))
/** An atomic NOT AND ((~)&) operation, returns new value */
#define fio_atomic_nand(p_obj, value) __sync_fetch_and_nand((p_obj), (value))
/** An atomic addition operation, returns previous value */
#define fio_atomic_add_fetch(p_obj, value) __sync_add_and_fetch((p_obj), (value))
/** An atomic subtraction operation, returns previous value */
#define fio_atomic_sub_fetch(p_obj, value) __sync_sub_and_fetch((p_obj), (value))
/** An atomic AND (&) operation, returns previous value */
#define fio_atomic_and_fetch(p_obj, value) __sync_and_and_fetch((p_obj), (value))
/** An atomic XOR (^) operation, returns previous value */
#define fio_atomic_xor_fetch(p_obj, value) __sync_xor_and_fetch((p_obj), (value))
/** An atomic OR (|) operation, returns previous value */
#define fio_atomic_or_fetch(p_obj, value) __sync_or_and_fetch((p_obj), (value))
/** An atomic NOT AND ((~)&) operation, returns previous value */
#define fio_atomic_nand_fetch(p_obj, value) __sync_nand_and_fetch((p_obj), (value))


/* Atomic Implementation Selector */
#elif __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_ATOMICS__)
#include <stdatomic.h>
#ifdef _MSC_VER
#pragma message ("Fallback to C11 atomic header, might be missing some features.")
#undef FIO_COMPILER_GUARD
#define FIO_COMPILER_GUARD atomic_thread_fence(memory_order_seq_cst)
#else
#warning Fallback to C11 atomic header, might be missing some features.
#endif /* _MSC_VER */
/** An atomic load operation, returns value in pointer. */
#define fio_atomic_load(dest, p_obj)  (dest = atomic_load(p_obj))

/** An atomic compare and exchange operation, returns true if an exchange occured. `p_expected` MAY be overwritten with the existing value (system specific). */
#define fio_atomic_compare_exchange_p(p_obj, p_expected, p_desired) atomic_compare_exchange_strong((p_obj), (p_expected), (p_desired))
/** An atomic exchange operation, returns previous value */
#define fio_atomic_exchange(p_obj, value) atomic_exchange((p_obj), (value))
/** An atomic addition operation, returns previous value */
#define fio_atomic_add(p_obj, value) atomic_fetch_add((p_obj), (value))
/** An atomic subtraction operation, returns previous value */
#define fio_atomic_sub(p_obj, value) atomic_fetch_sub((p_obj), (value))
/** An atomic AND (&) operation, returns previous value */
#define fio_atomic_and(p_obj, value) atomic_fetch_and((p_obj), (value))
/** An atomic XOR (^) operation, returns previous value */
#define fio_atomic_xor(p_obj, value) atomic_fetch_xor((p_obj), (value))
/** An atomic OR (|) operation, returns previous value */
#define fio_atomic_or(p_obj, value) atomic_fetch_or((p_obj), (value))
/** An atomic NOT AND ((~)&) operation, returns previous value */
#define fio_atomic_nand(p_obj, value) atomic_fetch_nand((p_obj), (value))
/** An atomic addition operation, returns new value */
#define fio_atomic_add_fetch(p_obj, value) (atomic_fetch_add((p_obj), (value)), atomic_load((p_obj)))
/** An atomic subtraction operation, returns new value */
#define fio_atomic_sub_fetch(p_obj, value) (atomic_fetch_sub((p_obj), (value)), atomic_load((p_obj)))
/** An atomic AND (&) operation, returns new value */
#define fio_atomic_and_fetch(p_obj, value) (atomic_fetch_and((p_obj), (value)), atomic_load((p_obj)))
/** An atomic XOR (^) operation, returns new value */
#define fio_atomic_xor_fetch(p_obj, value) (atomic_fetch_xor((p_obj), (value)), atomic_load((p_obj)))
/** An atomic OR (|) operation, returns new value */
#define fio_atomic_or_fetch(p_obj, value) (atomic_fetch_or((p_obj), (value)), atomic_load((p_obj)))

#elif _MSC_VER
#pragma message ("Warning: WinAPI atomics have less features, but this is what this compiler has, so...")
#include <intrin.h>
#define FIO___ATOMICS_FN_ROUTE(fn, ptr, ...)                                   \
  ((sizeof(*ptr) == 1)                                                         \
       ? fn##8((int8_t volatile *)(ptr), __VA_ARGS__)                          \
       : (sizeof(*ptr) == 2)                                                   \
             ? fn##16((int16_t volatile *)(ptr), __VA_ARGS__)                  \
             : (sizeof(*ptr) == 4)                                             \
                   ? fn((int32_t volatile *)(ptr), __VA_ARGS__)                \
                   : fn##64((int64_t volatile *)(ptr), __VA_ARGS__))

#ifndef _WIN64
#error Atomics on Windows require 64bit OS and compiler support.
#endif

/** An atomic load operation, returns value in pointer. */
#define fio_atomic_load(dest, p_obj) (dest = *(p_obj))

/** An atomic compare and exchange operation, returns true if an exchange occured. `p_expected` MAY be overwritten with the existing value (system specific). */
#define fio_atomic_compare_exchange_p(p_obj, p_expected, p_desired) (FIO___ATOMICS_FN_ROUTE(_InterlockedCompareExchange, (p_obj),(*(p_desired)),(*(p_expected))), (*(p_obj) == *(p_desired)))
/** An atomic exchange operation, returns previous value */
#define fio_atomic_exchange(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedExchange, (p_obj), (value))

/** An atomic addition operation, returns previous value */
#define fio_atomic_add(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedExchangeAdd, (p_obj), (value))
/** An atomic subtraction operation, returns previous value */
#define fio_atomic_sub(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedExchangeAdd, (p_obj), (0ULL - (value)))
/** An atomic AND (&) operation, returns previous value */
#define fio_atomic_and(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedAnd, (p_obj), (value))
/** An atomic XOR (^) operation, returns previous value */
#define fio_atomic_xor(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedXor, (p_obj), (value))
/** An atomic OR (|) operation, returns previous value */
#define fio_atomic_or(p_obj, value)  FIO___ATOMICS_FN_ROUTE(_InterlockedOr, (p_obj), (value))

/** An atomic addition operation, returns new value */
#define fio_atomic_add_fetch(p_obj, value) (fio_atomic_add((p_obj), (value)), (*(p_obj)))
/** An atomic subtraction operation, returns new value */
#define fio_atomic_sub_fetch(p_obj, value) (fio_atomic_sub((p_obj), (value)), (*(p_obj)))
/** An atomic AND (&) operation, returns new value */
#define fio_atomic_and_fetch(p_obj, value) (fio_atomic_and((p_obj), (value)), (*(p_obj)))
/** An atomic XOR (^) operation, returns new value */
#define fio_atomic_xor_fetch(p_obj, value) (fio_atomic_xor((p_obj), (value)), (*(p_obj)))
/** An atomic OR (|) operation, returns new value */
#define fio_atomic_or_fetch(p_obj, value) (fio_atomic_or((p_obj), (value)), (*(p_obj)))
#else
#error Required atomics not found (__STDC_NO_ATOMICS__) and older __sync_add_and_fetch is also missing.

#endif /* Atomic Implementation Selector */
// clang-format on

/* *****************************************************************************
Spin-Locks
***************************************************************************** */

#define FIO_LOCK_INIT         0
#define FIO_LOCK_SUBLOCK(sub) ((uint8_t)(1U) << ((sub)&7))
typedef volatile unsigned char fio_lock_i;

#ifndef FIO___LOCK_RESCHDULE_EVERY_LOG
#define FIO___LOCK_RESCHDULE_EVERY_LOG 8
#endif
/**
 * Tries to lock a group of sublocks.
 *
 * Combine a number of sublocks using OR (`|`) and the FIO_LOCK_SUBLOCK(i)
 * macro. i.e.:
 *
 *      if(!fio_trylock_group(&lock,
 *                            FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(2))) {
 *         // act in lock
 *      }
 *
 * Returns 0 on success and non-zero on failure.
 */
FIO_IFUNC uint8_t fio_trylock_group(fio_lock_i *lock, uint8_t group) {
  if (!group)
    group = 1;
  FIO_COMPILER_GUARD;
  uint8_t state = fio_atomic_or(lock, group);
  if (!(state & group))
    return 0;
  /* store the acquired locks in `state`. */
  state = ~((~state) & group);
  /* release the locks we acquired */
  fio_atomic_and(lock, state);
  return 1;
}

/**
 * Busy waits for a group lock to become available - not recommended.
 *
 * See `fio_trylock_group` for details.
 */
FIO_IFUNC void fio_lock_group(fio_lock_i *lock, uint8_t group) {
  size_t i = 0;
  while (fio_trylock_group(lock, group)) {
    if ((i++ & (1U << FIO___LOCK_RESCHDULE_EVERY_LOG))) {
      i = 0;
      FIO_THREAD_RESCHEDULE();
    }
  }
}

/** Unlocks a sublock group, no matter which thread owns which sublock. */
FIO_IFUNC void fio_unlock_group(fio_lock_i *lock, uint8_t group) {
  if (!group)
    group = 1;
  fio_atomic_and(lock, (~group));
}

/** Tries to lock all sublocks. Returns 0 on success and 1 on failure. */
FIO_IFUNC uint8_t fio_trylock_full(fio_lock_i *lock) {
  return fio_trylock_group(lock, (uint8_t)~0);
}

/** Busy waits for all sub lock to become available - not recommended. */
FIO_IFUNC void fio_lock_full(fio_lock_i *lock) {
  fio_lock_group(lock, (uint8_t)~0);
}

/** Unlocks all sub locks, no matter which thread owns the lock. */
FIO_IFUNC void fio_unlock_full(fio_lock_i *lock) { fio_atomic_and(lock, 0); }

/**
 * Tries to acquire the default lock (sublock 0).
 *
 * Returns 0 on success and 1 on failure.
 */
FIO_IFUNC uint8_t fio_trylock(fio_lock_i *lock) {
  return fio_trylock_group(lock, (uint8_t)1);
}

/** Busy waits for the default lock to become available - not recommended. */
FIO_IFUNC void fio_lock(fio_lock_i *lock) { fio_lock_group(lock, (uint8_t)1); }

/** Unlocks the default lock, no matter which thread owns the lock. */
FIO_IFUNC void fio_unlock(fio_lock_i *lock) {
  fio_unlock_group(lock, (uint8_t)1);
}

/** Returns 1 if the lock is locked, 0 otherwise. */
FIO_IFUNC uint8_t FIO_NAME_BL(fio, locked)(fio_lock_i *lock) {
  return *lock & 1;
}

/** Returns 1 if the lock is locked, 0 otherwise. */
FIO_IFUNC uint8_t FIO_NAME_BL(fio, group_locked)(fio_lock_i *lock,
                                                 uint8_t group) {
  return !!((*lock) & group);
}

/* *****************************************************************************
Atomic Bit access / manipulation
***************************************************************************** */

/** Gets the state of a bit in a bitmap. */
FIO_IFUNC uint8_t fio_atomic_bit_get(void *map, size_t bit) {
  return ((((uint8_t *)(map))[(bit) >> 3] >> ((bit)&7)) & 1);
}

/** Sets the a bit in a bitmap (sets to 1). */
FIO_IFUNC void fio_atomic_bit_set(void *map, size_t bit) {
  fio_atomic_or((uint8_t *)(map) + ((bit) >> 3), (uint8_t)(1UL << ((bit)&7)));
}

/** Unsets the a bit in a bitmap (sets to 0). */
FIO_IFUNC void fio_atomic_bit_unset(void *map, size_t bit) {
  fio_atomic_and((uint8_t *)(map) + ((bit) >> 3),
                 (uint8_t)(~(1UL << ((bit)&7))));
}

/** Flips the a bit in a bitmap (sets to 0 if 1, sets to 1 if 0). */
FIO_IFUNC void fio_atomic_bit_flip(void *map, size_t bit) {
  fio_atomic_xor((uint8_t *)(map) + ((bit) >> 3), (uint8_t)(1UL << ((bit)&7)));
}

/* *****************************************************************************
UNSAFE (good enough) Static Memory Allocation

This is useful when attempting thread-safety controls through a round-robin
buffer that assumes both fast usage and a maximum number of concurrent calls, or
maximum number of threads, of `FIO_STATIC_ALLOC_SAFE_CONCURRENCY_MAX`.

This is supposed to provide both a safe alternative to `alloca` and allows the
memory address to be returned if needed (valid until concurrency max calls).
***************************************************************************** */

#ifndef FIO_STATIC_ALLOC_SAFE_CONCURRENCY_MAX
/* The multiplier is used to set the maximum number of safe concurrent calls. */
#define FIO_STATIC_ALLOC_SAFE_CONCURRENCY_MAX 256
#endif

/**
 * Defines a simple (almost naive) static memory allocator named `name`.
 *
 * This defines a memory allocation function named `name` that accepts a
 * single input `count` and returns a `type_T` pointer (`type_T *`) containing
 * `sizeof(type_T) * count * size_per_allocation` in correct memory alignment.
 *
 *          static type_T *name(size_t allocation_count);
 *
 * That memory is statically allocated, allowing it be returned and never
 * needing to be freed.
 *
 * The functions can safely allocate the following number of bytes before
 * the function returns the same memory block to another caller:
 *
 *     FIO_STATIC_ALLOC_SAFE_CONCURRENCY_MAX * allocations_per_thread *
 *         sizeof(type_T) * size_per_allocation
 *
 * Example use:
 *
 * ```c
 * // defined a static allocator for 32 byte long strings
 * FIO_STATIC_ALLOC_DEF(numer2hex_allocator, char, 19, 1);
 * // a function that returns an unsigned number as a 16 digit hex string
 * char * ntos16(uint16_t n) {
 *   char * n = numer2hex_allocator(1);
 *   n[0] = '0'; n[1] = 'x';
 *   fio_ltoa16u(n+2, n, 16);
 *   n[18] = 0;
 *   return n;
 * }
 * ```
 *
 * A similar approach is use by `fiobj_num2cstr` in order to provide temporary
 * conversions of FIOBJ to a C String that doesn't require memory management.
 */
#define FIO_STATIC_ALLOC_DEF(name,                                             \
                             type_T,                                           \
                             size_per_allocation,                              \
                             allocations_per_thread)                           \
  FIO_SFUNC FIO_WARN_UNUSED type_T *name(size_t count) {                       \
    static type_T name##buffer[sizeof(type_T) *                                \
                               FIO_STATIC_ALLOC_SAFE_CONCURRENCY_MAX *         \
                               size_per_allocation * allocations_per_thread];  \
    static size_t pos;                                                         \
    size_t at = fio_atomic_add(&pos, count);                                   \
    at %= FIO_STATIC_ALLOC_SAFE_CONCURRENCY_MAX * allocations_per_thread;      \
    return (at * size_per_allocation) + name##buffer;                          \
  }

/* *****************************************************************************
Logging Primitives (no-op)
***************************************************************************** */

/* avoid printing a full / nested path when __FILE_NAME__ is available */
#ifdef __FILE_NAME__
#define FIO__FILE__ __FILE_NAME__
#else
#define FIO__FILE__ __FILE__
#endif

/** Logging level of zero (no logging). */
#define FIO_LOG_LEVEL_NONE 0
/** Log fatal errors. */
#define FIO_LOG_LEVEL_FATAL 1
/** Log errors and fatal errors. */
#define FIO_LOG_LEVEL_ERROR 2
/** Log warnings, errors and fatal errors. */
#define FIO_LOG_LEVEL_WARNING 3
/** Log every message (info, warnings, errors and fatal errors). */
#define FIO_LOG_LEVEL_INFO 4
/** Log everything, including debug messages. */
#define FIO_LOG_LEVEL_DEBUG 5

/** Sets the Logging Level */
#define FIO_LOG_LEVEL_SET(new_level) (0)
/** Returns the Logging Level */
#define FIO_LOG_LEVEL_GET() (0)

// clang-format off
#define FIO___LOG_PRINT_LEVEL(level, ...) do { if ((level) <= FIO_LOG_LEVEL_GET()) {FIO_LOG2STDERR(__VA_ARGS__);} } while (0)
#define FIO_LOG_WRITE(...)    FIO_LOG2STDERR("(" FIO__FILE__ ":" FIO_MACRO2STR(__LINE__) "): " __VA_ARGS__)
#define FIO_LOG_FATAL(...)    FIO___LOG_PRINT_LEVEL(FIO_LOG_LEVEL_FATAL, "\x1B[1m\x1B[7mFATAL:\x1B[0m    " __VA_ARGS__)
#define FIO_LOG_ERROR(...)    FIO___LOG_PRINT_LEVEL(FIO_LOG_LEVEL_ERROR, "\x1B[1mERROR:\x1B[0m    " __VA_ARGS__)
#define FIO_LOG_SECURITY(...) FIO___LOG_PRINT_LEVEL(FIO_LOG_LEVEL_ERROR, "\x1B[1mSECURITY:\x1B[0m " __VA_ARGS__)
#define FIO_LOG_WARNING(...)  FIO___LOG_PRINT_LEVEL(FIO_LOG_LEVEL_WARNING, "\x1B[2mWARNING:\x1B[0m  " __VA_ARGS__)
#define FIO_LOG_INFO(...)     FIO___LOG_PRINT_LEVEL(FIO_LOG_LEVEL_INFO, "INFO:     " __VA_ARGS__)
#define FIO_LOG_DEBUG(...)    FIO___LOG_PRINT_LEVEL(FIO_LOG_LEVEL_DEBUG,"DEBUG:    (" FIO__FILE__ ":" FIO_MACRO2STR(__LINE__) ") " __VA_ARGS__)
#define FIO_LOG_DEBUG2(...)   FIO___LOG_PRINT_LEVEL(FIO_LOG_LEVEL_DEBUG, "DEBUG:    " __VA_ARGS__)
// clang-format on

#ifdef DEBUG
#define FIO_LOG_DDEBUG(...)           FIO_LOG_DEBUG(__VA_ARGS__)
#define FIO_LOG_DDEBUG2(...)          FIO_LOG_DEBUG2(__VA_ARGS__)
#define FIO_LOG_DERROR(...)           FIO_LOG_ERROR(__VA_ARGS__)
#define FIO_LOG_DSECURITY(...)        FIO_LOG_SECURITY(__VA_ARGS__)
#define FIO_LOG_DWARNING(...)         FIO_LOG_WARNING(__VA_ARGS__)
#define FIO_LOG_DINFO(...)            FIO_LOG_INFO(__VA_ARGS__)
#define FIO_ASSERT___PERFORM_SIGNAL() FIO___KILL_SELF();
#else
#define FIO_LOG_DDEBUG(...)    ((void)(0))
#define FIO_LOG_DDEBUG2(...)   ((void)(0))
#define FIO_LOG_DERROR(...)    ((void)(0))
#define FIO_LOG_DSECURITY(...) ((void)(0))
#define FIO_LOG_DWARNING(...)  ((void)(0))
#define FIO_LOG_DINFO(...)     ((void)(0))
#define FIO_ASSERT___PERFORM_SIGNAL()
#endif /* DEBUG */

#ifndef FIO_LOG_LENGTH_LIMIT
/** Defines a point at which logging truncates (limits stack memory use) */
#define FIO_LOG_LENGTH_LIMIT 1024
#endif

/** Prints to STDERR, attempting to use only stack allocated memory. */
#define FIO_LOG2STDERR(...)

/* *****************************************************************************
Assertions
***************************************************************************** */

/* Asserts a condition is true, or kills the application using SIGINT. */
#define FIO_ASSERT(cond, ...)                                                  \
  do {                                                                         \
    if (FIO_UNLIKELY(!(cond))) {                                               \
      FIO_LOG_FATAL(__VA_ARGS__);                                              \
      FIO_LOG_FATAL("     errno(%d): %s\n", errno, strerror(errno));           \
      FIO_ASSERT___PERFORM_SIGNAL();                                           \
      abort();                                                                 \
    }                                                                          \
  } while (0)

#ifndef FIO_ASSERT_ALLOC
/** Tests for an allocation failure. The behavior can be overridden. */
#define FIO_ASSERT_ALLOC(ptr) FIO_ASSERT((ptr), "memory allocation failed.")
#endif

#ifdef DEBUG
/** If `DEBUG` is defined, raises SIGINT if assertion fails, otherwise NOOP. */
#define FIO_ASSERT_DEBUG(cond, ...)                                            \
  do {                                                                         \
    if (!(cond)) {                                                             \
      FIO_LOG_FATAL("(" FIO__FILE__                                            \
                    ":" FIO_MACRO2STR(__LINE__) ") " __VA_ARGS__);             \
      FIO_LOG_FATAL("     errno(%d): %s\n", errno, strerror(errno));           \
      FIO_ASSERT___PERFORM_SIGNAL();                                           \
      exit(-1);                                                                \
    }                                                                          \
  } while (0)
#else
#define FIO_ASSERT_DEBUG(...)
#endif

/* *****************************************************************************
Static Assertions
***************************************************************************** */
#if __STDC_VERSION__ >= 201112L
#define FIO_ASSERT_STATIC(cond, msg) _Static_assert((cond), msg)
#else
#define FIO_ASSERT_STATIC(cond, msg)                                           \
  static const char *FIO_NAME(fio_static_assertion_failed,                     \
                              __LINE__)[(((cond) << 1) - 1)] = {(char *)msg}
#endif

typedef struct {
  unsigned char data[2];
} fio___padding_char_struct_test_s;

FIO_ASSERT_STATIC(CHAR_BIT == 8, "facil.io requires an 8bit wide char");
FIO_ASSERT_STATIC(sizeof(uint8_t) == 1,
                  "facil.io requires an 8bit wide uint8_t");
FIO_ASSERT_STATIC(sizeof(uint16_t) == 2,
                  "facil.io requires a 16bit wide uint16_t");
FIO_ASSERT_STATIC(sizeof(uint32_t) == 4,
                  "facil.io requires a 32bit wide uint32_t");
FIO_ASSERT_STATIC(sizeof(uint64_t) == 8,
                  "facil.io requires a 64bit wide uint64_t");
FIO_ASSERT_STATIC(sizeof(fio___padding_char_struct_test_s) == 2,
                  "compiler adds padding to fio___memcpyX, creating memory "
                  "alignment issues.");

/* *****************************************************************************
Static Endian Test
***************************************************************************** */

#if (defined(__LITTLE_ENDIAN__) && __LITTLE_ENDIAN__) ||                       \
    (defined(__BIG_ENDIAN__) && !__BIG_ENDIAN__) ||                            \
    (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
#ifndef __BIG_ENDIAN__
#define __BIG_ENDIAN__ 0
#endif
#ifndef __LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__ 1
#endif
#elif (defined(__BIG_ENDIAN__) && __BIG_ENDIAN__) ||                           \
    (defined(__LITTLE_ENDIAN__) && !__LITTLE_ENDIAN__) ||                      \
    (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))
#ifndef __BIG_ENDIAN__
#define __BIG_ENDIAN__ 1
#endif
#ifndef __LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__ 0
#endif
#elif !defined(__BIG_ENDIAN__) && !defined(__BYTE_ORDER__) &&                  \
    !defined(__LITTLE_ENDIAN__)
#define FIO_LITTLE_ENDIAN_TEST 0x31323334UL
#define FIO_BIG_ENDIAN_TEST    0x34333231UL
#define FIO_ENDIAN_ORDER_TEST  ('1234')
#if ENDIAN_ORDER_TEST == LITTLE_ENDIAN_TEST
#define __BIG_ENDIAN__    0
#define __LITTLE_ENDIAN__ 1
#elif ENDIAN_ORDER_TEST == BIG_ENDIAN_TEST
#define __BIG_ENDIAN__    1
#define __LITTLE_ENDIAN__ 0
#else
#error Could not detect byte order on this system.
#endif

#endif /* predefined / test endianess */

/* *****************************************************************************
Dynamic Endian Testing
***************************************************************************** */

FIO_IFUNC unsigned int fio_is_little_endian(void) {
  union {
    unsigned long ul;
    unsigned char u8[sizeof(unsigned long)];
  } u = {.ul = 1};
  return (unsigned int)u.u8[0];
}

FIO_IFUNC unsigned int fio_is_big_endian(void) {
  return !fio_is_little_endian();
}

/* *****************************************************************************
Security Related macros
***************************************************************************** */
#define FIO_MEM_STACK_WIPE(pages)                                              \
  do {                                                                         \
    volatile char stack_mem[(pages) << 12] = {0};                              \
    (void)stack_mem;                                                           \
  } while (0)

/* *****************************************************************************
Settings - Memory Function Selectors
***************************************************************************** */
#ifdef FIO_MEMALT
#ifndef FIO_MEMCPY
#define FIO_MEMCPY fio_memcpy
#endif
#ifndef FIO_MEMMOVE
#define FIO_MEMMOVE fio_memcpy
#endif
#ifndef FIO_MEMCMP
#define FIO_MEMCMP fio_memcmp
#endif
#ifndef FIO_MEMCHR
#define FIO_MEMCHR fio_memchr
#endif
#ifndef FIO_MEMSET
#define FIO_MEMSET fio_memset
#endif
#ifndef FIO_STRLEN
#define FIO_STRLEN fio_strlen
#endif
#endif /* FIO_MEMALT */

/* memcpy selectors / overriding */
#ifndef FIO_MEMCPY
#if __has_builtin(__builtin_memcpy)
/** `memcpy` selector macro */
#define FIO_MEMCPY __builtin_memcpy
#else
/** `memcpy` selector macro */
#define FIO_MEMCPY memcpy
#endif
#endif /* FIO_MEMCPY */

/* memmove selectors / overriding */
#ifndef FIO_MEMMOVE
#if __has_builtin(__builtin_memmove)
/** `memmov` selector macro */
#define FIO_MEMMOVE __builtin_memmove
#else
/** `memmov` selector macro */
#define FIO_MEMMOVE memmove
#endif
#endif /* FIO_MEMMOVE */

/* memset selectors / overriding */
#ifndef FIO_MEMSET
#if __has_builtin(__builtin_memset)
/** `memset` selector macro */
#define FIO_MEMSET __builtin_memset
#else
/** `memset` selector macro */
#define FIO_MEMSET memset
#endif
#endif /* FIO_MEMSET */

/* memchr selectors / overriding */
#ifndef FIO_MEMCHR
#if __has_builtin(__builtin_memchr)
/** `memchr` selector macro */
#define FIO_MEMCHR __builtin_memchr
#else
/** `memchr` selector macro */
#define FIO_MEMCHR memchr
#endif
#endif /* FIO_MEMCHR */

/* strlen selectors / overriding */
#ifndef FIO_STRLEN
#if __has_builtin(__builtin_strlen)
/** `strlen` selector macro */
#define FIO_STRLEN __builtin_strlen
#else
/** `strlen` selector macro */
#define FIO_STRLEN strlen
#endif
#endif /* FIO_STRLEN */

/* memcmp selectors / overriding */
#ifndef FIO_MEMCMP
#if __has_builtin(__builtin_memcmp)
/** `memcmp` selector macro */
#define FIO_MEMCMP __builtin_memcmp
#else
/** `memcmp` selector macro */
#define FIO_MEMCMP memcmp
#endif
#endif /* FIO_MEMCMP */

#ifndef FIO_FOR
/** Helper for simple `for` loops, where `i` is the variable name to use. */
#define FIO_FOR(i, count) for (size_t i = 0; i < (count); ++i)
#endif

/* *****************************************************************************
SIMD Vector Looping Helper
***************************************************************************** */

/* Internal - bytes per constant iterative loop for compiler optimization  */
#define FIO___SIMD_BYTES ((size_t)256U)
/**
 * Unrolled `for` loop - separates for loops to make it easier for the compiler
 * to optimize.
 *
 * @param iterations - the number of loop iterations to perform
 * @param size_of_loop - the number of bytes consumed by each `action`
 * @param i - the loop index variable name to use (accessible by `action`)
 * @param action - an action to be performed each iteration (can be a macro)
 * */
#define FIO_FOR_UNROLL(iterations, size_of_loop, i, action)                    \
  do {                                                                         \
    size_t i = 0;                                                              \
    /* handle odd length vectors, not multiples of FIO___LOG2V */              \
    if ((iterations & ((FIO___SIMD_BYTES / size_of_loop) - 1)))                \
      for (; i < (iterations & ((FIO___SIMD_BYTES / size_of_loop) - 1)); ++i)  \
        action;                                                                \
    if (iterations)                                                            \
      for (; !(iterations + 1) || (i < iterations);)                           \
        for (size_t j__loop__ = 0;                                             \
             j__loop__ < (FIO___SIMD_BYTES / size_of_loop);                    \
             ++j__loop__, ++i) /* dear compiler, please vectorize */           \
          action;                                                              \
  } while (0)

/* *****************************************************************************
Memory Copying Primitives (the basis for unaligned memory access for numbers)
***************************************************************************** */

/* memcpy selectors / overriding */
#if __has_builtin(__builtin_memcpy) /* __builtin_memcpy isn't really better */
#define FIO___MAKE_MEMCPY_FIXED(bytes)                                         \
  FIO_SFUNC void *fio_memcpy##bytes(void *restrict d,                          \
                                    const void *restrict s) {                  \
    return __builtin_memcpy(d, s, bytes);                                      \
  }
#else
#define FIO___MAKE_MEMCPY_FIXED(bytes)                                         \
  FIO_SFUNC void *fio_memcpy##bytes(void *restrict d,                          \
                                    const void *restrict s) {                  \
    void *const r = (char *)d + bytes;                                         \
    FIO_FOR_UNROLL(bytes, 1, i, ((char *)d)[i] = ((const char *)s)[i]);        \
    return r;                                                                  \
  }
#endif /* __has_builtin(__builtin_memcpy) */

/** No-op (completes the name space). */
FIO_SFUNC void *fio_memcpy0(void *restrict d, const void *restrict s) {
  ((void)s);
  return d;
}
/** Copies 1 byte from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(1)
/** Copies 2 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(2)
/** Copies 3 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(3)
/** Copies 4 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(4)
/** Copies 5 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(5)
/** Copies 6 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(6)
/** Copies 7 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(7)
/** Copies 8 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(8)
/** Copies 16 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(16)
/** Copies 32 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(32)
/** Copies 64 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(64)
/** Copies 128 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(128)
/** Copies 256 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(256)
/** Copies 512 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(512)
/** Copies 1024 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(1024)
/** Copies 2048 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(2048)
/** Copies 4096 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(4096)
#undef FIO___MAKE_MEMCPY_FIXED

/** an unsafe memcpy (no checks + no overlapping memory regions) up to 63B */
FIO_IFUNC void *fio___memcpy_unsafe_63x(void *restrict d_,
                                        const void *restrict s_,
                                        size_t l) {
  char *restrict d = (char *restrict)d_;
  const char *restrict s = (const char *restrict)s_;
#define FIO___MEMCPY_XX_GROUP(bytes)                                           \
  do {                                                                         \
    fio_memcpy##bytes((void *)d, (const void *)s);                             \
    d += l & (bytes - 1);                                                      \
    s += l & (bytes - 1);                                                      \
    fio_memcpy##bytes((void *)d, (const void *)s);                             \
    return (void *)(d += bytes);                                               \
  } while (0)
  if (l > 31)
    FIO___MEMCPY_XX_GROUP(32);
  if (l > 15)
    FIO___MEMCPY_XX_GROUP(16);
  if (l > 7)
    FIO___MEMCPY_XX_GROUP(8);
#undef FIO___MEMCPY_XX_GROUP
  if ((l & 4)) {
    fio_memcpy4(d, s);
    d += 4;
    s += 4;
  }
  if ((l & 2)) {
    fio_memcpy2(d, s);
    d += 2;
    s += 2;
  }
  if ((l & 1))
    *d++ = *s;
  return (void *)d;
}
/** an unsafe memcpy (no checks + assumes no overlapping memory regions) */
FIO_SFUNC void *fio___memcpy_unsafe_x(void *restrict d_,
                                      const void *restrict s_,
                                      size_t l) {
  char *restrict d = (char *restrict)d_;
  const char *restrict s = (const char *restrict)s_;
  if (FIO_LIKELY(l < 64))
    return fio___memcpy_unsafe_63x(d_, s_, l);
#define FIO___MEMCPY_UNSAFE_STEP(bytes)                                        \
  do {                                                                         \
    fio_memcpy##bytes((void *)d, (const void *)s);                             \
    (l -= bytes), (d += bytes), (s += bytes);                                  \
  } while (0)

#if FIO_LIMIT_INTRINSIC_BUFFER
  while (l > 127)
    FIO___MEMCPY_UNSAFE_STEP(128);
#else
  while (l > 255)
    FIO___MEMCPY_UNSAFE_STEP(256);
  if (l & 128)
    FIO___MEMCPY_UNSAFE_STEP(128);
#endif
  if (l & 64)
    FIO___MEMCPY_UNSAFE_STEP(64);
#undef FIO___MEMCPY_UNSAFE_STEP
  d -= 64;
  s -= 64;
  d += l & 63U;
  s += l & 63U;
  fio_memcpy64((void *)d, (const void *)s);
  return (void *)(d += 64);
}

#define FIO___MEMCPYX_MAKER(lim, fn)                                           \
  FIO_IFUNC void *fio_memcpy##lim##x(void *restrict d,                         \
                                     const void *restrict s,                   \
                                     size_t l) {                               \
    return fn(d, s, (l & lim));                                                \
  }

/** No-op (completes the name space). */
FIO_SFUNC void *fio_memcpy0x(void *d, const void *s, size_t l) {
  ((void)s), ((void)l);
  return d;
}
/** Copies up to (len & 7) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(7, fio___memcpy_unsafe_63x)
/** Copies up to (len & 15) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(15, fio___memcpy_unsafe_63x)
/** Copies up to (len & 31) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(31, fio___memcpy_unsafe_63x)
/** Copies up to (len & 63) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(63, fio___memcpy_unsafe_63x)
/** Copies up to (len & 127) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(127, fio___memcpy_unsafe_x)
/** Copies up to (len & 255) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(255, fio___memcpy_unsafe_x)
/** Copies up to (len & 511) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(511, fio___memcpy_unsafe_x)
/** Copies up to (len & 1023) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(1023, fio___memcpy_unsafe_x)
/** Copies up to (len & 2047) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(2047, fio___memcpy_unsafe_x)
/** Copies up to (len & 4095) bytes from `src` (`s`) to `dest` (`d`). */
FIO___MEMCPYX_MAKER(4095, fio___memcpy_unsafe_x)
#undef FIO___MEMCPYX_MAKER

/* *****************************************************************************
Memory Leak Detection
***************************************************************************** */

#ifndef FIO_LEAK_COUNTER_SKIP_EXIT
#define FIO_LEAK_COUNTER_SKIP_EXIT 0
#endif
#ifndef FIO___LEAK_COUNTER_DEF
#define FIO___LEAK_COUNTER_DEF(name)                                           \
  size_t FIO_WEAK FIO_NAME(fio___leak_counter, name)(size_t i) {               \
    static volatile size_t counter = 0;                                        \
    size_t tmp = fio_atomic_add_fetch(&counter, i);                            \
    if (FIO_UNLIKELY(tmp == ((size_t)-1)))                                     \
      goto error_double_free;                                                  \
    return tmp;                                                                \
  error_double_free:                                                           \
    FIO_ASSERT(0,                                                              \
               "(%d) " FIO_MACRO2STR(name) " `free` after `free` detected!",   \
               fio_getpid());                                                  \
  }                                                                            \
  static void FIO_NAME(fio___leak_counter_cleanup, name)(void *i) {            \
    size_t counter = FIO_NAME(fio___leak_counter, name)((size_t)(uintptr_t)i); \
    FIO_LOG_DEBUG2("(%d) testing leaks for " FIO_MACRO2STR(name),              \
                   fio_getpid());                                              \
    if (counter)                                                               \
      FIO_LOG_ERROR("(%d) %zu leaks detected for " FIO_MACRO2STR(name),        \
                    fio_getpid(),                                              \
                    counter);                                                  \
  }                                                                            \
  FIO_CONSTRUCTOR(FIO_NAME(fio___leak_counter_const, name)) {                  \
    if (!FIO_LEAK_COUNTER_SKIP_EXIT)                                           \
      fio_state_callback_add(FIO_CALL_AT_EXIT,                                 \
                             FIO_NAME(fio___leak_counter_cleanup, name),       \
                             NULL);                                            \
  }
#define FIO___LEAK_COUNTER_COUNT(name)    FIO_NAME(fio___leak_counter, name)(0)
#define FIO___LEAK_COUNTER_ON_ALLOC(name) FIO_NAME(fio___leak_counter, name)(1)
#define FIO___LEAK_COUNTER_ON_FREE(name)                                       \
  FIO_NAME(fio___leak_counter, name)(((size_t)-1))
#endif

/* *****************************************************************************
Swapping byte's order (`bswap` variations)
***************************************************************************** */

/* avoid special cases by defining for all sizes */
#define fio_bswap8(i) (i)

/** Byte swap a 16 bit integer, inlined. */
#if __has_builtin(__builtin_bswap16)
#define fio_bswap16(i) __builtin_bswap16((uint16_t)(i))
#else
FIO_IFUNC FIO_CONST uint16_t fio_bswap16(uint16_t i) {
  return ((((i)&0xFFU) << 8) | (((i)&0xFF00U) >> 8));
}
#endif

/** Byte swap a 32 bit integer, inlined. */
#if __has_builtin(__builtin_bswap32)
#define fio_bswap32(i) __builtin_bswap32((uint32_t)(i))
#else
FIO_IFUNC FIO_CONST uint32_t fio_bswap32(uint32_t i) {
  return ((((i)&0xFFUL) << 24) | (((i)&0xFF00UL) << 8) |
          (((i)&0xFF0000UL) >> 8) | (((i)&0xFF000000UL) >> 24));
}
#endif

/** Byte swap a 64 bit integer, inlined. */
#if __has_builtin(__builtin_bswap64)
#define fio_bswap64(i) __builtin_bswap64((uint64_t)(i))
#else
FIO_IFUNC FIO_CONST uint64_t fio_bswap64(uint64_t i) {
  return ((((i)&0xFFULL) << 56) | (((i)&0xFF00ULL) << 40) |
          (((i)&0xFF0000ULL) << 24) | (((i)&0xFF000000ULL) << 8) |
          (((i)&0xFF00000000ULL) >> 8) | (((i)&0xFF0000000000ULL) >> 24) |
          (((i)&0xFF000000000000ULL) >> 40) |
          (((i)&0xFF00000000000000ULL) >> 56));
}
#endif

#ifdef __SIZEOF_INT128__
#if __has_builtin(__builtin_bswap128)
#define fio_bswap128(i) __builtin_bswap128((__uint128_t)(i))
#else
FIO_IFUNC FIO_CONST __uint128_t fio_bswap128(__uint128_t i) {
  return ((__uint128_t)fio_bswap64(i) << 64) | fio_bswap64(i >> 64);
}
#endif
#endif /* __SIZEOF_INT128__ */

/* *****************************************************************************
Switching Endian Ordering
***************************************************************************** */

#define fio_ltole8(i) (i) /* avoid special cases by defining for all sizes */
#define fio_lton8(i)  (i) /* avoid special cases by defining for all sizes */
#define fio_ntol8(i)  (i) /* avoid special cases by defining for all sizes */

#if __BIG_ENDIAN__

/** Local byte order to Network byte order, 16 bit integer */
#define fio_lton16(i) (i)
/** Local byte order to Network byte order, 32 bit integer */
#define fio_lton32(i) (i)
/** Local byte order to Network byte order, 62 bit integer */
#define fio_lton64(i) (i)

/** Local byte order to Little Endian byte order, 16 bit integer */
#define fio_ltole16(i) fio_bswap16((i))
/** Local byte order to Little Endian byte order, 32 bit integer */
#define fio_ltole32(i) fio_bswap32((i))
/** Local byte order to Little Endian byte order, 62 bit integer */
#define fio_ltole64(i) fio_bswap64((i))

/** Network byte order to Local byte order, 16 bit integer */
#define fio_ntol16(i) (i)
/** Network byte order to Local byte order, 32 bit integer */
#define fio_ntol32(i) (i)
/** Network byte order to Local byte order, 62 bit integer */
#define fio_ntol64(i) (i)

#ifdef __SIZEOF_INT128__
/** Network byte order to Local byte order, 128 bit integer */
#define fio_ntol128(i) (i)
/** Local byte order to Little Endian byte order, 128 bit integer */
#define fio_ltole128(i) fio_bswap128((i))

/** An endianess dependent shift operation, moves bytes forwards. */
#define FIO_SHIFT_FORWARDS(i, bits) ((i) >> (bits))
/** An endianess dependent shift operation, moves bytes backwards. */
#define FIO_SHIFT_BACKWARDS(i, bits) ((i) << (bits))

#endif /* __SIZEOF_INT128__ */

#else /* Little Endian */

/** Local byte order to Network byte order, 16 bit integer */
#define fio_lton16(i)  fio_bswap16((i))
/** Local byte order to Network byte order, 32 bit integer */
#define fio_lton32(i)  fio_bswap32((i))
/** Local byte order to Network byte order, 62 bit integer */
#define fio_lton64(i)  fio_bswap64((i))

/** Local byte order to Little Endian byte order, 16 bit integer */
#define fio_ltole16(i) (i)
/** Local byte order to Little Endian byte order, 32 bit integer */
#define fio_ltole32(i) (i)
/** Local byte order to Little Endian byte order, 62 bit integer */
#define fio_ltole64(i) (i)

/** Network byte order to Local byte order, 16 bit integer */
#define fio_ntol16(i)  fio_bswap16((i))
/** Network byte order to Local byte order, 32 bit integer */
#define fio_ntol32(i)  fio_bswap32((i))
/** Network byte order to Local byte order, 62 bit integer */
#define fio_ntol64(i)  fio_bswap64((i))

#ifdef __SIZEOF_INT128__
/** Local byte order to Network byte order, 128 bit integer */
#define fio_lton128(i)  fio_bswap128((i))
/** Network byte order to Local byte order, 128 bit integer */
#define fio_ntol128(i)  fio_bswap128((i))
/** Local byte order to Little Endian byte order, 128 bit integer */
#define fio_ltole128(i) (i)
#endif /* __SIZEOF_INT128__ */

/** An endianess dependent shift operation, moves bytes forwards. */
#define FIO_SHIFT_FORWARDS(i, bits)  ((i) << (bits))
/** An endianess dependent shift operation, moves bytes backwards. */
#define FIO_SHIFT_BACKWARDS(i, bits) ((i) >> (bits))

#endif /* __BIG_ENDIAN__ */

/* *****************************************************************************
Unaligned memory read / write operations
***************************************************************************** */

/** Converts an unaligned byte stream to an 8 bit number. */
FIO_IFUNC uint8_t fio_buf2u8u(const void *c) { return *(const uint8_t *)c; }
/** Writes a local 8 bit number to an unaligned buffer. */
FIO_IFUNC void fio_u2buf8u(void *buf, uint8_t i) { *((uint8_t *)buf) = i; }
/** Converts an unaligned byte stream to an 8 bit number. */
FIO_IFUNC uint8_t fio_buf2u8_le(const void *c) { return *(const uint8_t *)c; }
/** Writes a local 8 bit number to an unaligned buffer. */
FIO_IFUNC void fio_u2buf8_le(void *buf, uint8_t i) { *((uint8_t *)buf) = i; }
/** Converts an unaligned byte stream to an 8 bit number. */
FIO_IFUNC uint8_t fio_buf2u8_be(const void *c) { return *(const uint8_t *)c; }
/** Writes a local 8 bit number to an unaligned buffer. */
FIO_IFUNC void fio_u2buf8_be(void *buf, uint8_t i) { *((uint8_t *)buf) = i; }

#define FIO___U2U_NOOP(i) (i)
#define FIO___MEMBUF_FN(bytes, n_bits, bits, wrapper, postfix)                 \
  /** Converts an unaligned byte stream to a bits bit number. */               \
  FIO_IFUNC uint##bits##_t fio_buf2u##n_bits##postfix(const void *c) {         \
    uint##bits##_t tmp;                                                        \
    fio_memcpy##bytes(&tmp, c);                                                \
    return wrapper(tmp);                                                       \
  }                                                                            \
  /** Writes a bits bit number to an unaligned buffer. */                      \
  FIO_IFUNC void fio_u2buf##n_bits##postfix(void *buf, uint##bits##_t i) {     \
    i = wrapper(i);                                                            \
    fio_memcpy##bytes(buf, &i);                                                \
  }
/* unspecified byte order (native ordering) */
FIO___MEMBUF_FN(2, 16, 16, FIO___U2U_NOOP, u)
FIO___MEMBUF_FN(4, 32, 32, FIO___U2U_NOOP, u)
FIO___MEMBUF_FN(8, 64, 64, FIO___U2U_NOOP, u)
/* little endian byte order (native ordering) */
FIO___MEMBUF_FN(2, 16, 16, fio_ltole16, _le)
FIO___MEMBUF_FN(4, 32, 32, fio_ltole32, _le)
FIO___MEMBUF_FN(8, 64, 64, fio_ltole64, _le)
/* big / network endian byte order (native ordering) */
FIO___MEMBUF_FN(2, 16, 16, fio_lton16, _be)
FIO___MEMBUF_FN(4, 32, 32, fio_lton32, _be)
FIO___MEMBUF_FN(8, 64, 64, fio_lton64, _be)
#undef FIO___MEMBUF_FN

/** Converts an unaligned byte stream to a 24 bit number. */
FIO_IFUNC uint32_t fio_buf2u24_le(const void *c) {
  uint32_t tmp = ((uint32_t)((const uint8_t *)c)[0]) |
                 ((uint32_t)((const uint8_t *)c)[1] << 8) |
                 ((uint32_t)((const uint8_t *)c)[2] << 16);
  return tmp;
} /** Writes a 24 bit number to an unaligned buffer. */
FIO_IFUNC void fio_u2buf24_le(void *buf, uint32_t i) {
  ((uint8_t *)buf)[0] = i & 0xFFU;
  ((uint8_t *)buf)[1] = (i >> 8) & 0xFFU;
  ((uint8_t *)buf)[2] = (i >> 16) & 0xFFU;
}
/** Converts an unaligned byte stream to a 24 bit number. */
FIO_IFUNC uint32_t fio_buf2u24_be(const void *c) {
  uint32_t tmp = ((uint32_t)((const uint8_t *)c)[0] << 16) |
                 ((uint32_t)((const uint8_t *)c)[1] << 8) |
                 ((uint32_t)((const uint8_t *)c)[2]);
  return tmp;
}
/** Writes a 24 bit number to an unaligned buffer. */
FIO_IFUNC void fio_u2buf24_be(void *buf, uint32_t i) {
  ((uint8_t *)buf)[0] = (i >> 16) & 0xFFU;
  ((uint8_t *)buf)[1] = (i >> 8) & 0xFFU;
  ((uint8_t *)buf)[2] = (i)&0xFFU;
}

#if __BIG_ENDIAN__
/** Converts an unaligned byte stream to a 24 bit number - local endieness. */
FIO_IFUNC uint32_t fio_buf2u24u(const void *c) { return fio_buf2u24_be(c); }
/** Writes a 24 bit number to an unaligned buffer - in local endieness. */
FIO_IFUNC void fio_u2buf24u(void *buf, uint32_t i) { fio_u2buf24_be(buf, i); }
#elif __LITTLE_ENDIAN__
/** Converts an unaligned byte stream to a 24 bit number - local endieness. */
FIO_IFUNC uint32_t fio_buf2u24u(const void *c) { return fio_buf2u24_le(c); }
/** Writes a 24 bit number to an unaligned buffer - in local endieness. */
FIO_IFUNC void fio_u2buf24u(void *buf, uint32_t i) { fio_u2buf24_le(buf, i); }
#else
#warning "Couldn't calculate local version for fio_buf2u24u and fio_u2buf24u"
#endif

/* *****************************************************************************
Vector Math, Shuffle & Reduction on native types, for up to 2048 bits
***************************************************************************** */
#define FIO____SHFL_FN(T, prefx, len)                                          \
  FIO_IFUNC void fio_##prefx##x##len##_reshuffle(T *v, uint8_t indx[len]) {    \
    T tmp[len];                                                                \
    for (size_t i = 0; i < len; ++i) {                                         \
      tmp[i] = v[indx[i] & (len - 1)];                                         \
    }                                                                          \
    for (size_t i = 0; i < len; ++i) {                                         \
      v[i] = tmp[i];                                                           \
    }                                                                          \
  }
#define FIO____REDUCE_FN(T, prefx, len, opnm, op)                              \
  FIO_MIFN T fio_##prefx##x##len##_reduce_##opnm(T *v) {                       \
    T r = v[0];                                                                \
    for (size_t i = 1; i < len; ++i) {                                         \
      r = r op v[i];                                                           \
    }                                                                          \
    return r;                                                                  \
  }                                                                            \
  FIO_IFUNC void fio_##prefx##x##len##_##opnm(T *dest, T *a, T *b) {           \
    for (size_t i = 0; i < len; ++i)                                           \
      dest[i] = a[i] op b[i];                                                  \
  }
#define FIO____REDUCE_MINMAX(T, prefx, len)                                    \
  FIO_MIFN T fio_##prefx##x##len##_reduce_max(T *v) {                          \
    T r = v[0];                                                                \
    for (size_t i = 1; i < len; ++i) {                                         \
      r = r < v[i] ? v[i] : r;                                                 \
    }                                                                          \
    return r;                                                                  \
  }                                                                            \
  FIO_MIFN T fio_##prefx##x##len##_reduce_min(T *v) {                          \
    T r = v[0];                                                                \
    for (size_t i = 1; i < len; ++i) {                                         \
      r = r > v[i] ? v[i] : r;                                                 \
    }                                                                          \
    return r;                                                                  \
  }

#define FIO____SHFL_REDUCE(T, prefx, len)                                      \
  FIO____SHFL_FN(T, prefx, len)                                                \
  FIO____REDUCE_FN(T, prefx, len, add, +)                                      \
  FIO____REDUCE_FN(T, prefx, len, sub, -)                                      \
  FIO____REDUCE_FN(T, prefx, len, mul, *)                                      \
  FIO____REDUCE_FN(T, prefx, len, and, &)                                      \
  FIO____REDUCE_FN(T, prefx, len, or, |)                                       \
  FIO____REDUCE_FN(T, prefx, len, xor, ^)                                      \
  FIO____REDUCE_MINMAX(T, prefx, len)

FIO____SHFL_REDUCE(uint8_t, u8, 4)
FIO____SHFL_REDUCE(uint8_t, u8, 8)
FIO____SHFL_REDUCE(uint8_t, u8, 16)
FIO____SHFL_REDUCE(uint8_t, u8, 32)
FIO____SHFL_REDUCE(uint8_t, u8, 64)
FIO____SHFL_REDUCE(uint8_t, u8, 128)
FIO____SHFL_REDUCE(uint8_t, u8, 256)
FIO____SHFL_REDUCE(uint16_t, u16, 2)
FIO____SHFL_REDUCE(uint16_t, u16, 4)
FIO____SHFL_REDUCE(uint16_t, u16, 8)
FIO____SHFL_REDUCE(uint16_t, u16, 16)
FIO____SHFL_REDUCE(uint16_t, u16, 32)
FIO____SHFL_REDUCE(uint16_t, u16, 64)
FIO____SHFL_REDUCE(uint16_t, u16, 128)
FIO____SHFL_REDUCE(uint32_t, u32, 2)
FIO____SHFL_REDUCE(uint32_t, u32, 4)
FIO____SHFL_REDUCE(uint32_t, u32, 8)
FIO____SHFL_REDUCE(uint32_t, u32, 16)
FIO____SHFL_REDUCE(uint32_t, u32, 32)
FIO____SHFL_REDUCE(uint32_t, u32, 64)
FIO____SHFL_REDUCE(uint64_t, u64, 2)
FIO____SHFL_REDUCE(uint64_t, u64, 4)
FIO____SHFL_REDUCE(uint64_t, u64, 8)
FIO____SHFL_REDUCE(uint64_t, u64, 16)
FIO____SHFL_REDUCE(uint64_t, u64, 32)

#undef FIO____SHFL_REDUCE
#define FIO____SHFL_REDUCE(T, prefx, len)                                      \
  FIO____SHFL_FN(T, prefx, len)                                                \
  FIO____REDUCE_FN(T, prefx, len, add, +)                                      \
  FIO____REDUCE_FN(T, prefx, len, mul, *)                                      \
  FIO____REDUCE_MINMAX(T, prefx, len)

FIO____SHFL_REDUCE(float, float, 2)
FIO____SHFL_REDUCE(float, float, 4)
FIO____SHFL_REDUCE(float, float, 8)
FIO____SHFL_REDUCE(float, float, 16)
FIO____SHFL_REDUCE(float, float, 32)
FIO____SHFL_REDUCE(float, float, 64)
FIO____SHFL_REDUCE(double, dbl, 2)
FIO____SHFL_REDUCE(double, dbl, 4)
FIO____SHFL_REDUCE(double, dbl, 8)
FIO____SHFL_REDUCE(double, dbl, 16)
FIO____SHFL_REDUCE(double, dbl, 32)
#undef FIO____REDUCE_FN
#undef FIO____REDUCE_MINMAX
#undef FIO____SHFL_FN
#undef FIO____SHFL_REDUCE

/* clang-format off */
#define fio_u8x4_reshuffle(v, ...)     fio_u8x4_reshuffle(v,     (uint8_t[4]){__VA_ARGS__})
#define fio_u8x8_reshuffle(v, ...)     fio_u8x8_reshuffle(v,     (uint8_t[8]){__VA_ARGS__})
#define fio_u8x16_reshuffle(v, ...)    fio_u8x16_reshuffle(v,    (uint8_t[16]){__VA_ARGS__})
#define fio_u8x32_reshuffle(v, ...)    fio_u8x32_reshuffle(v,    (uint8_t[32]){__VA_ARGS__})
#define fio_u8x64_reshuffle(v, ...)    fio_u8x64_reshuffle(v,    (uint8_t[64]){__VA_ARGS__})
#define fio_u8x128_reshuffle(v, ...)   fio_u8x128_reshuffle(v,   (uint8_t[128]){__VA_ARGS__})
#define fio_u8x256_reshuffle(v, ...)   fio_u8x256_reshuffle(v,   (uint8_t[256]){__VA_ARGS__})
#define fio_u16x2_reshuffle(v, ...)    fio_u16x2_reshuffle(v,    (uint8_t[2]){__VA_ARGS__})
#define fio_u16x4_reshuffle(v, ...)    fio_u16x4_reshuffle(v,    (uint8_t[4]){__VA_ARGS__})
#define fio_u16x8_reshuffle(v, ...)    fio_u16x8_reshuffle(v,    (uint8_t[8]){__VA_ARGS__})
#define fio_u16x16_reshuffle(v, ...)   fio_u16x16_reshuffle(v,   (uint8_t[16]){__VA_ARGS__})
#define fio_u16x32_reshuffle(v, ...)   fio_u16x32_reshuffle(v,   (uint8_t[32]){__VA_ARGS__})
#define fio_u16x64_reshuffle(v, ...)   fio_u16x64_reshuffle(v,   (uint8_t[64]){__VA_ARGS__})
#define fio_u16x128_reshuffle(v,...)   fio_u16x128_reshuffle(v,  (uint8_t[128]){__VA_ARGS__})
#define fio_u32x2_reshuffle(v, ...)    fio_u32x2_reshuffle(v,    (uint8_t[2]){__VA_ARGS__})
#define fio_u32x4_reshuffle(v, ...)    fio_u32x4_reshuffle(v,    (uint8_t[4]){__VA_ARGS__})
#define fio_u32x8_reshuffle(v, ...)    fio_u32x8_reshuffle(v,    (uint8_t[8]){__VA_ARGS__})
#define fio_u32x16_reshuffle(v, ...)   fio_u32x16_reshuffle(v,   (uint8_t[16]){__VA_ARGS__})
#define fio_u32x32_reshuffle(v, ...)   fio_u32x32_reshuffle(v,   (uint8_t[32]){__VA_ARGS__})
#define fio_u32x64_reshuffle(v, ...)   fio_u32x64_reshuffle(v,   (uint8_t[64]){__VA_ARGS__})
#define fio_u64x2_reshuffle(v, ...)    fio_u64x2_reshuffle(v,    (uint8_t[2]){__VA_ARGS__})
#define fio_u64x4_reshuffle(v, ...)    fio_u64x4_reshuffle(v,    (uint8_t[4]){__VA_ARGS__})
#define fio_u64x8_reshuffle(v, ...)    fio_u64x8_reshuffle(v,    (uint8_t[8]){__VA_ARGS__})
#define fio_u64x16_reshuffle(v, ...)   fio_u64x16_reshuffle(v,   (uint8_t[16]){__VA_ARGS__})
#define fio_u64x32_reshuffle(v, ...)   fio_u64x32_reshuffle(v,   (uint8_t[32]){__VA_ARGS__})
#define fio_floatx2_reshuffle(v, ...)  fio_floatx2_reshuffle(v,  (uint8_t[2]){__VA_ARGS__})
#define fio_floatx4_reshuffle(v, ...)  fio_floatx4_reshuffle(v,  (uint8_t[4]){__VA_ARGS__})
#define fio_floatx8_reshuffle(v, ...)  fio_floatx8_reshuffle(v,  (uint8_t[8]){__VA_ARGS__})
#define fio_floatx16_reshuffle(v, ...) fio_floatx16_reshuffle(v, (uint8_t[16]){__VA_ARGS__})
#define fio_floatx32_reshuffle(v, ...) fio_floatx32_reshuffle(v, (uint8_t[32]){__VA_ARGS__})
#define fio_floatx64_reshuffle(v, ...) fio_floatx64_reshuffle(v, (uint8_t[64]){__VA_ARGS__})
#define fio_dblx2_reshuffle(v, ...)    fio_dblx2_reshuffle(v,    (uint8_t[2]){__VA_ARGS__})
#define fio_dblx4_reshuffle(v, ...)    fio_dblx4_reshuffle(v,    (uint8_t[4]){__VA_ARGS__})
#define fio_dblx8_reshuffle(v, ...)    fio_dblx8_reshuffle(v,    (uint8_t[8]){__VA_ARGS__})
#define fio_dblx16_reshuffle(v, ...)   fio_dblx16_reshuffle(v,   (uint8_t[16]){__VA_ARGS__})
#define fio_dblx32_reshuffle(v, ...)   fio_dblx32_reshuffle(v,   (uint8_t[32]){__VA_ARGS__})
/* clang-format on */

/* *****************************************************************************
Linked Lists Persistent Macros and Types
***************************************************************************** */

/** A linked list arch-type */
typedef struct fio_list_node_s {
  struct fio_list_node_s *next;
  struct fio_list_node_s *prev;
} fio_list_node_s;

/** A linked list node type */
#define FIO_LIST_NODE fio_list_node_s
/** A linked list head type */
#define FIO_LIST_HEAD fio_list_node_s

/** Allows initialization of FIO_LIST_HEAD objects. */
#define FIO_LIST_INIT(obj)                                                     \
  (fio_list_node_s) { .next = &(obj), .prev = &(obj) }

#ifndef FIO_LIST_EACH
/** Loops through every node in the linked list except the head. */
#define FIO_LIST_EACH(type, node_name, head, pos)                              \
  for (type *pos = FIO_PTR_FROM_FIELD(type, node_name, (head)->next),          \
            *next____p_ls_##pos =                                              \
                FIO_PTR_FROM_FIELD(type, node_name, (head)->next->next);       \
       pos != FIO_PTR_FROM_FIELD(type, node_name, (head));                     \
       (pos = next____p_ls_##pos),                                             \
            (next____p_ls_##pos =                                              \
                 FIO_PTR_FROM_FIELD(type,                                      \
                                    node_name,                                 \
                                    next____p_ls_##pos->node_name.next)))
/** Loops through every node in the linked list except the head. */
#define FIO_LIST_EACH_REVERSED(type, node_name, head, pos)                     \
  for (type *pos = FIO_PTR_FROM_FIELD(type, node_name, (head)->prev),          \
            *next____p_ls_##pos =                                              \
                FIO_PTR_FROM_FIELD(type, node_name, (head)->next->prev);       \
       pos != FIO_PTR_FROM_FIELD(type, node_name, (head));                     \
       (pos = next____p_ls_##pos),                                             \
            (next____p_ls_##pos =                                              \
                 FIO_PTR_FROM_FIELD(type,                                      \
                                    node_name,                                 \
                                    next____p_ls_##pos->node_name.prev)))
#endif

/** UNSAFE macro for pushing a node to a list. */
#define FIO_LIST_PUSH(head, n)                                                 \
  do {                                                                         \
    (n)->prev = (head)->prev;                                                  \
    (n)->next = (head);                                                        \
    (head)->prev->next = (n);                                                  \
    (head)->prev = (n);                                                        \
  } while (0)

/** UNSAFE macro for removing a node from a list. */
#define FIO_LIST_REMOVE(n)                                                     \
  do {                                                                         \
    (n)->prev->next = (n)->next;                                               \
    (n)->next->prev = (n)->prev;                                               \
  } while (0)

/** UNSAFE macro for removing a node from a list. Resets node data. */
#define FIO_LIST_REMOVE_RESET(n)                                               \
  do {                                                                         \
    (n)->prev->next = (n)->next;                                               \
    (n)->next->prev = (n)->prev;                                               \
    (n)->next = (n)->prev = (n);                                               \
  } while (0)

/** UNSAFE macro for popping a node to a list. */
#define FIO_LIST_POP(type, node_name, dest_ptr, head)                          \
  do {                                                                         \
    (dest_ptr) = FIO_PTR_FROM_FIELD(type, node_name, ((head)->next));          \
    FIO_LIST_REMOVE(&(dest_ptr)->node_name);                                   \
  } while (0)

/** UNSAFE macro for testing if a list is empty. */
#define FIO_LIST_IS_EMPTY(head)                                                \
  ((!(head)) || ((!(head)->next) | ((head)->next == (head))))

/* *****************************************************************************
Indexed Linked Lists Persistent Macros and Types

Indexed Linked Lists can be used to create a linked list that uses is always
relative to some root pointer (usually the root of an array). This:

1. Allows easy reallocation of the list without requiring pointer updates.

2. Could be used for memory optimization if the array limits are known.

The "head" index is usually validated by reserving the value of `-1` to indicate
an empty list.
***************************************************************************** */
#ifndef FIO_INDEXED_LIST_EACH

/** A 32 bit indexed linked list node type */
typedef struct fio_index32_node_s {
  uint32_t next;
  uint32_t prev;
} fio_index32_node_s;

/** A 16 bit indexed linked list node type */
typedef struct fio_index16_node_s {
  uint16_t next;
  uint16_t prev;
} fio_index16_node_s;

/** An 8 bit indexed linked list node type */
typedef struct fio_index8_node_s {
  uint8_t next;
  uint8_t prev;
} fio_index8_node_s;

/** A 32 bit indexed linked list node type */
#define FIO_INDEXED_LIST32_NODE fio_index32_node_s
#define FIO_INDEXED_LIST32_HEAD uint32_t
/** A 16 bit indexed linked list node type */
#define FIO_INDEXED_LIST16_NODE fio_index16_node_s
#define FIO_INDEXED_LIST16_HEAD uint16_t
/** An 8 bit indexed linked list node type */
#define FIO_INDEXED_LIST8_NODE fio_index8_node_s
#define FIO_INDEXED_LIST8_HEAD uint8_t

/** UNSAFE macro for pushing a node to a list. */
#define FIO_INDEXED_LIST_PUSH(root, node_name, head, i)                        \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[n__].node_name.prev = (root)[(head)].node_name.prev;                \
    (root)[n__].node_name.next = (head);                                       \
    (root)[(root)[(head)].node_name.prev].node_name.next = (n__);              \
    (root)[(head)].node_name.prev = (n__);                                     \
  } while (0)

/** UNSAFE macro for adding a node to the begging of the list. */
#define FIO_INDEXED_LIST_UNSHIFT(root, node_name, head, i)                     \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[n__].node_name.next = (root)[(head)].node_name.next;                \
    (root)[n__].node_name.prev = (head);                                       \
    (root)[(root)[(head)].node_name.next].node_name.prev = (n__);              \
    (root)[(head)].node_name.next = (n__);                                     \
    (head) = (n__);                                                            \
  } while (0)

/** UNSAFE macro for removing a node from a list. */
#define FIO_INDEXED_LIST_REMOVE(root, node_name, i)                            \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[(root)[n__].node_name.prev].node_name.next =                        \
        (root)[n__].node_name.next;                                            \
    (root)[(root)[n__].node_name.next].node_name.prev =                        \
        (root)[n__].node_name.prev;                                            \
  } while (0)

/** UNSAFE macro for removing a node from a list. Resets node data. */
#define FIO_INDEXED_LIST_REMOVE_RESET(root, node_name, i)                      \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[(root)[n__].node_name.prev].node_name.next =                        \
        (root)[n__].node_name.next;                                            \
    (root)[(root)[n__].node_name.next].node_name.prev =                        \
        (root)[n__].node_name.prev;                                            \
    (root)[n__].node_name.next = (root)[n__].node_name.prev = (n__);           \
  } while (0)

/** Loops through every index in the indexed list, assuming `head` is valid. */
#define FIO_INDEXED_LIST_EACH(root, node_name, head, pos)                      \
  for (size_t pos = (head),                                                    \
              stooper___hd = (head),                                           \
              stopper___ils___ = 0,                                            \
              pos##___nxt = (root)[(head)].node_name.next;                     \
       !stopper___ils___;                                                      \
       (stopper___ils___ = ((pos = pos##___nxt) == stooper___hd)),             \
              pos##___nxt = (root)[pos].node_name.next)

/** Loops through every index in the indexed list, assuming `head` is valid. */
#define FIO_INDEXED_LIST_EACH_REVERSED(root, node_name, head, pos)             \
  for (size_t pos = ((root)[(head)].node_name.prev),                           \
              pos##___nxt =                                                    \
                  ((root)[((root)[(head)].node_name.prev)].node_name.prev),    \
              stooper___hd = (head),                                           \
              stopper___ils___ = 0;                                            \
       !stopper___ils___;                                                      \
       ((stopper___ils___ = (pos == stooper___hd)),                            \
        (pos = pos##___nxt),                                                   \
        (pos##___nxt = (root)[pos##___nxt].node_name.prev)))
#endif

/* *****************************************************************************
Constant-Time Selectors
***************************************************************************** */

/** Returns 1 if the expression is true (input isn't zero). */
FIO_IFUNC FIO_CONST uintmax_t fio_ct_true(uintmax_t cond) {
  // promise that the highest bit is set if any bits are set, than shift.
  return ((cond | (0 - cond)) >> ((sizeof(cond) << 3) - 1));
}

/** Returns 1 if the expression is false (input is zero). */
FIO_IFUNC FIO_CONST uintmax_t fio_ct_false(uintmax_t cond) {
  // fio_ct_true returns only one bit, XOR will inverse that bit.
  return fio_ct_true(cond) ^ 1;
}

/** Returns `a` if `cond` is boolean and true, returns b otherwise. */
FIO_IFUNC FIO_CONST uintmax_t fio_ct_if_bool(uintmax_t cond,
                                             uintmax_t a,
                                             uintmax_t b) {
  // b^(a^b) cancels b out. 0-1 => sets all bits.
  return (b ^ (((uintmax_t)0ULL - (cond & 1)) & (a ^ b)));
}

/** Returns `a` if `cond` isn't zero (uses fio_ct_true), returns b otherwise. */
FIO_IFUNC FIO_CONST uintmax_t fio_ct_if(uintmax_t cond,
                                        uintmax_t a,
                                        uintmax_t b) {
  // b^(a^b) cancels b out. 0-1 => sets all bits.
  return fio_ct_if_bool(fio_ct_true(cond), a, b);
}

/** Returns `a` if a >= `b`. */
FIO_IFUNC FIO_CONST intmax_t fio_ct_max(intmax_t a_, intmax_t b_) {
  // if b - a is negative, a > b, unless both / one are negative.
  const uintmax_t a = a_, b = b_;
  return (
      intmax_t)fio_ct_if_bool(((a - b) >> ((sizeof(a) << 3) - 1)) & 1, b, a);
}

/** Returns `a` if a >= `b`. */
FIO_IFUNC FIO_CONST intmax_t fio_ct_min(intmax_t a_, intmax_t b_) {
  // if b - a is negative, a > b, unless both / one are negative.
  const uintmax_t a = a_, b = b_;
  return (
      intmax_t)fio_ct_if_bool(((a - b) >> ((sizeof(a) << 3) - 1)) & 1, a, b);
}

/** Returns absolute value. */
FIO_IFUNC FIO_CONST uintmax_t fio_ct_abs(intmax_t i_) {
  // if b - a is negative, a > b, unless both / one are negative.
  const uintmax_t i = i_;
  return (intmax_t)fio_ct_if_bool((i >> ((sizeof(i) << 3) - 1)), 0 - i, i);
}

/* *****************************************************************************
Constant-Time Bitwise Selection Functions

These functions perform bitwise selection operations in constant time.
They are commonly used in cryptographic algorithms (SHA, AES, etc.) and
can also be used for branchless programming.
***************************************************************************** */

/**
 * Bitwise "choose": for each bit, if x is set, return y's bit, else z's bit.
 * Formula: (x & y) ^ (~x & z)  -or equivalently-  z ^ (x & (y ^ z))
 * Used in: SHA-1 (Ch), SHA-256 (Ch), SHA-512 (Ch), AES, etc.
 */
FIO_IFUNC FIO_CONST uint32_t fio_ct_mux32(uint32_t x, uint32_t y, uint32_t z) {
  return z ^ (x & (y ^ z)); /* branchless ternary: x ? y : z (per bit) */
}

/** 64-bit version of bitwise choose/mux. */
FIO_IFUNC FIO_CONST uint64_t fio_ct_mux64(uint64_t x, uint64_t y, uint64_t z) {
  return z ^ (x & (y ^ z));
}

/**
 * Bitwise "majority": for each bit position, return 1 if 2+ inputs have 1.
 * Formula: (x & y) ^ (x & z) ^ (y & z)  -or-  (x & y) | (z & (x | y))
 * Used in: SHA-1 (Maj), SHA-256 (Maj), SHA-512 (Maj), etc.
 */
FIO_IFUNC FIO_CONST uint32_t fio_ct_maj32(uint32_t x, uint32_t y, uint32_t z) {
  return (x & y) | (z & (x | y)); /* slightly fewer ops than XOR version */
}

/** 64-bit version of bitwise majority. */
FIO_IFUNC FIO_CONST uint64_t fio_ct_maj64(uint64_t x, uint64_t y, uint64_t z) {
  return (x & y) | (z & (x | y));
}

/**
 * Bitwise "parity": XOR of all three inputs (1 if odd number of 1s).
 * Formula: x ^ y ^ z
 * Used in: SHA-1 (Parity function for rounds 20-39 and 60-79)
 */
FIO_IFUNC FIO_CONST uint32_t fio_ct_xor3_32(uint32_t x,
                                            uint32_t y,
                                            uint32_t z) {
  return x ^ y ^ z;
}

/** 64-bit version of 3-way XOR. */
FIO_IFUNC FIO_CONST uint64_t fio_ct_xor3_64(uint64_t x,
                                            uint64_t y,
                                            uint64_t z) {
  return x ^ y ^ z;
}

/* *****************************************************************************
Constant-Time Comparison Test
***************************************************************************** */

/** A timing attack resistant memory comparison function. */
FIO_SFUNC _Bool fio_ct_is_eq(const void *a_, const void *b_, size_t bytes) {
  uint64_t flag = 0;
  const char *a = (const char *)a_;
  const char *b = (const char *)b_;
  const char *e = a + bytes;
  /* any uneven bytes? */
  if (bytes & 63) {
    /* consume uneven byte head */
    uint64_t ua[8] FIO_ALIGN(16) = {0};
    uint64_t ub[8] FIO_ALIGN(16) = {0};
    /* all these if statements can run in parallel */
    if (bytes & 32) {
      fio_memcpy32(ua, a);
      fio_memcpy32(ub, b);
    }
    if (bytes & 16) {
      fio_memcpy16(ua + 4, a + (bytes & 32));
      fio_memcpy16(ub + 4, b + (bytes & 32));
    }
    if (bytes & 8) {
      fio_memcpy8(ua + 6, a + (bytes & 48));
      fio_memcpy8(ub + 6, b + (bytes & 48));
    }
    if (bytes & 4) {
      fio_memcpy4((uint32_t *)ua + 14, a + (bytes & 56));
      fio_memcpy4((uint32_t *)ub + 14, b + (bytes & 56));
    }
    if (bytes & 2) {
      fio_memcpy2((uint16_t *)ua + 30, a + (bytes & 60));
      fio_memcpy2((uint16_t *)ub + 30, b + (bytes & 60));
    }
    if (bytes & 1) {
      ((char *)ua)[62] = *(a + (bytes & 62));
      ((char *)ub)[62] = *(b + (bytes & 62));
    }
    for (size_t i = 0; i < 8; ++i)
      flag |= ua[i] ^ ub[i];
    a += bytes & 63;
    b += bytes & 63;
  }
  while (a < e) {
    uint64_t ua[8] FIO_ALIGN(16);
    uint64_t ub[8] FIO_ALIGN(16);
    fio_memcpy64(ua, a);
    fio_memcpy64(ub, b);
    for (size_t i = 0; i < 8; ++i)
      flag |= ua[i] ^ ub[i];
    a += 64;
    b += 64;
  }
  return !flag;
}

/** A timing attack resistant memory zeroing function. */
FIO_IFUNC void fio_secure_zero(void *a_, size_t bytes) {
  volatile uint8_t *buf = (volatile uint8_t *)(a_);
  FIO_FOR_UNROLL(bytes, 1, i, buf[i] = 0);
}

/* *****************************************************************************
Bit rotation
***************************************************************************** */

/** Left rotation for an unknown size element, inlined. */
#define FIO_LROT(i, bits)                                                      \
  (((i) << ((bits) & ((sizeof((i)) << 3) - 1))) |                              \
   ((i) >> ((-(bits)) & ((sizeof((i)) << 3) - 1))))

/** Right rotation for an unknown size element, inlined. */
#define FIO_RROT(i, bits)                                                      \
  (((i) >> ((bits) & ((sizeof((i)) << 3) - 1))) |                              \
   ((i) << ((-(bits)) & ((sizeof((i)) << 3) - 1))))

#if __has_builtin(__builtin_rotateleft8)
/** 8Bit left rotation, inlined. */
#define fio_lrot8(i, bits) __builtin_rotateleft8(i, bits)
#else
/** 8Bit left rotation, inlined. */
FIO_IFUNC FIO_CONST uint8_t fio_lrot8(uint8_t i, uint8_t bits) {
  return ((i << (bits & 7UL)) | (i >> ((-(bits)) & 7UL)));
}
#endif

#if __has_builtin(__builtin_rotateleft16)
/** 16Bit left rotation, inlined. */
#define fio_lrot16(i, bits) __builtin_rotateleft16(i, bits)
#else
/** 16Bit left rotation, inlined. */
FIO_IFUNC FIO_CONST uint16_t fio_lrot16(uint16_t i, uint8_t bits) {
  return ((i << (bits & 15UL)) | (i >> ((-(bits)) & 15UL)));
}
#endif

#if __has_builtin(__builtin_rotateleft32)
/** 32Bit left rotation, inlined. */
#define fio_lrot32(i, bits) __builtin_rotateleft32(i, bits)
#else
/** 32Bit left rotation, inlined. */
FIO_IFUNC FIO_CONST uint32_t fio_lrot32(uint32_t i, uint8_t bits) {
  return ((i << (bits & 31UL)) | (i >> ((-(bits)) & 31UL)));
}
#endif

#if __has_builtin(__builtin_rotateleft64)
/** 64Bit left rotation, inlined. */
#define fio_lrot64(i, bits) __builtin_rotateleft64(i, bits)
#else
/** 64Bit left rotation, inlined. */
FIO_IFUNC FIO_CONST uint64_t fio_lrot64(uint64_t i, uint8_t bits) {
  return ((i << ((bits)&63UL)) | (i >> ((-(bits)) & 63UL)));
}
#endif

#if __has_builtin(__builtin_rotatrightt8)
/** 8Bit right rotation, inlined. */
#define fio_rrot8(i, bits) __builtin_rotateright8(i, bits)
#else
/** 8Bit right rotation, inlined. */
FIO_IFUNC FIO_CONST uint8_t fio_rrot8(uint8_t i, uint8_t bits) {
  return (uint8_t)((i >> (bits & 7U)) | (i << ((-(bits)) & 7U)));
}
#endif

#if __has_builtin(__builtin_rotateright16)
/** 16Bit right rotation, inlined. */
#define fio_rrot16(i, bits) __builtin_rotateright16(i, bits)
#else
/** 16Bit right rotation, inlined. */
FIO_IFUNC FIO_CONST uint16_t fio_rrot16(uint16_t i, uint8_t bits) {
  return ((i >> (bits & 15UL)) | (i << ((-(bits)) & 15UL)));
}
#endif

#if __has_builtin(__builtin_rotateright32)
/** 32Bit right rotation, inlined. */
#define fio_rrot32(i, bits) __builtin_rotateright32(i, bits)
#else
/** 32Bit right rotation, inlined. */
FIO_IFUNC FIO_CONST uint32_t fio_rrot32(uint32_t i, uint8_t bits) {
  return ((i >> (bits & 31UL)) | (i << ((-(bits)) & 31UL)));
}
#endif

#if __has_builtin(__builtin_rotateright64)
/** 64Bit right rotation, inlined. */
#define fio_rrot64(i, bits) __builtin_rotateright64(i, bits)
#else
/** 64Bit right rotation, inlined. */
FIO_IFUNC FIO_CONST uint64_t fio_rrot64(uint64_t i, uint8_t bits) {
  return ((i >> ((bits)&63UL)) | (i << ((-(bits)) & 63UL)));
}
#endif

#ifdef __SIZEOF_INT128__
#if __has_builtin(__builtin_rotateright128) &&                                 \
    __has_builtin(__builtin_rotateleft128)
/** 128Bit left rotation, inlined. */
#define fio_lrot128(i, bits) __builtin_rotateleft128(i, bits)
/** 128Bit right rotation, inlined. */
#define fio_rrot128(i, bits) __builtin_rotateright128(i, bits)
#else
/** 128Bit left rotation, inlined. */
FIO_IFUNC FIO_CONST __uint128_t fio_lrot128(__uint128_t i, uint8_t bits) {
  return ((i << ((bits)&127UL)) | (i >> ((-(bits)) & 127UL)));
}
/** 128Bit right rotation, inlined. */
FIO_IFUNC FIO_CONST __uint128_t fio_rrot128(__uint128_t i, uint8_t bits) {
  return ((i >> ((bits)&127UL)) | (i << ((-(bits)) & 127UL)));
}
#endif
#endif /* __SIZEOF_INT128__ */

#if __LITTLE_ENDIAN__
/** Rotates the bits Forwards (endian specific). */
#define fio_frot16 fio_rrot16
/** Rotates the bits Forwards (endian specific). */
#define fio_frot32 fio_rrot32
/** Rotates the bits Forwards (endian specific). */
#define fio_frot64 fio_rrot64
#else
/** Rotates the bits Forwards (endian specific). */
#define fio_frot16 fio_lrot16
/** Rotates the bits Forwards (endian specific). */
#define fio_frot32 fio_lrot32
/** Rotates the bits Forwards (endian specific). */
#define fio_frot64 fio_lrot64
#endif

/* *****************************************************************************
Combined Rotation-XOR operations (common in cryptographic hash functions)

These combine multiple rotations with XOR, which is a common pattern in
SHA-2, BLAKE2, and other hash functions. Keeping them as separate operations
allows the compiler to potentially optimize better than inline expressions.
***************************************************************************** */

/**
 * XOR of three right rotations: ROTR(x,a) ^ ROTR(x,b) ^ ROTR(x,c)
 * Common in SHA-256/SHA-512 Sigma functions.
 */
FIO_IFUNC FIO_CONST uint32_t fio_xor_rrot3_32(uint32_t x,
                                              uint8_t a,
                                              uint8_t b,
                                              uint8_t c) {
  return fio_rrot32(x, a) ^ fio_rrot32(x, b) ^ fio_rrot32(x, c);
}

/** 64-bit version of triple rotation XOR. */
FIO_IFUNC FIO_CONST uint64_t fio_xor_rrot3_64(uint64_t x,
                                              uint8_t a,
                                              uint8_t b,
                                              uint8_t c) {
  return fio_rrot64(x, a) ^ fio_rrot64(x, b) ^ fio_rrot64(x, c);
}

/**
 * XOR of two right rotations and a right shift: ROTR(x,a) ^ ROTR(x,b) ^
 * SHR(x,c) Common in SHA-256/SHA-512 sigma (lowercase) functions for message
 * schedule.
 */
FIO_IFUNC FIO_CONST uint32_t fio_xor_rrot2_shr_32(uint32_t x,
                                                  uint8_t a,
                                                  uint8_t b,
                                                  uint8_t c) {
  return fio_rrot32(x, a) ^ fio_rrot32(x, b) ^ (x >> c);
}

/** 64-bit version of double rotation + shift XOR. */
FIO_IFUNC FIO_CONST uint64_t fio_xor_rrot2_shr_64(uint64_t x,
                                                  uint8_t a,
                                                  uint8_t b,
                                                  uint8_t c) {
  return fio_rrot64(x, a) ^ fio_rrot64(x, b) ^ (x >> c);
}

/* *****************************************************************************
Byte masking (XOR)
***************************************************************************** */

/**
 * Masks data using a persistent 64 bit mask.
 *
 * When the buffer's memory is aligned, the function may perform significantly
 * better.
 */
FIO_IFUNC void fio_xmask(void *buf_, size_t len, uint64_t mask) {
  register char *buf = (char *)buf_;
  for (size_t i = 31; i < len; i += 32) {
    for (size_t g = 0; g < 4; ++g) {
      fio_u2buf64u(buf, (fio_buf2u64u(buf) ^ mask));
      buf += 8;
    }
  }
  if (len & 16)
    for (size_t g = 0; g < 2; ++g) {
      fio_u2buf64u(buf, (fio_buf2u64u(buf) ^ mask));
      buf += 8;
    }
  if (len & 8) {
    fio_u2buf64u(buf, (fio_buf2u64u(buf) ^ mask));
    buf += 8;
  }
  {
    uint64_t tmp = 0;
    fio_memcpy7x(&tmp, buf, len);
    tmp ^= mask;
    fio_memcpy7x(buf, &tmp, len);
  }
}

/**
 * Masks data using a persistent 64 bit mask.
 *
 * When the buffer's memory is aligned, the function may perform significantly
 * better.
 */
FIO_IFUNC void fio_xmask_cpy(char *restrict dest,
                             const char *src,
                             size_t len,
                             uint64_t mask) {
  if (dest == src) {
    fio_xmask(dest, len, mask);
    return;
  }
  for (size_t i = 31; i < len; i += 32) {
    for (size_t g = 0; g < 4; ++g) {
      fio_u2buf64u(dest, (fio_buf2u64u(src) ^ mask));
      dest += 8;
      src += 8;
    }
  }
  if (len & 16)
    for (size_t g = 0; g < 2; ++g) {
      fio_u2buf64u(dest, (fio_buf2u64u(src) ^ mask));
      dest += 8;
      src += 8;
    }
  if (len & 8) {
    fio_u2buf64u(dest, (fio_buf2u64u(src) ^ mask));
    dest += 8;
    src += 8;
  }
  if (len & 7) {
    uint64_t tmp;
    fio_memcpy7x(&tmp, src, len);
    tmp ^= mask;
    fio_memcpy7x(dest, &tmp, len);
  }
}

/* *****************************************************************************
Popcount (set bit counting) and Hemming Distance
***************************************************************************** */

#if __has_builtin(__builtin_popcountll)
/** performs a `popcount` operation to count the set bits. */
#define fio_popcount(n) __builtin_popcountll(n)
#else
FIO_IFUNC FIO_CONST int fio_popcount(uint64_t n) {
  /* for logic, see Wikipedia: https://en.wikipedia.org/wiki/Hamming_weight */
  n = n - ((n >> 1) & 0x5555555555555555);
  n = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);
  n = (n + (n >> 4)) & 0x0f0f0f0f0f0f0f0f;
  n = n + (n >> 8);
  n = n + (n >> 16);
  n = n + (n >> 32);
  return n & 0x7f;
}
#endif

#define fio_hemming_dist(n1, n2) fio_popcount(((uint64_t)(n1) ^ (uint64_t)(n2)))

/* *****************************************************************************
Bit Mapping (placed here to avoid dependency between FIO_MEMALT and FIO_MATH)
***************************************************************************** */
#if !defined(__has_builtin) || !__has_builtin(__builtin_ctzll) ||              \
    !__has_builtin(__builtin_clzll)
FIO_SFUNC size_t fio___single_bit_index_unsafe(uint64_t i) {
  switch (i) {
  case UINT64_C(0x1): return 0;
  case UINT64_C(0x2): return 1;
  case UINT64_C(0x4): return 2;
  case UINT64_C(0x8): return 3;
  case UINT64_C(0x10): return 4;
  case UINT64_C(0x20): return 5;
  case UINT64_C(0x40): return 6;
  case UINT64_C(0x80): return 7;
  case UINT64_C(0x100): return 8;
  case UINT64_C(0x200): return 9;
  case UINT64_C(0x400): return 10;
  case UINT64_C(0x800): return 11;
  case UINT64_C(0x1000): return 12;
  case UINT64_C(0x2000): return 13;
  case UINT64_C(0x4000): return 14;
  case UINT64_C(0x8000): return 15;
  case UINT64_C(0x10000): return 16;
  case UINT64_C(0x20000): return 17;
  case UINT64_C(0x40000): return 18;
  case UINT64_C(0x80000): return 19;
  case UINT64_C(0x100000): return 20;
  case UINT64_C(0x200000): return 21;
  case UINT64_C(0x400000): return 22;
  case UINT64_C(0x800000): return 23;
  case UINT64_C(0x1000000): return 24;
  case UINT64_C(0x2000000): return 25;
  case UINT64_C(0x4000000): return 26;
  case UINT64_C(0x8000000): return 27;
  case UINT64_C(0x10000000): return 28;
  case UINT64_C(0x20000000): return 29;
  case UINT64_C(0x40000000): return 30;
  case UINT64_C(0x80000000): return 31;
  case UINT64_C(0x100000000): return 32;
  case UINT64_C(0x200000000): return 33;
  case UINT64_C(0x400000000): return 34;
  case UINT64_C(0x800000000): return 35;
  case UINT64_C(0x1000000000): return 36;
  case UINT64_C(0x2000000000): return 37;
  case UINT64_C(0x4000000000): return 38;
  case UINT64_C(0x8000000000): return 39;
  case UINT64_C(0x10000000000): return 40;
  case UINT64_C(0x20000000000): return 41;
  case UINT64_C(0x40000000000): return 42;
  case UINT64_C(0x80000000000): return 43;
  case UINT64_C(0x100000000000): return 44;
  case UINT64_C(0x200000000000): return 45;
  case UINT64_C(0x400000000000): return 46;
  case UINT64_C(0x800000000000): return 47;
  case UINT64_C(0x1000000000000): return 48;
  case UINT64_C(0x2000000000000): return 49;
  case UINT64_C(0x4000000000000): return 50;
  case UINT64_C(0x8000000000000): return 51;
  case UINT64_C(0x10000000000000): return 52;
  case UINT64_C(0x20000000000000): return 53;
  case UINT64_C(0x40000000000000): return 54;
  case UINT64_C(0x80000000000000): return 55;
  case UINT64_C(0x100000000000000): return 56;
  case UINT64_C(0x200000000000000): return 57;
  case UINT64_C(0x400000000000000): return 58;
  case UINT64_C(0x800000000000000): return 59;
  case UINT64_C(0x1000000000000000): return 60;
  case UINT64_C(0x2000000000000000): return 61;
  case UINT64_C(0x4000000000000000): return 62;
  case UINT64_C(0x8000000000000000): return 63;
  }
  return (0ULL - 1ULL);
}
#endif /* __builtin_ctzll || __builtin_clzll */

/** Returns the index of the least significant (lowest) bit. */
FIO_SFUNC FIO_CONST size_t fio_lsb_index_unsafe(uint64_t i) {
#if defined(__has_builtin) && __has_builtin(__builtin_ctzll)
  return (size_t)__builtin_ctzll(i);
#else
  return fio___single_bit_index_unsafe(i & ((~i) + 1));
#endif /* __builtin vs. map */
}

/** Returns the index of the most significant (highest) bit. */
FIO_SFUNC FIO_CONST size_t fio_msb_index_unsafe(uint64_t i) {
#if defined(__has_builtin) && __has_builtin(__builtin_clzll)
  return (size_t)(63 - __builtin_clzll(i));
#else
  i |= i >> 1;
  i |= i >> 2;
  i |= i >> 4;
  i |= i >> 8;
  i |= i >> 16;
  i |= i >> 32;
  i = ((i + 1) >> 1) | (i & ((uint64_t)1ULL << 63));
  return fio___single_bit_index_unsafe(i);
#endif /* __builtin vs. map */
}

/* *****************************************************************************
Byte Value helpers
***************************************************************************** */

/**
 * Detects a byte where no bits are set (0) within a 4 byte vector.
 *
 * The zero byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC FIO_CONST uint32_t fio_has_zero_byte32(uint32_t row) {
  return (row - UINT32_C(0x01010101)) & (~row & UINT32_C(0x80808080));
}

/**
 * Detects if `byte` exists within a 4 byte vector.
 *
 * The requested byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC FIO_CONST uint32_t fio_has_byte32(uint32_t row, uint8_t byte) {
  return fio_has_zero_byte32((row ^ (UINT32_C(0x01010101) * byte)));
}

/**
 * Detects a byte where all the bits are set (255) within a 4 byte vector.
 *
 * The full byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC FIO_CONST uint32_t fio_has_full_byte32(uint32_t row) {
  return fio_has_zero_byte32(row);
  // return ((row & UINT32_C(0x7F7F7F7F)) + UINT32_C(0x01010101)) &
  //        (row & UINT32_C(0x80808080));
}

/**
 * Detects a byte where no bits are set (0) within an 8 byte vector.
 *
 * The zero byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC FIO_CONST uint64_t fio_has_zero_byte64(uint64_t row) {
#define FIO_HAS_ZERO_BYTE64(row)                                               \
  (((row)-UINT64_C(0x0101010101010101)) &                                      \
   ((~(row)) & UINT64_C(0x8080808080808080)))
  return FIO_HAS_ZERO_BYTE64(row);
}

/**
 * Detects a byte where no bits are set (0) within an 8 byte vector.
 *
 * This variation should NOT be used to build a bitmap, but May be used to
 * detect the first occurrence.
 */
FIO_IFUNC FIO_CONST uint64_t fio_has_zero_byte_alt64(uint64_t row) {
#define FIO_HAS_ZERO_BYTE64(row)                                               \
  (((row)-UINT64_C(0x0101010101010101)) &                                      \
   ((~(row)) & UINT64_C(0x8080808080808080)))
  return FIO_HAS_ZERO_BYTE64(row);
}

/**
 * Detects if `byte` exists within an 8 byte vector.
 *
 * The requested byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC FIO_CONST uint64_t fio_has_byte64(uint64_t row, uint8_t byte) {
  return fio_has_zero_byte64((row ^ (UINT64_C(0x0101010101010101) * byte)));
}

/**
 * Detects a byte where all the bits are set (255) within an 8 byte vector.
 *
 * The full byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC FIO_CONST uint64_t fio_has_full_byte64(uint64_t row) {
#define FIO_HAS_FULL_BYTE64(row)                                               \
  ((((row)&UINT64_C(0x7F7F7F7F7F7F7F7F)) + UINT64_C(0x0101010101010101)) &     \
   (row)&UINT64_C(0x8080808080808080))
  return FIO_HAS_FULL_BYTE64(row);
}

/** Converts a `fio_has_byteX` result to a bitmap. */
FIO_IFUNC FIO_CONST uint64_t fio_has_byte2bitmap(uint64_t result) {
/** Converts a FIO_HAS_FULL_BYTE64 result to relative position bitmap. */
#define FIO_HAS_BYTE2BITMAP(result, bit_index)                                 \
  do {                                                                         \
    (result) = fio_ltole64((result)); /* map little endian to bitmap */        \
    (result) >>= bit_index;           /* move bit index to 0x01 */             \
    (result) |= (result) >> 7;        /* pack all 0x80 bits into one byte */   \
    (result) |= (result) >> 14;                                                \
    (result) |= (result) >> 28;                                                \
    (result) &= 0xFFU;                                                         \
  } while (0)
  FIO_HAS_BYTE2BITMAP(result, 7);
  return result;
}

/** Isolates the least significant (lowest) bit. */
FIO_IFUNC FIO_CONST uint64_t fio_bits_lsb(uint64_t i) {
  return (i & ((~i) + 1));
}

/** Isolates the most significant (highest) bit. */
FIO_IFUNC FIO_CONST uint64_t fio_bits_msb(uint64_t i) {
  i |= i >> 1;
  i |= i >> 2;
  i |= i >> 4;
  i |= i >> 8;
  i |= i >> 16;
  i |= i >> 32;
  i = ((i + 1) >> 1) | (i & ((uint64_t)1ULL << 63));
  return i;
}

/** Returns the index of the most significant (highest) bit. */
FIO_IFUNC FIO_CONST size_t fio_bits_msb_index(uint64_t i) {
  if (!i)
    goto zero;
  return fio_msb_index_unsafe(i);
zero:
  return (size_t)-1;
}

/** Returns the index of the least significant (lowest) bit. */
FIO_IFUNC FIO_CONST size_t fio_bits_lsb_index(uint64_t i) {
  if (!i)
    goto zero;
  return fio_lsb_index_unsafe(i);
zero:
  return (size_t)-1;
}

/* *****************************************************************************
Bitmap access / manipulation
***************************************************************************** */

/** Gets the state of a bit in a bitmap. */
FIO_IFUNC uint8_t fio_bit_get(void *map, size_t bit) {
  return ((((uint8_t *)(map))[(bit) >> 3] >> ((bit)&7)) & 1);
}

/** Sets the a bit in a bitmap (sets to 1). */
FIO_IFUNC void fio_bit_set(void *map, size_t bit) {
  ((uint8_t *)map)[bit >> 3] |= (uint8_t)(1UL << (bit & 7));
}

/** Unsets the a bit in a bitmap (sets to 0). */
FIO_IFUNC void fio_bit_unset(void *map, size_t bit) {
  ((uint8_t *)map)[bit >> 3] &= (uint8_t)(~(1UL << (bit & 7)));
}

/** Flips the a bit in a bitmap (sets to 0 if 1, sets to 1 if 0). */
FIO_IFUNC void fio_bit_flip(void *map, size_t bit) {
  ((uint8_t *)map)[bit >> 3] ^= (uint8_t)((1UL << (bit & 7)));
}

/* *****************************************************************************
Fun Primes
***************************************************************************** */
/* clang-format off */

/* Primes with with 8 bits, 3 to 5 bits of them are set. */
#define FIO_U8_HASH_PRIME0   0x17U   /* (4/6) 00010111 */
#define FIO_U8_HASH_PRIME1   0x1DU   /* (4/6) 00011101 */
#define FIO_U8_HASH_PRIME2   0x25U   /* (3/6) 00100101 */
#define FIO_U8_HASH_PRIME3   0x29U   /* (3/6) 00101001 */
#define FIO_U8_HASH_PRIME4   0x2BU   /* (4/6) 00101011 */
#define FIO_U8_HASH_PRIME5   0x35U   /* (4/6) 00110101 */
#define FIO_U8_HASH_PRIME6   0x3BU   /* (5/6) 00111011 */
#define FIO_U8_HASH_PRIME7   0x43U   /* (3/8) 01000011 */
#define FIO_U8_HASH_PRIME8   0x47U   /* (4/8) 01000111 */
#define FIO_U8_HASH_PRIME9   0x49U   /* (3/8) 01001001 */
#define FIO_U8_HASH_PRIME10  0x53U   /* (4/8) 01010011 */
#define FIO_U8_HASH_PRIME11  0x59U   /* (4/8) 01011001 */
#define FIO_U8_HASH_PRIME12  0x61U   /* (3/8) 01100001 */
#define FIO_U8_HASH_PRIME13  0x65U   /* (4/8) 01100101 */
#define FIO_U8_HASH_PRIME14  0x67U   /* (5/8) 01100111 */
#define FIO_U8_HASH_PRIME15  0x6BU   /* (5/8) 01101011 */
#define FIO_U8_HASH_PRIME16  0x6DU   /* (5/8) 01101101 */
#define FIO_U8_HASH_PRIME17  0x83U   /* (3/8) 10000011 */
#define FIO_U8_HASH_PRIME18  0x89U   /* (3/8) 10001001 */
#define FIO_U8_HASH_PRIME19  0x8BU   /* (4/8) 10001011 */
#define FIO_U8_HASH_PRIME20  0x95U   /* (4/8) 10010101 */
#define FIO_U8_HASH_PRIME21  0x97U   /* (5/8) 10010111 */
#define FIO_U8_HASH_PRIME22  0x9DU   /* (5/8) 10011101 */
#define FIO_U8_HASH_PRIME23  0xA3U   /* (4/8) 10100011 */
#define FIO_U8_HASH_PRIME24  0xA7U   /* (5/8) 10100111 */
#define FIO_U8_HASH_PRIME25  0xADU   /* (5/8) 10101101 */
#define FIO_U8_HASH_PRIME26  0xB3U   /* (5/8) 10110011 */
#define FIO_U8_HASH_PRIME27  0xB5U   /* (5/8) 10110101 */
#define FIO_U8_HASH_PRIME28  0xC1U   /* (3/8) 11000001 */
#define FIO_U8_HASH_PRIME29  0xC5U   /* (4/8) 11000101 */
#define FIO_U8_HASH_PRIME30  0xC7U   /* (5/8) 11000111 */
#define FIO_U8_HASH_PRIME31  0xD3U   /* (5/8) 11010011 */

/* Primes with with 16 bits, half of them set. */
#define FIO_U16_HASH_PRIME0  0x631DU /* 0110001100011101 */
#define FIO_U16_HASH_PRIME1  0x4F19U /* 0100111100011001 */
#define FIO_U16_HASH_PRIME2  0xA91BU /* 1010100100011011 */
#define FIO_U16_HASH_PRIME3  0xDF01U /* 1101111100000001 */
#define FIO_U16_HASH_PRIME4  0x8C5DU /* 1000110001011101 */
#define FIO_U16_HASH_PRIME5  0xF941U /* 1111100101000001 */
#define FIO_U16_HASH_PRIME6  0xC49DU /* 1100010010011101 */
#define FIO_U16_HASH_PRIME7  0xA32BU /* 1010001100101011 */
#define FIO_U16_HASH_PRIME8  0x7859U /* 0111100001011001 */
#define FIO_U16_HASH_PRIME9  0xC4F1U /* 1100010011110001 */
#define FIO_U16_HASH_PRIME10 0x74E1U /* 0111010011100001 */
#define FIO_U16_HASH_PRIME11 0xD433U /* 1101010000110011 */
#define FIO_U16_HASH_PRIME12 0xCB29U /* 1100101100101001 */
#define FIO_U16_HASH_PRIME13 0xC2A7U /* 1100001010100111 */
#define FIO_U16_HASH_PRIME14 0xC317U /* 1100001100010111 */
#define FIO_U16_HASH_PRIME15 0x92B9U /* 1001001010111001 */
#define FIO_U16_HASH_PRIME16 0x7D03U /* 0111110100000011 */
#define FIO_U16_HASH_PRIME17 0x5CD1U /* 0101110011010001 */
#define FIO_U16_HASH_PRIME18 0x73C1U /* 0111001111000001 */
#define FIO_U16_HASH_PRIME19 0x69A3U /* 0110100110100011 */
#define FIO_U16_HASH_PRIME20 0xA2B3U /* 1010001010110011 */
#define FIO_U16_HASH_PRIME21 0x521FU /* 0101001000011111 */
#define FIO_U16_HASH_PRIME22 0x4E53U /* 0100111001010011 */
#define FIO_U16_HASH_PRIME23 0xFC41U /* 1111110001000001 */
#define FIO_U16_HASH_PRIME24 0x5F09U /* 0101111100001001 */
#define FIO_U16_HASH_PRIME25 0x605FU /* 0110000001011111 */
#define FIO_U16_HASH_PRIME26 0xA715U /* 1010011100010101 */
#define FIO_U16_HASH_PRIME27 0x6C65U /* 0110110001100101 */
#define FIO_U16_HASH_PRIME28 0x65C5U /* 0110010111000101 */
#define FIO_U16_HASH_PRIME29 0x85D3U /* 1000010111010011 */
#define FIO_U16_HASH_PRIME30 0xDE41U /* 1101111001000001 */
#define FIO_U16_HASH_PRIME31 0xCA8DU /* 1100101010001101 */

/* Primes with with 32 bits, half of them set. */
#define FIO_U32_HASH_PRIME0  0x618E9735 /* 01100001100011101001011100110101 */
#define FIO_U32_HASH_PRIME1  0xD9E8E033 /* 11011001111010001110000000110011 */
#define FIO_U32_HASH_PRIME2  0x50F116F9 /* 01010000111100010001011011111001 */
#define FIO_U32_HASH_PRIME3  0x6E098F4B /* 01101110000010011000111101001011 */
#define FIO_U32_HASH_PRIME4  0x8CC87A6B /* 10001100110010000111101001101011 */
#define FIO_U32_HASH_PRIME5  0x59E16F03 /* 01011001111000010110111100000011 */
#define FIO_U32_HASH_PRIME6  0xBB838C63 /* 10111011100000111000110001100011 */
#define FIO_U32_HASH_PRIME7  0x8532FF05 /* 10000101001100101111111100000101 */
#define FIO_U32_HASH_PRIME8  0x44FEC4A5 /* 01000100111111101100010010100101 */
#define FIO_U32_HASH_PRIME9  0x9B3350D5 /* 10011011001100110101000011010101 */
#define FIO_U32_HASH_PRIME10 0x64BE6287 /* 01100100101111100110001010000111 */
#define FIO_U32_HASH_PRIME11 0x57C2370B /* 01010111110000100011011100001011 */
#define FIO_U32_HASH_PRIME12 0x9E724F41 /* 10011110011100100100111101000001 */
#define FIO_U32_HASH_PRIME13 0xF4A8A173 /* 11110100101010001010000101110011 */
#define FIO_U32_HASH_PRIME14 0x6C4560FD /* 01101100010001010110000011111101 */
#define FIO_U32_HASH_PRIME15 0xD8558C3D /* 11011000010101011000110000111101 */
#define FIO_U32_HASH_PRIME16 0xC2F29157 /* 11000010111100101001000101010111 */
#define FIO_U32_HASH_PRIME17 0xF4D03789 /* 11110100110100000011011110001001 */
#define FIO_U32_HASH_PRIME18 0x9FB01857 /* 10011111101100000001100001010111 */
#define FIO_U32_HASH_PRIME19 0xE9513C0F /* 11101001010100010011110000001111 */
#define FIO_U32_HASH_PRIME20 0x89862FD3 /* 10001001100001100010111111010011 */
#define FIO_U32_HASH_PRIME21 0xB742A51D /* 10110111010000101010010100011101 */
#define FIO_U32_HASH_PRIME22 0xB3A681B9 /* 10110011101001101000000110111001 */
#define FIO_U32_HASH_PRIME23 0xC44899F7 /* 11000100010010001001100111110111 */
#define FIO_U32_HASH_PRIME24 0x67DE8341 /* 01100111110111101000001101000001 */
#define FIO_U32_HASH_PRIME25 0xF453213B /* 11110100010100110010000100111011 */
#define FIO_U32_HASH_PRIME26 0xD22F9855 /* 11010010001011111001100001010101 */
#define FIO_U32_HASH_PRIME27 0x8B3E807D /* 10001011001111101000000001111101 */
#define FIO_U32_HASH_PRIME28 0x59DD1C23 /* 01011001110111010001110000100011 */
#define FIO_U32_HASH_PRIME29 0xEE548C8B /* 11101110010101001000110010001011 */
#define FIO_U32_HASH_PRIME30 0xD2E74E05 /* 11010010111001110100111000000101 */
#define FIO_U32_HASH_PRIME31 0x4E55788D /* 01001110010101010111100010001101 */

/* Primes with with 64 bits, half of them set. */
#define FIO_U64_HASH_PRIME0  ((uint64_t)0x39664DEECA23D825) /* 0011100101100110010011011110111011001010001000111101100000100101 */
#define FIO_U64_HASH_PRIME1  ((uint64_t)0x48644F7B3959621F) /* 0100100001100100010011110111101100111001010110010110001000011111 */
#define FIO_U64_HASH_PRIME2  ((uint64_t)0x613A19F5CB0D98D5) /* 0110000100111010000110011111010111001011000011011001100011010101 */
#define FIO_U64_HASH_PRIME3  ((uint64_t)0x84B56B93C869EA0F) /* 1000010010110101011010111001001111001000011010011110101000001111 */
#define FIO_U64_HASH_PRIME4  ((uint64_t)0x8EE38D13E0D95A8D) /* 1000111011100011100011010001001111100000110110010101101010001101 */
#define FIO_U64_HASH_PRIME5  ((uint64_t)0x92E99EC981F0E279) /* 1001001011101001100111101100100110000001111100001110001001111001 */
#define FIO_U64_HASH_PRIME6  ((uint64_t)0xDDC3100BEF158BB1) /* 1101110111000011000100000000101111101111000101011000101110110001 */
#define FIO_U64_HASH_PRIME7  ((uint64_t)0x918F4D38049F78BD) /* 1001000110001111010011010011100000000100100111110111100010111101 */
#define FIO_U64_HASH_PRIME8  ((uint64_t)0xB6C9F8032A35E2D9) /* 1011011011001001111110000000001100101010001101011110001011011001 */
#define FIO_U64_HASH_PRIME9  ((uint64_t)0xFA2A5F16D2A128D5) /* 1111101000101010010111110001011011010010101000010010100011010101 */
#define FIO_U64_HASH_PRIME10 ((uint64_t)0x5823C958ED5547D9) /* 0101100000100011110010010101100011101101010101010100011111011001 */
#define FIO_U64_HASH_PRIME11 ((uint64_t)0xE8AB702EEE09CB43) /* 1110100010101011011100000010111011101110000010011100101101000011 */
#define FIO_U64_HASH_PRIME12 ((uint64_t)0xEBD609356421F13D) /* 1110101111010110000010010011010101100100001000011111000100111101 */
#define FIO_U64_HASH_PRIME13 ((uint64_t)0x43D0C330AF5B1F17) /* 0100001111010000110000110011000010101111010110110001111100010111 */
#define FIO_U64_HASH_PRIME14 ((uint64_t)0xFEAE66D234871807) /* 1111111010101110011001101101001000110100100001110001100000000111 */
#define FIO_U64_HASH_PRIME15 ((uint64_t)0xEE54B43A52941D6B) /* 1110111001010100101101000011101001010010100101000001110101101011 */
#define FIO_U64_HASH_PRIME16 ((uint64_t)0x874E9DE46F15E205) /* 1000011101001110100111011110010001101111000101011110001000000101 */
#define FIO_U64_HASH_PRIME17 ((uint64_t)0xFC7CA51A8A2E9171) /* 1111110001111100101001010001101010001010001011101001000101110001 */
#define FIO_U64_HASH_PRIME18 ((uint64_t)0x83A70617F71F3C21) /* 1000001110100111000001100001011111110111000111110011110000100001 */
#define FIO_U64_HASH_PRIME19 ((uint64_t)0x50FA705D6D99C11D) /* 0101000011111010011100000101110101101101100110011100000100011101 */
#define FIO_U64_HASH_PRIME20 ((uint64_t)0x5362B5E6CF64814B) /* 0101001101100010101101011110011011001111011001001000000101001011 */
#define FIO_U64_HASH_PRIME21 ((uint64_t)0xA7A178389B0F3077) /* 1010011110100001011110000011100010011011000011110011000001110111 */
#define FIO_U64_HASH_PRIME22 ((uint64_t)0x779D78921199BA45) /* 0111011110011101011110001001001000010001100110011011101001000101 */
#define FIO_U64_HASH_PRIME23 ((uint64_t)0xB42FD16A9AE90F81) /* 1011010000101111110100010110101010011010111010010000111110000001 */
#define FIO_U64_HASH_PRIME24 ((uint64_t)0xA2B4538A3C95576D) /* 1010001010110100010100111000101000111100100101010101011101101101 */
#define FIO_U64_HASH_PRIME25 ((uint64_t)0x5E23D8E445F94E0D) /* 0101111000100011110110001110010001000101111110010100111000001101 */
#define FIO_U64_HASH_PRIME26 ((uint64_t)0xE7CA493CD6444F07) /* 1110011111001010010010010011110011010110010001000100111100000111 */
#define FIO_U64_HASH_PRIME27 ((uint64_t)0x734719A6A1873CB5) /* 0111001101000111000110011010011010100001100001110011110010110101 */
#define FIO_U64_HASH_PRIME28 ((uint64_t)0x56CCB954143A3AB7) /* 0101011011001100101110010101010000010100001110100011101010110111 */
#define FIO_U64_HASH_PRIME29 ((uint64_t)0xFA5BC5A72480BF81) /* 1111101001011011110001011010011100100100100000001011111110000001 */
#define FIO_U64_HASH_PRIME30 ((uint64_t)0xD9B97D090C09F789) /* 1101100110111001011111010000100100001100000010011111011110001001 */
#define FIO_U64_HASH_PRIME31 ((uint64_t)0x9F74D0B9972E404B) /* 1001111101110100110100001011100110010111001011100100000001001011 */

/* clang-format on */

/** Perform modular multiplication for numbers with up to 64 bits. */
FIO_IFUNC uint64_t fio_math_mod_mul64(uint64_t a, uint64_t b, uint64_t mod) {
#if defined(__SIZEOF_INT128__) && !FIO_OS_WIN
  return (uint64_t)(((__uint128_t)a * b) % mod);
#else
  uint64_t r = 0;
  for (; b; b >>= 1) {
    if (b & 1)
      r = (r + a) % mod;
    a = (a + a) % mod;
  }
  return r;
#endif
}

/** Perform modular exponentiation */
FIO_IFUNC uint64_t fio_math_mod_expo64(uint64_t base,
                                       uint64_t exp,
                                       uint64_t mod) {
  uint64_t result = 1;
  base %= mod;
  for (; exp; exp >>= 1) {
    if ((exp & 1)) { /* if exp is odd, multiply base with result */
      result = fio_math_mod_mul64(result, base, mod);
    }
    base = fio_math_mod_mul64(base, base, mod); /* mod square base */
  }
  return result;
}

#ifndef FIO_PRIME_TABLE_LIMIT
#define FIO_PRIME_TABLE_LIMIT 1024
#endif
/* Perform sieve prime test - deterministic. */
FIO_SFUNC bool fio___is_prime_table(size_t n) {
  FIO_ASSERT_DEBUG(n < FIO_PRIME_TABLE_LIMIT,
                   "%zu too big for fio___is_prime_table",
                   n);
  uint64_t primes[((FIO_PRIME_TABLE_LIMIT + 63) >> 6)];
  for (size_t i = 0; i < (sizeof(primes) / sizeof(primes[0])); ++i)
    primes[i] = ~(uint64_t)0;
  fio_bit_unset(primes, 0);
  for (size_t i = 2; i < FIO_PRIME_TABLE_LIMIT; ++i) {
    if (!fio_bit_get(primes, i))
      continue;
    for (size_t j = i * i; j < FIO_PRIME_TABLE_LIMIT; j += i)
      fio_bit_unset(primes, j);
  }
  return fio_bit_get(primes, n);
}

/* Perform the Miller-Rabin test - probabilistic. */
FIO_SFUNC bool fio___is_prime_maybe(uint64_t n, size_t tests) {
  tests += !tests; /* perform loop at least once */
  /* find d such that n = (2**r) * d + 1 with d odd */
  const uint64_t nm1 = n - 1;
  uint64_t d = nm1;
  size_t r = fio_lsb_index_unsafe(d);
  d >>= r;
  // fprintf(stderr, "n = %llu; r = %zu; d = %llu\n", n, r, d);
  /* loop until tests == 0, starting with base 2 */
  uint64_t a = 2;
  for (;;) {
    uint64_t x = fio_math_mod_expo64(a, d, n);
    if (x != 1 && x != nm1) {
      bool composite = 1;
      for (size_t j = 0; j < r - 1; j++) {
        x = fio_math_mod_expo64(x, 2, n);
        if (x == nm1) {
          composite = 0;
          break;
        }
      }
      if (composite)
        return 0;
    }
    if (!(--tests)) /* n is (probably) prime */
      return 1;
    /* step into the next base between [2, n-2]... no randomness, but okay */
    a = 2 + ((((n & 0xFFFFU) + (a - 2) + FIO_U32_HASH_PRIME0) & 0xFFFFFFFF) %
             (n - 4));
    a += (a == 2);
  }
}

/**
 * Tests if an unsigned 64 bit number is (probably) a prime.
 *
 * For numbers up to 1023 this is deterministic.
 * */
FIO_SFUNC bool fio_math_is_uprime(uint64_t n) {
  if (n < 2)
    return 0; // 0 and 1 aren't prime
  if (n < 4)
    return 1; // 2 and 3 are prime
  if (!(n & 1))
    return 0; // even numbers other than 2 aren't primes
  if (n < (FIO_PRIME_TABLE_LIMIT))
    return fio___is_prime_table(n);
  return fio___is_prime_maybe(n, 10);
}

/**
 * Tests if the absolute value of a signed 64 bit number is (probably) a prime.
 *
 * For numbers up to 1023 this is deterministic.
 */
FIO_IFUNC bool fio_math_is_iprime(int64_t n) {
  return fio_math_is_uprime((n < 0) ? (uint64_t)(0LL - n) : (uint64_t)n);
}

/* *****************************************************************************
64bit addition (ADD) / subtraction (SUB) / multiplication (MUL) with carry.
***************************************************************************** */

/** Add with carry. */
FIO_MIFN uint64_t fio_math_addc64(uint64_t a,
                                  uint64_t b,
                                  uint64_t carry_in,
                                  uint64_t *carry_out) {
  FIO_ASSERT_DEBUG(carry_out, "fio_math_addc64 requires a carry pointer");
#if __has_builtin(__builtin_addcll) && UINT64_MAX == LLONG_MAX
  return __builtin_addcll(a, b, carry_in, (unsigned long long *)carry_out);
#elif defined(__SIZEOF_INT128__) && 0
  /* This is actually slower as it occupies more CPU registers */
  __uint128_t u = (__uint128_t)a + b + carry_in;
  *carry_out = (uint64_t)(u >> 64U);
  return (uint64_t)u;
#else
  uint64_t u = a + (b += carry_in);
  *carry_out = (b < carry_in) + (u < a);
  return u;
#endif
}

/** Multi-precision ADD for `len` 64 bit words a + b. Returns the carry. */
FIO_MIFN bool fio_math_add(uint64_t *dest,
                           const uint64_t *a,
                           const uint64_t *b,
                           const size_t len) {
  uint64_t c = 0;
  for (size_t i = 0; i < len; ++i)
    dest[i] = fio_math_addc64(a[i], b[i], c, &c);
  return (bool)c;
}

#ifdef __SIZEOF_INT128__
/** Multi-precision ADD for `bits` long a + b. Returns the carry. */
FIO_MIFN __uint128_t fio_math_addc128(const __uint128_t a,
                                      const __uint128_t b,
                                      bool carry_in,
                                      bool *carry_out) {
  __uint128_t r = a + b + carry_in;
  *carry_out = (r < a) | ((r == a) & carry_in);
  return r;
}
FIO_MIFN bool fio_math_add2(__uint128_t *dest,
                            const __uint128_t *a,
                            const __uint128_t *b,
                            const size_t len) {
  bool c = 0;
  for (size_t i = 0; i < len; ++i)
    dest[i] = fio_math_addc128(a[i], b[i], c, &c);
  return c;
}
#endif

/** Subtract with borrow. */
FIO_MIFN uint64_t fio_math_subc64(uint64_t a,
                                  uint64_t b,
                                  uint64_t borrow_in,
                                  uint64_t *borrow_out) {
  FIO_ASSERT_DEBUG(borrow_out, "fio_math_subc64 requires a carry pointer");
#if __has_builtin(__builtin_subcll) && UINT64_MAX == LLONG_MAX
  uint64_t u =
      __builtin_subcll(a, b, borrow_in, (unsigned long long *)borrow_out);
#elif defined(__SIZEOF_INT128__)
  __uint128_t u = (__uint128_t)a - b - borrow_in;
  if (borrow_out)
    *borrow_out = (uint64_t)(u >> 127U);
#else
  uint64_t u = a - b;
  a = u > a;
  b = u < borrow_in;
  u -= borrow_in;
  *borrow_out = a + b;
#endif
  return (uint64_t)u;
}

/** Multi-precision SUB for `len` 64 bit words a + b. Returns the borrow. */
FIO_MIFN uint64_t fio_math_sub(uint64_t *dest,
                               const uint64_t *a,
                               const uint64_t *b,
                               const size_t len) {
  uint64_t c = 0;
  for (size_t i = 0; i < len; ++i)
    dest[i] = fio_math_subc64(a[i], b[i], c, &c);
  return c;
}

/** Multiply with carry out. */
FIO_MIFN uint64_t fio_math_mulc64(uint64_t a, uint64_t b, uint64_t *carry_out) {
  FIO_ASSERT_DEBUG(carry_out, "fio_math_mulc64 requires a carry pointer");
#if defined(__SIZEOF_INT128__)
  __uint128_t r = (__uint128_t)a * b;
  *carry_out = (uint64_t)(r >> 64U);
#else /* long multiplication using 32 bits results in up to 64 bit result */
  uint64_t r, midc = 0, lowc = 0;
  const uint64_t al = a & 0xFFFFFFFF;
  const uint64_t ah = a >> 32;
  const uint64_t bl = b & 0xFFFFFFFF;
  const uint64_t bh = b >> 32;
  const uint64_t lo = al * bl;
  const uint64_t hi = ah * bh;
  const uint64_t mid = fio_math_addc64(al * bh, ah * bl, 0, &midc);
  r = fio_math_addc64(lo, (mid << 32), 0, &lowc);
  *carry_out = hi + (mid >> 32) + (midc << 32) + lowc;
#endif
  return (uint64_t)r;
}

/**
 * Multi-precision long multiplication for `len` 64 bit words.
 *
 * `dest` must be `len * 2` long to hold the result.
 *
 * `a` and `b` must be of equal `len`.
 *
 * This uses long multiplication with loop unrolling for better performance.
 */
FIO_IFUNC void fio___math_mul_long(uint64_t *restrict target,
                                   const uint64_t *a,
                                   const uint64_t *b,
                                   const size_t len) {
  /* Zero out result */
  for (size_t i = 0; i < len * 2; ++i)
    target[i] = 0;

  for (size_t i = 0; i < len; ++i) {
#ifdef __SIZEOF_INT128__
    __uint128_t carry = 0;
    size_t j = 0;

    /* Unroll inner loop by 4 for better performance */
    for (; j + 3 < len; j += 4) {
      size_t k = i + j;

      /* Iteration 0 */
      __uint128_t prod0 = (__uint128_t)a[i] * b[j];
      __uint128_t sum0 = (__uint128_t)target[k] + (uint64_t)prod0 + carry;
      target[k] = (uint64_t)sum0;
      carry = (prod0 >> 64) + (sum0 >> 64);

      /* Iteration 1 */
      __uint128_t prod1 = (__uint128_t)a[i] * b[j + 1];
      __uint128_t sum1 = (__uint128_t)target[k + 1] + (uint64_t)prod1 + carry;
      target[k + 1] = (uint64_t)sum1;
      carry = (prod1 >> 64) + (sum1 >> 64);

      /* Iteration 2 */
      __uint128_t prod2 = (__uint128_t)a[i] * b[j + 2];
      __uint128_t sum2 = (__uint128_t)target[k + 2] + (uint64_t)prod2 + carry;
      target[k + 2] = (uint64_t)sum2;
      carry = (prod2 >> 64) + (sum2 >> 64);

      /* Iteration 3 */
      __uint128_t prod3 = (__uint128_t)a[i] * b[j + 3];
      __uint128_t sum3 = (__uint128_t)target[k + 3] + (uint64_t)prod3 + carry;
      target[k + 3] = (uint64_t)sum3;
      carry = (prod3 >> 64) + (sum3 >> 64);
    }

    /* Handle remainder */
    for (; j < len; j++) {
      size_t k = i + j;
      __uint128_t product = (__uint128_t)a[i] * b[j];
      __uint128_t sum = (__uint128_t)target[k] + (uint64_t)product + carry;
      target[k] = (uint64_t)sum;
      carry = (product >> 64) + (sum >> 64);
    }

    target[i + len] = (uint64_t)carry;
#else
    /* Optimized non-__uint128_t path with loop unrolling */
    uint64_t ch = 0, cl = 0;
    size_t j = 0;

    /* Unroll inner loop by 4 */
    for (; j + 3 < len; j += 4) {
      uint64_t hi0, lo0, hi1, lo1, hi2, lo2, hi3, lo3;
      size_t k = i + j;

      /* Iteration 0 */
      lo0 = fio_math_mulc64(a[i], b[j], &hi0);
      target[k] = fio_math_addc64(target[k], lo0, cl, &cl);
      target[k + 1] = fio_math_addc64(target[k + 1], hi0, ch, &ch);

      /* Iteration 1 */
      lo1 = fio_math_mulc64(a[i], b[j + 1], &hi1);
      target[k + 1] = fio_math_addc64(target[k + 1], lo1, cl, &cl);
      target[k + 2] = fio_math_addc64(target[k + 2], hi1, ch, &ch);

      /* Iteration 2 */
      lo2 = fio_math_mulc64(a[i], b[j + 2], &hi2);
      target[k + 2] = fio_math_addc64(target[k + 2], lo2, cl, &cl);
      target[k + 3] = fio_math_addc64(target[k + 3], hi2, ch, &ch);

      /* Iteration 3 */
      lo3 = fio_math_mulc64(a[i], b[j + 3], &hi3);
      target[k + 3] = fio_math_addc64(target[k + 3], lo3, cl, &cl);
      target[k + 4] = fio_math_addc64(target[k + 4], hi3, ch, &ch);
    }

    /* Handle remainder */
    for (; j < len; ++j) {
      uint64_t hi, lo;
      lo = fio_math_mulc64(a[i], b[j], &hi);
      target[i + j] = fio_math_addc64(target[i + j], lo, cl, &cl);
      target[i + j + 1] = fio_math_addc64(target[i + j + 1], hi, ch, &ch);
    }
    target[i + len] += cl;
#endif
  }
}

/**
 * Optimized 256-bit (4 word) multiplication.
 * Fully unrolled for maximum performance in ECC-256 and SHA-256 operations.
 */
FIO_IFUNC void fio___math_mul_256(uint64_t *restrict dest,
                                  const uint64_t *a,
                                  const uint64_t *b) {
#ifdef __SIZEOF_INT128__
  /* Use __uint128_t for efficient 64x64->128 multiply */
  __uint128_t t0, t1, t2, t3, t4;

  /* Zero out destination - we'll accumulate into it */
  dest[0] = dest[1] = dest[2] = dest[3] = 0;
  dest[4] = dest[5] = dest[6] = dest[7] = 0;

  /* Row 0: a[0] * b[0..3] */
  t0 = (__uint128_t)a[0] * b[0];
  dest[0] = (uint64_t)t0;
  t1 = t0 >> 64;

  t2 = (__uint128_t)a[0] * b[1];
  t1 += t2;
  dest[1] = (uint64_t)t1;
  t1 >>= 64;

  t3 = (__uint128_t)a[0] * b[2];
  t1 += t3;
  dest[2] = (uint64_t)t1;
  t1 >>= 64;

  t4 = (__uint128_t)a[0] * b[3];
  t1 += t4;
  dest[3] = (uint64_t)t1;
  dest[4] = (uint64_t)(t1 >> 64);

  /* Row 1: a[1] * b[0..3] */
  t0 = (__uint128_t)a[1] * b[0];
  t1 = (__uint128_t)dest[1] + (uint64_t)t0;
  dest[1] = (uint64_t)t1;
  t1 = (t1 >> 64) + (t0 >> 64);

  t2 = (__uint128_t)a[1] * b[1];
  t1 += (__uint128_t)dest[2] + (uint64_t)t2;
  dest[2] = (uint64_t)t1;
  t1 = (t1 >> 64) + (t2 >> 64);

  t3 = (__uint128_t)a[1] * b[2];
  t1 += (__uint128_t)dest[3] + (uint64_t)t3;
  dest[3] = (uint64_t)t1;
  t1 = (t1 >> 64) + (t3 >> 64);

  t4 = (__uint128_t)a[1] * b[3];
  t1 += (__uint128_t)dest[4] + (uint64_t)t4;
  dest[4] = (uint64_t)t1;
  dest[5] = (uint64_t)((t1 >> 64) + (t4 >> 64));

  /* Row 2: a[2] * b[0..3] */
  t0 = (__uint128_t)a[2] * b[0];
  t1 = (__uint128_t)dest[2] + (uint64_t)t0;
  dest[2] = (uint64_t)t1;
  t1 = (t1 >> 64) + (t0 >> 64);

  t2 = (__uint128_t)a[2] * b[1];
  t1 += (__uint128_t)dest[3] + (uint64_t)t2;
  dest[3] = (uint64_t)t1;
  t1 = (t1 >> 64) + (t2 >> 64);

  t3 = (__uint128_t)a[2] * b[2];
  t1 += (__uint128_t)dest[4] + (uint64_t)t3;
  dest[4] = (uint64_t)t1;
  t1 = (t1 >> 64) + (t3 >> 64);

  t4 = (__uint128_t)a[2] * b[3];
  t1 += (__uint128_t)dest[5] + (uint64_t)t4;
  dest[5] = (uint64_t)t1;
  dest[6] = (uint64_t)((t1 >> 64) + (t4 >> 64));

  /* Row 3: a[3] * b[0..3] */
  t0 = (__uint128_t)a[3] * b[0];
  t1 = (__uint128_t)dest[3] + (uint64_t)t0;
  dest[3] = (uint64_t)t1;
  t1 = (t1 >> 64) + (t0 >> 64);

  t2 = (__uint128_t)a[3] * b[1];
  t1 += (__uint128_t)dest[4] + (uint64_t)t2;
  dest[4] = (uint64_t)t1;
  t1 = (t1 >> 64) + (t2 >> 64);

  t3 = (__uint128_t)a[3] * b[2];
  t1 += (__uint128_t)dest[5] + (uint64_t)t3;
  dest[5] = (uint64_t)t1;
  t1 = (t1 >> 64) + (t3 >> 64);

  t4 = (__uint128_t)a[3] * b[3];
  t1 += (__uint128_t)dest[6] + (uint64_t)t4;
  dest[6] = (uint64_t)t1;
  dest[7] = (uint64_t)((t1 >> 64) + (t4 >> 64));
#else
  /* Fallback for platforms without __uint128_t (MSVC) */
  fio___math_mul_long(dest, a, b, 4);
#endif
}

/**
 * Optimized 512-bit (8 word) multiplication.
 * Semi-unrolled for hash operations and intermediate crypto.
 */
FIO_IFUNC void fio___math_mul_512(uint64_t *restrict dest,
                                  const uint64_t *a,
                                  const uint64_t *b) {
#ifdef __SIZEOF_INT128__
  /* Use __uint128_t for efficient 64x64->128 multiply */
  __uint128_t t0, t1;

  /* Zero out destination */
  for (size_t i = 0; i < 16; ++i)
    dest[i] = 0;

  /* Outer loop - process each word of 'a' */
  for (size_t i = 0; i < 8; ++i) {
    t1 = 0;
    size_t j = 0;

    /* Inner loop unrolled by 4 */
    for (; j + 3 < 8; j += 4) {
      size_t k = i + j;

      /* Iteration 0 */
      t0 = (__uint128_t)a[i] * b[j];
      t1 += (__uint128_t)dest[k] + (uint64_t)t0;
      dest[k] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);

      /* Iteration 1 */
      t0 = (__uint128_t)a[i] * b[j + 1];
      t1 += (__uint128_t)dest[k + 1] + (uint64_t)t0;
      dest[k + 1] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);

      /* Iteration 2 */
      t0 = (__uint128_t)a[i] * b[j + 2];
      t1 += (__uint128_t)dest[k + 2] + (uint64_t)t0;
      dest[k + 2] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);

      /* Iteration 3 */
      t0 = (__uint128_t)a[i] * b[j + 3];
      t1 += (__uint128_t)dest[k + 3] + (uint64_t)t0;
      dest[k + 3] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);
    }

    /* Handle remainder */
    for (; j < 8; ++j) {
      size_t k = i + j;
      t0 = (__uint128_t)a[i] * b[j];
      t1 += (__uint128_t)dest[k] + (uint64_t)t0;
      dest[k] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);
    }

    dest[i + 8] = (uint64_t)t1;
  }
#else
  /* Fallback for platforms without __uint128_t (MSVC) */
  fio___math_mul_long(dest, a, b, 8);
#endif
}

/**
 * Optimized 1024-bit (16 word) multiplication.
 * Semi-unrolled for RSA-1024 and intermediate crypto operations.
 */
FIO_IFUNC void fio___math_mul_1024(uint64_t *restrict dest,
                                   const uint64_t *a,
                                   const uint64_t *b) {
#ifdef __SIZEOF_INT128__
  /* Use __uint128_t for efficient 64x64->128 multiply */
  __uint128_t t0, t1;

  /* Zero out destination */
  for (size_t i = 0; i < 32; ++i)
    dest[i] = 0;

  /* Outer loop - process each word of 'a' */
  for (size_t i = 0; i < 16; ++i) {
    t1 = 0;
    size_t j = 0;

    /* Inner loop unrolled by 4 */
    for (; j + 3 < 16; j += 4) {
      size_t k = i + j;

      /* Iteration 0 */
      t0 = (__uint128_t)a[i] * b[j];
      t1 += (__uint128_t)dest[k] + (uint64_t)t0;
      dest[k] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);

      /* Iteration 1 */
      t0 = (__uint128_t)a[i] * b[j + 1];
      t1 += (__uint128_t)dest[k + 1] + (uint64_t)t0;
      dest[k + 1] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);

      /* Iteration 2 */
      t0 = (__uint128_t)a[i] * b[j + 2];
      t1 += (__uint128_t)dest[k + 2] + (uint64_t)t0;
      dest[k + 2] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);

      /* Iteration 3 */
      t0 = (__uint128_t)a[i] * b[j + 3];
      t1 += (__uint128_t)dest[k + 3] + (uint64_t)t0;
      dest[k + 3] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);
    }

    /* Handle remainder */
    for (; j < 16; ++j) {
      size_t k = i + j;
      t0 = (__uint128_t)a[i] * b[j];
      t1 += (__uint128_t)dest[k] + (uint64_t)t0;
      dest[k] = (uint64_t)t1;
      t1 = (t1 >> 64) + (t0 >> 64);
    }

    dest[i + 16] = (uint64_t)t1;
  }
#else
  /* Fallback for platforms without __uint128_t (MSVC) */
  fio___math_mul_long(dest, a, b, 16);
#endif
}

/**
 * Karatsuba multiplication threshold (in 64-bit words).
 *
 * Below this threshold, schoolbook multiplication is faster.
 * Empirical testing (tests/performance-core.c) shows:
 *
 *   Size          Schoolbook      Karatsuba       Winner
 *   256-bit  (4w)  227 M ops/sec  22 M ops/sec   Schoolbook 10x faster
 *   512-bit  (8w)  41 M ops/sec   13 M ops/sec   Schoolbook 3x faster
 *   1024-bit (16w) 9 M ops/sec    5 M ops/sec    Schoolbook 2x faster
 *   2048-bit (32w) 1.18 M ops/sec 1.34 M ops/sec Karatsuba 1.13x faster
 *
 * Crossover point: ~32 words (2048 bits) on modern CPUs.
 * Conservative threshold accounts for platform variations (28-36 words).
 *
 * Override with: -DFIO___MATH_KARATSUBA_THRESHOLD=N for platform tuning.
 */
#ifndef FIO___MATH_KARATSUBA_THRESHOLD
#define FIO___MATH_KARATSUBA_THRESHOLD 32
#endif

/**
 * Karatsuba multiplication for large multi-precision numbers.
 *
 * For a = a_hi * B + a_lo and b = b_hi * B + b_lo (where B = 2^(half*64)):
 *   z0 = a_lo * b_lo
 *   z2 = a_hi * b_hi
 *   z1 = (a_lo + a_hi) * (b_lo + b_hi) - z0 - z2
 *   result = z2 * B + z1 * B + z0
 *
 * Uses 3 multiplications instead of 4, giving O(n^1.585) complexity.
 *
 * `dest` must be `len * 2` long. `a` and `b` must be `len` words each.
 * `len` must be even.
 */
FIO_SFUNC void fio___math_mul_karatsuba(uint64_t *restrict dest,
                                        const uint64_t *a,
                                        const uint64_t *b,
                                        const size_t len);

/**
 * Multi-precision MUL for `len` 64 bit words.
 *
 * `dest` must be `len * 2` long to hold the result.
 *
 * `a` and `b` must be of equal `len`.
 */
FIO_IFUNC void fio_math_mul(uint64_t *restrict dest,
                            const uint64_t *a,
                            const uint64_t *b,
                            const size_t len) {
  if (!len) {
    dest[0] = 0;
    return;
  }
  if (len == 1) {
    dest[0] = fio_math_mulc64(a[0], b[0], dest + 1);
    return;
  }

  /* Fast paths for common crypto sizes - fully optimized */
  if (len == 4) {
    fio___math_mul_256(dest, a, b);
    return;
  }
  if (len == 8) {
    fio___math_mul_512(dest, a, b);
    return;
  }
  /* Skip 1024-bit fast path - general optimized path is faster
  if (len == 16) {
    fio___math_mul_1024(dest, a, b);
    return;
  }
  */

  /* Large numbers: use Karatsuba if above threshold */
  if (len >= FIO___MATH_KARATSUBA_THRESHOLD && !(len & 1)) {
    fio___math_mul_karatsuba(dest, a, b, len);
    return;
  }

  /* Default: optimized schoolbook multiplication */
  fio___math_mul_long(dest, a, b, len);
}
/* Helper: non-recursive multiplication dispatcher for Karatsuba sub-tasks */
FIO_IFUNC void fio___math_mul_norecurse(uint64_t *restrict dest,
                                        const uint64_t *a,
                                        const uint64_t *b,
                                        const size_t len) {
  if (!len) {
    dest[0] = 0;
    return;
  }
  if (len == 1) {
    dest[0] = fio_math_mulc64(a[0], b[0], dest + 1);
    return;
  }

  /* Fast paths for common crypto sizes */
  if (len == 4) {
    fio___math_mul_256(dest, a, b);
    return;
  }
  if (len == 8) {
    fio___math_mul_512(dest, a, b);
    return;
  }
  /* Skip 1024-bit fast path - general optimized path is faster
  if (len == 16) {
    fio___math_mul_1024(dest, a, b);
    return;
  }
  */

  /* Always use optimized long multiplication - no recursion */
  fio___math_mul_long(dest, a, b, len);
}

/* Karatsuba implementation - non-recursive iterative version */
FIO_SFUNC void fio___math_mul_karatsuba(uint64_t *restrict dest,
                                        const uint64_t *a,
                                        const uint64_t *b,
                                        const size_t len) {
  const size_t half = len >> 1;

  /* Pointers to halves (little-endian: low words first) */
  const uint64_t *a_lo = a;
  const uint64_t *a_hi = a + half;
  const uint64_t *b_lo = b;
  const uint64_t *b_hi = b + half;

/* Stack allocation for small sizes, otherwise use heap */
#if !defined(_MSC_VER) && (!defined(__cplusplus) || __cplusplus > 201402L)
  uint64_t z0_buf[len];         /* a_lo * b_lo result (len words) */
  uint64_t z2_buf[len];         /* a_hi * b_hi result (len words) */
  uint64_t z1_buf[len + 2];     /* (a_lo+a_hi) * (b_lo+b_hi) result */
  uint64_t sum_a_buf[half + 1]; /* a_lo + a_hi with carry */
  uint64_t sum_b_buf[half + 1]; /* b_lo + b_hi with carry */
  uint64_t *z0 = z0_buf;
  uint64_t *z2 = z2_buf;
  uint64_t *z1 = z1_buf;
  uint64_t *sum_a = sum_a_buf;
  uint64_t *sum_b = sum_b_buf;
#else
  /* MSVC or old C++ - use fixed size with assertion */
  uint64_t z0_buf[256];
  uint64_t z2_buf[256];
  uint64_t z1_buf[258];
  uint64_t sum_a_buf[129];
  uint64_t sum_b_buf[129];
  uint64_t *z0 = z0_buf;
  uint64_t *z2 = z2_buf;
  uint64_t *z1 = z1_buf;
  uint64_t *sum_a = sum_a_buf;
  uint64_t *sum_b = sum_b_buf;
  FIO_ASSERT(len <= 256,
             "Karatsuba multiplication overflow at 16384 bit numbers");
#endif

  /* Initialize all buffers to zero */
  for (size_t i = 0; i < len; ++i)
    z1[i] = z2[i] = z0[i] = 0;
  z1[len] = z1[len + 1] = 0;
  for (size_t i = 0; i < (half + 1); ++i)
    sum_a[i] = sum_b[i] = 0;

  /* z0 = a_lo * b_lo - non-recursive */
  fio___math_mul_norecurse(z0, a_lo, b_lo, half);

  /* z2 = a_hi * b_hi - non-recursive */
  fio___math_mul_norecurse(z2, a_hi, b_hi, half);

  /* sum_a = a_lo + a_hi (with potential carry into extra word) */
  FIO_FOR_UNROLL(half, sizeof(uint64_t), i, sum_a[i] = a_lo[i]);
  sum_a[half] = (uint64_t)fio_math_add(sum_a, sum_a, a_hi, half);

  /* sum_b = b_lo + b_hi (with potential carry into extra word) */
  FIO_FOR_UNROLL(half, sizeof(uint64_t), i, sum_b[i] = b_lo[i]);
  sum_b[half] = (uint64_t)fio_math_add(sum_b, sum_b, b_hi, half);

  /* z1 = sum_a * sum_b - non-recursive
   * Result is (half+1) * 2 = len+2 words */
  fio___math_mul_norecurse(z1, sum_a, sum_b, half + 1);

  /* z1 = z1 - z0 - z2
   * Note: z1 is len+2 words, z0 and z2 are len words */
  {
    uint64_t borrow = fio_math_sub(z1, z1, z0, len);
    /* Propagate borrow to upper words */
    for (size_t i = len; i < len + 2 && borrow; ++i) {
      uint64_t tmp = z1[i];
      z1[i] = tmp - borrow;
      borrow = (z1[i] > tmp);
    }
  }
  {
    uint64_t borrow = fio_math_sub(z1, z1, z2, len);
    for (size_t i = len; i < len + 2 && borrow; ++i) {
      uint64_t tmp = z1[i];
      z1[i] = tmp - borrow;
      borrow = (z1[i] > tmp);
    }
  }

  /* Combine: dest = z2 * B + z1 * B + z0
   * dest layout (2*len words):
   *   [0..len-1]     : low part (z0 contributes here, z1*B overlaps)
   *   [len..2*len-1] : high part (z2 contributes here, z1*B overlaps)
   */
  FIO_FOR_UNROLL(len,
                 sizeof(uint64_t),
                 i,
                 ((dest[i] = z0[i]), (dest[len + i] = 0)));

  /* Add z1 at position half (z1 * B) */
  {
    uint64_t carry = 0;
    for (size_t i = 0; i < len + 2 && (half + i) < 2 * len; ++i) {
      dest[half + i] = fio_math_addc64(dest[half + i], z1[i], carry, &carry);
    }
  }

  /* Add z2 at position len (z2 * B) */
  {
    uint64_t carry = 0;
    for (size_t i = 0; i < len; ++i) {
      dest[len + i] = fio_math_addc64(dest[len + i], z2[i], carry, &carry);
    }
  }
}

/* *****************************************************************************
Vector Types (SIMD / Math)
***************************************************************************** */
#if FIO___HAS_ARM_INTRIN || __has_attribute(vector_size)
#define FIO_HAS_UX 1
#endif

#if FIO___HAS_ARM_INTRIN
/** defines a vector group for a fio_uXXX union */
#define FIO___UXXX_XGRP_DEF(bits)                                              \
  uint64x2_t x64[bits / 128];                                                  \
  uint32x4_t x32[bits / 128];                                                  \
  uint16x8_t x16[bits / 128];                                                  \
  uint8x16_t x8[bits / 128]
#elif __has_attribute(vector_size)
/** defines a vector group for a fio_uXXX union */
#define FIO___UXXX_XGRP_DEF(bits)                                              \
  uint64_t __attribute__((vector_size((bits / 8)))) x64[1];                    \
  uint32_t __attribute__((vector_size((bits / 8)))) x32[1];                    \
  uint16_t __attribute__((vector_size((bits / 8)))) x16[1];                    \
  uint8_t __attribute__((vector_size((bits / 8)))) x8[1]
#else
/** defines a (fake) vector group for a fio_uXXX union */
#define FIO___UXXX_XGRP_DEF(bits)                                              \
  uint64_t x64[(bits / 64)];                                                   \
  uint32_t x32[(bits / 32)];                                                   \
  uint16_t x16[(bits / 16)];                                                   \
  uint8_t x8[(bits / 8)]
#endif

/** defines a type array group for a fio_uXXX union */
#define FIO___UXXX_UGRP_DEF(bits)                                              \
  /** unsigned native word size array, length is system dependent */           \
  size_t uz[(bits / 8) / sizeof(size_t)];                                      \
  /** known bit word arrays */                                                 \
  uint64_t u64[(bits / 64)];                                                   \
  uint32_t u32[(bits / 32)];                                                   \
  uint16_t u16[(bits / 16)];                                                   \
  uint8_t u8[(bits / 8)];                                                      \
  /** signed variants */                                                       \
  ssize_t iz[(bits / 8) / sizeof(size_t)];                                     \
  int64_t i64[(bits / 64)];                                                    \
  int32_t i32[(bits / 32)];                                                    \
  int16_t i16[(bits / 16)];                                                    \
  int8_t i8[(bits / 8)];                                                       \
  /** float variants */                                                        \
  float f[(bits / 8) / sizeof(float)];                                         \
  double d[(bits / 8) / sizeof(double)];                                       \
  long double ld[(bits / 8) / sizeof(long double)];                            \
  /** vector variants (if supported) */                                        \
  FIO___UXXX_XGRP_DEF(bits)

/** An unsigned 128bit union type. */
typedef union fio_u128 {
  FIO___UXXX_UGRP_DEF(128);
#if defined(__SIZEOF_INT128__)
  __uint128_t alignment_for_u128_[1];
#endif
} fio_u128 FIO_ALIGN(16);

/** An unsigned 256bit union type. */
typedef union fio_u256 {
  fio_u128 u128[2];
  FIO___UXXX_UGRP_DEF(256);
#if defined(__SIZEOF_INT256__)
  __uint256_t alignment_for_u256_[1];
#endif
} fio_u256 FIO_ALIGN(16);

/** An unsigned 512bit union type. */
typedef union fio_u512 {
  fio_u128 u128[4];
  fio_u256 u256[2];
  FIO___UXXX_UGRP_DEF(512);
} fio_u512 FIO_ALIGN(16);

/** An unsigned 1024bit union type. */
typedef union fio_u1024 {
  fio_u128 u128[8];
  fio_u256 u256[4];
  fio_u512 u512[2];
  FIO___UXXX_UGRP_DEF(1024);
} fio_u1024 FIO_ALIGN(16);

/** An unsigned 2048bit union type. */
typedef union fio_u2048 {
  fio_u128 u128[16];
  fio_u256 u256[8];
  fio_u512 u512[4];
  fio_u1024 u1024[2];
  FIO___UXXX_UGRP_DEF(2048);
} fio_u2048 FIO_ALIGN(16);

/** An unsigned 4096bit union type. */
typedef union fio_u4096 {
  fio_u128 u128[32];
  fio_u256 u256[16];
  fio_u512 u512[8];
  fio_u1024 u1024[4];
  fio_u2048 u2048[2];
  FIO___UXXX_UGRP_DEF(4096);
} fio_u4096 FIO_ALIGN(16);

#undef FIO___UXXX_XGRP_DEF
#undef FIO___UXXX_UGRP_DEF

FIO_ASSERT_STATIC(sizeof(fio_u128) == 16, "Math type size error!");
FIO_ASSERT_STATIC(sizeof(fio_u4096) == 512, "Math type size error!");

#define fio_u128_init8(...)  ((fio_u128){.u8 = {__VA_ARGS__}})
#define fio_u128_init16(...) ((fio_u128){.u16 = {__VA_ARGS__}})
#define fio_u128_init32(...) ((fio_u128){.u32 = {__VA_ARGS__}})
#define fio_u128_init64(...) ((fio_u128){.u64 = {__VA_ARGS__}})
#define fio_u256_init8(...)  ((fio_u256){.u8 = {__VA_ARGS__}})
#define fio_u256_init16(...) ((fio_u256){.u16 = {__VA_ARGS__}})
#define fio_u256_init32(...) ((fio_u256){.u32 = {__VA_ARGS__}})
#define fio_u256_init64(...) ((fio_u256){.u64 = {__VA_ARGS__}})
#define fio_u512_init8(...)  ((fio_u512){.u8 = {__VA_ARGS__}})
#define fio_u512_init16(...) ((fio_u512){.u16 = {__VA_ARGS__}})
#define fio_u512_init32(...) ((fio_u512){.u32 = {__VA_ARGS__}})
#define fio_u512_init64(...) ((fio_u512){.u64 = {__VA_ARGS__}})

#define fio_u1024_init8(...)  ((fio_u1024){.u8 = {__VA_ARGS__}})
#define fio_u1024_init16(...) ((fio_u1024){.u16 = {__VA_ARGS__}})
#define fio_u1024_init32(...) ((fio_u1024){.u32 = {__VA_ARGS__}})
#define fio_u1024_init64(...) ((fio_u1024){.u64 = {__VA_ARGS__}})
#define fio_u2048_init8(...)  ((fio_u2048){.u8 = {__VA_ARGS__}})
#define fio_u2048_init16(...) ((fio_u2048){.u16 = {__VA_ARGS__}})
#define fio_u2048_init32(...) ((fio_u2048){.u32 = {__VA_ARGS__}})
#define fio_u2048_init64(...) ((fio_u2048){.u64 = {__VA_ARGS__}})
#define fio_u4096_init8(...)  ((fio_u4096){.u8 = {__VA_ARGS__}})
#define fio_u4096_init16(...) ((fio_u4096){.u16 = {__VA_ARGS__}})
#define fio_u4096_init32(...) ((fio_u4096){.u32 = {__VA_ARGS__}})
#define fio_u4096_init64(...) ((fio_u4096){.u64 = {__VA_ARGS__}})

/* *****************************************************************************
Vector Helpers - memory load operations (implementation starts here)
***************************************************************************** */

#define FIO_MATH_TYPE_LOADER(bits, bytes)                                      \
  /** Loads from memory using local-endian. */                                 \
  FIO_MIFN fio_u##bits fio_u##bits##_load(const void *buf) {                   \
    fio_u##bits r;                                                             \
    fio_memcpy##bytes(&r, buf);                                                \
    return r;                                                                  \
  }                                                                            \
  /** Stores to memory using local-endian. */                                  \
  FIO_IFUNC void fio_u##bits##_store(void *buf, const fio_u##bits a) {         \
    fio_memcpy##bytes(buf, &a);                                                \
  }                                                                            \
  FIO_VECTOR_LOADER_ENDIAN_FUNC(bits, 16)                                      \
  FIO_VECTOR_LOADER_ENDIAN_FUNC(bits, 32)                                      \
  FIO_VECTOR_LOADER_ENDIAN_FUNC(bits, 64)

#define FIO_VECTOR_LOADER_ENDIAN_FUNC(total_bits, bits)                        \
  /** Loads vector from memory, reading from little-endian.  */                \
  FIO_MIFN fio_u##total_bits fio_u##total_bits##_load_le##bits(                \
      const void *buf) {                                                       \
    fio_u##total_bits r = fio_u##total_bits##_load(buf);                       \
    for (size_t i = 0; i < (total_bits / bits); ++i) {                         \
      r.u##bits[i] = fio_ltole##bits(r.u##bits[i]);                            \
    }                                                                          \
    return r;                                                                  \
  }                                                                            \
  /** Loads vector from memory, reading from big-endian.  */                   \
  FIO_MIFN fio_u##total_bits fio_u##total_bits##_load_be##bits(                \
      const void *buf) {                                                       \
    fio_u##total_bits r = fio_u##total_bits##_load(buf);                       \
    for (size_t i = 0; i < (total_bits / bits); ++i) {                         \
      r.u##bits[i] = fio_lton##bits(r.u##bits[i]);                             \
    }                                                                          \
    return r;                                                                  \
  }                                                                            \
  FIO_MIFN fio_u##total_bits fio_u##total_bits##_bswap##bits(                  \
      fio_u##total_bits a) {                                                   \
    fio_u##total_bits r = {0};                                                 \
    for (size_t i = 0; i < (total_bits / bits); ++i)                           \
      r.u##bits[i] = fio_bswap##bits(a.u##bits[i]);                            \
    return r;                                                                  \
  }

FIO_MATH_TYPE_LOADER(128, 16)
FIO_MATH_TYPE_LOADER(256, 32)
FIO_MATH_TYPE_LOADER(512, 64)
FIO_MATH_TYPE_LOADER(1024, 128)
FIO_MATH_TYPE_LOADER(2048, 256)
FIO_MATH_TYPE_LOADER(4096, 512)

#undef FIO_MATH_TYPE_LOADER
#undef FIO_VECTOR_LOADER_ENDIAN_FUNC
#undef FIO_VECTOR_LOADER_ENDIAN

/* *****************************************************************************
Vector Helpers - Vector Math Operations

The `bits` parameter selects which union member to access (.x64, .x32, etc.).
The loop count is computed dynamically via sizeof, yielding:
- GCC/Clang: 1 iteration (full-width vector in .x64[0])
- ARM NEON: bits/128 iterations (128-bit vectors in .x64[])
- Scalar: bits/64 iterations (64-bit scalars in .u64[])
***************************************************************************** */

#if FIO_HAS_UX && !defined(DEBUG)

/** Performs `a op b` (+,-, *, etc') using vector member .x##bits[]. */
#define FIO_MATH_UXXX_OP(t, a, b, bits, op)                                    \
  do {                                                                         \
    for (size_t i__ = 0; i__ < (sizeof((t).x##bits) / sizeof((t).x##bits[0])); \
         ++i__)                                                                \
      (t).x##bits[i__] = (a).x##bits[i__] op(b).x##bits[i__];                  \
  } while (0)
/** Performs `a op b` (+,-, *, etc'), where `b` is a constant. */
#define FIO_MATH_UXXX_COP(t, a, b, bits, op)                                   \
  do {                                                                         \
    for (size_t i__ = 0; i__ < (sizeof((t).x##bits) / sizeof((t).x##bits[0])); \
         ++i__)                                                                \
      (t).x##bits[i__] = (a).x##bits[i__] op(b);                               \
  } while (0)
/** Performs `t = op (a)`. */
#define FIO_MATH_UXXX_SOP(t, a, bits, op)                                      \
  do {                                                                         \
    for (size_t i__ = 0; i__ < (sizeof((t).x##bits) / sizeof((t).x##bits[0])); \
         ++i__)                                                                \
      (t).x##bits[i__] = op(a).x##bits[i__];                                   \
  } while (0)

#else /* FIO_HAS_UX */

#define FIO_MATH_UXXX_OP(t, a, b, bits, op)                                    \
  do {                                                                         \
    for (size_t i__ = 0; i__ < (sizeof((t).u##bits) / sizeof((t).u##bits[0])); \
         ++i__)                                                                \
      (t).u##bits[i__] = (a).u##bits[i__] op(b).u##bits[i__];                  \
  } while (0)
#define FIO_MATH_UXXX_COP(t, a, b, bits, op)                                   \
  do {                                                                         \
    for (size_t i__ = 0; i__ < (sizeof((t).u##bits) / sizeof((t).u##bits[0])); \
         ++i__)                                                                \
      (t).u##bits[i__] = (a).u##bits[i__] op(b);                               \
  } while (0)
#define FIO_MATH_UXXX_SOP(t, a, bits, op)                                      \
  do {                                                                         \
    for (size_t i__ = 0; i__ < (sizeof((t).u##bits) / sizeof((t).u##bits[0])); \
         ++i__)                                                                \
      (t).u##bits[i__] = op((a).u##bits[i__]);                                 \
  } while (0)
#endif /* FIO_HAS_UX */

/** Performs vector reduction for using `op` (+,-, *, etc'), storing to `t`. */
#define FIO_MATH_UXXX_REDUCE(t, a, bits, op)                                   \
  do {                                                                         \
    t = (a).u##bits[0];                                                        \
    for (size_t i__ = 1; i__ < (sizeof((a).u##bits) / sizeof((a).u##bits[0])); \
         ++i__)                                                                \
      (t) = (t)op(a).u##bits[i__];                                             \
  } while (0)

/** Performs vector shuffling (reordering) of `var`. */
#define FIO_MATH_UXXX_SUFFLE(var, bits, ...)                                   \
  do {                                                                         \
    uint##bits##_t t____[sizeof((var).u##bits) / sizeof((var).u##bits[0])];    \
    const uint8_t shuf____[sizeof((var).u##bits) / sizeof((var).u##bits[0])] = \
        {__VA_ARGS__};                                                         \
    for (size_t i___ = 0;                                                      \
         i___ < (sizeof((var).u##bits) / sizeof((var).u##bits[0]));            \
         ++i___)                                                               \
      t____[i___] = (var).u##bits[shuf____[i___]];                             \
    for (size_t i___ = 0;                                                      \
         i___ < (sizeof((var).u##bits) / sizeof((var).u##bits[0]));            \
         ++i___)                                                               \
      (var).u##bits[i___] = t____[i___];                                       \
  } while (0)

#define FIO___UXXX_DEF_OP(total_bits, bits, opnm, op)                          \
  FIO_IFUNC void fio_u##total_bits##_##opnm##bits(                             \
      fio_u##total_bits *target,                                               \
      const fio_u##total_bits *a,                                              \
      const fio_u##total_bits *b) {                                            \
    FIO_MATH_UXXX_OP(((target)[0]), ((a)[0]), ((b)[0]), bits, op);             \
  }                                                                            \
  FIO_IFUNC void fio_u##total_bits##_c##opnm##bits(fio_u##total_bits *target,  \
                                                   const fio_u##total_bits *a, \
                                                   uint##bits##_t b) {         \
    FIO_MATH_UXXX_COP(((target)[0]), ((a)[0]), (b), bits, op);                 \
  }                                                                            \
  FIO_MIFN uint##bits##_t fio_u##total_bits##_reduce_##opnm##bits(             \
      const fio_u##total_bits *a) {                                            \
    uint##bits##_t t;                                                          \
    FIO_MATH_UXXX_REDUCE(t, ((a)[0]), bits, op);                               \
    return t;                                                                  \
  }
#define FIO___UXXX_DEF_OP2(total_bits, bits, opnm, op)                         \
  FIO_IFUNC void fio_u##total_bits##_##opnm(fio_u##total_bits *target,         \
                                            const fio_u##total_bits *a,        \
                                            const fio_u##total_bits *b) {      \
    FIO_MATH_UXXX_OP(((target)[0]), ((a)[0]), ((b)[0]), bits, op);             \
  }

#define FIO___UXXX_DEF_OP4T_INNER(total_bits, opnm, op)                        \
  FIO___UXXX_DEF_OP(total_bits, 8, opnm, op)                                   \
  FIO___UXXX_DEF_OP(total_bits, 16, opnm, op)                                  \
  FIO___UXXX_DEF_OP(total_bits, 32, opnm, op)                                  \
  FIO___UXXX_DEF_OP(total_bits, 64, opnm, op)

#define FIO___UXXX_DEF_OP4T(total_bits)                                        \
  FIO___UXXX_DEF_OP4T_INNER(total_bits, add, +)                                \
  FIO___UXXX_DEF_OP4T_INNER(total_bits, sub, -)                                \
  FIO___UXXX_DEF_OP4T_INNER(total_bits, mul, *)                                \
  FIO___UXXX_DEF_OP4T_INNER(total_bits, and, &)                                \
  FIO___UXXX_DEF_OP4T_INNER(total_bits, or, |)                                 \
  FIO___UXXX_DEF_OP4T_INNER(total_bits, xor, ^)                                \
  FIO___UXXX_DEF_OP2(total_bits, 64, and, &)                                   \
  FIO___UXXX_DEF_OP2(total_bits, 64, or, |)                                    \
  FIO___UXXX_DEF_OP2(total_bits, 64, xor, ^)                                   \
  FIO_IFUNC bool fio_u##total_bits##_is_eq(const fio_u##total_bits *a,         \
                                           const fio_u##total_bits *b) {       \
    uint64_t red = 0;                                                          \
    fio_u##total_bits eq;                                                      \
    FIO_MATH_UXXX_OP(eq, a[0], b[0], 64, ^);                                   \
    FIO_MATH_UXXX_REDUCE(red, eq, 64, |);                                      \
    return !red;                                                               \
  }                                                                            \
  FIO_IFUNC void fio_u##total_bits##_inv(fio_u##total_bits *target,            \
                                         const fio_u##total_bits *a) {         \
    FIO_MATH_UXXX_SOP(((target)[0]), ((a)[0]), 64, ~);                         \
  }                                                                            \
  FIO_IFUNC void fio_u##total_bits##_ct_swap_if(                               \
      bool cond,                                                               \
      fio_u##total_bits *restrict a,                                           \
      fio_u##total_bits *restrict b) {                                         \
    fio_u##total_bits mask;                                                    \
    /* compiler, please vectorize / unify loops as well as possible */         \
    fio_u##total_bits##_xor(&mask, a, b);                                      \
    fio_u##total_bits##_cand64(&mask, &mask, (uint64_t)0ULL - cond);           \
    fio_u##total_bits##_xor(a, a, &mask);                                      \
    fio_u##total_bits##_xor(b, b, &mask);                                      \
  }

FIO___UXXX_DEF_OP4T(128)
FIO___UXXX_DEF_OP4T(256)
FIO___UXXX_DEF_OP4T(512)
FIO___UXXX_DEF_OP4T(1024)
FIO___UXXX_DEF_OP4T(2048)
FIO___UXXX_DEF_OP4T(4096)

#undef FIO___UXXX_DEF_OP4T
#undef FIO___UXXX_DEF_OP4T_INNER
#undef FIO___UXXX_DEF_OP
#undef FIO___UXXX_DEF_OP2

/* *****************************************************************************
SIMD-Optimized Vector Operations (XOR, AND, OR) - Value Semantics

These provide return-by-value vector operations that leverage SIMD when
available. The naming convention is fio_uXXX_<op>v (v = value semantics).

Uses the existing FIO_MATH_UXXX_OP macro which correctly accesses union members:
- .x64[], .x32[] etc. when FIO_HAS_UX is defined (vector types)
- .u64[], .u32[] etc. otherwise (scalar fallback)

IMPORTANT: The `64` parameter in FIO_MATH_UXXX_OP selects the union member
(.x64), NOT the element size. The loop count is computed dynamically:

  sizeof((t).x64) / sizeof((t).x64[0])

This yields different iteration counts based on the platform:

- GCC/Clang vector_size: x64[1] is a SINGLE full-width vector (128/256/512-bit)
  so the loop runs ONCE, operating on the entire vector in one instruction.

- ARM NEON: x64[bits/128] is an array of 128-bit vectors (uint64x2_t),
  so the loop runs bits/128 times (e.g., 2 for 256-bit, 4 for 512-bit).

- Scalar fallback: Uses .u64[bits/64] array, loop runs bits/64 times.

The compiler auto-vectorizes these operations when possible.
***************************************************************************** */

/** Macro to define value-returning binary vector operations for a given size */
#define FIO___UXXX_SIMD_BINOP_DEF(bits)                                        \
  /** XOR two values, returning result by value. */                            \
  FIO_MIFN fio_u##bits fio_u##bits##_xorv(fio_u##bits a, fio_u##bits b) {      \
    fio_u##bits r = {0};                                                       \
    FIO_MATH_UXXX_OP(r, a, b, 64, ^);                                          \
    return r;                                                                  \
  }                                                                            \
  /** AND two values, returning result by value. */                            \
  FIO_MIFN fio_u##bits fio_u##bits##_andv(fio_u##bits a, fio_u##bits b) {      \
    fio_u##bits r = {0};                                                       \
    FIO_MATH_UXXX_OP(r, a, b, 64, &);                                          \
    return r;                                                                  \
  }                                                                            \
  /** OR two values, returning result by value. */                             \
  FIO_MIFN fio_u##bits fio_u##bits##_orv(fio_u##bits a, fio_u##bits b) {       \
    fio_u##bits r = {0};                                                       \
    FIO_MATH_UXXX_OP(r, a, b, 64, |);                                          \
    return r;                                                                  \
  }                                                                            \
  /** ADD two values as 64-bit lanes, returning result by value. */            \
  FIO_MIFN fio_u##bits fio_u##bits##_addv64(fio_u##bits a, fio_u##bits b) {    \
    fio_u##bits r = {0};                                                       \
    FIO_MATH_UXXX_OP(r, a, b, 64, +);                                          \
    return r;                                                                  \
  }

FIO___UXXX_SIMD_BINOP_DEF(128)
FIO___UXXX_SIMD_BINOP_DEF(256)
FIO___UXXX_SIMD_BINOP_DEF(512)
FIO___UXXX_SIMD_BINOP_DEF(1024)
FIO___UXXX_SIMD_BINOP_DEF(2048)
FIO___UXXX_SIMD_BINOP_DEF(4096)

#undef FIO___UXXX_SIMD_BINOP_DEF

/* *****************************************************************************
Vector Helpers - Multi-Precision Math
***************************************************************************** */

#undef FIO___VMATH_DEF_LARGE_ADD_SUB
#define FIO___VMATH_DEF_LARGE_ADD_SUB(bits)                                    \
  /** Performs A+B, storing in `result`. Return the carry bit (1 or 0). */     \
  FIO_MIFN uint64_t fio_u##bits##_add(fio_u##bits *result,                     \
                                      const fio_u##bits *a,                    \
                                      const fio_u##bits *b) {                  \
    uint64_t carry = 0;                                                        \
    for (size_t i = 0; i < (bits / 64); ++i) {                                 \
      uint64_t sum = a->u64[i] + b->u64[i] + carry;                            \
      carry = (sum < a->u64[i]) | (carry & (sum == a->u64[i]));                \
      result->u64[i] = sum;                                                    \
    }                                                                          \
    return carry;                                                              \
  }                                                                            \
  /** Performs A-B, storing in `result`. Returns the borrow bit (1 or 0). */   \
  FIO_MIFN uint64_t fio_u##bits##_sub(fio_u##bits *result,                     \
                                      const fio_u##bits *a,                    \
                                      const fio_u##bits *b) {                  \
    uint64_t borrow = 0;                                                       \
    for (size_t i = 0; i < (bits / 64); ++i) {                                 \
      uint64_t diff = a->u64[i] - b->u64[i] - borrow;                          \
      borrow =                                                                 \
          ((a->u64[i] < b->u64[i]) | ((a->u64[i] == b->u64[i]) & borrow));     \
      result->u64[i] = diff;                                                   \
    }                                                                          \
    return borrow;                                                             \
  }                                                                            \
  /** Returns -1, 0, or 1 if a < b, a == b or a > a (respectively). */         \
  FIO_MIFN int fio_u##bits##_cmp(const fio_u##bits *a, const fio_u##bits *b) { \
    unsigned is_eq = 1;                                                        \
    unsigned is_bigger = 0;                                                    \
    for (size_t i = (bits / 64); i--;) {                                       \
      is_bigger |= (is_eq & (a->u64[i] > b->u64[i]));                          \
      is_eq &= (unsigned)(a->u64[i] == b->u64[i]);                             \
    }                                                                          \
    return (is_eq - 1) + (is_bigger << 1);                                     \
  }

#undef FIO___VMATH_DEF_LARGE_MUL
#define FIO___VMATH_DEF_LARGE_MUL(dbl_bits, bits)                              \
  /** Multiplies A and B, storing the result in `result`. */                   \
  FIO_SFUNC void fio_u##bits##_mul(fio_u##dbl_bits *result,                    \
                                   const fio_u##bits *a,                       \
                                   const fio_u##bits *b) {                     \
    fio_math_mul(result->u64, a->u64, b->u64, (bits / 64));                    \
  }                                                                            \
  FIO_SFUNC void fio_u##bits##_montgomery_mul(fio_u##bits *result,             \
                                              const fio_u##bits *a,            \
                                              const fio_u##bits *b,            \
                                              const fio_u##bits *N,            \
                                              const fio_u##bits *N_dash) {     \
    fio_u##dbl_bits u;                                                         \
    fio_u##dbl_bits t, mN;                                                     \
    /* Step 1: t = a * b  */                                                   \
    fio_u##bits##_mul(&t, a, b);                                               \
    /* Step 2: m = ((t Mod R) * N_dash) mod R */                               \
    fio_u##bits##_mul(&mN, t.u##bits, N_dash);                                 \
    /* Step 3: u = (t + m * N) */                                              \
    fio_u##bits##_mul(&mN, mN.u##bits, N);                                     \
    uint64_t ignr_ = fio_u##dbl_bits##_add(&u, &t, &mN);                       \
    (void)ignr_;                                                               \
    /* Step 4: Constant Time select, if u >= N, then u = u - N */              \
    bool selector = (bool)fio_u##bits##_sub(u.u##bits, u.u##bits + 1, N);      \
    /* Step 5: Set result */                                                   \
    /* result is u.u##bits[0] if equal or bigger */                            \
    /* result is u.u##bits[1] if smaller */                                    \
    /* TODO: use mask instead of implied `if` selector? memory not hot? */     \
    *result = u.u##bits[selector];                                             \
  }

FIO___VMATH_DEF_LARGE_ADD_SUB(128)
FIO___VMATH_DEF_LARGE_ADD_SUB(256)
FIO___VMATH_DEF_LARGE_ADD_SUB(512)
FIO___VMATH_DEF_LARGE_ADD_SUB(1024)
FIO___VMATH_DEF_LARGE_ADD_SUB(2048)
FIO___VMATH_DEF_LARGE_ADD_SUB(4096)

FIO___VMATH_DEF_LARGE_MUL(256, 128)
FIO___VMATH_DEF_LARGE_MUL(512, 256)
FIO___VMATH_DEF_LARGE_MUL(1024, 512)
FIO___VMATH_DEF_LARGE_MUL(2048, 1024)
FIO___VMATH_DEF_LARGE_MUL(4096, 2048)

#undef FIO___VMATH_DEF_LARGE_ADD_SUB
#undef FIO___VMATH_DEF_LARGE_MUL

/* *****************************************************************************
SIMD Vector Operations
***************************************************************************** */

/** A math operation `op` between correlating vector positions of same length */
#define FIO_VEC_SIMPLE_OP(result, a, b, len, op)                               \
  FIO_FOR_UNROLL(len, sizeof(*a), i__, result[i__] = a[i__] op b[i__])
/** A math operation `op` between a scalar and a vector */
#define FIO_VEC_SCALAR_OP(result, v, sclr, len, op)                            \
  FIO_FOR_UNROLL(len, sizeof(*v), i__, result[i__] = vec[i__] op scalar)
/** A math operation `op` between all vector members */
#define FIO_VEC_REDUCE_OP(result, vec, len, op)                                \
  FIO_FOR_UNROLL(len, sizeof(*vec), i__, result = result op vec[i__])

/** The dot product of two vectors (sum(a[i]*b[i])). */
#define FIO_VEC_DOT(result, a, b, len)                                         \
  FIO_FOR_UNROLL(len, sizeof(*a), i__, result += a[i__] * b[i__])

/** Add two vectors of same length (adding corresponding positions) */
#define FIO_VEC_ADD(result, a, b, len) FIO_VEC_SIMPLE_OP(result, a, b, len, +)
/** Subtracting two vectors of same length */
#define FIO_VEC_SUB(result, a, b, len) FIO_VEC_SIMPLE_OP(result, a, b, len, -)
/** Multiplying two vectors (multiplying corresponding positions - half dot) */
#define FIO_VEC_MUL(result, a, b, len) FIO_VEC_SIMPLE_OP(result, a, b, len, *)

/** Add scalar to vector */
#define FIO_VEC_SCALAR_ADD(result, vec, scalar, vlen)                          \
  FIO_VEC_SCALAR_OP(result, vec, scalar, vlen, +)
/** Subtract scalar from vector */
#define FIO_VEC_SCALAR_SUB(result, vec, scalar, vlen)                          \
  FIO_VEC_SCALAR_OP(result, vec, scalar, vlen, -)
/** Multiply scalar from vector */
#define FIO_VEC_SCALAR_MUL(result, vec, scalar, vlen)                          \
  FIO_VEC_SCALAR_OP(result, vec, scalar, vlen, *)

/** Add all members of a vector */
#define FIO_VEC_REDUCE_ADD(result, vec, vlen)                                  \
  FIO_VEC_REDUCE_OP(result, vec, vlen, +)
/** Subtract all members of a vector */
#define FIO_VEC_REDUCE_SUB(result, vec, vlen)                                  \
  FIO_VEC_REDUCE_OP(result, vec, vlen, -)
/** Multiply all members of a vector */
#define FIO_VEC_REDUCE_MUL(result, vec, vlen)                                  \
  FIO_VEC_REDUCE_OP(result, vec, vlen, *)

/* ****************************************************************************
Defining a Pseudo-Random Number Generator Function (deterministic / not)
**************************************************************************** */

#if defined(__x86_64__) || defined(__i386__)
FIO_IFUNC uint64_t fio_cycle_counter(void) {
  uint64_t r = 0;
  uint32_t lo, hi;
  __asm__ volatile("rdtsc" : "=a"(lo), "=d"(hi));
  r = ((uint64_t)hi << 32) | lo;
  return r;
}
#elif defined(__aarch64__)
FIO_IFUNC uint64_t fio_cycle_counter(void) {
  uint64_t r;
  __asm__ volatile("mrs %0, cntvct_el0" : "=r"(r));
  return r;
}
#else
FIO_IFUNC uint64_t fio_cycle_counter(void) { return (uint64_t)0; }
#endif

/**
 * Defines a semi-deterministic Pseudo-Random 128 bit Number Generator function.
 *
 * The following functions will be defined:
 *
 * - extern fio_u128 name##128(void); // returns 128 bits
 * - extern uint64_t name##64(void); // returns 64 bits (simply half the result)
 * - extern void name##_bytes(void *buffer, size_t len); // fills a buffer
 * - extern void name##_reset(void); // resets the state of the PRNG
 * - extern void name##_on_fork(void * is_null); // reseeds the PRNG
 *
 * If `reseed_log` is non-zero and less than 64, the PNGR is no longer
 * deterministic, as it will automatically re-seeds itself every 2^reseed_log
 * iterations.
 *
 * If `extern` is `static` or `FIO_SFUNC`, static function will be defined.
 */
#define FIO_DEFINE_RANDOM128_FN(extern, name, reseed_log, seed_offset)         \
  static uint64_t name##___state[8] FIO_ALIGN(64) = {                          \
      0x9c65875be1fce7b9ULL + seed_offset,                                     \
      0x7cc568e838f6a40dULL,                                                   \
      0x4bb8d885a0fe47d5ULL + seed_offset,                                     \
      0x95561f0927ad7ecdULL,                                                   \
      0};                                                                      \
  extern FIO_MAYBE_UNUSED void name##_reset(void) {                            \
    name##___state[0] = 0x9c65875be1fce7b9ULL + seed_offset;                   \
    name##___state[1] = 0x7cc568e838f6a40dULL;                                 \
    name##___state[2] = 0x4bb8d885a0fe47d5ULL + seed_offset;                   \
    name##___state[3] = 0x95561f0927ad7ecdULL;                                 \
    name##___state[4] = 0;                                                     \
  }                                                                            \
  extern void name##_reseed(void) {                                            \
    const size_t jitter_samples = 16 | (name##___state[0] & 15);               \
    for (size_t i = 0; i < jitter_samples; ++i) {                              \
      struct timespec t;                                                       \
      clock_gettime(CLOCK_MONOTONIC, &t);                                      \
      uint64_t clk[2] = {(uint64_t)(uintptr_t)&clk + (uint64_t)(uintptr_t) &   \
                             (name##_reseed),                                  \
                         0};                                                   \
      clk[0] += (uint64_t)((t.tv_sec << 30) + (int64_t)t.tv_nsec);             \
      clk[0] = fio_math_mulc64(clk[0], FIO_U64_HASH_PRIME0, clk + 1);          \
      clk[1] += FIO_U64_HASH_PRIME0;                                           \
      clk[0] += fio_lrot64(clk[0], 27);                                        \
      clk[0] += fio_lrot64(clk[0], 49);                                        \
      clk[1] += fio_lrot64(clk[1], 27);                                        \
      clk[1] += fio_lrot64(clk[1], 49);                                        \
      name##___state[0] += clk[0] + fio_cycle_counter();                       \
      name##___state[1] += clk[1] + fio_cycle_counter();                       \
      name##___state[2] += clk[0] + fio_cycle_counter();                       \
      name##___state[3] += clk[1] + fio_cycle_counter();                       \
    }                                                                          \
  }                                                                            \
  /** Re-seeds the PNGR so forked processes don't match. */                    \
  extern FIO_MAYBE_UNUSED void name##_on_fork(void *is_null) {                 \
    (void)is_null;                                                             \
    name##_reseed();                                                           \
  }                                                                            \
  /** Returns a 128 bit pseudo-random number. */                               \
  extern FIO_MAYBE_UNUSED fio_u128 name##128(void) {                           \
    fio_u256 r;                                                                \
    if (!(fio_atomic_add(name##___state + 4, 1) &                              \
          ((1ULL << reseed_log) - 1)) &&                                       \
        ((size_t)(reseed_log - 1) < 63))                                       \
      name##_reseed();                                                         \
    uint64_t s1[4];                                                            \
    { /* load state to registers and roll, mul, add */                         \
      const uint64_t cycles =                                                  \
          reseed_log ? fio_cycle_counter() + (uint64_t)(uintptr_t)&cycles      \
                     : 0xB5ULL;                                                \
      const uint64_t variation =                                               \
          0x4E55788DULL +                                                      \
          (reseed_log ? (uint64_t)(uintptr_t)&name##_reseed : 0);              \
      const uint64_t s0[] = {(name##___state[0] + cycles),                     \
                             (name##___state[1] + cycles),                     \
                             (name##___state[2] + cycles),                     \
                             (name##___state[3] + cycles)};                    \
      const uint64_t mulp[] = {0x37701261ED6C16C7ULL,                          \
                               0x764DBBB75F3B3E0DULL,                          \
                               ~(0x37701261ED6C16C7ULL),                       \
                               ~(0x764DBBB75F3B3E0DULL)};                      \
      const uint64_t addc[] = {name##___state[4],                              \
                               seed_offset + 0x59DD1C23ULL,                    \
                               name##___state[4] + cycles,                     \
                               variation};                                     \
      for (size_t i = 0; i < 4; ++i) {                                         \
        s1[i] = fio_lrot64(s0[i], 33);                                         \
        s1[i] += addc[i];                                                      \
        s1[i] *= mulp[i];                                                      \
        s1[i] += s0[i];                                                        \
      }                                                                        \
    }                                                                          \
    for (size_t i = 0; i < 4; ++i) /* store to memory */                       \
      name##___state[i] = s1[i];                                               \
    {                                                                          \
      const uint8_t rotc[] = {31, 29, 27, 30};                                 \
      for (size_t i = 0; i < 4; ++i)                                           \
        r.u64[i] = fio_lrot64(s1[i], rotc[i]);                                 \
    }                                                                          \
    r.u64[0] += r.u64[2];                                                      \
    r.u64[1] += r.u64[3];                                                      \
    return r.u128[0];                                                          \
  }                                                                            \
  /** Returns a 64 bit pseudo-random number. */                                \
  extern FIO_MAYBE_UNUSED uint64_t name##64(void) {                            \
    static size_t counter;                                                     \
    static fio_u128 r;                                                         \
    if (!((counter++) & 1))                                                    \
      r = name##128();                                                         \
    return r.u64[counter & 1];                                                 \
  }                                                                            \
  /** Fills the `dest` buffer with pseudo-random noise. */                     \
  extern FIO_MAYBE_UNUSED void name##_bytes(void *dest, size_t len) {          \
    if (!dest || !len)                                                         \
      return;                                                                  \
    uint8_t *d = (uint8_t *)dest;                                              \
    for (unsigned i = 15; i < len; i += 16) {                                  \
      fio_u128 r = name##128();                                                \
      fio_memcpy16(d, r.u8);                                                   \
      d += 16;                                                                 \
    }                                                                          \
    if (len & 15) {                                                            \
      fio_u128 r = name##128();                                                \
      fio_memcpy15x(d, r.u8, len);                                             \
    }                                                                          \
  }

/* *****************************************************************************
String and Buffer Information Containers + Helper Macros
***************************************************************************** */

/** An information type for reporting the string's state. */
typedef struct fio_str_info_s {
  /** The string's length, if any. */
  size_t len;
  /** The string's buffer (pointer to first byte) or NULL on error. */
  char *buf;
  /** The buffer's capacity. Zero (0) indicates the buffer is read-only. */
  size_t capa;
} fio_str_info_s;

/** An information type for reporting/storing buffer data (no `capa`). */
typedef struct fio_buf_info_s {
  /** The buffer's length, if any. */
  size_t len;
  /** The buffer's address (may be NULL if no buffer). */
  char *buf;
} fio_buf_info_s;

/** Compares two `fio_str_info_s` objects for content equality. */
#define FIO_STR_INFO_IS_EQ(s1, s2)                                             \
  ((s1).len == (s2).len &&                                                     \
   (!(s1).len || (s1).buf == (s2).buf ||                                       \
    ((s1).buf && (s2).buf && (s1).buf[0] == (s2).buf[0] &&                     \
     !FIO_MEMCMP((s1).buf, (s2).buf, (s1).len))))

/** Compares two `fio_buf_info_s` objects for content equality. */
#define FIO_BUF_INFO_IS_EQ(s1, s2) FIO_STR_INFO_IS_EQ((s1), (s2))

/** A NULL fio_str_info_s. */
#define FIO_STR_INFO0 ((fio_str_info_s){0})

/** Converts a C String into a fio_str_info_s. */
#define FIO_STR_INFO1(str)                                                     \
  ((fio_str_info_s){.len = ((str) ? FIO_STRLEN((str)) : 0), .buf = (str)})

/** Converts a String with a known length into a fio_str_info_s. */
#define FIO_STR_INFO2(str, length)                                             \
  ((fio_str_info_s){.len = (length), .buf = (str)})

/** Converts a String with a known length and capacity into a fio_str_info_s. */
#define FIO_STR_INFO3(str, length, capacity)                                   \
  ((fio_str_info_s){.len = (length), .buf = (str), .capa = (capacity)})

/** A NULL fio_buf_info_s. */
#define FIO_BUF_INFO0 ((fio_buf_info_s){0})

/** Converts a C String into a fio_buf_info_s. */
#define FIO_BUF_INFO1(str)                                                     \
  ((fio_buf_info_s){.len = ((str) ? FIO_STRLEN((str)) : 0), .buf = (str)})

/** Converts a String with a known length into a fio_buf_info_s. */
#define FIO_BUF_INFO2(str, length)                                             \
  ((fio_buf_info_s){.len = (length), .buf = (str)})

/** Converts a fio_buf_info_s into a fio_str_info_s. */
#define FIO_BUF2STR_INFO(buf_info)                                             \
  ((fio_str_info_s){.len = (buf_info).len, .buf = (buf_info).buf})

/** Converts a fio_buf_info_s into a fio_str_info_s. */
#define FIO_STR2BUF_INFO(str_info)                                             \
  ((fio_buf_info_s){.len = (str_info).len, .buf = (str_info).buf})

/** Creates a stack fio_str_info_s variable `name` with `capacity` bytes. */
#define FIO_STR_INFO_TMP_VAR(name, capacity)                                   \
  char fio___stack_mem___##name[(capacity) + 1];                               \
  fio___stack_mem___##name[0] = 0; /* guard */                                 \
  fio_str_info_s name = (fio_str_info_s) {                                     \
    .buf = fio___stack_mem___##name, .capa = (capacity)                        \
  }

/** Tests to see if memory reallocation happened. */
#define FIO_STR_INFO_TMP_IS_REALLOCATED(name)                                  \
  (fio___stack_mem___##name != name.buf)

/* *****************************************************************************
UTF-8 Support (basic)
***************************************************************************** */

#ifndef FIO_UTF8_ALLOW_IF
/* UTF-8 Constant Time? (0 = avoid mis-predictions; 1 = mostly ascii) */
#define FIO_UTF8_ALLOW_IF 1

#endif

/* Returns the number of bytes required to UTF-8 encoded a code point `u` */
FIO_IFUNC FIO_CONST unsigned fio_utf8_code_len(uint32_t u) {
  uint32_t len = (1U + ((uint32_t)(u) > 127) + ((uint32_t)(u) > 2047) +
                  ((uint32_t)(u) > 65535));
  len &= (uint32_t)((uint32_t)(u) > ((1U << 21) - 1)) - 1;
  return len;
}

/** Returns 1-4 (UTF-8 char length), 8 (middle of a char) or 0 (invalid). */
FIO_IFUNC FIO_CONST unsigned fio_utf8_char_len_unsafe(uint8_t c) {
  /* Ruby script for map:
  map = [];
  32.times { | i |
    map << (((i & 0b10000) == 0b00000) ? 1
        :   ((i & 0b11000) == 0b10000) ? 8
        :   ((i & 0b11100) == 0b11000) ? 2
        :   ((i & 0b11110) == 0b11100) ? 3
        :   ((i & 0b11111) == 0b11110) ? 4
                               : 0)
  }; puts "static const uint8_t map[32] = {#{ map.join(', ')} };"
  */
  static const uint8_t map[32] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                  1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8,
                                  8, 8, 2, 2, 2, 2, 3, 3, 4, 0};
  return map[c >> 3];
}

/** Returns the number of valid UTF-8 bytes used by first char at `str`. */
FIO_IFUNC unsigned fio_utf8_char_len(const void *str_) {
  unsigned r, tst;
  const uint8_t *s = (const uint8_t *)str_;
  r = fio_utf8_char_len_unsafe(*s) & 7;
#if FIO_UTF8_ALLOW_IF
  if (r < 2)
    return r;
  tst = 1;
  tst += (fio_utf8_char_len_unsafe(s[tst]) >> 3) & (r > 3);
  tst += (fio_utf8_char_len_unsafe(s[tst]) >> 3) & (r > 2);
  tst += (fio_utf8_char_len_unsafe(s[tst]) >> 3);
  if (r != tst)
    r = 0;
#else
  tst = (r > 0);
  tst += ((fio_utf8_char_len_unsafe(s[tst]) >> 3) & (r > 3));
  tst += ((fio_utf8_char_len_unsafe(s[tst]) >> 3) & (r > 2));
  tst += (fio_utf8_char_len_unsafe(s[tst]) >> 3);
  r &= 0U - (r == tst);
#endif

  return r;
}

/** Writes code point to `dest` using UFT-8. Returns number of bytes written. */
FIO_IFUNC unsigned fio_utf8_write(void *dest_, uint32_t u) {
  const uint8_t len = (uint8_t)fio_utf8_code_len(u);
  uint8_t *dest = (uint8_t *)dest_;
#if FIO_UTF8_ALLOW_IF
  if (len < 2) { /* writes, but doesn't report on len == 0 */
    *dest = (uint8_t)u;
    return len;
  }
  const uint8_t offset = (uint8_t)(0xF0U << (4U - len));
  const uint8_t head = (uint8_t)(0x80U << (len < 2));
  const uint8_t mask = 63U;
  *(dest) = (uint8_t)(offset | ((u) >> (((len - 1) << 3) - ((len - 1) << 1))));
  (dest) += 1;
  *(dest) = (uint8_t)(head | (((u) >> 12) & mask));
  (dest) += (len > 3);
  *(dest) = (uint8_t)(head | (((u) >> 6) & mask));
  (dest) += (len > 2);
  *(dest) = (uint8_t)(head | ((u)&mask));
  return len;
#else
  const uint8_t offset = 0xF0U << (4U - len);
  const uint8_t head = 0x80U << (len < 2);
  const uint8_t mask = 63U;
  *dest = (uint8_t)u;
  dest += (len == 1);
  *dest = offset | ((u) >> (((len - 1) << 3) - ((len - 1) << 1)));
  dest += (len > 1);
  *dest = head | (((u) >> 12) & mask);
  dest += (len > 3);
  *dest = head | (((u) >> 6) & mask);
  dest += (len > 2);
  *dest = head | ((u)&mask);
  return len;
#endif
}

/**
 * Decodes the first UTF-8 char at `str` and returns its code point value.
 *
 * Advances the pointer at `str` by the number of bytes consumed (read).
 */
FIO_IFUNC uint32_t fio_utf8_read(char **str) {
  const uint8_t *s = *(const uint8_t **)str;
  unsigned len = fio_utf8_char_len(s);
  *str += len;
#if FIO_UTF8_ALLOW_IF
  if (!len)
    return 0;
  if (len == 1)
    return *s;
  const uint32_t t2 = (len > 2);
  const uint32_t t3 = 1 + (len > 3);
  const uint32_t t3a = (len > 2) + (len > 3);
  const uint32_t t4 = len - 1;
  return ((uint32_t)(s[0] & (63 >> t4)) << ((t4 << 3) - (t4 << 1))) |
         ((uint32_t)(s[1] & 63) << ((t3a << 3) - (t3a << 1))) |
         ((uint32_t)(s[t3] & 63) << ((t2 << 3) - (t2 << 1))) |
         ((uint32_t)(s[t4] & 63));
#else
  const uint32_t t1 = (len > 1);
  const uint32_t t2 = (len > 2);
  const uint32_t t3 = t2 + (len > 3);
  const uint32_t t3a = (len > 2) + (len > 3);
  const uint32_t t4 = len - t1;
  uint32_t r1 = *s & ((uint32_t)0UL - (len == 1));
  uint32_t r2 = ((uint32_t)(s[0] & (63 >> t4)) << ((t4 << 3) - (t4 << 1))) |
                ((uint32_t)(s[t1] & 63) << ((t3a << 3) - (t3a << 1))) |
                ((uint32_t)(s[t3] & 63) << ((t2 << 3) - (t2 << 1))) |
                ((uint32_t)(s[t4] & 63));
  r2 &= (uint32_t)0UL - t1;
  return (r1 | r2);
#endif
}

/** Decodes the first UTF-8 char at `str` and returns its code point value. */
FIO_IFUNC uint32_t fio_utf8_peek(const char *str) {
  char *tmp = (char *)(uintptr_t)str;
  return fio_utf8_read(&tmp);
}

/* *****************************************************************************
C++ extern end
***************************************************************************** */
/* support C++ */
#ifdef __cplusplus
}
#endif

/* *****************************************************************************
End persistent segment (end include-once guard)
***************************************************************************** */
#endif /* H___FIO_CORE___H */
/* *****************************************************************************



                              Multi-Inclusion Macros



***************************************************************************** */

/* *****************************************************************************
Tests Inclusion (everything + MEMALT)
***************************************************************************** */
#if !defined(FIO___RECURSIVE_INCLUDE) &&                                       \
    (defined(FIO_TEST_ALL) || defined(FIO___TEST_MACRO_SUSPENDED)) &&          \
    !defined(H___FIO_TESTS_INC_FINISHED___H)

/* Inclusion cycle three - facil.io memory allocator for all else. */
#if !defined(H___FIO_EVERYTHING___H) /* include everything first, then test */
#undef FIO_TEST_ALL
#define FIO___TEST_MACRO_SUSPENDED
#undef FIO_LEAK_COUNTER
#define FIO_LEAK_COUNTER 1
#define FIO_EVERYTHING
#else /* define test inclusion */
#define H___FIO_TESTS_INC_FINISHED___H
#undef FIO___TEST_MACRO_SUSPENDED
#define FIO_TEST_ALL
#endif

#endif /* FIO_TEST_ALL */

/* *****************************************************************************
Special `extern` support FIO_BASIC, FIO_EVERYTHING, etc'
***************************************************************************** */
#if !defined(FIO___RECURSIVE_INCLUDE) && defined(FIO_EXTERN) &&                \
    (defined(FIO_TEST_ALL) || defined(FIO_EVERYTHING) || defined(FIO_BASIC))
#if defined(FIO_EXTERN) && ((FIO_EXTERN + 1) < 3)
#undef FIO_EXTERN
#define FIO_EXTERN                     2
#define FIO_EVERYTHING___REMOVE_EXTERN 1
#endif
#if defined(FIO_EXTERN_COMPLETE) && ((FIO_EXTERN_COMPLETE + 1) < 3)
#undef FIO_EXTERN_COMPLETE
#define FIO_EXTERN_COMPLETE                     2
#define FIO_EVERYTHING___REMOVE_EXTERN_COMPLETE 1
#endif
#endif

/* *****************************************************************************
Everything Inclusion
***************************************************************************** */
#if !defined(FIO___RECURSIVE_INCLUDE) && defined(FIO_EVERYTHING) &&            \
    !defined(H___FIO_EVERYTHING___H)

#if !defined(H___FIO_EVERYTHING1___H)
#define H___FIO_EVERYTHING1___H
#undef FIO_FIOBJ
#undef FIO_HTTP
#undef FIO_MALLOC
#undef FIO_MUSTACHE
#undef FIO_PUBSUB
#undef FIO_IO
#undef FIOBJ_MALLOC
#define FIO_CLI
#define FIO_CORE
#define FIO_CRYPTO
#define FIO_SIGNAL
#define FIO_SOCK
#define FIO_THREADS

#else
#undef H___FIO_EVERYTHING1___H
#undef FIO_EVERYTHING
#define H___FIO_EVERYTHING___H
#undef FIO_MEMALT
#define FIO_FIOBJ
#define FIO_HTTP
#define FIO_IO
#define FIO_MALLOC
#define FIO_MUSTACHE
#define FIO_PUBSUB
#define FIO_MEMALT

#endif

#define FIO___INCLUDE_AGAIN
#endif /* FIO_EVERYTHING */

/* *****************************************************************************
FIO_BASIC                   Basic Kitchen Sink Inclusion
***************************************************************************** */
#if !defined(FIO___RECURSIVE_INCLUDE) && defined(FIO_BASIC) &&                 \
    !defined(H___FIO_BASIC___H)

#if !defined(H___FIO_BASIC_ROUND1___H)
#define H___FIO_BASIC_ROUND1___H
#undef FIO_CLI
#undef FIO_CORE
#undef FIO_CRYPTO
#undef FIO_FIOBJ
#undef FIO_MALLOC
#undef FIO_MUSTACHE
#undef FIO_THREADS
#undef FIOBJ_MALLOC
#define FIO_CLI
#define FIO_CORE
#define FIO_CRYPTO
#define FIO_THREADS

#elif !defined(H___FIO_BASIC_ROUND2___H)
#define H___FIO_BASIC_ROUND2___H
#define FIO_FIOBJ
#define FIO_MUSTACHE
#define FIOBJ_MALLOC
#define FIO_OTP

#else
#define H___FIO_BASIC___H
#undef H___FIO_BASIC_ROUND1___H
#undef H___FIO_BASIC_ROUND2___H
#undef FIO_BASIC
#define FIO_MALLOC
#endif

#define FIO___INCLUDE_AGAIN
#endif /* FIO_BASIC */
/* *****************************************************************************
FIO_CRYPTO            Poor-man's Cryptographic Elements
***************************************************************************** */
#if defined(FIO_CRYPT) || defined(FIO_CRYPTO) || defined(FIO_TLS13) ||         \
    defined(FIO_IO)
#undef FIO_CRYPT
#undef FIO_CRYPTO
#undef FIO_AES
#undef FIO_ASN1
#undef FIO_CHACHA
#undef FIO_CRYPTO_CORE
#undef FIO_ED25519
#undef FIO_OTP
#undef FIO_P256
#undef FIO_P384
#undef FIO_PEM
#undef FIO_RSA
#undef FIO_SECRET
#undef FIO_SHA1
#undef FIO_SHA2
#undef FIO_TLS13
#undef FIO_X509
#define FIO_CRYPTO_CORE
#define FIO_SHA1
#define FIO_SHA2
#define FIO_SHA3
#define FIO_BLAKE2
#define FIO_CHACHA
#define FIO_HKDF
#define FIO_AES
#define FIO_ED25519
#define FIO_P256
#define FIO_P384
#define FIO_ASN1
#define FIO_RSA
#define FIO_X509
#define FIO_PEM
#define FIO_OTP
#define FIO_SECRET
#define FIO_TLS13
#endif /* FIO_CRYPTO */

/* *****************************************************************************
FIO_CORE                        Core Inclusion
***************************************************************************** */
#if defined(FIO_CORE)
#undef FIO_ATOL
#undef FIO_FILES
#undef FIO_GLOB_MATCH
#undef FIO_LOG
#undef FIO_MATH
#undef FIO_RAND
#undef FIO_STATE
#undef FIO_TIME
#undef FIO_URL
#undef FIO_CORE
#define FIO_ATOL
#define FIO_FILES
#define FIO_GLOB_MATCH
#define FIO_LOG
#define FIO_MATH
#define FIO_RAND
#define FIO_STATE
#define FIO_TIME
#define FIO_URL
#endif

/* *****************************************************************************



                                  Shortcut Macros



***************************************************************************** */

/* *****************************************************************************
Memory Allocation - FIO_MALLOC as a "global" default memory allocator
***************************************************************************** */
/* FIO_MALLOC defines a "global" default memory allocator */
#if defined(FIO_MALLOC) && !defined(H___FIO_MALLOC___H)
#define H___FIO_MALLOC___H
#ifndef FIO_MEMORY_NAME
#define FIO_MEMORY_NAME fio
#endif
#ifndef FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG
/* for a general allocator, increase system allocation size to 8Mb */
#define FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG 23
#endif

#ifndef FIO_MEMORY_CACHE_SLOTS
/* for a general allocator, increase cache size */
#define FIO_MEMORY_CACHE_SLOTS 8
#endif

#ifndef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
/* set fragmentation cost at 0.25Mb blocks */
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 5
#endif

#ifndef FIO_MEMORY_ENABLE_BIG_ALLOC
/* support big allocations using undivided memory chunks */
#define FIO_MEMORY_ENABLE_BIG_ALLOC 1
#endif

#ifndef FIO_MEMORY_INITIALIZE_ALLOCATIONS
/* should memory be initialized to zero? */
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 1
#endif
/* *****************************************************************************
Memory Allocation - FIO_MALLOC defines a FIOBJ dedicated memory allocator
***************************************************************************** */
/* FIOBJ_MALLOC defines a FIOBJ dedicated memory allocator */
#elif defined(FIOBJ_MALLOC) && !defined(H___FIOBJ_MALLOC___H)
#define H___FIOBJ_MALLOC___H
#ifndef FIO_MEMORY_NAME
#define FIO_MEMORY_NAME fiobj_mem
#endif
#ifndef FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG
/* 4Mb per system call */
#define FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG 22
#endif
#ifndef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
/* fight fragmentation */
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 4
#endif
#ifndef FIO_MEMORY_CACHE_SLOTS
/* cache up to 64Mb */
#define FIO_MEMORY_CACHE_SLOTS 16
#endif
#endif /* FIOBJ_MALLOC / FIO_MALLOC*/

#undef FIOBJ_MALLOC
#undef FIO_MALLOC
/* *****************************************************************************
FIO_SORT_NAME naming
***************************************************************************** */

#if defined(FIO_SORT_TYPE) && !defined(FIO_SORT_NAME)
#define FIO_SORT_NAME FIO_NAME(FIO_SORT_TYPE, vec)
#endif

/* *****************************************************************************
FIO_MAP Ordering & Naming Shortcut
***************************************************************************** */
#if defined(FIO_UMAP_NAME)
#define FIO_MAP_NAME FIO_UMAP_NAME
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 0
#elif defined(FIO_OMAP_NAME)
#define FIO_MAP_NAME FIO_OMAP_NAME
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 1
#endif

/* *****************************************************************************



                  Higher Level Dependencies (i.e. Server module)



***************************************************************************** */

#if defined(FIO_HTTP)
#undef FIO_HTTP_HANDLE
#define FIO_HTTP_HANDLE
#endif

#if defined(FIO_HTTP_HANDLE)
#undef FIO_JSON
#define FIO_JSON
#undef FIO_MULTIPART
#define FIO_MULTIPART
#undef FIO_URL_ENCODED
#define FIO_URL_ENCODED
#endif

#if defined(FIO_PUBSUB) || (defined(DEBUG) && defined(FIO_HTTP_HANDLE))
#undef FIO_IO
#define FIO_IO
#endif

#if defined(FIO_HTTP) || defined(FIO_REDIS)
#undef FIO_PUBSUB
#define FIO_PUBSUB
#endif

#if defined(FIO_HTTP) || defined(FIO_PUBSUB)
#undef FIO_IO
#define FIO_IO
#endif

#if defined(FIO_HTTP) || defined(FIO_IO)
#undef FIO_POLL
#define FIO_POLL
#endif

/* *****************************************************************************



                  Mid Level Dependencies (i.e., types / helpers)



***************************************************************************** */

#if defined(FIO_REDIS)
#define FIO_RESP3
#endif

#if defined(FIO_FIOBJ)
#define FIO_MUSTACHE
#define FIO_JSON
#endif

#if defined(FIO_HTTP)
#undef FIO_HTTP1_PARSER
#define FIO_HTTP1_PARSER
#endif

#if defined(FIO_HTTP)
#undef FIO_WEBSOCKET_PARSER
#define FIO_WEBSOCKET_PARSER
#endif

#if defined(FIO_POLL) || defined(FIO_IO) || defined(FIO_PUBSUB)
#undef FIO_SOCK
#define FIO_SOCK
#endif

#if defined(FIO_HTTP_HANDLE) || defined(FIO_QUEUE) || defined(FIO_FIOBJ) ||    \
    defined(FIO_LEAK_COUNTER) || defined(FIO_MEMORY_NAME) || defined(FIO_POLL)
#undef FIO_STATE
#define FIO_STATE
#endif

#if defined(FIO_HTTP_HANDLE) || defined(FIO_STR_NAME) ||                       \
    defined(FIO_STR_SMALL) || defined(FIO_ARRAY_TYPE_STR) ||                   \
    defined(FIO_MAP_KEY_KSTR) || defined(FIO_MAP_KEY_BSTR) ||                  \
    (defined(FIO_MAP_NAME) && !defined(FIO_MAP_KEY)) ||                        \
    defined(FIO_MUSTACHE) || defined(FIO_MAP2_NAME) || defined(FIO_OTP)
#undef FIO_STR
#define FIO_STR
#endif

#if defined(FIO_IO)
#undef FIO_STREAM
#define FIO_STREAM
#endif

#if defined(FIO_IO)
#undef FIO_QUEUE
#define FIO_QUEUE
#endif

#if defined(FIO_HTTP_HANDLE) || defined(FIO_QUEUE) || defined(FIO_OTP) ||      \
    defined(FIO_X509)
#undef FIO_TIME
#define FIO_TIME
#endif

/* *****************************************************************************



              Crypto Elements Dependencies (i.e., SHA-1 etc')



***************************************************************************** */
#if defined(FIO_PUBSUB)
#define FIO_CHACHA
#define FIO_SECRET
#endif

#if defined(FIO_HTTP_HANDLE) || defined(FIO_OTP)
#define FIO_SHA1
#endif

#if defined(FIO_PUBSUB) || defined(FIO_SECRET)
#define FIO_SHA2
#endif

#if defined(FIO_CHACHA) || defined(FIO_SHA1) || defined(FIO_SHA2)
#undef FIO_CRYPTO_CORE
#define FIO_CRYPTO_CORE
#endif

/* *****************************************************************************



                  Core Level Dependencies (i.e., atomics, etc')



***************************************************************************** */

#if defined(FIO_STR) || defined(FIO_HTTP) || defined(FIO_STREAM)
#undef FIO_FILES
#define FIO_FILES
#endif

#if defined(FIO_CLI) || defined(FIO_HTTP_HANDLE) ||                            \
    defined(FIO_HTTP1_PARSER) || defined(FIO_JSON) || defined(FIO_STR) ||      \
    defined(FIO_TIME) || defined(FIO_FILES) || defined(FIO_SECRET)
#undef FIO_ATOL
#define FIO_ATOL
#endif

#if defined(FIO_PUBSUB)
#undef FIO_GLOB_MATCH
#define FIO_GLOB_MATCH
#endif

#if defined(FIO_CLI) || defined(FIO_MEMORY_NAME) || defined(FIO_POLL) ||       \
    defined(FIO_STATE) || defined(FIO_HTTP_HANDLE)
#undef FIO_IMAP_CORE
#define FIO_IMAP_CORE
#endif

#if defined(FIO_CHACHA) || defined(FIO_SHA2)
#undef FIO_MATH
#define FIO_MATH
#endif

#if defined(FIO_CLI) || defined(FIO_FILES) || defined(FIO_HTTP_HANDLE) ||      \
    defined(FIO_MEMORY_NAME) || defined(FIO_POLL) || defined(FIO_STATE) ||     \
    defined(FIO_STR)
#undef FIO_RAND
#define FIO_RAND
#endif

#if defined(FIO_IO)
#undef FIO_SIGNAL
#define FIO_SIGNAL
#endif

#if defined(FIO_MEMORY_NAME) || defined(FIO_QUEUE) ||                          \
    (defined(DEBUG) && defined(FIO_STATE)) || defined(FIO_HTTP_HANDLE)
#undef FIO_THREADS
#define FIO_THREADS
#endif

#if defined(FIO_SOCK)
#undef FIO_URL
#define FIO_URL
#endif
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************
C++ extern start
***************************************************************************** */
/* support C++ */
#ifdef __cplusplus
extern "C" {
#endif

/* *****************************************************************************




                          Common internal Macros



These are re-defined for ever `include` cycle
***************************************************************************** */

/* *****************************************************************************
Memory allocation macros
***************************************************************************** */

#if defined(FIO_MEM_RESET) || !defined(FIO_MEM_REALLOC) ||                     \
    !defined(FIO_MEM_FREE)

#undef FIO_MEM_REALLOC
#undef FIO_MEM_FREE
#undef FIO_MEM_REALLOC_IS_SAFE
#undef FIO_MEM_ALIGNMENT_SIZE
#undef FIO_MEM_RESET

/* if a global allocator was previously defined route macros to fio_malloc */
#if defined(H___FIO_MALLOC___H)
/** Reallocates memory, copying (at least) `copy_len` if necessary. */
#define FIO_MEM_REALLOC(ptr, old_size, new_size, copy_len)                     \
  fio_realloc2((ptr), (new_size), (copy_len))
/** Frees allocated memory. */
#define FIO_MEM_FREE(ptr, size) fio_free((ptr))
/** Set to true of internall allocator is used (memory returned set to zero). */
#define FIO_MEM_REALLOC_IS_SAFE fio_realloc_is_safe()
/** Detect allocator allignment dynamically. */
#define FIO_MEM_ALIGNMENT_SIZE fio_malloc_alignment()

#else /* H___FIO_MALLOC___H */
/** Reallocates memory, copying (at least) `copy_len` if necessary. */
#define FIO_MEM_REALLOC(ptr, old_size, new_size, copy_len)                     \
  realloc((ptr), (new_size))
/** Frees allocated memory. */
#define FIO_MEM_FREE(ptr, size) free((ptr))
/** Set to true of internall allocator is used (memory returned set to zero). */
#define FIO_MEM_REALLOC_IS_SAFE 0
/** Assume allocator allignment. */
#define FIO_MEM_ALIGNMENT_SIZE  sizeof(long double)
#endif /* H___FIO_MALLOC___H */

#endif /* defined(FIO_MEM_REALLOC) */

/** FIO_MEMORY_DISABLE disables all custom memory allocators. */
#if defined(FIO_MEMORY_DISABLE)
#ifndef FIO_MALLOC_TMP_USE_SYSTEM
#define FIO_MALLOC_TMP_USE_SYSTEM 1
#endif
#endif

/* recursive? */
#if !defined(FIO_MEM_REALLOC_) || !defined(FIO_MEM_FREE_)
#undef FIO_MEM_REALLOC_
#undef FIO_MEM_FREE_
#undef FIO_MEM_REALLOC_IS_SAFE_
#undef FIO_MEM_ALIGNMENT_SIZE_

#ifdef FIO_MALLOC_TMP_USE_SYSTEM /* force malloc */
#define FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)                    \
  realloc((ptr), (new_size))
#define FIO_MEM_FREE_(ptr, size) free((ptr))
#define FIO_MEM_REALLOC_IS_SAFE_ 0
#define FIO_MEM_ALIGNMENT_SIZE_  sizeof(long double)

#else /* FIO_MALLOC_TMP_USE_SYSTEM */
#define FIO_MEM_REALLOC_         FIO_MEM_REALLOC
#define FIO_MEM_FREE_            FIO_MEM_FREE
#define FIO_MEM_REALLOC_IS_SAFE_ FIO_MEM_REALLOC_IS_SAFE
#define FIO_MEM_ALIGNMENT_SIZE_  FIO_MEM_ALIGNMENT_SIZE
#endif /* FIO_MALLOC_TMP_USE_SYSTEM */

#endif /* !defined(FIO_MEM_REALLOC_)... */

/* *****************************************************************************
Locking selector
***************************************************************************** */

#ifndef FIO_USE_THREAD_MUTEX_TMP
#define FIO_USE_THREAD_MUTEX_TMP FIO_USE_THREAD_MUTEX
#endif

#if FIO_USE_THREAD_MUTEX_TMP
#define FIO_THREADS
#define FIO___LOCK_NAME          "OS mutex"
#define FIO___LOCK_TYPE          fio_thread_mutex_t
#define FIO___LOCK_INIT          ((FIO___LOCK_TYPE)FIO_THREAD_MUTEX_INIT)
#define FIO___LOCK_DESTROY(lock) fio_thread_mutex_destroy(&(lock))
#define FIO___LOCK_LOCK(lock)                                                  \
  do {                                                                         \
    if (fio_thread_mutex_lock(&(lock)))                                        \
      FIO_LOG_ERROR("Couldn't lock mutex @ %s:%d - error (%d): %s",            \
                    __FILE__,                                                  \
                    __LINE__,                                                  \
                    errno,                                                     \
                    strerror(errno));                                          \
  } while (0)
#define FIO___LOCK_TRYLOCK(lock) fio_thread_mutex_trylock(&(lock))
#define FIO___LOCK_UNLOCK(lock)                                                \
  do {                                                                         \
    if (fio_thread_mutex_unlock(&(lock))) {                                    \
      FIO_LOG_ERROR("Couldn't release mutex @ %s:%d - error (%d): %s",         \
                    __FILE__,                                                  \
                    __LINE__,                                                  \
                    errno,                                                     \
                    strerror(errno));                                          \
    }                                                                          \
  } while (0)

#else
#define FIO___LOCK_NAME          "facil.io spinlocks"
#define FIO___LOCK_TYPE          fio_lock_i
#define FIO___LOCK_INIT          ((FIO___LOCK_TYPE)FIO_LOCK_INIT)
#define FIO___LOCK_DESTROY(lock) ((lock) = FIO___LOCK_INIT)
#define FIO___LOCK_LOCK(lock)    fio_lock(&(lock))
#define FIO___LOCK_TRYLOCK(lock) fio_trylock(&(lock))
#define FIO___LOCK_UNLOCK(lock)  fio_unlock(&(lock))
#endif

/* *****************************************************************************
Recursive inclusion management
***************************************************************************** */
#ifndef SFUNC_ /* if we aren't in a recursive #include statement */

#ifdef FIO_EXTERN
#define SFUNC_
#define IFUNC_

#else /* !FIO_EXTERN */
#undef SFUNC
#undef IFUNC
#define SFUNC_ FIO_SFUNC
#define IFUNC_ FIO_IFUNC
#endif /* FIO_EXTERN */

#undef SFUNC
#undef IFUNC
#define SFUNC SFUNC_
#define IFUNC IFUNC_

#elif !defined(FIO___RECURSIVE_INCLUDE) || (FIO___RECURSIVE_INCLUDE + 1 != 100)
/* SFUNC_ - internal helper types are always `static` */
#undef SFUNC
#undef IFUNC
#define SFUNC static FIO_MAYBE_UNUSED
#define IFUNC static inline FIO_MAYBE_UNUSED
#endif /* SFUNC_ vs FIO___RECURSIVE_INCLUDE*/

/* *****************************************************************************
Leak Counter Helpers
***************************************************************************** */
#undef FIO_LEAK_COUNTER_DEF
#undef FIO_LEAK_COUNTER_ON_ALLOC
#undef FIO_LEAK_COUNTER_ON_FREE
#undef FIO_LEAK_COUNTER_COUNT

#if ((FIO_LEAK_COUNTER + 1) == 1)
/* No leak counting defined */
#define FIO_LEAK_COUNTER_DEF(name)
#define FIO_LEAK_COUNTER_ON_ALLOC(name) ((void)0)
#define FIO_LEAK_COUNTER_ON_FREE(name)  ((void)0)
#define FIO_LEAK_COUNTER_COUNT(name)    ((size_t)0)
#else
#ifndef FIO_LEAK_COUNTER_SKIP_EXIT
#define FIO_LEAK_COUNTER_SKIP_EXIT 0
#endif
#define FIO_LEAK_COUNTER_DEF      FIO___LEAK_COUNTER_DEF
#define FIO_LEAK_COUNTER_COUNT    FIO___LEAK_COUNTER_COUNT
#define FIO_LEAK_COUNTER_ON_ALLOC FIO___LEAK_COUNTER_ON_ALLOC
#define FIO_LEAK_COUNTER_ON_FREE  FIO___LEAK_COUNTER_ON_FREE
#endif

/* *****************************************************************************
Pointer Tagging
***************************************************************************** */
#ifndef FIO_PTR_TAG
/**
 * Supports embedded pointer tagging / untagging for the included types.
 *
 * Should resolve to a tagged pointer value. i.e.: ((uintptr_t)(p) | 1)
 */
#define FIO_PTR_TAG(p) (p)
#endif

#ifndef FIO_PTR_UNTAG
/**
 * Supports embedded pointer tagging / untagging for the included types.
 *
 * Should resolve to an untagged pointer value. i.e.: ((uintptr_t)(p) | ~1UL)
 */
#define FIO_PTR_UNTAG(p) (p)
#endif

/**
 * If FIO_PTR_TAG_TYPE is defined, then functions returning a type's pointer
 * will return a pointer of the specified type instead.
 */
#ifndef FIO_PTR_TAG_TYPE
#endif

#ifndef FIO_PTR_TAG_VALIDATE
/**
 * If FIO_PTR_TAG_VALIDATE is defined, tagging will be verified before executing
 * any code.
 *
 * FIO_PTR_TAG_VALIDATE must fail on NULL pointers.
 */
#define FIO_PTR_TAG_VALIDATE(ptr) ((ptr) != NULL)
#endif

#undef FIO_PTR_TAG_VALID_OR_RETURN
#define FIO_PTR_TAG_VALID_OR_RETURN(tagged_ptr, value)                         \
  do {                                                                         \
    if (!(FIO_PTR_TAG_VALIDATE((tagged_ptr)))) {                               \
      FIO_LOG_DEBUG("pointer tag (type) mismatch in function call.");          \
      return (value);                                                          \
    }                                                                          \
  } while (0)
#undef FIO_PTR_TAG_VALID_OR_RETURN_VOID
#define FIO_PTR_TAG_VALID_OR_RETURN_VOID(tagged_ptr)                           \
  do {                                                                         \
    if (!(FIO_PTR_TAG_VALIDATE((tagged_ptr)))) {                               \
      FIO_LOG_DEBUG("pointer tag (type) mismatch in function call.");          \
      return;                                                                  \
    }                                                                          \
  } while (0)
#undef FIO_PTR_TAG_VALID_OR_GOTO
#define FIO_PTR_TAG_VALID_OR_GOTO(tagged_ptr, lable)                           \
  do {                                                                         \
    if (!(FIO_PTR_TAG_VALIDATE((tagged_ptr)))) {                               \
      /* Log error since GOTO indicates cleanup or other side-effects. */      \
      FIO_LOG_ERROR("(" FIO__FILE__ ":" FIO_MACRO2STR(                         \
          __LINE__) ") pointer tag (type) mismatch in function call.");        \
      goto lable;                                                              \
    }                                                                          \
  } while (0)

#define FIO_PTR_TAG_GET_UNTAGGED(untagged_type, tagged_ptr)                    \
  ((untagged_type *)(FIO_PTR_UNTAG((tagged_ptr))))
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_LOG                /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                  Logging





Use:

```c
FIO_LOG2STDERR("message.") // => message.
FIO_LOG_LEVEL = FIO_LOG_LEVEL_WARNING; // set dynamic logging level
FIO_LOG_INFO("message"); // => [no output, exceeds logging level]
int i = 3;
FIO_LOG_WARNING("number invalid: %d", i); // => WARNING: number invalid: 3
```

Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */

/**
 * Enables logging macros that avoid heap memory allocations
 */
#if !defined(FIO_NO_LOG) && !defined(H___FIO_LOG___H) &&                       \
    (defined(FIO_LOG) || defined(FIO_LEAK_COUNTER))
#define H___FIO_LOG___H

#undef FIO_LOG2STDERR

FIO_SFUNC FIO___PRINTF_STYLE(1, 0) void FIO_LOG2STDERR(const char *format,
                                                       ...) {
#if FIO_LOG_LENGTH_LIMIT > 128
#define FIO_LOG____LENGTH_ON_STACK FIO_LOG_LENGTH_LIMIT
#define FIO_LOG____LENGTH_BORDER   (FIO_LOG_LENGTH_LIMIT - 34)
#else
#define FIO_LOG____LENGTH_ON_STACK (FIO_LOG_LENGTH_LIMIT + 34)
#define FIO_LOG____LENGTH_BORDER   FIO_LOG_LENGTH_LIMIT
#endif
  va_list argv;
  char tmp___log[FIO_LOG____LENGTH_ON_STACK + 32];
  va_start(argv, format);
  int len___log = vsnprintf(tmp___log, FIO_LOG_LENGTH_LIMIT - 2, format, argv);
  va_end(argv);
  if (len___log > 0) {
    if (len___log >= FIO_LOG_LENGTH_LIMIT - 2) {
      fio_memcpy32(tmp___log + FIO_LOG____LENGTH_BORDER,
                   "...\n\t\x1B[2mWARNING:\x1B[0m TRUNCATED!");
      len___log = FIO_LOG____LENGTH_BORDER + 32;
    }
    tmp___log[len___log++] = '\n';
    tmp___log[len___log] = '0';
    fwrite(tmp___log, 1, len___log, stderr);
    return;
  }
  fwrite("\x1B[1mERROR:\x1B[0m log output error (can't write).\n",
         1,
         47,
         stderr);
#undef FIO_LOG____LENGTH_ON_STACK
#undef FIO_LOG____LENGTH_BORDER
}

/** The logging level */
#ifndef FIO_LOG_LEVEL_DEFAULT
#if defined(DEBUG) && DEBUG
#define FIO_LOG_LEVEL_DEFAULT FIO_LOG_LEVEL_DEBUG
#else
#define FIO_LOG_LEVEL_DEFAULT FIO_LOG_LEVEL_INFO
#endif
#endif
int FIO_WEAK FIO_LOG_LEVEL = FIO_LOG_LEVEL_DEFAULT;
FIO_IFUNC int fio___log_level_set(int i) { return (FIO_LOG_LEVEL = i); }
FIO_IFUNC int fio___log_level(void) { return FIO_LOG_LEVEL; }

#undef FIO_LOG_LEVEL_GET
#undef FIO_LOG_LEVEL_SET

/** Sets the Logging Level. */
#define FIO_LOG_LEVEL_SET(new_level) fio___log_level_set(new_level)
/** Returns the Logging Level. */
#define FIO_LOG_LEVEL_GET() ((fio___log_level()))

#endif /* FIO_LOG */
#undef FIO_LOG
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                    Alternatives to memcpy, memchr etc'



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_MEMALT) && !defined(H___FIO_MEMALT___H)
#define H___FIO_MEMALT___H 1

/* *****************************************************************************
Memory Helpers - API
***************************************************************************** */

/**
 * A somewhat naive implementation of `memset`.
 *
 * Probably slower than the one included with your compiler's C library.
 */
SFUNC void *fio_memset(void *restrict dest, uint64_t data, size_t bytes);

/**
 * A somewhat naive implementation of `memcpy`.
 *
 * Probably slower than the one included with your compiler's C library.
 */
SFUNC void *fio_memcpy(void *dest_, const void *src_, size_t bytes);

/**
 * A token seeking function. This is a fallback for `memchr`, but `memchr`
 * should be faster.
 */
SFUNC void *fio_memchr(const void *buffer, const char token, size_t len);

/**
 * A comparison function. This is a fallback for `memcmp`, but `memcmp`
 * should be faster.
 */
SFUNC int fio_memcmp(const void *a_, const void *b_, size_t len);

/** An alternative to `strlen` - may raise Address Sanitation errors. */
SFUNC size_t fio_strlen(const char *str);

/* *****************************************************************************
Alternatives - Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
FIO_MEMCPY / fio_memcpy - memcpy fallback
***************************************************************************** */

/** an unsafe memcpy (no checks + assumes no overlapping memory regions)*/
FIO_SFUNC void *fio___memcpy_buffered_x(void *restrict d_,
                                        const void *restrict s_,
                                        size_t l) {
  char *restrict d = (char *restrict)d_;
  const char *restrict s = (const char *restrict)s_;
  uint64_t t[8] FIO_ALIGN(16);
  while (l > 63) {
    fio_memcpy64(t, s);
    FIO_COMPILER_GUARD_INSTRUCTION;
    fio_memcpy64(d, t);
    l -= 64;
    d += 64;
    s += 64;
  }
#define FIO___MEMCPY_UNSAFE_STEP(bytes)                                        \
  do {                                                                         \
    fio_memcpy##bytes(t, s);                                                   \
    FIO_COMPILER_GUARD_INSTRUCTION;                                            \
    fio_memcpy##bytes(d, t);                                                   \
    (d += bytes), (s += bytes);                                                \
  } while (0)
  if (l & 32)
    FIO___MEMCPY_UNSAFE_STEP(32);
  if ((l & 16))
    FIO___MEMCPY_UNSAFE_STEP(16);
  if ((l & 8))
    FIO___MEMCPY_UNSAFE_STEP(8);
  if ((l & 4))
    FIO___MEMCPY_UNSAFE_STEP(4);
  if ((l & 2))
    FIO___MEMCPY_UNSAFE_STEP(2);
#undef FIO___MEMCPY_UNSAFE_STEP
  if ((l & 1))
    *d++ = *s;

  return (void *)d;
}

/** an unsafe memcpy (no checks + assumes no overlapping memory regions)*/
FIO_SFUNC void *fio___memcpy_buffered_reversed_x(void *d_,
                                                 const void *s_,
                                                 size_t l) {
  char *d = (char *)d_ + l;
  const char *s = (const char *)s_ + l;
  uint64_t t[8] FIO_ALIGN(16);
  while (l > 63) {
    (s -= 64), (d -= 64), (l -= 64);
    fio_memcpy64(t, s);
    FIO_COMPILER_GUARD_INSTRUCTION;
    fio_memcpy64(d, t);
  }
  if ((l & 32)) {
    (d -= 32), (s -= 32);
    fio_memcpy32(t, s);
    FIO_COMPILER_GUARD_INSTRUCTION;
    fio_memcpy32(d, t);
  }
  if ((l & 16)) {
    (d -= 16), (s -= 16);
    fio_memcpy16(t, s);
    FIO_COMPILER_GUARD_INSTRUCTION;
    fio_memcpy16(d, t);
  }
  if ((l & 8)) {
    (d -= 8), (s -= 8);
    fio_memcpy8(t, s);
    FIO_COMPILER_GUARD_INSTRUCTION;
    fio_memcpy8(d, t);
  }
  if ((l & 4)) {
    (d -= 4), (s -= 4);
    fio_memcpy4(t, s);
    fio_memcpy4(d, t);
  }
  if ((l & 2)) {
    (d -= 2), (s -= 2);
    fio_memcpy2(t, s);
    fio_memcpy2(d, t);
  }
  if ((l & 1))
    *--d = *--s;
  return (void *)d;
}

#define FIO___MEMCPY_BLOCKx_NUM 255ULL

/** memcpy / memmove alternative that should work with unaligned memory */
SFUNC void *fio_memcpy(void *dest_, const void *src_, size_t bytes) {
  char *d = (char *)dest_;
  const char *s = (const char *)src_;

  if (FIO_UNLIKELY((d == s) | !bytes | !d | !s)) {
    if (bytes && (d != s))
      FIO_LOG_DEBUG2("fio_memcpy null error - ignored instruction");
    return d;
  }

  /* Fast path for small, non-overlapping copies (<=64 bytes) */
  if (bytes <= 64 && (d + bytes <= s || s + bytes <= d)) {
    if (bytes <= 8) {
      /* Handle 1-8 bytes with overlapping copies */
      if (bytes >= 4) {
        fio_memcpy4(d, s);
        fio_memcpy4(d + bytes - 4, s + bytes - 4);
      } else if (bytes >= 2) {
        fio_memcpy2(d, s);
        fio_memcpy2(d + bytes - 2, s + bytes - 2);
      } else {
        *d = *s;
      }
      return dest_;
    }
    if (bytes <= 16) {
      /* 9-16 bytes: two overlapping 8-byte copies */
      fio_memcpy8(d, s);
      fio_memcpy8(d + bytes - 8, s + bytes - 8);
      return dest_;
    }
    if (bytes <= 32) {
      /* 17-32 bytes: two overlapping 16-byte copies */
      fio_memcpy16(d, s);
      fio_memcpy16(d + bytes - 16, s + bytes - 16);
      return dest_;
    }
    /* 33-64 bytes: two overlapping 32-byte copies */
    fio_memcpy32(d, s);
    fio_memcpy32(d + bytes - 32, s + bytes - 32);
    return dest_;
  }

  /* Existing path for larger copies or overlapping memory */
  if (s + bytes <= d || d + bytes <= s ||
      (uintptr_t)d + FIO___MEMCPY_BLOCKx_NUM < (uintptr_t)s) {
    return fio___memcpy_unsafe_x(d, s, bytes);
  } else if (d < s) { /* memory overlaps at end (copy forward, use buffer) */
    return fio___memcpy_buffered_x(d, s, bytes);
  } else { /* memory overlaps at beginning, walk backwards (memmove) */
    return fio___memcpy_buffered_reversed_x(d, s, bytes);
  }
  return d;
}

#undef FIO___MEMCPY_BLOCKx_NUM

/* *****************************************************************************
FIO_MEMSET / fio_memset - memset fallbacks
***************************************************************************** */

/** an 8 byte value memset implementation. */
SFUNC void *fio_memset(void *restrict dest_, uint64_t data, size_t bytes) {
  if (FIO_UNLIKELY(!dest_))
    return NULL;
  char *d = (char *)dest_;
  if (data < 0x100) { /* if a single byte value, match memset */
    data |= (data << 8);
    data |= (data << 16);
    data |= (data << 32);
  }
  if (FIO_UNLIKELY(bytes < 32))
    goto small_memset;

  /* 32 byte groups */
  for (;;) {
    for (size_t i = 0; i < 32; i += 8) {
      fio_memcpy8(d + i, &data);
    }
    bytes -= 32;
    if (bytes < 32)
      break;
    d += 32;
  }
  /* remainder  */
  d += bytes & 31;
  data = fio_frot64(data, ((bytes & 7) << 3));
  for (size_t i = 0; i < 32; i += 8) {
    fio_memcpy8(d + i, &data);
  }
  return dest_;

small_memset:
  if (bytes & 16) {
    fio_memcpy8(d, &data);
    fio_memcpy8(d + 8, &data);
    d += 16;
  }
  if (bytes & 8) {
    fio_memcpy8(d, &data);
    d += 8;
  }
  fio_memcpy7x(d, &data, bytes);
  return dest_;
}

/* *****************************************************************************
FIO_MEMCHR / fio_memchr - memchr fallbacks
***************************************************************************** */

/* Scalar implementation - fallback for all platforms */
FIO_SFUNC void *fio___memchr_scalar(const void *buffer,
                                    const char token,
                                    size_t len) {
  const char *r = (const char *)buffer;
  const char *const end = r + len; /* absolute end of buffer */
  const char *e;
  uint64_t u[16] FIO_ALIGN(16) = {0};
  uint64_t flag = 0;
  size_t i;
  uint64_t umsk = ((uint64_t)((uint8_t)token));
  umsk |= (umsk << 32); /* make each byte in umsk == token */
  umsk |= (umsk << 16);
  umsk |= (umsk << 8);
  if (FIO_UNLIKELY(len < 128))
    goto small_memchr;
  e = end - 127; /* safe: len >= 128, so end - 127 >= r */
  while (r < e) {
    fio_memcpy128(u, r);
    for (i = 0; i < 16; ++i) {
      u[i] ^= umsk;
      flag |= (u[i] = fio_has_zero_byte64(u[i]));
    }
    if (flag)
      goto found_in_map;
    r += 128;
  }
  e = end - 7; /* process remaining 8-byte chunks */
  i = 0;
  while (r < e) {
    fio_memcpy8(u, r);
    u[0] ^= umsk;
    flag = fio_has_zero_byte64(u[0]);
    if (flag)
      goto found_in_8;
    r += 8;
  }
small_memchr:
  /* Handle remaining bytes */
  while (r < end) {
    if (*r == token)
      return (void *)r;
    ++r;
  }
  return NULL;
found_in_map:
  flag = 0;
  for (i = 0; !u[i]; ++i)
    ;
  flag = u[i];
  r += i << 3;
found_in_8:
  flag = fio_has_byte2bitmap(flag);
  return (void *)(r + fio_lsb_index_unsafe(flag));
}

/* *****************************************************************************
FIO_MEMCHR - SIMD implementations
***************************************************************************** */

#if defined(FIO___HAS_X86_INTRIN) && defined(__SSE2__)
/* SSE2 implementation - 16 bytes at a time */
FIO_SFUNC void *fio___memchr_sse2(const void *buffer,
                                  const char token,
                                  size_t len) {
  const uint8_t *r = (const uint8_t *)buffer;
  const uint8_t *e = r + len;
  /* Broadcast token to all 16 bytes */
  const __m128i needle = _mm_set1_epi8(token);

  /* Handle unaligned head - process byte by byte until aligned */
  while (((uintptr_t)r & 15) && r < e) {
    if (*r == (uint8_t)token)
      return (void *)r;
    ++r;
  }
  if (r >= e)
    return NULL;

  /* Main loop: process 64 bytes (4x16) at a time for better throughput */
  const uint8_t *e64 = e - 63;
  while (r < e64) {
    __m128i v0 = _mm_load_si128((const __m128i *)(r));
    __m128i v1 = _mm_load_si128((const __m128i *)(r + 16));
    __m128i v2 = _mm_load_si128((const __m128i *)(r + 32));
    __m128i v3 = _mm_load_si128((const __m128i *)(r + 48));
    __m128i cmp0 = _mm_cmpeq_epi8(v0, needle);
    __m128i cmp1 = _mm_cmpeq_epi8(v1, needle);
    __m128i cmp2 = _mm_cmpeq_epi8(v2, needle);
    __m128i cmp3 = _mm_cmpeq_epi8(v3, needle);
    /* Combine results to check if any match found */
    __m128i or01 = _mm_or_si128(cmp0, cmp1);
    __m128i or23 = _mm_or_si128(cmp2, cmp3);
    __m128i orall = _mm_or_si128(or01, or23);
    int mask = _mm_movemask_epi8(orall);
    if (mask) {
      /* Found a match - determine which 16-byte chunk */
      int m0 = _mm_movemask_epi8(cmp0);
      if (m0)
        return (void *)(r + __builtin_ctz(m0));
      int m1 = _mm_movemask_epi8(cmp1);
      if (m1)
        return (void *)(r + 16 + __builtin_ctz(m1));
      int m2 = _mm_movemask_epi8(cmp2);
      if (m2)
        return (void *)(r + 32 + __builtin_ctz(m2));
      int m3 = _mm_movemask_epi8(cmp3);
      return (void *)(r + 48 + __builtin_ctz(m3));
    }
    r += 64;
  }

  /* Process remaining 16-byte chunks */
  const uint8_t *e16 = e - 15;
  while (r < e16) {
    __m128i v = _mm_load_si128((const __m128i *)r);
    __m128i cmp = _mm_cmpeq_epi8(v, needle);
    int mask = _mm_movemask_epi8(cmp);
    if (mask)
      return (void *)(r + __builtin_ctz(mask));
    r += 16;
  }

  /* Handle tail bytes */
  while (r < e) {
    if (*r == (uint8_t)token)
      return (void *)r;
    ++r;
  }
  return NULL;
}
#endif /* SSE2 */

#if defined(FIO___HAS_X86_INTRIN) && defined(__AVX2__)
/* AVX2 implementation - 32 bytes at a time */
FIO_SFUNC void *fio___memchr_avx2(const void *buffer,
                                  const char token,
                                  size_t len) {
  const uint8_t *r = (const uint8_t *)buffer;
  const uint8_t *e = r + len;
  /* Broadcast token to all 32 bytes */
  const __m256i needle = _mm256_set1_epi8(token);

  /* Handle unaligned head - process byte by byte until 32-byte aligned */
  while (((uintptr_t)r & 31) && r < e) {
    if (*r == (uint8_t)token)
      return (void *)r;
    ++r;
  }
  if (r >= e)
    return NULL;

  /* Main loop: process 128 bytes (4x32) at a time for better throughput */
  const uint8_t *e128 = e - 127;
  while (r < e128) {
    __m256i v0 = _mm256_load_si256((const __m256i *)(r));
    __m256i v1 = _mm256_load_si256((const __m256i *)(r + 32));
    __m256i v2 = _mm256_load_si256((const __m256i *)(r + 64));
    __m256i v3 = _mm256_load_si256((const __m256i *)(r + 96));
    __m256i cmp0 = _mm256_cmpeq_epi8(v0, needle);
    __m256i cmp1 = _mm256_cmpeq_epi8(v1, needle);
    __m256i cmp2 = _mm256_cmpeq_epi8(v2, needle);
    __m256i cmp3 = _mm256_cmpeq_epi8(v3, needle);
    /* Combine results to check if any match found */
    __m256i or01 = _mm256_or_si256(cmp0, cmp1);
    __m256i or23 = _mm256_or_si256(cmp2, cmp3);
    __m256i orall = _mm256_or_si256(or01, or23);
    int mask = _mm256_movemask_epi8(orall);
    if (mask) {
      /* Found a match - determine which 32-byte chunk */
      int m0 = _mm256_movemask_epi8(cmp0);
      if (m0)
        return (void *)(r + __builtin_ctz(m0));
      int m1 = _mm256_movemask_epi8(cmp1);
      if (m1)
        return (void *)(r + 32 + __builtin_ctz(m1));
      int m2 = _mm256_movemask_epi8(cmp2);
      if (m2)
        return (void *)(r + 64 + __builtin_ctz(m2));
      int m3 = _mm256_movemask_epi8(cmp3);
      return (void *)(r + 96 + __builtin_ctz(m3));
    }
    r += 128;
  }

  /* Process remaining 32-byte chunks */
  const uint8_t *e32 = e - 31;
  while (r < e32) {
    __m256i v = _mm256_load_si256((const __m256i *)r);
    __m256i cmp = _mm256_cmpeq_epi8(v, needle);
    int mask = _mm256_movemask_epi8(cmp);
    if (mask)
      return (void *)(r + __builtin_ctz(mask));
    r += 32;
  }

  /* Handle tail bytes - fall through to SSE2 or scalar for remaining */
  while (r < e) {
    if (*r == (uint8_t)token)
      return (void *)r;
    ++r;
  }
  return NULL;
}
#endif /* AVX2 */

#if defined(FIO___HAS_ARM_INTRIN)
/* ARM NEON implementation - 16 bytes at a time */
FIO_SFUNC void *fio___memchr_neon(const void *buffer,
                                  const char token,
                                  size_t len) {
  const uint8_t *r = (const uint8_t *)buffer;
  const uint8_t *e = r + len;
  /* Broadcast token to all 16 bytes */
  const uint8x16_t needle = vdupq_n_u8((uint8_t)token);

  /* Handle unaligned head - process byte by byte until aligned */
  while (((uintptr_t)r & 15) && r < e) {
    if (*r == (uint8_t)token)
      return (void *)r;
    ++r;
  }
  if (r >= e)
    return NULL;

  /* Main loop: process 64 bytes (4x16) at a time for better throughput */
  const uint8_t *e64 = e - 63;
  while (r < e64) {
    uint8x16_t v0 = vld1q_u8(r);
    uint8x16_t v1 = vld1q_u8(r + 16);
    uint8x16_t v2 = vld1q_u8(r + 32);
    uint8x16_t v3 = vld1q_u8(r + 48);
    uint8x16_t cmp0 = vceqq_u8(v0, needle);
    uint8x16_t cmp1 = vceqq_u8(v1, needle);
    uint8x16_t cmp2 = vceqq_u8(v2, needle);
    uint8x16_t cmp3 = vceqq_u8(v3, needle);
    /* Combine results using OR to check if any match found */
    uint8x16_t or01 = vorrq_u8(cmp0, cmp1);
    uint8x16_t or23 = vorrq_u8(cmp2, cmp3);
    uint8x16_t orall = vorrq_u8(or01, or23);
    /* Check if any byte is non-zero (match found) */
    uint64x2_t orall64 = vreinterpretq_u64_u8(orall);
    if (vgetq_lane_u64(orall64, 0) | vgetq_lane_u64(orall64, 1)) {
      /* Found a match - determine which 16-byte chunk and position */
      uint64x2_t cmp0_64 = vreinterpretq_u64_u8(cmp0);
      if (vgetq_lane_u64(cmp0_64, 0) | vgetq_lane_u64(cmp0_64, 1)) {
        /* Match in first chunk - find exact position */
        for (size_t i = 0; i < 16; ++i)
          if (r[i] == (uint8_t)token)
            return (void *)(r + i);
      }
      uint64x2_t cmp1_64 = vreinterpretq_u64_u8(cmp1);
      if (vgetq_lane_u64(cmp1_64, 0) | vgetq_lane_u64(cmp1_64, 1)) {
        for (size_t i = 0; i < 16; ++i)
          if (r[16 + i] == (uint8_t)token)
            return (void *)(r + 16 + i);
      }
      uint64x2_t cmp2_64 = vreinterpretq_u64_u8(cmp2);
      if (vgetq_lane_u64(cmp2_64, 0) | vgetq_lane_u64(cmp2_64, 1)) {
        for (size_t i = 0; i < 16; ++i)
          if (r[32 + i] == (uint8_t)token)
            return (void *)(r + 32 + i);
      }
      for (size_t i = 0; i < 16; ++i)
        if (r[48 + i] == (uint8_t)token)
          return (void *)(r + 48 + i);
    }
    r += 64;
  }

  /* Process remaining 16-byte chunks */
  const uint8_t *e16 = e - 15;
  while (r < e16) {
    uint8x16_t v = vld1q_u8(r);
    uint8x16_t cmp = vceqq_u8(v, needle);
    uint64x2_t cmp64 = vreinterpretq_u64_u8(cmp);
    if (vgetq_lane_u64(cmp64, 0) | vgetq_lane_u64(cmp64, 1)) {
      for (size_t i = 0; i < 16; ++i)
        if (r[i] == (uint8_t)token)
          return (void *)(r + i);
    }
    r += 16;
  }

  /* Handle tail bytes */
  while (r < e) {
    if (*r == (uint8_t)token)
      return (void *)r;
    ++r;
  }
  return NULL;
}
#endif /* ARM NEON */

/**
 * A token seeking function. This is a fallback for `memchr`, but `memchr`
 * should be faster.
 */
SFUNC void *fio_memchr(const void *buffer, const char token, size_t len) {
  if (FIO_UNLIKELY(!buffer || !len))
    return NULL;
#if defined(FIO___HAS_X86_INTRIN) && defined(__AVX2__)
  return fio___memchr_avx2(buffer, token, len);
#elif defined(FIO___HAS_X86_INTRIN) && defined(__SSE2__)
  return fio___memchr_sse2(buffer, token, len);
#elif defined(FIO___HAS_ARM_INTRIN)
  return fio___memchr_neon(buffer, token, len);
#else
  return fio___memchr_scalar(buffer, token, len);
#endif
}

/* *****************************************************************************
fio_strlen - (trust the compiler to optimize)
***************************************************************************** */

/** An alternative to `strlen` - though really, strlen should be much better. */
SFUNC FIO___ASAN_AVOID size_t fio_strlen(const char *str) {
  const char *start = str;
  if (FIO_UNLIKELY(!str))
    return 0;
  for (; *str;) /* compiler, please vectorize */
    ++str;
  return (str - start);
  //   const char *r = (const char *)str;
  //   uint64_t u[16] FIO_ALIGN(16) = {0};
  //   uint64_t flag = 0;
  //   for (;;) {
  //     fio_memcpy128(u, r);
  //     for (size_t i = 0; i < 16; ++i) {
  //       flag |= (u[i] = fio_has_zero_byte64(u[i]));
  //     }
  //     if (flag)
  //       goto found_in_map;
  //     r += 128;
  //   }
  // found_in_map:
  //   flag = u[0];
  //   for (size_t i = 0; i < 7; ++i) {
  //     if (!flag) {
  //       r += 8;
  //       flag = u[i + 1];
  //     }
  //   }
  //   return ((r - str) + fio_lsb_index_unsafe(flag));
}

/* *****************************************************************************
fio_memcmp
***************************************************************************** */

/** Same as `memcmp`. Returns 1 if `a > b`, -1 if `a < b` and 0 if `a == b`. */
SFUNC int fio_memcmp(const void *a_, const void *b_, size_t len) {
  if (FIO_UNLIKELY(a_ == b_ || !len))
    return 0;
  uint64_t ua[8] FIO_ALIGN(16);
  uint64_t ub[8] FIO_ALIGN(16);
  size_t flag = 0;
  char *a = (char *)a_;
  char *b = (char *)b_;
  char *e;
  if (*a != *b)
    return (int)1 - (int)(((unsigned)b[0] > (unsigned)a[0]) << 1);
  if (FIO_UNLIKELY(len < 8))
    goto fio_memcmp_mini;
  if (FIO_UNLIKELY(len < 64))
    goto fio_memcmp_small;

  e = a + len - 63;
  do {
    fio_memcpy64(ua, a);
    fio_memcpy64(ub, b);
    for (size_t i = 0; i < 8; ++i)
      flag |= (ua[i] ^ ub[i]);
    if (flag)
      goto fio_memcmp_found;
    a += 64;
    b += 64;
  } while (a < e);
  a += len & 63;
  b += len & 63;
  a -= 64;
  b -= 64;
  fio_memcpy64(ua, a);
  fio_memcpy64(ub, b);
  for (size_t i = 0; i < 8; ++i)
    flag |= (ua[i] ^ ub[i]);
  if (flag)
    goto fio_memcmp_found;
  return 0;

fio_memcmp_found:
  if (ua[0] == ub[0])
    for (size_t i = 8; --i;)
      if (ua[i] != ub[i]) {
        ua[0] = ua[i];
        ub[0] = ub[i];
      }
  goto fio_memcmp_small_found;

fio_memcmp_small:
  e = a + len - 7;
  do {
    fio_memcpy8(ua, a);
    fio_memcpy8(ub, b);
    if (ua[0] != ub[0])
      goto fio_memcmp_small_found;
    a += 8;
    b += 8;
  } while (a < e);
  a += len & 7;
  b += len & 7;
  a -= 8;
  b -= 8;
  fio_memcpy8(ua, a);
  fio_memcpy8(ub, b);
  if (ua[0] != ub[0])
    goto fio_memcmp_small_found;
  return 0;

fio_memcmp_small_found:
  ua[0] = fio_lton64(ua[0]);
  ub[0] = fio_lton64(ub[0]);
  return (int)1 - (int)((ub[0] > ua[0]) << 1);

fio_memcmp_mini:
  switch ((len & 7)) { /* clang-format off */
    case 7: if (*a != *b) return (int)1 - (int)(((unsigned)b[0] > (unsigned)a[0]) << 1); ++a; ++b; /* fall through */
    case 6: if (*a != *b) return (int)1 - (int)(((unsigned)b[0] > (unsigned)a[0]) << 1); ++a; ++b; /* fall through */
    case 5: if (*a != *b) return (int)1 - (int)(((unsigned)b[0] > (unsigned)a[0]) << 1); ++a; ++b; /* fall through */
    case 4: if (*a != *b) return (int)1 - (int)(((unsigned)b[0] > (unsigned)a[0]) << 1); ++a; ++b; /* fall through */
    case 3: if (*a != *b) return (int)1 - (int)(((unsigned)b[0] > (unsigned)a[0]) << 1); ++a; ++b; /* fall through */
    case 2: if (*a != *b) return (int)1 - (int)(((unsigned)b[0] > (unsigned)a[0]) << 1); ++a; ++b; /* fall through */
    case 1: if (*a != *b) return (int)1 - (int)(((unsigned)b[0] > (unsigned)a[0]) << 1); ++a; ++b;
    } /* clang-format on */
  return 0;
}

/* *****************************************************************************
Alternatives - cleanup
***************************************************************************** */
#endif /* FIO_EXTERN */
#endif /* FIO_MEMALT */
#ifndef H___FIO_OS_PATCHES___H
#define H___FIO_OS_PATCHES___H
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* ************************************************************************* */

/* *****************************************************************************


Patch for OSX version < 10.12 from https://stackoverflow.com/a/9781275/4025095

Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if (defined(__MACH__) && !defined(CLOCK_REALTIME))
#warning fio_time functions defined using gettimeofday patch.
#include <sys/time.h>
#define CLOCK_REALTIME 0
#ifndef CLOCK_MONOTONIC
#define CLOCK_MONOTONIC 0
#endif
#define clock_gettime fio_clock_gettime
// clock_gettime is not implemented on older versions of OS X (< 10.12).
// If implemented, CLOCK_MONOTONIC will have already been defined.
FIO_IFUNC int fio_clock_gettime(int clk_id, struct timespec *t) {
  struct timeval now;
  int rv = gettimeofday(&now, NULL);
  if (rv)
    return rv;
  t->tv_sec = now.tv_sec;
  t->tv_nsec = now.tv_usec * 1000;
  return 0;
  (void)clk_id;
}

#endif
/* *****************************************************************************




Patches for Windows




***************************************************************************** */
#ifndef SIGKILL
#ifdef SIGABRT
#define SIGKILL SIGABRT
#endif
#endif
#if FIO_OS_WIN

/* *****************************************************************************
Windows initialization
***************************************************************************** */

/* Enable console colors */
FIO_CONSTRUCTOR(fio___windows_startup_housekeeping) {
  HANDLE c = GetStdHandle(STD_OUTPUT_HANDLE);
  if (c) {
    DWORD mode = 0;
    if (GetConsoleMode(c, &mode)) {
      mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(c, mode);
    }
  }
  c = GetStdHandle(STD_ERROR_HANDLE);
  if (c) {
    DWORD mode = 0;
    if (GetConsoleMode(c, &mode)) {
      mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(c, mode);
    }
  }
  /* by default, windows read files using _O_TEXT, which affects behavior */
  _set_fmode(_O_BINARY);
}

/* *****************************************************************************
Inlined patched and MACRO statements
***************************************************************************** */

#ifndef __MINGW32__
/** patch for strcasecmp */
FIO_IFUNC int strcasecmp(const char *s1, const char *s2) {
  return _stricmp(s1, s2);
}
/** patch for write */
FIO_IFUNC int write(int fd, const void *b, unsigned int l) {
  return _write(fd, b, l);
}
/** patch for read */
FIO_IFUNC int read(int const fd, void *const b, unsigned const l) {
  return _read(fd, b, l);
}
/** patch for clock_gettime */
FIO_SFUNC int clock_gettime(const uint32_t clk_type, struct timespec *tv);
#endif /* __MINGW32__ */

/** patch for pwrite */
FIO_SFUNC ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

#ifndef O_APPEND
#define O_APPEND      _O_APPEND
#define O_BINARY      _O_BINARY
#define O_CREAT       _O_CREAT
#define O_CREAT       _O_CREAT
#define O_SHORT_LIVED _O_SHORT_LIVED
#define O_CREAT       _O_CREAT
#define O_TEMPORARY   _O_TEMPORARY
#define O_CREAT       _O_CREAT
#define O_EXCL        _O_EXCL
#define O_NOINHERIT   _O_NOINHERIT
#define O_RANDOM      _O_RANDOM
#define O_RDONLY      _O_RDONLY
#define O_RDWR        _O_RDWR
#define O_SEQUENTIAL  _O_SEQUENTIAL
#define O_TEXT        _O_TEXT
#define O_TRUNC       _O_TRUNC
#define O_WRONLY      _O_WRONLY
#define O_U16TEXT     _O_U16TEXT
#define O_U8TEXT      _O_U8TEXT
#define O_WTEXT       _O_WTEXT
#endif /* O_APPEND */

#ifndef S_IWUSR
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IRUSR  _S_IREAD
#define S_IWUSR  _S_IWRITE
#define S_IRWXO  (_S_IREAD | _S_IWRITE)
#define S_IRWXG  (_S_IREAD | _S_IWRITE)
#define S_IRWXU  (_S_IREAD | _S_IWRITE)
#endif /* S_IWUSR */

#ifndef O_TMPFILE
#define O_TMPFILE O_TEMPORARY
#endif

#if defined(CLOCK_REALTIME) && defined(CLOCK_MONOTONIC) &&                     \
    CLOCK_REALTIME == CLOCK_MONOTONIC
#undef CLOCK_MONOTONIC
#undef CLOCK_REALTIME
#endif

#ifndef CLOCK_REALTIME
#ifdef CLOCK_MONOTONIC
#define CLOCK_REALTIME (CLOCK_MONOTONIC + 1)
#else
#define CLOCK_REALTIME 0
#endif
#endif

#ifndef CLOCK_MONOTONIC
#define CLOCK_MONOTONIC 1
#endif

#ifndef PATH_MAX
#ifdef MAX_PATH
#define PATH_MAX MAX_PATH
#else /* although this value is usually (in practice) 256 + 4, we go big. */
#define PATH_MAX 1024
#endif
#endif

#if !defined(fstat)
#define fstat _fstat
#endif /* fstat */
#if !defined(stat)
#define stat _stat
#endif /* stat */
#if !defined(lseek)
#define lseek _lseeki64
#endif /* lseek */
#if !defined(unlink)
#define unlink _unlink
#endif /* unlink */

#if !FIO_HAVE_UNIX_TOOLS || defined(__MINGW32__)
#define pipe(fds) _pipe(fds, 65536, _O_BINARY)
#endif

/* *****************************************************************************
Patched function Implementation
***************************************************************************** */

#ifndef __MINGW32__
/* based on:
 * https://stackoverflow.com/questions/5404277/porting-clock-gettime-to-windows
 */
/** patch for clock_gettime */
FIO_SFUNC int clock_gettime(const uint32_t clk_type, struct timespec *tv) {
  if (!tv)
    return -1;
  static union {
    uint64_t u;
    LARGE_INTEGER li;
  } freq = {.u = 0};
  static double tick2n = 0;
  union {
    uint64_t u;
    FILETIME ft;
    LARGE_INTEGER li;
  } tu;

  switch (clk_type) {
  case CLOCK_REALTIME:
  realtime_clock:
    GetSystemTimePreciseAsFileTime(&tu.ft);
    tv->tv_sec = tu.u / 10000000;
    tv->tv_nsec = tu.u - (tv->tv_sec * 10000000);
    return 0;

#ifdef CLOCK_PROCESS_CPUTIME_ID
  case CLOCK_PROCESS_CPUTIME_ID:
#endif
#ifdef CLOCK_THREAD_CPUTIME_ID
  case CLOCK_THREAD_CPUTIME_ID:
#endif
  case CLOCK_MONOTONIC:
    if (!QueryPerformanceCounter(&tu.li))
      goto realtime_clock;
    if (!freq.u)
      QueryPerformanceFrequency(&freq.li);
    if (!freq.u) {
      tick2n = 0;
      freq.u = 1;
    } else {
      tick2n = (double)1000000000 / freq.u;
    }
    tv->tv_sec = tu.u / freq.u;
    tv->tv_nsec =
        (uint64_t)(0ULL + ((double)(tu.u - (tv->tv_sec * freq.u)) * tick2n));
    return 0;
  }
  return -1;
}
#endif /* __MINGW32__ */

/** patch for pwrite */
FIO_SFUNC ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset) {
  /* Credit to Jan Biedermann (GitHub: @janbiedermann) */
  ssize_t bytes_written = 0;
  HANDLE handle = (HANDLE)_get_osfhandle(fd);
  if (handle == INVALID_HANDLE_VALUE)
    goto bad_file;
  OVERLAPPED overlapped = {0};
  if (offset > 0)
    overlapped.Offset = offset;
  if (WriteFile(handle, buf, count, (u_long *)&bytes_written, &overlapped))
    return bytes_written;
  errno = EIO;
  return -1;
bad_file:
  errno = EBADF;
  return -1;
}

/* *****************************************************************************



Patches for POSIX



***************************************************************************** */
#elif FIO_OS_POSIX /* POSIX patches */
#endif

/* *****************************************************************************
Done with Patches
***************************************************************************** */
#endif /* H___FIO_OS_PATCHES___H */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_ATOL               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                            String <=> Number helpers



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_ATOL) && !defined(H___FIO_ATOL___H)
#define H___FIO_ATOL___H
#include <inttypes.h>
#include <math.h>

#ifndef FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER
#define FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER 1
#endif

/* *****************************************************************************
Strings to Signed Numbers - The fio_aton function
***************************************************************************** */

/** Result type for fio_aton */
typedef struct {
  union {
    int64_t i;
    double f;
    uint64_t u;
  };
  int is_float;
  int err;
} fio_aton_s;

/**
 * Converts a String to a number - either an integer or a float (double).
 *
 * Skips white space at the beginning of the string.
 *
 * Auto detects binary and hex formats when prefix is provided (0x / 0b).
 *
 * Auto detects octal when number starts with zero.
 *
 * Auto detects the Strings "inf", "infinity" and "nan" as float values.
 *
 * The number's format and type are returned in the return type.
 *
 * If a numerical overflow or format error occurred, the `.err` flag is set.
 *
 * Note: rounding errors may occur, as this is not an `strtod` exact match.
 */
FIO_SFUNC fio_aton_s fio_aton(char **pstr);

/* *****************************************************************************
Strings to Signed Numbers - API
***************************************************************************** */
/**
 * A helper function that converts between String data to a signed int64_t.
 *
 * Numbers are assumed to be in base 10. Octal (`0###`), Hex (`0x##`/`x##`) and
 * binary (`0b##`/ `b##`) are recognized as well. For binary Most Significant
 * Bit must come first.
 *
 * The most significant difference between this function and `strtol` (aside of
 * API design), is the added support for binary representations.
 */
SFUNC int64_t fio_atol(char **pstr);

/** A helper function that converts between String data to a signed double. */
SFUNC double fio_atof(char **pstr);

/* *****************************************************************************
Signed Numbers to Strings - API
***************************************************************************** */

/**
 * A helper function that writes a signed int64_t to a string.
 *
 * No overflow guard is provided, make sure there's at least 68 bytes available
 * (for base 2).
 *
 * Offers special support for base 2 (binary), base 8 (octal), base 10 and base
 * 16 (hex) where prefixes are automatically added if required (i.e.,`"0x"` for
 * hex and `"0b"` for base 2, and `"0"` for octal).
 *
 * Supports any base up to base 36 (using 0-9,A-Z).
 *
 * An unsupported base will log an error and print zero.
 *
 * Returns the number of bytes actually written (excluding the NUL terminator).
 */
SFUNC size_t fio_ltoa(char *dest, int64_t num, uint8_t base);

/**
 * A helper function that converts between a double to a string.
 *
 * No overflow guard is provided, make sure there's at least 130 bytes
 * available (for base 2).
 *
 * Supports base 2, base 10 and base 16. An unsupported base will silently
 * default to base 10. Prefixes aren't added (i.e., no "0x" or "0b" at the
 * beginning of the string).
 *
 * Returns the number of bytes actually written (excluding the NUL
 * terminator).
 */
SFUNC size_t fio_ftoa(char *dest, double num, uint8_t base);

/* *****************************************************************************
Unsigned Numbers, Building Blocks and Helpers
***************************************************************************** */
/**
 * Maps characters to alphanumerical value, where numbers have their natural
 * values (0-9) and `A-Z` (or `a-z`) are the values 10-35.
 *
 * Out of bound values return 255.
 *
 * This allows parsing of numeral strings for up to base 36.
 */
IFUNC uint8_t fio_c2i(unsigned char c);

/**
 * Maps numeral values to alphanumerical characters, where numbers have their
 * natural values (0-9) and `A-Z` are the values 10-35.
 *
 * Accepts values up to 63. Returns zero for values over 35. Out of bound values
 * produce undefined behavior.
 *
 * This allows printing of numerals for up to base 36.
 */
IFUNC uint8_t fio_i2c(unsigned char i);

/** Returns the number of digits in base 10. */
FIO_IFUNC size_t fio_digits10(int64_t i);
/** Returns the number of digits in base 10 for an unsigned number. */
FIO_SFUNC size_t fio_digits10u(uint64_t i);

/** Returns the number of digits in base 8 for an unsigned number. */
FIO_SFUNC size_t fio_digits8u(uint64_t i);
/** Returns the number of digits in base 16 for an unsigned number. */
FIO_SFUNC size_t fio_digits16u(uint64_t i);
/** Returns the number of digits in base 2 for an unsigned number. */
FIO_SFUNC size_t fio_digits_bin(uint64_t i);
/** Returns the number of digits in any base X<65 for an unsigned number. */
FIO_SFUNC size_t fio_digits_xbase(uint64_t i, size_t base);

/** Writes a signed number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa10(char *dest, int64_t i, size_t digits);
/** Reads a signed base 10 formatted number. */
SFUNC int64_t fio_atol10(char **pstr);

/** Writes unsigned number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa10u(char *dest, uint64_t i, size_t digits);
/** Writes unsigned number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa16u(char *dest, uint64_t i, size_t digits);
/** Writes unsigned number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa_bin(char *dest, uint64_t i, size_t digits);
/** Writes unsigned number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa_xbase(char *dest,
                              uint64_t i,
                              size_t digits,
                              size_t base);

/** Reads a signed base 8 formatted number. */
SFUNC uint64_t fio_atol8u(char **pstr);
/** Reads a signed base 10 formatted number. */
SFUNC uint64_t fio_atol10u(char **pstr);
/** Reads an unsigned hex formatted number (possibly prefixed with "0x"). */
SFUNC uint64_t fio_atol16u(char **pstr);
/** Reads an unsigned binary formatted number (possibly prefixed with "0b"). */
SFUNC uint64_t fio_atol_bin(char **pstr);
/** Read an unsigned number in any base up to base 36. */
SFUNC uint64_t fio_atol_xbase(char **pstr, size_t base);

/** Converts an unsigned `val` to a signed `val`, with overflow protection. */
FIO_IFUNC int64_t fio_u2i_limit(uint64_t val, size_t invert);

/* *****************************************************************************
IEEE 754 Floating Points, Building Blocks and Helpers
***************************************************************************** */

/** Converts a 64 bit integer to an IEEE 754 formatted double. */
FIO_IFUNC double fio_i2d(int64_t mant, int64_t exponent_in_base_2);

/** Converts a 64 bit unsigned integer to an IEEE 754 formatted double. */
FIO_IFUNC double fio_u2d(uint64_t mant, int64_t exponent_in_base_2);

/* *****************************************************************************
Big Numbers
***************************************************************************** */

/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u128 fio_u128_hex_read(char **pstr);
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u256 fio_u256_hex_read(char **pstr);
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u512 fio_u512_hex_read(char **pstr);
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u1024 fio_u1024_hex_read(char **pstr);
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u2048 fio_u2048_hex_read(char **pstr);
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u4096 fio_u4096_hex_read(char **pstr);

/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u128_hex_write(char *dest, const fio_u128 *);
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u256_hex_write(char *dest, const fio_u256 *);
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u512_hex_write(char *dest, const fio_u512 *);
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u1024_hex_write(char *dest, const fio_u1024 *);
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u2048_hex_write(char *dest, const fio_u2048 *);
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u4096_hex_write(char *dest, const fio_u4096 *);

/* *****************************************************************************


Implementation - inlined


***************************************************************************** */

/** Returns the number of digits in base 10. */
FIO_IFUNC size_t fio_digits10(int64_t i) {
  if (i >= 0)
    return fio_digits10u(i);
  return fio_digits10u((0ULL - (uint64_t)i)) + 1;
}

/** Returns the number of digits in base 2 for an unsigned number. */
FIO_SFUNC size_t fio_digits_bin(uint64_t i) {
  size_t r = 1;
  if (!i)
    return r;
  r = fio_msb_index_unsafe(i) + 1;
  r += (r & 1); /* binary is written 2 zeros at a time */
  return r;
}

/** Returns the number of digits in base 8 for an unsigned number. */
FIO_SFUNC size_t fio_digits8u(uint64_t i) {
  size_t r = 1;
  for (;;) {
    if (i < 8)
      return r;
    if (i < 64)
      return r + 1;
    if (i < 512)
      return r + 2;
    if (i < 4096)
      return r + 3;
    if (i < 32768)
      return r + 4;
    if (i < 262144)
      return r + 5;
    if (i < 2097152)
      return r + 6;
    if (i < 16777216)
      return r + 7;
    r += 8;
    i >>= 24;
  }
}

/** Returns the number of digits in base 10 for an unsigned number. */
FIO_SFUNC size_t fio_digits10u(uint64_t i) {
  size_t r = 1;
  for (;;) {
    if (i < 10ULL)
      return r;
    if (i < 100ULL)
      return r + 1;
    if (i < 1000ULL)
      return r + 2;
    if (i < 10000ULL)
      return r + 3;
    r += 4;
    i /= 10000ULL;
  }
}

/** Returns the number of digits in base 16 for an unsigned number. */
FIO_SFUNC size_t fio_digits16u(uint64_t i) {
  if (i < 0x100ULL)
    return 2;
  if (i < 0x10000ULL)
    return 4;
  if (i < 0x1000000ULL)
    return 6;
  if (i < 0x100000000ULL)
    return 8;
  if (i < 0x10000000000ULL)
    return 10;
  if (i < 0x1000000000000ULL)
    return 12;
  if (i < 0x100000000000000ULL)
    return 14;
  return 16;
}

/** Returns the number of digits in base X<65 for an unsigned number. */
FIO_SFUNC size_t fio_digits_xbase(uint64_t i, size_t base) {
  size_t base2 = base * base;
  size_t base3 = base2 * base;
  size_t base4 = base3 * base;
  size_t r = 1;
  for (;;) {
    if (i < base)
      return r;
    if (i < base2)
      return r + 1;
    if (i < base3)
      return r + 2;
    if (i < base4)
      return r + 3;
    r += 4;
    i /= base4;
  }
}

FIO_IFUNC void fio_ltoa10(char *dest, int64_t i, size_t digits) {
  size_t inv = i < 0;
  dest[0] = '-';
  dest += inv;
  if (inv)
    i = (int64_t)((uint64_t)0 - (uint64_t)i);
  fio_ltoa10u(dest, (uint64_t)i, digits - inv);
}

FIO_IFUNC void fio_ltoa8u(char *dest, uint64_t i, size_t digits) {
  dest += digits;
  *dest-- = 0;
  while (i > 7) {
    *dest-- = '0' + (i & 7);
    i >>= 3;
  }
  *dest = '0' + i;
}

FIO_IFUNC void fio_ltoa10u(char *dest, uint64_t i, size_t digits) {
  dest += digits;
  *dest-- = 0;
  while (i > 9) {
    uint64_t nxt = i / 10;
    *dest-- = '0' + (i - (nxt * 10ULL));
    i = nxt;
  }
  *dest = '0' + (unsigned char)i;
}

FIO_IFUNC void fio_ltoa16u(char *dest, uint64_t i, size_t digits) {
  digits += (digits & 1U); /* force even number of digits */
  dest += digits;
  *dest-- = 0;
  while (digits) {
    digits -= 2;
    *dest-- = fio_i2c(i & 15);
    i >>= 4;
    *dest-- = fio_i2c(i & 15);
    i >>= 4;
  }
}

FIO_IFUNC void fio_ltoa_bin(char *dest, uint64_t i, size_t digits) {
  dest += digits;
  *dest = 0;
  switch (digits & 7) {
  case 7: *--dest = '0' + (i & 1); i >>= 1; /* fall through */
  case 6: *--dest = '0' + (i & 1); i >>= 1; /* fall through */
  case 5: *--dest = '0' + (i & 1); i >>= 1; /* fall through */
  case 4: *--dest = '0' + (i & 1); i >>= 1; /* fall through */
  case 3: *--dest = '0' + (i & 1); i >>= 1; /* fall through */
  case 2: *--dest = '0' + (i & 1); i >>= 1; /* fall through */
  case 1: *--dest = '0' + (i & 1); i >>= 1; /* fall through */
  case 0:;
  }
  digits &= ~(uint64_t)7ULL;
  while (digits > 7) {
    uint64_t tmp = (i & 0xFFULL);
    dest -= 8;
    digits -= 8;
    i >>= 8;
    tmp = ((tmp & 0x7F) * 0x02040810204081ULL) | ((tmp & 0x80) << 49);
    tmp &= 0x0101010101010101ULL;
    tmp += (0x0101010101010101ULL * '0');
    fio_u2buf64_be(dest, tmp);
  }
}

FIO_IFUNC void fio_ltoa_xbase(char *dest,
                              uint64_t i,
                              size_t digits,
                              size_t base) {
  dest += digits;
  *dest-- = 0;
  while (i >= base) {
    uint64_t nxt = i / base;
    *dest-- = fio_i2c(i - (nxt * base));
    i = nxt;
  }
  *dest = fio_i2c(i);
}

/** Converts an unsigned `val` to a signed `val`, with overflow protection. */
FIO_IFUNC int64_t fio_u2i_limit(uint64_t val, size_t to_negative) {
  if (!to_negative) {
    /* overflow? */
    if (!(val & 0x8000000000000000ULL))
      return val;
    errno = E2BIG;
    val = 0x7FFFFFFFFFFFFFFFULL;
    return val;
  }
  if (!(val & 0x8000000000000000ULL)) {
    val = (int64_t)0LL - (int64_t)val;
    return val;
  }
  /* read overflow */
  errno = E2BIG;
  return (int64_t)(val = 0x8000000000000000ULL);
}

/* *****************************************************************************
IEEE 754 Floating Points, Building Blocks and Helpers
***************************************************************************** */

#ifndef FIO_MATH_DBL_MANT_MASK
#define FIO_MATH_DBL_MANT_MASK (((uint64_t)1ULL << 52) - 1)
#define FIO_MATH_DBL_EXPO_MASK ((uint64_t)2047ULL << 52)
#define FIO_MATH_DBL_SIGN_MASK ((uint64_t)1ULL << 63)
#endif

FIO_IFUNC int fio_d2expo(double d) {
  int r;
  union {
    uint64_t u64;
    double d;
  } u = {.d = d};
  u.u64 &= FIO_MATH_DBL_EXPO_MASK;
  r = (int)(u.u64 >> 52);
  r -= 1023;
  r *= -1;
  return r;
}

/** Converts a 64 bit integer to an IEEE 754 formatted double. */
FIO_IFUNC double fio_u2d(uint64_t mant, int64_t exponent) {
#ifndef FIO___ATON_TIE2EVEN
  /* If set, performs a rounding attempt with tie to even */
#define FIO___ATON_TIE2EVEN 0
#endif
  union {
    uint64_t u64;
    double d;
  } u = {0};
  size_t msbi;
  if (!mant)
    return u.d;
  msbi = fio_msb_index_unsafe(mant);
  if (FIO___ATON_TIE2EVEN && FIO_UNLIKELY(msbi > 52)) { /* losing precision */
    bool not53 = (msbi != 53);
    bool far_set = ((mant >> (53 + not53)) != 0);
    mant = mant >> (msbi - (53 + not53));
    mant |= far_set;
    mant |= (mant >> (1U + not53)) & 1; /* set the non-even bit as rounder */
    mant += 1; /* 1 will propagate if rounding is necessary. */
    bool add_to_expo = (mant >> (53U + not53)) & 1;
    mant >>= (1U + not53 + add_to_expo);
    exponent += add_to_expo;
  }
  /* normalize exponent */
  exponent += msbi + 1023;
  if (FIO_UNLIKELY(exponent > 2047))
    goto is_inifinity_or_nan;
  if (FIO_UNLIKELY(exponent <= 0))
    goto is_subnormal;
  exponent = (uint64_t)exponent << 52;
  u.u64 |= exponent;
  /* reposition mant bits so we "hide" the fist set bit in bit[52] */
  if (msbi < 52)
    mant = mant << (52 - msbi);
  else if (!FIO___ATON_TIE2EVEN &&
           FIO_UNLIKELY(msbi > 52)) /* losing precision */
    mant = mant >> (msbi - 52);
  u.u64 |= mant & FIO_MATH_DBL_MANT_MASK; /* remove the 1 set bit */
  return u.d;

is_inifinity_or_nan:
  u.u64 = FIO_MATH_DBL_EXPO_MASK;
  return u.d;

is_subnormal:
  exponent += 51 - msbi;
  if (exponent < 0)
    return u.d;
  u.u64 = mant >> exponent;
  return u.d;
}

/** Converts a 64 bit integer to an IEEE 754 formatted double. */
FIO_IFUNC double fio_i2d(int64_t mant, int64_t exponent) {
  union {
    uint64_t u64;
    int64_t i64;
    double d;
  } u = {.i64 = mant};
  bool sign = (u.i64 < 0);
  if (sign)
    u.i64 = -u.i64;
  u.d = fio_u2d(u.u64, exponent);
  u.u64 |= ((uint64_t)sign) << 63;
  return u.d;
}

/* *****************************************************************************
Implementation - possibly externed
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Unsigned core and helpers
***************************************************************************** */

/**
 * Maps characters to alphanumerical value, where numbers have their natural
 * values (0-9) and `A-Z` (or `a-z`) are the values 10-35.
 *
 * Out of bound values return 255.
 *
 * This allows parsing of numeral strings for up to base 36.
 */
IFUNC uint8_t fio_c2i(unsigned char c) {
  static const uint8_t fio___alphanumeric_map[256] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   255, 255,
      255, 255, 255, 255, 255, 10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
      20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,
      35,  255, 255, 255, 255, 255, 255, 10,  11,  12,  13,  14,  15,  16,  17,
      18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,
      33,  34,  35,  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255};
  return fio___alphanumeric_map[c];
}

/**
 * Maps numeral values to alphanumerical characters, where numbers have their
 * natural values (0-9) and `A-Z` are the values 10-35.
 *
 * Accepts values up to 63. Returns zero for values over 35. Out of bound values
 * produce undefined behavior.
 *
 * This allows printing of numerals for up to base 36.
 */
IFUNC uint8_t fio_i2c(unsigned char i) {
  static const uint8_t fio___alphanumeric_map[64] = {
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B',
      'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
      'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
  return fio___alphanumeric_map[i & 63];
}

/** Reads a signed base 8 formatted number. */
SFUNC uint64_t fio_atol8u(char **pstr) {
  uint64_t r = 0;
  size_t d;
  while ((d = (size_t)fio_c2i((unsigned char)(**pstr))) < 8) {
    r <<= 3;
    r |= d;
    ++*pstr;
    if ((r & UINT64_C(0xE000000000000000)))
      break;
#if FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER
    *pstr += (**pstr == '_'); /* allow '_' as a divider. */
#endif
  }
  if ((fio_c2i(**pstr)) < 8)
    errno = E2BIG;
  return r;
}

/** Reads an unsigned base 10 formatted number. */
SFUNC uint64_t fio_atol10u(char **pstr) {
  uint64_t r = 0, u0 = 0, u1 = 0;
  char *pos = *pstr;
  /* can't use SIMD, as we don't want to overflow. */
  for (size_t i = 0; i < 8; ++i)
    u0 += ((pos[u0] >= '0') & (pos[u0] <= '9'));
  switch ((u0 & 12)) { /* now we are safe to copy all bytes validated */
  case 8:
    r = fio_buf2u64_le(pos);
    *pstr = (pos += 8); /* credit Johnny Lee, not mine... */
    r = ((r & 0x0F0F0F0F0F0F0F0FULL) * 2561ULL) >> 8;
    r = ((r & 0x00FF00FF00FF00FFULL) * 6553601ULL) >> 16;
    r = ((r & 0x0000FFFF0000FFFFULL) * 42949672960001ULL) >> 32;
    u1 = r; /* https://johnnylee-sde.github.io/Fast-numeric-string-to-int/ */
    break;
  case 4:
    r = ((unsigned)(pos[0] - '0') * 1000) + ((unsigned)(pos[1] - '0') * 100) +
        ((unsigned)(pos[2] - '0') * 10) + (unsigned)(pos[3] - '0');
    *pstr = (pos += 4);
    u1 = r;
    break;
  }

  u0 = (uint64_t)(pos[0] - '0');
  if (u0 > 9ULL)
    return r;
  r *= 10;
  for (;;) {
    r += u0;
    if (r < u1)
      goto value_overflow;
    ++pos;
#if FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER
    pos += (*pos == '_'); /* allow '_' as a divider. */
#endif
    u0 = (uint64_t)(pos[0] - '0');
    if (u0 > 9ULL)
      break;
    if (r > ((~(uint64_t)0ULL) / 10))
      goto value_overflow_stepback;
    u1 = r;
    r *= 10;
  }
  *pstr = pos;
  return r;

value_overflow_stepback:
  --pos;
value_overflow:
  r = u1;
  errno = E2BIG;
  *pstr = pos;
  return r;
}

/** Reads a signed base 10 formatted number. */
SFUNC int64_t fio_atol10(char **pstr) {
  // const uint64_t add_limit = (~(uint64_t)0ULL) - 9;
  char *pos = *pstr;
  const size_t inv = (pos[0] == '-');
  pos += inv;
  // uint64_t val = 0;
  // uint64_t r0;
  // while (((r0 = pos[0] - '0') < 10ULL) & (val < add_limit)) {
  //   val *= 10;
  //   val += r0;
  //   ++pos;
  // }
  // if (((size_t)(pos[0] - '0') < 10ULL)) {
  //   errno = E2BIG;
  // }
  *pstr = pos;
  uint64_t val = fio_atol10u(pstr);
  if (((size_t)(**pstr - '0') < 10ULL))
    errno = E2BIG;
  return fio_u2i_limit(val, inv);
}

/** Reads an unsigned hex formatted number (possibly prefixed with "0x"). */
FIO_IFUNC uint64_t fio___atol16u_with_prefix(uint64_t r, char **pstr) {
  size_t d;
  unsigned char *p = (unsigned char *)*pstr;
  p += ((p[0] == '0') & ((p[1] | 32) == 'x')) << 1;
  if ((d = fio_c2i(*p)) > 15)
    goto possible_misread;
  for (;;) {
    r |= d;
    ++p;
    d = (size_t)fio_c2i(*p);
    if (d > 15)
      break;
    if ((r & UINT64_C(0xF000000000000000))) {
      errno = E2BIG;
      break;
    }
    r <<= 4;
#if FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER
    p += (*p == '_'); /* allow '_' as a divider. */
#endif
  }
  *pstr = (char *)p;
  return r;
possible_misread:
  /* if 0x was read, move to X. */
  *pstr += ((pstr[0][0] == '0') & ((pstr[0][1] | 32) == 'x'));
  return r;
}

/** Reads an unsigned hex formatted number (possibly prefixed with "0x"). */
SFUNC uint64_t fio_atol16u(char **pstr) {
  uint64_t r = 0;
  size_t d;
  unsigned char *p = (unsigned char *)*pstr;
  p += ((p[0] == '0') & ((p[1] | 32) == 'x')) << 1;
  if ((d = fio_c2i(*p)) > 15)
    goto possible_misread;
  for (;;) {
    r |= d;
    ++p;
    d = (size_t)fio_c2i(*p);
    if (d > 15)
      break;
    if ((r & UINT64_C(0xF000000000000000))) {
      errno = E2BIG;
      break;
    }
    r <<= 4;
#if FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER
    p += (*p == '_'); /* allow '_' as a divider. */
#endif
  }
  *pstr = (char *)p;
  return r;
possible_misread:
  /* if 0x was read, move to X. */
  *pstr += ((pstr[0][0] == '0') & ((pstr[0][1] | 32) == 'x'));
  return r;
}

/** Reads an unsigned binary formatted number (possibly prefixed with "0b"). */
SFUNC FIO___ASAN_AVOID uint64_t fio_atol_bin(char **pstr) {
  uint64_t r = 0;
  *pstr += (**pstr == '0');
  *pstr += (**pstr | 32) == 'b' && (((size_t)(pstr[0][1]) - (size_t)'0') < 2);
#if (defined(FIO___ASAN_DETECTED) && FIO___ASAN_DETECTED) || 1
  for (;;) { /* Prevent safe overflow of allocated memory region */
    if ((r & UINT64_C(0x8000000000000000)))
      break;
    size_t len = 0;
    union {
      uint64_t u64;
      uint32_t u32;
    } u;
    for (size_t i = 0; i < 8; ++i)
      len += (((size_t)pstr[0][len] - (size_t)'0') < 2);
    if (!len)
      goto done;
    switch (len & 12) {
    case 8:
      if ((r & UINT64_C(0xFF00000000000000)))
        break; /* from switch */
      u.u64 = fio_buf2u64_be(*pstr);
      u.u64 -= 0x0101010101010101ULL * '0';
      u.u64 |= u.u64 >> 7;
      u.u64 |= u.u64 >> 14;
      u.u64 |= u.u64 >> 28;
      u.u64 &= 0xFF;
      r <<= 8;
      r |= u.u64;
      *pstr += 8;
      continue;
    case 4:
      if ((r & UINT64_C(0xF000000000000000)))
        break; /* from switch */
      u.u32 = fio_buf2u32_be(*pstr);
      u.u32 -= (0x01010101UL * '0');
      u.u32 |= u.u32 >> 7;
      u.u32 |= u.u32 >> 14;
      u.u32 &= 0x0F;
      r <<= 4;
      r |= u.u32;
      *pstr += 4;
      continue;
    }
    while ((len = (size_t)((unsigned char)(**pstr)) - (size_t)'0') < 2) {
      r <<= 1;
      r |= len;
      ++*pstr;
      if ((r & UINT64_C(0x8000000000000000)))
        break;
    }
#if FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER
    if ((**pstr == '_') | (**pstr == '.')) { /* allow as a dividers */
      ++*pstr;
      continue;
    }
#endif
    break;
  }
done:
#else
  size_t d;
  for (; (((uintptr_t)*pstr & 4095) < 4089);) { /* respect page boundary */
    uint64_t tmp = fio_buf2u64_be(*pstr);       /* may overflow */
    tmp -= 0x0101010101010101ULL * '0';         /* was it all `0`s and `1`s? */
    if (tmp & (~0x0101010101010101ULL))         /* if note, break. */
      break;
    tmp |= tmp >> 7;
    tmp |= tmp >> 14;
    tmp |= tmp >> 28;
    tmp &= 0xFF;
    r <<= 8;
    r |= tmp;
    *pstr += 8;
    if ((r & UINT64_C(0xFF00000000000000)))
      break;
  }
  while ((d = (size_t)((unsigned char)(**pstr)) - (size_t)'0') < 2) {
    r <<= 1;
    r |= d;
    ++*pstr;
    if ((r & UINT64_C(0x8000000000000000)))
      break;
#if FIO_ATOL_ALLOW_UNDERSCORE_DIVIDER
    *pstr += (**pstr == '_') | (**pstr == '.'); /* allow as a dividers */
#endif
  }
#endif
  if (((size_t)(**pstr) - (size_t)'0') < 2)
    errno = E2BIG;
  return r;
}

/** Attempts to read an unsigned number in any base up to base 36. */
SFUNC uint64_t fio_atol_xbase(char **pstr, size_t base) {
  uint64_t r = 0;
  if (base > 36)
    return r;
  if (base == 10)
    return (r = fio_atol10u(pstr));
  if (base == 16)
    return (r = fio_atol16u(pstr));
  if (base == 2)
    return (r = fio_atol_bin(pstr));
  const uint64_t limit = (~UINT64_C(0)) / base;
  size_t d;
  while ((d = (size_t)fio_c2i((unsigned char)(**pstr))) < base) {
    r *= base;
    r += d;
    ++*pstr;
    if (r > limit)
      break;
  }
  if ((fio_c2i(**pstr)) < base)
    errno = E2BIG;
  return r;
}

/* *****************************************************************************
fio_atol
***************************************************************************** */

SFUNC int64_t FIO___ASAN_AVOID fio_atol(char **pstr) {
  /* note: sanitizer avoided due to possible 8 byte overflow within mem-page */
  static uint64_t (*const fn[])(char **) = {
      fio_atol10u,
      fio_atol8u,
      fio_atol_bin,
      fio_atol16u,
  };
  if (!pstr || !(*pstr))
    return 0;
  union {
    uint64_t u64;
    int64_t i64;
  } u = {0};
  char *p = *pstr;

  uint32_t neg = 0, base = 0;
  neg = (p[0] == '-');
  p += (neg | (p[0] == '+'));

  base += (p[0] == '0');             /* starts with zero? - oct */
  p += base;                         /* consume the possible '0' */
  base += ((p[0] | 32) == 'b');      /* binary */
  base += ((p[0] | 32) == 'x') << 1; /* hex */
  p += (base > 1);                   /* consume 'b' or 'x' */
  char *const s = p;                 /* mark starting point */
  u.u64 = fn[base](&p);              /* convert string to unsigned long long */
  if (p != s || base == 1)           /* false oct base, a single '0'? */
    *pstr = p;
  if ((neg | !base)) /* if base 10 or negative, treat signed bit as overflow */
    return fio_u2i_limit(u.u64, neg);
  return u.i64;
}

/* *****************************************************************************
fio_ltoa
***************************************************************************** */

SFUNC size_t fio_ltoa(char *dest, int64_t num, uint8_t base) {
  size_t len = 0;
  uint64_t n = (uint64_t)num;
  size_t digits;
  char dump[96];
  if (!dest)
    dest = dump;

  switch (base) {
  case 1: /* fall through */
  case 2: /* Base 2 */
    len += (digits = fio_digits_bin(n));
    fio_ltoa_bin(dest, n, digits); /* embedded sign bit */
    return len;
  case 8: /* Base 8 */
    if (num < 0) {
      *(dest++) = '-';
      n = 0 - n;
      ++len;
    }
    len += (digits = fio_digits8u(n));
    fio_ltoa8u(dest, n, digits);
    return len;
  case 16: /* Base 16 */
    len += (digits = fio_digits16u(n));
    fio_ltoa16u(dest, n, digits); /* embedded sign bit */
    return len;
  case 0:  /* fall through */
  case 10: /* Base 10 */
    if (num < 0) {
      *(dest++) = '-';
      n = 0 - n;
      ++len;
    }
    len += (digits = fio_digits10u(n));
    fio_ltoa10u(dest, n, digits);
    return len;
  default: /* any base up to base 36 */
    if (base > 36)
      goto base_error;
    if (num < 0) {
      *(dest++) = '-';
      n = 0 - n;
      ++len;
    }
    len += (digits = fio_digits_xbase(n, base));
    fio_ltoa_xbase(dest, n, digits, base);
    return len;
  }

base_error:
  FIO_LOG_ERROR("fio_ltoa base out of range");
  return len;
}

/* *****************************************************************************
fio_atof
***************************************************************************** */

SFUNC double fio_atof(char **pstr) {
  if (!pstr || !(*pstr))
    return 0;
  if ((*pstr)[0] == 'b' || ((*pstr)[1] == '0' && (*pstr)[1] == 'b'))
    goto binary_raw;
  return strtod(*pstr, pstr);
binary_raw:
  /* binary representation is assumed to spell an exact double */
  (void)0;
  union {
    uint64_t i;
    double d;
  } punned = {.i = (uint64_t)fio_atol_bin(pstr)};
  *pstr += ((**pstr | 32) == 'f'); /* support 0b1111111F */
  return punned.d;
}

/* *****************************************************************************
fio_ftoa
***************************************************************************** */

SFUNC size_t fio_ftoa(char *dest, double num, uint8_t base) {
  if (base == 2 || base == 16) {
    /* handle binary / Hex representation the same as an int64_t */
    /* FIXME: Hex representation should use floating-point hex instead */
    union {
      int64_t i;
      double d;
    } p;
    p.d = num;
    return fio_ltoa(dest, p.i, base);
  }
  size_t written = 0;

  if (isinf(num))
    goto is_inifinity;
  if (isnan(num))
    goto is_nan;

  written = snprintf(dest, 30, "%g", num);
  /* test if we need to add a ".0" to the end of the string */
  for (char *start = dest;;) {
    switch (*start) {
    case ',':
      *start = '.'; // locale issues?
    /* fall through */
    case 'e': /* fall through */
    case '.': /* fall through */ goto finish;
    case 0: goto add_dot_zero;
    }
    ++start;
  }
add_dot_zero:
  dest[written++] = '.';
  dest[written++] = '0';

finish:
  dest[written] = 0;
  return written;

is_inifinity:
  if (num < 0)
    dest[written++] = '-';
  fio_memcpy8(dest + written, "Infinity");
  written += 8;
  dest[written] = 0;
  return written;
is_nan:
  fio_memcpy4(dest, "NaN");
  return 3;
}

/* *****************************************************************************
fio_aton
***************************************************************************** */
/** Returns a power of 10. Supports values up to 1.0e308. */
FIO_IFUNC long double fio___aton_pow10(uint64_t e10) {
  // clang-format off
#define fio___aton_pow10_map_row(i) 1.0e##i##0L, 1.0e##i##1L, 1.0e##i##2L, 1.0e##i##3L, 1.0e##i##4L, 1.0e##i##5L, 1.0e##i##6L, 1.0e##i##7L, 1.0e##i##8L, 1.0e##i##9L
  static const long double pow_map[] = {
      fio___aton_pow10_map_row(0),  fio___aton_pow10_map_row(1),  fio___aton_pow10_map_row(2),  fio___aton_pow10_map_row(3),  fio___aton_pow10_map_row(4),
      fio___aton_pow10_map_row(5),  fio___aton_pow10_map_row(6),  fio___aton_pow10_map_row(7),  fio___aton_pow10_map_row(8),  fio___aton_pow10_map_row(9),
      fio___aton_pow10_map_row(10), fio___aton_pow10_map_row(11), fio___aton_pow10_map_row(12), fio___aton_pow10_map_row(13), fio___aton_pow10_map_row(14),
      fio___aton_pow10_map_row(15), fio___aton_pow10_map_row(16), fio___aton_pow10_map_row(17), fio___aton_pow10_map_row(18), fio___aton_pow10_map_row(19),
      fio___aton_pow10_map_row(20), fio___aton_pow10_map_row(21), fio___aton_pow10_map_row(22), fio___aton_pow10_map_row(23), fio___aton_pow10_map_row(24),
      fio___aton_pow10_map_row(25), fio___aton_pow10_map_row(26), fio___aton_pow10_map_row(27), fio___aton_pow10_map_row(28), fio___aton_pow10_map_row(29),
      1.0e300L, 1.0e301L, 1.0e302L, 1.0e303L, 1.0e304L, 1.0e305L, 1.0e306L, 1.0e307L, 1.0e308L, // clang-format on
  };
#undef fio___aton_pow10_map_row
  if (e10 < sizeof(pow_map) / sizeof(pow_map[0]))
    return pow_map[e10];
  return powl(10, e10); /* return infinity? */
}

/** Returns a power of 10. Supports values up to 1.0e-308. */
FIO_IFUNC long double fio___aton_pow10n(uint64_t e10) {
  // clang-format off
#define fio___aton_pow10_map_row(i) 1.0e-##i##0L, 1.0e-##i##1L, 1.0e-##i##2L, 1.0e-##i##3L, 1.0e-##i##4L, 1.0e-##i##5L, 1.0e-##i##6L, 1.0e-##i##7L, 1.0e-##i##8L, 1.0e-##i##9L
  static const long double pow_map[] = {
      fio___aton_pow10_map_row(0),  fio___aton_pow10_map_row(1),  fio___aton_pow10_map_row(2),  fio___aton_pow10_map_row(3),  fio___aton_pow10_map_row(4),
      fio___aton_pow10_map_row(5),  fio___aton_pow10_map_row(6),  fio___aton_pow10_map_row(7),  fio___aton_pow10_map_row(8),  fio___aton_pow10_map_row(9),
      fio___aton_pow10_map_row(10), fio___aton_pow10_map_row(11), fio___aton_pow10_map_row(12), fio___aton_pow10_map_row(13), fio___aton_pow10_map_row(14),
      fio___aton_pow10_map_row(15), fio___aton_pow10_map_row(16), fio___aton_pow10_map_row(17), fio___aton_pow10_map_row(18), fio___aton_pow10_map_row(19),
      fio___aton_pow10_map_row(20), fio___aton_pow10_map_row(21), fio___aton_pow10_map_row(22), fio___aton_pow10_map_row(23), fio___aton_pow10_map_row(24),
      fio___aton_pow10_map_row(25), fio___aton_pow10_map_row(26), fio___aton_pow10_map_row(27), fio___aton_pow10_map_row(28), fio___aton_pow10_map_row(29),
      1.0e-300L, 1.0e-301L, 1.0e-302L, 1.0e-303L, 1.0e-304L, 1.0e-305L, 1.0e-306L, 1.0e-307L, 1.0e-308L, // clang-format on
  };
#undef fio___aton_pow10_map_row
  if (e10 < sizeof(pow_map) / sizeof(pow_map[0]))
    return pow_map[e10];
  return powl(10, (int64_t)(0 - e10)); /* return zero? */
}

FIO_SFUNC FIO___ASAN_AVOID fio_aton_s fio_aton(char **pstr) {
  /* note: sanitizer avoided due to possible 8 byte overflow within mem-page */
  static uint64_t (*const fn[])(char **) = {
      fio_atol10u,
      fio_atol8u,
      fio_atol_bin,
      fio_atol16u,
  };
  static uint32_t base_limit[] = {10, 8, 1, 16};
  static char exponent_char[] = "eepp";
  fio_aton_s r = {0};
  long double dbl = 0, dbl_dot = 0;
  if (!pstr || !(*pstr))
    return r;
  char *start, *head, *p = *pstr;
  uint64_t before_dot = 0, after_dot = 0, expo = 0;
  size_t head_expo = 0, dot_expo = 0;
  while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r')
    ++p;

  uint16_t neg = 0, expo_neg = 0, base = 0, force_float = 0;
  neg = (p[0] == '-');
  p += (neg | (p[0] == '+'));

  if ((p[0] | 32) == 'i')
    goto is_infinity;
  if ((p[0] | 32) == 'n')
    goto is_nan;

  base += (p[0] == '0');             /* oct */
  p += base;                         /* consume '0' */
  base += ((p[0] | 32) == 'b');      /* binary */
  base += ((p[0] | 32) == 'x') << 1; /* hex */
  base -= (base & (p[0] == '.'));    /* 0. isn't oct...  */
  p += (base > 1);                   /* consume 'b' or 'x' */
  start = p;                         /* mark starting point */

  // FIO_LOG_INFO("Start Unsigned: %s", p);
  before_dot = fn[base]((char **)&p);
  if (base == 2)
    goto is_binary;
  head = p;
  while (fio_c2i(p[0]) < base_limit[base])
    ++p;
  head_expo = p - head;
  force_float |= !!(head_expo);
  if (p[0] == '.') {
    ++p;
    force_float = 1;
    head = p;
    after_dot = fn[base]((char **)&p);
    dot_expo = p - head;
    while (fio_c2i(p[0]) < base_limit[base])
      ++p;
  }
  if ((p[0] | 32) == exponent_char[base]) {
    force_float = 1;
    ++p;
    expo_neg = (p[0] == '-');
    p += (expo_neg | (p[0] == '+'));
    expo = fio_atol10u((char **)&p);
    while ((uint8_t)(p[0] - '0') < 10)
      ++p;
  }
  if (p != start || base == 1) /* false oct base, a single '0'? */
    *pstr = p;
  // FIO_LOG_INFO("Start Tail: %s", p);
  if (!force_float && (!(before_dot & ((uint64_t)1ULL << 63)) ||
                       (!neg && base))) { /* is integer */
    r.u = before_dot;
    if (neg)
      r.i = 0 - r.u;
    return r;
  }
  dbl = (long double)before_dot;
  dbl_dot = (long double)after_dot;
  if (!base) {
    dbl *= fio___aton_pow10(head_expo);
    if (after_dot)
      dbl_dot *= fio___aton_pow10n(dot_expo);
  } else if (base == 3) {
    dbl *= fio_u2d(1, (head_expo << 2));
    dbl_dot *= fio_u2d(1, 0 - (dot_expo << 2));
  } else { /* if (base == 1) */
    dbl *= fio_u2d(1, (head_expo * 3));
    dbl_dot *= fio_u2d(1, 0 - (dot_expo * 3));
  }
  dbl += dbl_dot;
  if (expo) {
    if (base < 2) { /* base 10 / Oct */
      dbl *= (expo_neg ? fio___aton_pow10n : fio___aton_pow10)(expo);
    } else {
      dbl *= fio_u2d(1, (int64_t)(expo_neg ? 0 - expo : expo));
    }
  }
  r.is_float = 1;
  r.f = (double)dbl;
  r.u |= (uint64_t)neg << 63;
  return r;

is_infinity:
  if ((p[1] | 32) == 'n' && (p[2] | 32) == 'f') { /* inf */
    r.is_float = 1;
    r.u = ((uint64_t)neg << 63) | ((uint64_t)2047ULL << 52);
    p += 3 + (((p[3] | 32) == 'i' &&
               fio_buf2u64u("infinity") ==
                   (fio_buf2u64u(p) | 0x2020202020202020ULL)) *
              5);
    *pstr = (char *)p;
  } else
    r.err = 1;
  return r;

is_nan:
  if ((p[1] | 32) == 'a' && (p[2] | 32) == 'n') { /* nan */
    r.is_float = 1;
    r.i = ((~(uint64_t)0) >> (!neg));
    p += 3;
    *pstr = (char *)p;
  } else
    r.err = 1;
  return r;

is_binary:
  if (p == start)
    return r;
  r.u = before_dot;
  r.is_float = ((p[0] | 32) == 'f');
  p += r.is_float;
  *pstr = (char *)p;
  return r;
}

/* *****************************************************************************
Big Numbers
***************************************************************************** */

FIO_IFUNC void fio___uXXX_hex_read(uint64_t *t, char **p, size_t l) {
  char *start = *p;
  start += (((unsigned)(start[0] == '0') & (start[1] == 'x')) << 1);
  char *pos = start;
  while (fio_i2c((uint8_t)*pos) < 16)
    ++pos;
  ++pos;
  *p = pos;
  for (size_t i = 0; i < l; ++i) { /* per uint64_t in t */
    uint64_t wrd = 0;
    for (size_t j = 0; j < 16 && pos > start; ++j) {
      --pos;
      wrd |= ((uint64_t)fio_i2c((uint8_t)*pos) << (j << 2));
    }
    *t = wrd;
    ++t;
  }
}

FIO_IFUNC size_t fio___uXXX_hex_write(char *dest, const uint64_t *t, size_t l) {
  while (--l && !t[l])
    ;
  if (!l && !t[0]) {
    dest[0] = '0';
    return 1;
  }
  char *pos = dest;
  size_t digits = fio_digits16u(t[l]);
  ++l;
  while (l--) {
    fio_ltoa16u(pos, t[l], digits);
    pos += digits;
    digits = 16;
  }
  return (size_t)(pos - dest);
}

/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u128 fio_u128_hex_read(char **pstr) {
  fio_u128 r;
  fio___uXXX_hex_read(r.u64, pstr, sizeof(r) / sizeof(r.u64[0]));
  return r;
}
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u256 fio_u256_hex_read(char **pstr) {
  fio_u256 r;
  fio___uXXX_hex_read(r.u64, pstr, sizeof(r) / sizeof(r.u64[0]));
  return r;
}
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u512 fio_u512_hex_read(char **pstr) {
  fio_u512 r;
  fio___uXXX_hex_read(r.u64, pstr, sizeof(r) / sizeof(r.u64[0]));
  return r;
}
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u1024 fio_u1024_hex_read(char **pstr) {
  fio_u1024 r;
  fio___uXXX_hex_read(r.u64, pstr, sizeof(r) / sizeof(r.u64[0]));
  return r;
}
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u2048 fio_u2048_hex_read(char **pstr) {
  fio_u2048 r;
  fio___uXXX_hex_read(r.u64, pstr, sizeof(r) / sizeof(r.u64[0]));
  return r;
}
/** Reads a hex numeral string and initializes the numeral. */
SFUNC fio_u4096 fio_u4096_hex_read(char **pstr) {
  fio_u4096 r;
  fio___uXXX_hex_read(r.u64, pstr, sizeof(r) / sizeof(r.u64[0]));
  return r;
}

/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u128_hex_write(char *dest, const fio_u128 *u) {
  return fio___uXXX_hex_write(dest, u->u64, sizeof(u->u64) / sizeof(u->u64[0]));
}
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u256_hex_write(char *dest, const fio_u256 *u) {
  return fio___uXXX_hex_write(dest, u->u64, sizeof(u->u64) / sizeof(u->u64[0]));
}
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u512_hex_write(char *dest, const fio_u512 *u) {
  return fio___uXXX_hex_write(dest, u->u64, sizeof(u->u64) / sizeof(u->u64[0]));
}
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u1024_hex_write(char *dest, const fio_u1024 *u) {
  return fio___uXXX_hex_write(dest, u->u64, sizeof(u->u64) / sizeof(u->u64[0]));
}
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u2048_hex_write(char *dest, const fio_u2048 *u) {
  return fio___uXXX_hex_write(dest, u->u64, sizeof(u->u64) / sizeof(u->u64[0]));
}
/** Prints out the underlying 64 bit array (for debugging). */
SFUNC size_t fio_u4096_hex_write(char *dest, const fio_u4096 *u) {
  return fio___uXXX_hex_write(dest, u->u64, sizeof(u->u64) / sizeof(u->u64[0]));
}

/* *****************************************************************************
Numbers <=> Strings - Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_ATOL */
#undef FIO_ATOL
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_GLOB_MATCH         /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                            Globe Matching



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_GLOB_MATCH) && !defined(H___FIO_GLOB_MATCH___H)
#define H___FIO_GLOB_MATCH___H

/* *****************************************************************************
Globe Matching API
***************************************************************************** */

/** A binary glob matching helper. Returns 1 on match, otherwise returns 0. */
SFUNC uint8_t fio_glob_match(fio_str_info_s pattern, fio_str_info_s string);

/* *****************************************************************************




                          Globe Matching Implementation




***************************************************************************** */

/* *****************************************************************************
Globe Matching Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
 * Glob Matching
 **************************************************************************** */

/** A binary glob matching helper. Returns 1 on match, otherwise returns 0. */
SFUNC uint8_t fio_glob_match(fio_str_info_s pat, fio_str_info_s str) {
  /* adapted and rewritten, with thankfulness, from the code at:
   * https://github.com/opnfv/kvmfornfv/blob/master/kernel/lib/glob.c
   *
   * Original version's copyright:
   * Copyright 2015 Open Platform for NFV Project, Inc. and its contributors
   * Under the MIT license.
   */

  /*
   * Backtrack to previous * on mismatch and retry starting one
   * character later in the string.  Because * matches all characters,
   * there's never a need to backtrack multiple levels.
   */
  uint8_t *back_pat = NULL, *back_str = (uint8_t *)str.buf;
  size_t back_pat_len = 0, back_str_len = str.len;

  /*
   * Loop over each token (character or class) in pat, matching
   * it against the remaining unmatched tail of str.  Return false
   * on mismatch, or true after matching the trailing nul bytes.
   */
  while (str.len && pat.len) {
    uint8_t c = *(uint8_t *)str.buf++;
    uint8_t d = *(uint8_t *)pat.buf++;
    str.len--;
    pat.len--;

    switch (d) {
    case '?': /* Wildcard: anything goes */ break;

    case '*':       /* Any-length wildcard */
      if (!pat.len) /* Optimize trailing * case */
        return 1;
      back_pat = (uint8_t *)pat.buf;
      back_pat_len = pat.len;
      back_str = (uint8_t *)--str.buf; /* Allow zero-length match */
      back_str_len = ++str.len;
      break;

    case '[': { /* Character class */
      uint8_t match = 0, inverted = (*(uint8_t *)pat.buf == '^' ||
                                     *(uint8_t *)pat.buf == '!');
      uint8_t *cls = (uint8_t *)pat.buf + inverted;
      uint8_t a = *cls++;

      /*
       * Iterate over each span in the character class.
       * A span is either a single character a, or a
       * range a-b.  The first span may begin with ']'.
       */
      do {
        uint8_t b = a;
        if (a == '\\') { /* when escaped, next character is regular */
          b = a = *(cls++);
        } else if (cls[0] == '-' && cls[1] != ']') {
          b = cls[1];

          cls += 2;
          if (a > b) {
            uint8_t tmp = a;
            a = b;
            b = tmp;
          }
        }
        match |= (a <= c && c <= b);
      } while ((a = *cls++) != ']');

      if (match == inverted)
        goto backtrack;
      pat.len -= cls - (uint8_t *)pat.buf;
      pat.buf = (char *)cls;

    } break;
    case '\\': d = *(uint8_t *)pat.buf++; pat.len--;
    /* fall through */
    default: /* Literal character */
      if (c == d)
        break;
    backtrack:
      if (!back_pat)
        return 0; /* No point continuing */
      /* Try again from last *, one character later in str. */
      pat.buf = (char *)back_pat;
      str.buf = (char *)++back_str;
      str.len = --back_str_len;
      pat.len = back_pat_len;
    }
  }
  /* if the trailing pattern allows for empty data, skip it */
  while (pat.len && pat.buf[0] == '*') {
    ++pat.buf;
    --pat.len;
  }
  return !str.len && !pat.len;
}

/* *****************************************************************************
Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_GLOB_MATCH_MONITOR_MAX
#endif /* FIO_GLOB_MATCH */
#undef FIO_GLOB_MATCH
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_IMAP_CORE          /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




            Index Maps (mapping a partial hash to an Array object)
        Maps a Log 2 sized index map to a position in a Log 2 sized Array



Copyright: Boaz Segev, 2019-2021; License: ISC / MIT (choose your license)
***************************************************************************** */
#if defined(FIO_IMAP_CORE) && !defined(H___FIO_IMAP_CORE___H)
#define H___FIO_IMAP_CORE___H

/* *****************************************************************************
iMap Helper Macros
***************************************************************************** */

/** Helper macro for simple iMap array types. */
#define FIO_IMAP_ALWAYS_VALID(o) (1)
/** Helper macro for simple iMap array types. */
#define FIO_IMAP_ALWAYS_CMP_TRUE(a, b) (1)
/** Helper macro for simple iMap array types. */
#define FIO_IMAP_ALWAYS_CMP_FALSE(a, b) (0)
/** Helper macro for simple iMap array types. */
#define FIO_IMAP_SIMPLE_CMP(a, b) ((a)[0] == (b)[0])
/** Helper macro for simple iMap array types. */
#define FIO_IMAP_EACH(array_name, map_ptr, i)                                  \
  for (size_t i = 0; i < (map_ptr)->w; ++i)                                    \
    if (!FIO_NAME(array_name, is_valid)((map_ptr)->ary + i))                   \
      continue;                                                                \
    else

/* *****************************************************************************
iMap Creation Macro
***************************************************************************** */

/**
 * This MACRO defines the type and functions needed for an indexed array.
 *
 * This is used internally and documentation is poor.
 *
 * An indexed array is simple ordered array who's objects are indexed using an
 * almost-hash map, allowing for easy seeking while also enjoying an array's
 * advantages.
 *
 * The index map uses one `imap_type` (i.e., `uint64_t`) to store both the array
 * index and any leftover hash data (the first half being tested during the
 * random access and the leftover during comparison). The reserved value `0`
 * indicates a free slot. The reserved value `~0` indicates a freed item (a free
 * slot that was previously used).
 *
 * - `array_name_s`        the main array container (.ary is the array itself)
 * - `array_name_seeker_s` is a seeker type that finds objects.
 * - `array_name_seek`     finds an object or its future position.
 *
 * - `array_name_capa`     the imap's theoretical storage capacity.
 * - `array_name_set`      writes or overwrites data to the array.
 * - `array_name_get`      returns a pointer to the object within the array.
 * - `array_name_remove`   removes an object and resets its memory to zero.
 * - `array_name_reserve`  reserves a minimum imap storage capacity.
 * - `array_name_rehash`   re-builds the imap (use after sorting).
 */
#define FIO_TYPEDEF_IMAP_ARRAY(array_name,                                     \
                               array_type,                                     \
                               imap_type,                                      \
                               hash_fn,                                        \
                               cmp_fn,                                         \
                               is_valid_fn)                                    \
  FIO_LEAK_COUNTER_DEF(FIO_NAME(array_name, s))                                \
  typedef struct {                                                             \
    array_type *ary;                                                           \
    imap_type count;                                                           \
    imap_type w;                                                               \
    uint32_t capa_bits;                                                        \
  } FIO_NAME(array_name, s);                                                   \
  typedef struct {                                                             \
    imap_type pos;                                                             \
    imap_type ipos;                                                            \
    imap_type set_val;                                                         \
  } FIO_NAME(array_name, seeker_s);                                            \
  /** Returns the theoretical capacity for the indexed array. */               \
  FIO_IFUNC int FIO_NAME(array_name, is_valid)(array_type * pobj) {            \
    return pobj && (!!is_valid_fn(pobj));                                      \
  }                                                                            \
  /** Returns the theoretical capacity for the indexed array. */               \
  FIO_IFUNC size_t FIO_NAME(array_name, capa)(FIO_NAME(array_name, s) * a) {   \
    if (!a || !a->capa_bits)                                                   \
      return 0;                                                                \
    return ((size_t)1ULL << a->capa_bits);                                     \
  }                                                                            \
  /** Returns a pointer to the index map. */                                   \
  FIO_IFUNC imap_type *FIO_NAME(array_name,                                    \
                                imap)(FIO_NAME(array_name, s) * a) {           \
    return (imap_type *)(a->ary + ((imap_type)1ULL << a->capa_bits));          \
  }                                                                            \
  /** Deallocates dynamic memory. */                                           \
  FIO_IFUNC void FIO_NAME(array_name, destroy)(FIO_NAME(array_name, s) * a) {  \
    size_t capa = FIO_NAME(array_name, capa)(a);                               \
    if (a->ary) {                                                              \
      FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(array_name, s));                       \
      FIO_TYPEDEF_IMAP_FREE(                                                   \
          a->ary,                                                              \
          (capa * (sizeof(*a->ary)) + (capa * (sizeof(imap_type)))));          \
    }                                                                          \
    *a = (FIO_NAME(array_name, s)){0};                                         \
    (void)capa; /* if unused */                                                \
  }                                                                            \
  /** Allocates dynamic memory. */                                             \
  FIO_IFUNC int FIO_NAME(array_name, __alloc)(FIO_NAME(array_name, s) * a,     \
                                              size_t bits) {                   \
    if (!bits || bits > ((sizeof(imap_type) << 3) - 2))                        \
      return -1;                                                               \
    size_t capa = 1ULL << bits;                                                \
    size_t old_capa = FIO_NAME(array_name, capa)(a);                           \
    array_type *tmp = (array_type *)FIO_TYPEDEF_IMAP_REALLOC(                  \
        a->ary,                                                                \
        (a->bits ? (old_capa * (sizeof(array_type)) +                          \
                    (old_capa * (sizeof(imap_type))))                          \
                 : 0),                                                         \
        (capa * (sizeof(array_type)) + (capa * (sizeof(imap_type)))),          \
        (a->w * (sizeof(array_type))));                                        \
    (void)old_capa; /* if unused */                                            \
    if (!tmp)                                                                  \
      return -1;                                                               \
    if (!a->ary)                                                               \
      FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(array_name, s));                      \
    a->capa_bits = (uint32_t)bits;                                             \
    a->ary = tmp;                                                              \
    if (!FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE) {                                   \
      FIO_MEMSET((tmp + a->w), 0, ((capa - a->w) * (sizeof(*tmp))));           \
      FIO_MEMSET((tmp + capa), 0, (capa * (sizeof(imap_type))));               \
    }                                                                          \
    return 0;                                                                  \
  }                                                                            \
  /** Returns the index map position and array position of a value, if any. */ \
  FIO_SFUNC FIO_NAME(array_name, seeker_s)                                     \
      FIO_NAME(array_name, seek)(FIO_NAME(array_name, s) * a,                  \
                                 array_type * pobj) {                          \
    FIO_NAME(array_name, seeker_s)                                             \
    r = {0, ((imap_type) ~(imap_type)0), ((imap_type) ~(imap_type)0)};         \
    if (!a || ((!a->capa_bits) | (!a->ary)))                                   \
      return r;                                                                \
    r.pos = a->w;                                                              \
    imap_type capa = (imap_type)1UL << a->capa_bits;                           \
    imap_type *imap = (imap_type *)(a->ary + capa);                            \
    const imap_type pos_mask = (imap_type)(capa - (imap_type)1);               \
    const imap_type hash_mask = (imap_type)~pos_mask;                          \
    const imap_type hash = (imap_type)hash_fn(pobj);                           \
    imap_type tester = (hash & hash_mask); /* hides lower bits for `tester` */ \
    imap_type pos = hash + (hash >> a->capa_bits); /* use more bits for pos */ \
    tester += (!tester) << a->capa_bits;                                       \
    tester -= (hash_mask == tester) << a->capa_bits;                           \
    size_t attempts = 11;                                                      \
    for (;;) {                                                                 \
      /* tests up to 3 groups of 4 bytes (uint32_t) within a 64 byte group */  \
      for (size_t mini_steps = 0;;) {                                          \
        pos &= pos_mask;                                                       \
        const imap_type pos_hash = imap[pos] & hash_mask;                      \
        const imap_type pos_index = imap[pos] & pos_mask;                      \
        if ((pos_hash == tester) && cmp_fn((a->ary + pos_index), pobj)) {      \
          r.ipos = pos;                                                        \
          r.pos = pos_index;                                                   \
          r.set_val = tester | pos_index;                                      \
          return r;                                                            \
        }                                                                      \
        if (!imap[pos]) {                                                      \
          r.ipos = pos;                                                        \
          r.set_val = tester | r.pos; /* r.pos == a->w */                      \
          return r;                                                            \
        }                                                                      \
        if (imap[pos] == (imap_type)(~(imap_type)0)) {                         \
          r.ipos = pos;                                                        \
          r.set_val = tester | r.pos; /* r.pos == a->w */                      \
        }                                                                      \
        if (!((--attempts)))                                                   \
          return r;                                                            \
        if (mini_steps == 2)                                                   \
          break;                                                               \
        pos += 3 + mini_steps; /* 0, 3, 7 =  max of 56 byte distance */        \
        ++mini_steps;                                                          \
      }                                                                        \
      pos += (imap_type)0xC19F5985UL; /* big step */                           \
    }                                                                          \
  }                                                                            \
  /** fills an empty imap with the info about existing elements. */            \
  FIO_SFUNC int FIO_NAME(array_name,                                           \
                         __fill_imap)(FIO_NAME(array_name, s) * a) {           \
    if (!a->count) {                                                           \
      a->w = 0;                                                                \
      return 0;                                                                \
    }                                                                          \
    imap_type *imap = FIO_NAME(array_name, imap)(a);                           \
    if (a->count != a->w) {                                                    \
      a->count = 0;                                                            \
      for (size_t i = 0; i < a->w; ++i) {                                      \
        if (!is_valid_fn((a->ary + i)))                                        \
          continue;                                                            \
        if (a->count != i)                                                     \
          a->ary[a->count] = a->ary[i];                                        \
        ++a->count;                                                            \
      }                                                                        \
    }                                                                          \
    for (a->w = 0; a->w < a->count; ++(a->w)) {                                \
      FIO_NAME(array_name, seeker_s)                                           \
      s = FIO_NAME(array_name, seek)(a, a->ary + a->w);                        \
      if (s.pos != a->w || s.ipos == (imap_type)(~(imap_type)0)) {             \
        a->w = a->count;                                                       \
        return -1; /* destination not big enough to contain collisions! */     \
      }                                                                        \
      imap[s.ipos] = s.set_val;                                                \
    }                                                                          \
    a->w = a->count;                                                           \
    return 0;                                                                  \
  }                                                                            \
  /** expands the existing array & imap storage capacity. */                   \
  FIO_IFUNC int FIO_NAME(array_name, __expand)(FIO_NAME(array_name, s) * a) {  \
    for (;;) {                                                                 \
      if (FIO_NAME(array_name, __alloc)(a,                                     \
                                        a->capa_bits + 1 + (!a->capa_bits)))   \
        return -1;                                                             \
      if (!FIO_NAME(array_name, __fill_imap)(a))                               \
        return 0;                                                              \
    }                                                                          \
  }                                                                            \
  /** Reserves a minimum imap storage capacity. */                             \
  FIO_IFUNC int FIO_NAME(array_name, reserve)(FIO_NAME(array_name, s) * a,     \
                                              imap_type min) {                 \
    imap_type bits = 2;                                                        \
    if (min > ((imap_type)~0ULL) >> 1)                                         \
      return -1;                                                               \
    while ((1ULL << bits) < min)                                               \
      ++bits;                                                                  \
    if (bits <= a->capa_bits)                                                  \
      return 0;                                                                \
    if (FIO_NAME(array_name, __alloc)(a, bits))                                \
      return -1;                                                               \
    if (!FIO_NAME(array_name, __fill_imap)(a))                                 \
      return 0;                                                                \
    return FIO_NAME(array_name, __expand)(a);                                  \
  }                                                                            \
  /** Rehashes the array and fills the imap (use after sorting). */            \
  FIO_IFUNC int FIO_NAME(array_name, rehash)(FIO_NAME(array_name, s) * a) {    \
    if (!a || !a->ary)                                                         \
      return -1;                                                               \
    size_t bytes = sizeof(imap_type) * ((size_t)1ULL << a->capa_bits);         \
    imap_type *imap = FIO_NAME(array_name, imap)(a);                           \
    FIO_MEMSET(imap, 0, bytes);                                                \
    if (!FIO_NAME(array_name, __fill_imap)(a))                                 \
      return -1;                                                               \
    return 0;                                                                  \
  }                                                                            \
  /** Sets an object in the Array. Optionally overwrites existing data. */     \
  FIO_IFUNC array_type *FIO_NAME(array_name, set)(FIO_NAME(array_name, s) * a, \
                                                  array_type obj,              \
                                                  int overwrite) {             \
    if (!a || !is_valid_fn((&obj)))                                            \
      return NULL;                                                             \
    {                                                                          \
      size_t capa = FIO_NAME(array_name, capa)(a);                             \
      if (a->w == capa)                                                        \
        FIO_NAME(array_name, __expand)(a);                                     \
      else if (a->count != a->w &&                                             \
               (a->w + (a->w >> 1)) > FIO_NAME(array_name, capa)(a)) {         \
        FIO_MEMSET((a->ary + capa), 0, (capa * (sizeof(imap_type))));          \
        FIO_NAME(array_name, __fill_imap)(a);                                  \
      }                                                                        \
    }                                                                          \
    for (;;) {                                                                 \
      FIO_NAME(array_name, seeker_s) s = FIO_NAME(array_name, seek)(a, &obj);  \
      if (s.ipos == (imap_type)(~(imap_type)0)) { /* no room in the imap */    \
        FIO_NAME(array_name, __expand)(a);                                     \
        continue;                                                              \
      }                                                                        \
      if (s.pos == a->w) { /* new object */                                    \
        a->ary[a->w] = obj;                                                    \
        ++a->w;                                                                \
        ++a->count;                                                            \
        FIO_NAME(array_name, imap)(a)[s.ipos] = s.set_val;                     \
        return a->ary + s.pos;                                                 \
      }                                                                        \
      FIO_ASSERT_DEBUG(s.pos < a->w && s.ipos < FIO_NAME(array_name, capa)(a), \
                       "WTF?");                                                \
      if (!overwrite)                                                          \
        return a->ary + s.pos;                                                 \
      a->ary[s.pos] = obj;                                                     \
      return a->ary + s.pos;                                                   \
    }                                                                          \
  }                                                                            \
  /** Finds an object in the Array using the index map. */                     \
  FIO_IFUNC array_type *FIO_NAME(array_name, get)(FIO_NAME(array_name, s) * a, \
                                                  array_type obj) {            \
    if (!a || !is_valid_fn((&obj)))                                            \
      return NULL;                                                             \
    FIO_NAME(array_name, seeker_s) s = FIO_NAME(array_name, seek)(a, &obj);    \
    if (s.pos >= a->w)                                                         \
      return NULL;                                                             \
    return a->ary + s.pos;                                                     \
  }                                                                            \
  /** Removes an object in the Array's index map, zeroing out its memory. */   \
  FIO_IFUNC int FIO_NAME(array_name, remove)(FIO_NAME(array_name, s) * a,      \
                                             array_type obj) {                 \
    if (!a || !is_valid_fn((&obj)))                                            \
      return -1;                                                               \
    FIO_NAME(array_name, seeker_s) s = FIO_NAME(array_name, seek)(a, &obj);    \
    if (s.pos >= a->w)                                                         \
      return -1;                                                               \
    a->ary[s.pos] = (array_type){0};                                           \
    FIO_NAME(array_name, imap)(a)[s.ipos] = (imap_type)(~(imap_type)0);        \
    --a->count;                                                                \
    while (a->w && !is_valid_fn((a->ary + a->w - 1)))                          \
      --a->w;                                                                  \
    return 0;                                                                  \
  }

#ifndef FIO_TYPEDEF_IMAP_REALLOC
#define FIO_TYPEDEF_IMAP_REALLOC FIO_MEM_REALLOC
#endif
#ifndef FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE
#define FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE FIO_MEM_REALLOC_IS_SAFE
#endif

#ifndef FIO_TYPEDEF_IMAP_FREE
#define FIO_TYPEDEF_IMAP_FREE FIO_MEM_FREE
#endif

#define FIO___IMAP_SEEKER_TYPE(bits)                                           \
  typedef struct {                                                             \
    uint##bits##_t pos;                                                        \
    uint##bits##_t ipos;                                                       \
    uint##bits##_t set_val;                                                    \
    bool is_valid;                                                             \
  } fio___imap##bits##_seeker_s;                                               \
  /** Returns the index map position and array position of a value, if any. */ \
  FIO_SFUNC fio___imap##bits##_seeker_s fio___imap##bits##_seek(               \
      void *ary,                                                               \
      uint##bits##_t *imap,                                                    \
      const uint##bits##_t capa_bits,                                          \
      void *pobj,                                                              \
      uint##bits##_t hash,                                                     \
      bool cmp_fn(void *arry, void *obj, uint##bits##_t indx),                 \
      const size_t max_attempts) {                                             \
    fio___imap##bits##_seeker_s r = {(uint##bits##_t)(~(uint##bits##_t)0),     \
                                     (uint##bits##_t)(~(uint##bits##_t)0),     \
                                     (uint##bits##_t)(~(uint##bits##_t)0)};    \
    if (!ary)                                                                  \
      return r;                                                                \
    const uint##bits##_t capa = ((uint##bits##_t)1 << capa_bits);              \
    const uint##bits##_t pos_mask = (uint##bits##_t)(capa - 1);                \
    const uint##bits##_t hash_mask = (uint##bits##_t) ~pos_mask;               \
    uint##bits##_t tester = (hash & hash_mask); /* hide `tester` lower bits */ \
    uint##bits##_t pos = hash;                  /* use more bits */            \
    /* make sure tester isn't a reserved value (0 || ~0) */                    \
    tester += (!tester) << capa_bits;                                          \
    tester -= (hash_mask == tester) << capa_bits;                              \
    r.set_val = tester; /* store tester value */                               \
    size_t attempts = max_attempts;                                            \
    /* tests up to 3 groups of 4 bytes (uint32_t) within a 64 byte group */    \
    for (;;) {                                                                 \
      for (size_t mini_steps = 0;;) {                                          \
        pos &= pos_mask;                                                       \
        const uint##bits##_t pos_hash = imap[pos] & hash_mask;                 \
        const uint##bits##_t pos_index = imap[pos] & pos_mask;                 \
        if ((pos_hash == tester) && cmp_fn(ary, pobj, pos_index)) {            \
          r.ipos = pos;                                                        \
          r.pos = pos_index;                                                   \
          r.set_val = tester | pos_index;                                      \
          r.is_valid = 1;                                                      \
          return r;                                                            \
        }                                                                      \
        if (!imap[pos]) {                                                      \
          r.ipos = pos;                                                        \
          r.set_val = tester; /* mark empty slot */                            \
          return r;                                                            \
        }                                                                      \
        if (imap[pos] == (uint##bits##_t)(~(uint##bits##_t)0)) {               \
          r.ipos = pos;                                                        \
        }                                                                      \
        if (!((--attempts)))                                                   \
          return r;                                                            \
        if (mini_steps == 2)                                                   \
          break;                                                               \
        pos += 3 + mini_steps; /* 0, 3, 7 =>  max of 56 byte distance */       \
        ++mini_steps;                                                          \
      }                                                                        \
      pos += (uint##bits##_t)FIO_U##bits##_HASH_PRIME0;                        \
    }                                                                          \
  }                                                                            \
  /** utilizes the values returned by the seeker object. */                    \
  FIO_IFUNC void fio___imap##bits##_set(uint##bits##_t *imap,                  \
                                        uint##bits##_t ipos,                   \
                                        uint##bits##_t set_val) {              \
    imap[ipos] = set_val;                                                      \
  }

FIO___IMAP_SEEKER_TYPE(8)
FIO___IMAP_SEEKER_TYPE(16)
FIO___IMAP_SEEKER_TYPE(32)
FIO___IMAP_SEEKER_TYPE(64)

/* *****************************************************************************
iMap Cleanup
***************************************************************************** */
#endif /* FIO_IMAP_CORE */
#undef FIO_IMAP_CORE
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_MATH               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                    Basic Math Operations and Multi-Precision
                        Constant Time (when possible)



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_MATH) && !defined(H___FIO_MATH___H)
#define H___FIO_MATH___H 1

/* *****************************************************************************
Multi-precision, little endian helpers.

Works with little endian uint64_t arrays or 64 bit numbers.
***************************************************************************** */

/**
 * Multi-precision DIV for `len*64` bit long a, b.
 *
 * This is NOT constant time.
 *
 * The algorithm might be slow, as my math isn't that good and I couldn't
 * understand faster division algorithms (such as NewtonRaphson division)... so
 * this is sort of a factorized variation on long division.
 */
FIO_IFUNC void fio_math_div(uint64_t *dest,
                            uint64_t *reminder,
                            const uint64_t *a,
                            const uint64_t *b,
                            const size_t number_array_length);

/** Multi-precision shift right for `len` word number `n`. */
FIO_IFUNC void fio_math_shr(uint64_t *dest,
                            uint64_t *n,
                            const size_t right_shift_bits,
                            size_t number_array_length);

/** Multi-precision shift left for `len*64` bit number `n`. */
FIO_IFUNC void fio_math_shl(uint64_t *dest,
                            uint64_t *n,
                            const size_t left_shift_bits,
                            const size_t number_array_length);

/** Multi-precision Inverse for `len*64` bit number `n` (turn `1` into `-1`). */
FIO_IFUNC void fio_math_inv(uint64_t *dest, uint64_t *n, size_t len);

/** Multi-precision - returns the index for the most significant bit or -1. */
FIO_MIFN size_t fio_math_msb_index(uint64_t *n, const size_t len);

/** Multi-precision - returns the index for the least significant bit or -1. */
FIO_MIFN size_t fio_math_lsb_index(uint64_t *n, const size_t len);

/* *****************************************************************************
Multi-precision, little endian helpers. Works with full uint64_t arrays.
***************************************************************************** */

/** Multi-precision Inverse for `bits` number `n`. */
FIO_IFUNC void fio_math_inv(uint64_t *dest, uint64_t *n, const size_t len) {
  uint64_t c = 1;
  for (size_t i = 0; i < len; ++i) {
    uint64_t tmp = ~n[i] + c;
    c = (tmp ^ n[i]) >> 63;
    dest[i] = tmp;
  }
}

/** Multi-precision shift right for `bits` number `n`. */
FIO_IFUNC void fio_math_shr(uint64_t *dest,
                            uint64_t *n,
                            size_t bits,
                            size_t len) {
  const size_t offset = len - (bits >> 6);
  bits &= 63;
  // FIO_LOG_DEBUG("Shift Light of %zu bytes and %zu
  // bits", len - offset, bits);
  uint64_t c = 0, trash;
  uint64_t *p_select[] = {dest + offset, &trash};
  if (bits) {
    while (len--) {
      --p_select[0];
      uint64_t ntmp = n[len];
      uint64_t ctmp = (ntmp << (64 - bits));
      dest[len] &= (uint64_t)0ULL - (len < offset);
      p_select[p_select[0] < dest][0] = ((ntmp >> bits) | c);
      c = ctmp;
    }
    return;
  }
  while (len--) {
    --p_select[0];
    uint64_t ntmp = n[len];
    dest[len] &= (uint64_t)0ULL - (len < offset);
    p_select[p_select[0] < dest][0] = ntmp;
  }
}

/** Multi-precision shift left for `bits` number `n`. */
FIO_IFUNC void fio_math_shl(uint64_t *dest,
                            uint64_t *n,
                            size_t bits,
                            const size_t len) {
  if (!len || !n || !dest)
    return;
  /* Handle zero shift: just copy */
  if (!bits) {
    FIO_MEMCPY(dest, n, sizeof(uint64_t) * len);
    return;
  }
  const size_t offset = bits >> 6;
  bits &= 63;
  uint64_t c = 0, trash;
  uint64_t *p_select[] = {dest + offset, &trash};
  if (bits) {
    for (size_t i = 0; i < len; (++i), ++p_select[0]) {
      uint64_t ntmp = n[i];
      uint64_t ctmp = (ntmp >> (64 - bits)) & ((uint64_t)0ULL - (!!bits));
      ;
      dest[i] &= (uint64_t)0ULL - (i >= offset);
      p_select[p_select[0] >= (dest + len)][0] = ((ntmp << bits) | c);
      c = ctmp;
    }
    return;
  }
  for (size_t i = 0; i < len; (++i), ++p_select[0]) {
    uint64_t ntmp = n[i];
    dest[i] &= (uint64_t)0ULL - (i >= offset);
    p_select[p_select[0] >= (dest + len)][0] = ntmp;
  }
}

/** Multi-precision - returns the index for the most
 * significant bit. */
FIO_IFUNC size_t fio_math_msb_index(uint64_t *n, size_t len) {
  size_t r[2] = {0, (size_t)-1};
  uint64_t a = 0;
  while (len--) {
    const uint64_t mask = ((uint64_t)0ULL - (!a));
    a |= (mask & n[len]);
    r[0] += (64 & (~mask));
  }
  r[0] += fio_bits_msb_index(a);
  return r[!a];
}

/** Multi-precision - returns the index for the least
 * significant bit. */
FIO_IFUNC size_t fio_math_lsb_index(uint64_t *n, const size_t len) {
  size_t r[2] = {0, (size_t)-1};
  uint64_t a = 0;
  uint64_t mask = (~(uint64_t)0ULL);
  for (size_t i = 0; i < len; ++i) {
    a |= mask & n[i];
    mask = ((uint64_t)0ULL - (!a));
    r[0] += (64 & mask);
  }
  r[0] += fio_bits_lsb_index(a);
  return r[!a];
}

/**
 * Multi-precision DIV for `len*64` bit long a, b.
 *
 * This is NOT constant time.
 *
 * Uses binary long division: for each bit position from high to low,
 * if shifted divisor <= remainder, subtract it and set the quotient bit.
 */
FIO_IFUNC void fio_math_div(uint64_t *dest,
                            uint64_t *remainder,
                            const uint64_t *a,
                            const uint64_t *b,
                            const size_t len) {
  if (!len)
    return;

  /* Get MSB index of divisor (returns (size_t)-1 if zero) */
  const size_t b_msb = fio_math_msb_index((uint64_t *)b, len);
  if (b_msb == (size_t)-1) {
    /* Division by zero */
    FIO_LOG_ERROR("divide by zero!");
    if (dest)
      FIO_MEMSET(dest, 0xFF, sizeof(uint64_t) * len);
    if (remainder)
      FIO_MEMSET(remainder, 0xFF, sizeof(uint64_t) * len);
    return;
  }

#if !defined(_MSC_VER) && (!defined(__cplusplus) || __cplusplus > 201402L)
  uint64_t t[len];
  uint64_t r[len];
  uint64_t q[len];
#else
  uint64_t t[1024];
  uint64_t r[1024];
  uint64_t q[1024];
  FIO_ASSERT(
      len <= 1024,
      "Multi Precision DIV (fio_math_div) overflows at 32768 bit numbers");
#endif

  /* Initialize: r = a (remainder starts as dividend), q = 0 */
  FIO_MEMCPY(r, a, sizeof(uint64_t) * len);
  FIO_MEMSET(q, 0, sizeof(uint64_t) * len);

  /* Get initial MSB of remainder */
  size_t r_msb = fio_math_msb_index((uint64_t *)r, len);

  /* If dividend is zero or smaller than divisor, quotient is 0, remainder is a
   */
  if (!(r_msb == (size_t)-1 || r_msb < b_msb)) {
    /* Binary long division: iterate from highest possible shift down to 0 */
    size_t shift = r_msb - b_msb;
    for (;;) {
      /* Shift divisor left to current position */
      fio_math_shl(t, (uint64_t *)b, shift, len);

      /* Try to subtract: compute r - t */
      uint64_t borrow = fio_math_sub(t, (uint64_t *)r, t, len);

      if (!borrow) {
        /* t <= r: subtraction succeeded, update remainder and set quotient bit
         */
        FIO_MEMCPY(r, t, sizeof(uint64_t) * len);
        q[shift >> 6] |= (1ULL << (shift & 63));

        /* Recalculate r_msb since remainder changed */
        r_msb = fio_math_msb_index((uint64_t *)r, len);

        /* If remainder is now zero or less than divisor, we're done */
        if (r_msb == (size_t)-1 || r_msb < b_msb)
          break;

        /* Update shift based on new remainder's MSB */
        shift = r_msb - b_msb;
      } else {
        /* t > r: can't subtract at this shift, try smaller shift */
        if (shift == 0)
          break;
        --shift;
      }
    }
  }

  /* Copy results to output */
  if (dest)
    FIO_MEMCPY(dest, q, len * sizeof(uint64_t));
  if (remainder)
    FIO_MEMCPY(remainder, r, len * sizeof(uint64_t));
}

/* *****************************************************************************
Math - cleanup
***************************************************************************** */
#endif /* FIO_MATH */
#undef FIO_MATH
#undef FIO_MIFN
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_RAND               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                      Psedo-Random Generator Functions
                    and friends - risky hash / stable hash



Copyright and License: see header file (000 copyright.h) / top of file
***************************************************************************** */
#if defined(FIO_RAND) && !defined(H___FIO_RAND_H)
#define H___FIO_RAND_H

/* *****************************************************************************
Random - API
***************************************************************************** */

/** Returns 64 psedo-random bits. Probably not cryptographically safe. */
SFUNC uint64_t fio_rand64(void);

/** Returns 64 psedo-random bits. Probably not cryptographically safe. */
SFUNC fio_u128 fio_rand128(void);

/** Writes `len` bytes of psedo-random bits to the target buffer. */
SFUNC void fio_rand_bytes(void *target, size_t len);

/**
 * Writes `len` bytes of cryptographically secure random data to `target`.
 *
 * Uses system CSPRNG: getrandom() on Linux, arc4random_buf() on BSD/macOS,
 * or /dev/urandom as fallback. Returns 0 on success, -1 on failure.
 *
 * IMPORTANT: Use this for security-sensitive operations like key generation.
 */
SFUNC int fio_rand_bytes_secure(void *target, size_t len);

/** Reseeds the random engine using system state (rusage / jitter). */
SFUNC void fio_rand_reseed(void);

/* *****************************************************************************
Risky / Stable Hash - API
***************************************************************************** */

/** Computes a facil.io Risky Hash (Risky v.3). */
SFUNC uint64_t fio_risky_hash(const void *buf, size_t len, uint64_t seed);

/** Adds a bit of entropy to pointer values. Designed to be unsafe. */
FIO_IFUNC uint64_t fio_risky_ptr(void *ptr);

/** Adds a bit of entropy to numeral values. Designed to be unsafe. */
FIO_IFUNC uint64_t fio_risky_num(uint64_t number, uint64_t seed);

/** Computes a facil.io Stable Hash (will not be updated, even if broken). */
SFUNC uint64_t fio_stable_hash(const void *data, size_t len, uint64_t seed);

/** Computes a facil.io Stable Hash (will not be updated, even if broken). */
SFUNC void fio_stable_hash128(void *restrict dest,
                              const void *restrict data,
                              size_t len,
                              uint64_t seed);

#define FIO_USE_STABLE_HASH_WHEN_CALLING_RISKY_HASH 0
/* *****************************************************************************
Risky Hash - Implementation

Note: I don't remember what information I used when designing this, but Risky
Hash is probably NOT cryptographically safe (though I wish it was).

Here's a few resources about hashes that might explain more:
- https://komodoplatform.com/cryptographic-hash-function/
- https://en.wikipedia.org/wiki/Avalanche_effect
- http://ticki.github.io/blog/designing-a-good-non-cryptographic-hash-function/

***************************************************************************** */

/** Adds bit entropy to a pointer values. Designed to be unsafe. */
FIO_IFUNC uint64_t fio_risky_num(uint64_t n, uint64_t seed) {
  seed ^= fio_lrot64(seed, 47);
  seed += FIO_U64_HASH_PRIME0;
  seed = seed | 1;
  uint64_t h = n + seed;
  h += fio_lrot64(seed, 5);
  h += fio_bswap64(seed);
  h += fio_lrot64(h, 27);
  h += fio_lrot64(h, 49);
  return h;
}

/** Adds bit entropy to a pointer values. Designed to be unsafe. */
FIO_IFUNC uint64_t fio_risky_ptr(void *ptr) {
  return fio_risky_num((uint64_t)(uintptr_t)ptr, FIO_U64_HASH_PRIME9);
}

/* *****************************************************************************
Possibly `extern` Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Risky Hash
***************************************************************************** */

/*  Computes a facil.io Risky Hash. */
SFUNC uint64_t fio_risky_hash(const void *data_, size_t len, uint64_t seed) {
#if FIO_USE_STABLE_HASH_WHEN_CALLING_RISKY_HASH
  return fio_stable_hash(data_, len, seed);
#endif
#define FIO___RISKY_HASH_ROUND64()                                             \
  do {                                                                         \
    for (size_t i = 0; i < 8; ++i) /* use little endian? */                    \
      w[i] = fio_ltole64(w[i]);                                                \
    for (size_t i = 0; i < 8; ++i) { /* xor vector with input (words) */       \
      v[i] ^= w[i];                                                            \
    }                                                                          \
    for (size_t i = 0; i < 4; ++i) { /* MUL folding, adding high bits */       \
      v[i] += fio_math_mulc64(v[i], v[i + 4], w + i);                          \
      v[i + 4] += w[i];                                                        \
    }                                                                          \
  } while (0)
  /* Approach inspired by komihash, copyrighted: Aleksey Vaneev, MIT license */
  const uint8_t *data = (const uint8_t *)data_;
  uint64_t v[8] FIO_ALIGN(16), w[8] FIO_ALIGN(16) = {0};
  uint64_t const prime[8] FIO_ALIGN(16) = {
      FIO_U64_HASH_PRIME1,
      FIO_U64_HASH_PRIME2,
      FIO_U64_HASH_PRIME3,
      FIO_U64_HASH_PRIME4,
      FIO_U64_HASH_PRIME5,
      FIO_U64_HASH_PRIME6,
      FIO_U64_HASH_PRIME7,
      FIO_U64_HASH_PRIME0,
  };
  /* seed mixing is constant time to avoid leaking seed data */
  seed += len;
  seed ^= fio_lrot64(seed, 47);
  /* initialize vector with mixed secret */
  for (size_t i = 0; i < 8; ++i)
    v[i] = seed + prime[i];
  /* pad uneven head with zeros and consume (if any) */
  if ((len & 63)) {
    for (size_t i = 0; i < 8; ++i)
      w[i] = 0;
    fio_memcpy63x(w, data, len);
    data += (len & 63);
    ((uint8_t *)w)[63] = (uint8_t)(len & 63);
    FIO___RISKY_HASH_ROUND64();
  }
  /* consumes remaining 64 bytes (512 bits) blocks */
  for (size_t j = 63; j < len; j += 64) {
    for (size_t i = 0; i < 4; ++i)
      v[i] += prime[i]; /* mark each round, may double mark if(!(len & 63)) */
    fio_memcpy64(w, data);
    data += 64;
    FIO___RISKY_HASH_ROUND64();
  }

  w[4] = (v[0] ^ v[1]) + (v[1] ^ v[2]) + (v[2] ^ v[3]);
  w[5] = (v[4] + v[5]) ^ (v[5] + v[6]) ^ (v[6] + v[7]);
  w[6] = (w[0] + w[1]) ^ (w[1] + w[2]) ^ (w[2] + w[3]);
  v[0] = w[5] + fio_math_mulc64(w[4], w[6], v + 1);
  v[0] += v[1];
  return v[0];
#undef FIO___RISKY_HASH_ROUND64
}

/* *****************************************************************************
Stable Hash (unlike Risky Hash, this can be used for non-ephemeral hashing)
***************************************************************************** */
#define FIO_STABLE_HASH_ROUND_WORD(i)                                          \
  v[i] += w[i];                                                                \
  v[i] += prime[i];                                                            \
  v[i] *= prime[i];                                                            \
  w[i] = fio_lrot64(w[i], 19);                                                 \
  v[i] += w[i] + seed;

FIO_IFUNC void fio_stable_hash___inner(uint64_t dest[4],
                                       const void *restrict data_,
                                       const size_t len,
                                       uint64_t seed) {
  const uint8_t *data = (const uint8_t *)data_;
  /* seed selection is constant time to avoid leaking seed data */
  seed += len;
  seed ^= fio_lrot64(seed, 47);
  seed = (seed << 1) + 1;
  uint64_t v[4] = {seed, seed, seed, seed};
  uint64_t const prime[4] = {0xC19F5985UL,
                             0x8D567931UL,
                             0x9C178B17UL,
                             0xA4B842DFUL};

  for (size_t j = 31; j < len; j += 32) {
    /* consumes 32 bytes (256 bits) each loop */
    uint64_t w[4];
    for (size_t i = 0; i < 4; ++i) {
      w[i] = fio_ltole64(fio_buf2u64u(data));
      data += 8;
      FIO_STABLE_HASH_ROUND_WORD(i);
    }
  }
  { /* pad with zeros (even if %32 == 0) and add len to last word */
    uint64_t w[4] = {0};
    fio_memcpy31x(w, data, len); /* copies `len & 31` bytes */
    for (size_t i = 0; i < 4; ++i)
      w[i] = fio_ltole64(w[i]);
    w[3] += len;
    for (size_t i = 0; i < 4; ++i) {
      FIO_STABLE_HASH_ROUND_WORD(i);
    }
  }
  for (size_t i = 0; i < 4; ++i) {
    dest[i] = v[i];
  }
}

/* Computes a facil.io Stable Hash. */
SFUNC uint64_t fio_stable_hash(const void *data_, size_t len, uint64_t seed) {
  uint64_t r;
  uint64_t v[4];
  fio_stable_hash___inner(v, data_, len, seed);
  /* summing & avalanche */
  r = v[0] + v[1] + v[2] + v[3];
  for (size_t i = 0; i < 4; ++i)
    v[i] = fio_bswap64(v[i]);
  r ^= fio_lrot64(r, 5);
  r += v[0] ^ v[1];
  r ^= fio_lrot64(r, 27);
  r += v[1] ^ v[2];
  r ^= fio_lrot64(r, 49);
  r += v[2] ^ v[3];
  r ^= (r >> 29) * FIO_U64_HASH_PRIME0;
  r ^= fio_lrot64(r, 29);
  return r;
}

SFUNC void fio_stable_hash128(void *restrict dest,
                              const void *restrict data_,
                              size_t len,
                              uint64_t seed) {

  uint64_t v[4];
  fio_stable_hash___inner(v, data_, len, seed);
  uint64_t r[2];
  uint64_t prime[2] = {FIO_U64_HASH_PRIME0, FIO_U64_HASH_PRIME1};
  r[0] = v[0] + v[1] + v[2] + v[3];
  r[1] = v[0] ^ v[1] ^ v[2] ^ v[3];
  for (size_t i = 0; i < 4; ++i)
    v[i] = fio_bswap64(v[i]);
  for (size_t i = 0; i < 2; ++i) {
    r[i] ^= fio_lrot64(r[i], 5);
    r[i] += v[0] ^ v[1];
    r[i] ^= fio_lrot64(r[i], 27);
    r[i] += v[1] ^ v[2];
    r[i] ^= fio_lrot64(r[i], 49);
    r[i] += v[2] ^ v[3];
    r[i] ^= (r[i] >> 29) * prime[i];
    r[i] ^= fio_lrot64(r[i], 29);
  }
  fio_memcpy16(dest, r);
}

#undef FIO_STABLE_HASH_ROUND_WORD
/* *****************************************************************************
Random - Implementation
***************************************************************************** */

#if FIO_OS_POSIX || (__has_include("sys/resource.h") &&                        \
                     __has_include("sys/time.h") && __has_include("fcntl.h"))
#include <fcntl.h>
#include <sys/resource.h>
#include <sys/time.h>
#endif

/* The fio_rand64 implementation. */
FIO_DEFINE_RANDOM128_FN(SFUNC, fio_rand, 11, 0)

/**
 * Cryptographically secure random bytes using system CSPRNG.
 * Returns 0 on success, -1 on failure.
 */
SFUNC int fio_rand_bytes_secure(void *target, size_t len) {
  if (!target || !len)
    return 0;

#if (defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) ||     \
     defined(__NetBSD__) || defined(__DragonFly__))
  /* BSD/macOS: use arc4random_buf (always succeeds, CSPRNG) */
  arc4random_buf(target, len);
  return 0;
#else
  /* Generic POSIX fallback: read from /dev/urandom */
  uint8_t *buf = (uint8_t *)target;
  int fd = open("/dev/urandom", O_RDONLY);
  if (fd < 0)
    return -1;
  while (len > 0) {
    ssize_t got = read(fd, buf, len);
    if (got < 0) {
      if (errno == EINTR)
        continue;
      close(fd);
      return -1;
    }
    if (got == 0) {
      close(fd);
      return -1; /* unexpected EOF */
    }
    buf += got;
    len -= (size_t)got;
  }
  close(fd);
  return 0;
#endif
}
/* *****************************************************************************
Random - Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_RAND */
#undef FIO_RAND
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_SIGNAL             /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                              Signal Monitoring



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_SIGNAL) && !defined(H___FIO_SIGNAL___H)
#define H___FIO_SIGNAL___H

#ifndef FIO_SIGNAL_MONITOR_MAX
/* The maximum number of signals the implementation will be able to monitor */
#define FIO_SIGNAL_MONITOR_MAX 24
#endif

#if !(FIO_OS_POSIX) && !(FIO_OS_WIN) /* use FIO_HAVE_UNIX_TOOLS instead? */
#error Either POSIX or Windows are required for the fio_signal API.
#endif

#include <signal.h>
/* *****************************************************************************
Signal Monitoring API
***************************************************************************** */

typedef struct {
  /** The signal number to listen for. */
  int sig;
  /** The callback to run - leave NULL to ignore signal. */
  void (*callback)(int sig, void *udata);
  /** Opaque user data. */
  void *udata;
  /** Should the signal propagate to existing handler(s)? */
  bool propagate;
  /** Call (safe) callback immediately? or wait for `fio_signal_review`? */
  bool immediate;
} fio_signal_monitor_args_s;
/**
 * Starts to monitor for the specified signal, setting an optional callback.
 */
SFUNC int fio_signal_monitor(fio_signal_monitor_args_s args);
#define fio_signal_monitor(...)                                                \
  fio_signal_monitor((fio_signal_monitor_args_s){__VA_ARGS__})

/** Reviews all signals, calling any relevant callbacks. */
SFUNC int fio_signal_review(void);

/** Stops monitoring the specified signal. */
SFUNC int fio_signal_forget(int sig);

/* *****************************************************************************




                          Signal Monitoring Implementation




***************************************************************************** */

/* *****************************************************************************
Signal Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
POSIX implementation
***************************************************************************** */
#if FIO_OS_POSIX

static struct {
  fio_signal_monitor_args_s args;
  struct sigaction old;
  volatile uint16_t flag;
} fio___signal_watchers[FIO_SIGNAL_MONITOR_MAX];

FIO_SFUNC void fio___signal_catcher(int sig) {
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].args.sig &&
        !fio___signal_watchers[i].args.udata)
      return; /* initialized list is finishe */
    if (fio___signal_watchers[i].args.sig != sig)
      continue;
    /* execute vs mark */
    if (fio___signal_watchers[i].args.immediate)
      fio___signal_watchers[i].args.callback(
          fio___signal_watchers[i].args.sig,
          fio___signal_watchers[i].args.udata);
    /* mark flag */
    fio___signal_watchers[i].flag = !fio___signal_watchers[i].args.immediate;

    /* pass-through if exists */
    if (fio___signal_watchers[i].args.propagate &&
        fio___signal_watchers[i].old.sa_handler != SIG_IGN &&
        fio___signal_watchers[i].old.sa_handler != SIG_DFL)
      fio___signal_watchers[i].old.sa_handler(sig);
    return;
  }
}

int fio_signal_monitor___(void); /* IDE Marker */
/**
 * Starts to monitor for the specified signal, setting an optional callback.
 */
SFUNC int fio_signal_monitor FIO_NOOP(fio_signal_monitor_args_s args) {
  if (!args.sig)
    return -1;
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    /* updating an existing monitor */
    if (fio___signal_watchers[i].args.sig == args.sig) {
      fio___signal_watchers[i].args = args;
      return 0;
    }
    /* slot busy */
    if (fio___signal_watchers[i].args.sig ||
        fio___signal_watchers[i].args.callback)
      continue;
    /* place monitor in this slot */
    struct sigaction act;
    memset(&act, 0, sizeof(act));
    memset(fio___signal_watchers + i, 0, sizeof(fio___signal_watchers[i]));
    fio___signal_watchers[i].args = args;
    act.sa_handler = fio___signal_catcher;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_RESTART | SA_NOCLDSTOP;
    if (sigaction(args.sig, &act, &fio___signal_watchers[i].old)) {
      FIO_LOG_ERROR("couldn't set signal handler: %s", strerror(errno));
      fio___signal_watchers[i].args = (fio_signal_monitor_args_s){
          .udata = (void *)1,
      };
      return -1;
    }
    return 0;
  }
  return -1;
}

/** Stops monitoring the specified signal. */
SFUNC int fio_signal_forget(int sig) {
  if (!sig)
    return -1;
  struct sigaction act = {0};
  act.sa_handler = SIG_DFL;
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].args.sig &&
        !fio___signal_watchers[i].args.udata)
      break; /* initialized list is finished */
    if (fio___signal_watchers[i].args.sig != sig)
      continue;
    fio___signal_watchers[i].args = (fio_signal_monitor_args_s){
        .udata = (void *)1,
    };
    struct sigaction old = fio___signal_watchers[i].old;
    old = act;
    if (sigaction(sig, &old, &act)) {
      FIO_LOG_ERROR("couldn't unset signal handler: %s", strerror(errno));
      return -1;
    }
    return 0;
  }
  sigaction(sig, &act, NULL);
  return -1;
}

/* *****************************************************************************
Windows Implementation
***************************************************************************** */
#elif FIO_OS_WIN

static struct {
  fio_signal_monitor_args_s args;
  void (*old)(int sig);
  volatile uint16_t flag;
} fio___signal_watchers[FIO_SIGNAL_MONITOR_MAX];

FIO_SFUNC void fio___signal_catcher(int sig) {
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].args.sig &&
        !fio___signal_watchers[i].args.udata)
      return; /* initialized list is finished */
    if (fio___signal_watchers[i].args.sig != sig)
      continue;
    /* execute vs mark */
    if (fio___signal_watchers[i].args.immediate)
      fio___signal_watchers[i].args.callback(
          fio___signal_watchers[i].args.sig,
          fio___signal_watchers[i].args.udata);
    /* mark flag */
    fio___signal_watchers[i].flag = !fio___signal_watchers[i].args.immediate;
    /* pass-through if exists */
    if (fio___signal_watchers[i].args.propagate &&
        fio___signal_watchers[i].old &&
        (intptr_t)fio___signal_watchers[i].old != (intptr_t)SIG_IGN &&
        (intptr_t)fio___signal_watchers[i].old != (intptr_t)SIG_DFL) {
      fio___signal_watchers[i].old(sig);
      fio___signal_watchers[i].old = signal(sig, fio___signal_catcher);
    } else {
      fio___signal_watchers[i].old = signal(sig, fio___signal_catcher);
    }
    break;
  }
}

SFUNC int fio_signal_monitor___(void); /* IDE Marker */
/**
 * Starts to monitor for the specified signal, setting an optional callback.
 */
SFUNC int fio_signal_monitor FIO_NOOP(fio_signal_monitor_args_s args) {
  if (!args.sig)
    return -1;
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    /* updating an existing monitor */
    if (fio___signal_watchers[i].args.sig == args.sig) {
      fio___signal_watchers[i].args = args;
      return 0;
    }
    /* slot busy */
    if (fio___signal_watchers[i].args.sig ||
        fio___signal_watchers[i].args.callback ||
        fio___signal_watchers[i].args.udata)
      continue;
    /* place monitor in this slot */
    fio___signal_watchers[i].args = args;
    fio___signal_watchers[i].old = signal(args.sig, fio___signal_catcher);
    if ((intptr_t)SIG_ERR == (intptr_t)fio___signal_watchers[i].old) {
      fio___signal_watchers[i].args = (fio_signal_monitor_args_s){
          .udata = (void *)1,
      };
      FIO_LOG_ERROR("couldn't set signal handler: %s", strerror(errno));
      return -1;
    }
    return 0;
  }
  return -1;
}

/** Stops monitoring the specified signal. */
SFUNC int fio_signal_forget(int sig) {
  if (!sig)
    return -1;
  size_t i = 0;
  for (; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].args.sig &&
        !fio___signal_watchers[i].args.udata)
      return -1; /* initialized list is finished */
    if (fio___signal_watchers[i].args.sig != sig)
      continue;
    fio___signal_watchers[i].args = (fio_signal_monitor_args_s){
        .udata = (void *)1,
    };
    if (fio___signal_watchers[i].old &&
        fio___signal_watchers[i].old != SIG_DFL) {
      if ((intptr_t)signal(sig, fio___signal_watchers[i].old) ==
          (intptr_t)SIG_ERR)
        goto sig_error;
    } else {
      if ((intptr_t)signal(sig, SIG_DFL) == (intptr_t)SIG_ERR)
        goto sig_error;
    }
    fio___signal_watchers[i].old = SIG_DFL;
    return 0;
  }
  signal(sig, SIG_DFL);
  return -1;
sig_error:
  fio___signal_watchers[i].old = SIG_DFL;
  signal(sig, SIG_DFL);
  FIO_LOG_ERROR("couldn't unset signal handler: %s", strerror(errno));
  return -1;
}
#endif /* POSIX vs WINDOWS */

/* *****************************************************************************
Common OS implementation
***************************************************************************** */

/** Reviews all signals, calling any relevant callbacks. */
SFUNC int fio_signal_review(void) {
  int c = 0;
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].args.sig &&
        !fio___signal_watchers[i].args.udata)
      return c;
    if (fio___signal_watchers[i].flag) {
      fio___signal_watchers[i].flag = 0;
      ++c;
      if (fio___signal_watchers[i].args.callback)
        fio___signal_watchers[i].args.callback(
            fio___signal_watchers[i].args.sig,
            fio___signal_watchers[i].args.udata);
    }
  }
  return c;
}

/* *****************************************************************************
Signal Monitoring Testing?
***************************************************************************** */
#ifdef FIO_TEST_ALL
FIO_SFUNC void FIO_NAME_TEST(stl, signal)(void) {

#define FIO___SIGNAL_MEMBER(a)                                                 \
  { (int)a, #a }
  struct {
    int sig;
    const char *name;
  } t[] = {
    FIO___SIGNAL_MEMBER(SIGINT),
    FIO___SIGNAL_MEMBER(SIGILL),
    FIO___SIGNAL_MEMBER(SIGABRT),
    FIO___SIGNAL_MEMBER(SIGSEGV),
    FIO___SIGNAL_MEMBER(SIGTERM),
#if FIO_OS_POSIX
    FIO___SIGNAL_MEMBER(SIGQUIT),
    FIO___SIGNAL_MEMBER(SIGHUP),
    FIO___SIGNAL_MEMBER(SIGTRAP),
    FIO___SIGNAL_MEMBER(SIGBUS),
    FIO___SIGNAL_MEMBER(SIGFPE),
    FIO___SIGNAL_MEMBER(SIGUSR1),
    FIO___SIGNAL_MEMBER(SIGUSR2),
    FIO___SIGNAL_MEMBER(SIGPIPE),
    FIO___SIGNAL_MEMBER(SIGALRM),
    FIO___SIGNAL_MEMBER(SIGCHLD),
    FIO___SIGNAL_MEMBER(SIGCONT),
#endif
  };
#undef FIO___SIGNAL_MEMBER
  size_t e = 0;
  fprintf(stderr, "* testing signal monitoring (setup / cleanup only).\n");
  for (size_t i = 0; i < sizeof(t) / sizeof(t[0]); ++i) {
    if (fio_signal_monitor(t[i].sig, NULL, NULL, 1)) {
      FIO_LOG_ERROR("couldn't set signal monitoring for %s (%d)",
                    t[i].name,
                    t[i].sig);
      e = 1;
    }
  }
  for (size_t i = 0; i < sizeof(t) / sizeof(t[0]); ++i) {
    if (fio_signal_forget(t[i].sig)) {
      FIO_LOG_ERROR("couldn't stop signal monitoring for %s (%d)",
                    t[i].name,
                    t[i].sig);
      e = 1;
    }
  }
  FIO_ASSERT(!e, "signal monitoring error");
}

#endif /* FIO_TEST_ALL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_SIGNAL_MONITOR_MAX
#endif /* FIO_SIGNAL */
#undef FIO_SIGNAL
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_SORT_NAME num      /* Development inclusion - ignore line */
#define FIO_SORT_TYPE size_t   /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                          A Good Enough Sorting Helper



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#ifdef FIO_SORT_NAME

/* *****************************************************************************
Sort Settings
***************************************************************************** */

#ifndef FIO_SORT_TYPE
#error FIO_SORT_TYPE must contain a valid type name!
#endif

#ifndef FIO_SORT_THRESHOLD
/** The default threshold below which quicksort delegates to insert sort. */
#define FIO_SORT_THRESHOLD 96
#endif

#ifndef FIO_SORT_SWAP
/** Default swap operation assumes an array and swaps array members */
#define FIO_SORT_SWAP(a, b)                                                    \
  do {                                                                         \
    FIO_SORT_TYPE tmp__ = (a);                                                 \
    (a) = (b);                                                                 \
    (b) = tmp__;                                                               \
  } while (0)
#endif

#ifndef FIO_SORT_IS_BIGGER
/** MUST evaluate as 1 if a > b (zero if equal or smaller). */
#define FIO_SORT_IS_BIGGER(a, b) ((a) > (b))
#endif

/* *****************************************************************************
Sort API
***************************************************************************** */

/* Sorts a `FIO_SORT_TYPE` array with `count` members (quicksort). */
FIO_IFUNC void FIO_NAME(FIO_SORT_NAME, sort)(FIO_SORT_TYPE *array,
                                             size_t count);

/* Insert sort, for small arrays of `FIO_SORT_TYPE`. */
SFUNC void FIO_NAME(FIO_SORT_NAME, isort)(FIO_SORT_TYPE *array, size_t count);

/* Quick sort, for larger arrays of `FIO_SORT_TYPE`. */
SFUNC void FIO_NAME(FIO_SORT_NAME, qsort)(FIO_SORT_TYPE *array, size_t count);

/* *****************************************************************************
Sort Implementation - inlined static functions
see ideas from: https://youtu.be/FJJTYQYB1JQ
***************************************************************************** */

/* Sorts a `FIO_SORT_TYPE` array with `count` members (quicksort). */
FIO_IFUNC void FIO_NAME(FIO_SORT_NAME, sort)(FIO_SORT_TYPE *array,
                                             size_t count) {
  FIO_NAME(FIO_SORT_NAME, qsort)(array, count);
}

/* *****************************************************************************
Sort Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* Insert sort, for small arrays of `FIO_SORT_TYPE`. */
SFUNC void FIO_NAME(FIO_SORT_NAME, isort)(FIO_SORT_TYPE *array, size_t count) {
  /* a fast(ish) small sort on small arrays */
  if ((!count | !array))
    return;
  if (count < 3) { /* special case */
    if (FIO_SORT_IS_BIGGER((array[0]), (array[count == 2])))
      FIO_SORT_SWAP((array[0]), (array[1]));
    return;
  }
  /* place smallest item in position array[0] (guard element) */
  for (size_t pos = 1; pos < count; ++pos) {
    if (FIO_SORT_IS_BIGGER((array[0]), (array[pos]))) {
      FIO_SORT_SWAP((array[0]), (array[pos]));
    }
  }
  /* perform insert sort */
  for (size_t i = 2; i < count; ++i) {
    for (size_t a = i - 1; FIO_SORT_IS_BIGGER((array[a]), (array[a + 1]));
         --a) {
      FIO_SORT_SWAP((array[a]), (array[a + 1]));
    }
  }
}

/* Sorts a `FIO_SORT_TYPE` array with `count` members. */
SFUNC void FIO_NAME(FIO_SORT_NAME, qsort)(FIO_SORT_TYPE *array, size_t count) {
  /* With thanks to Douglas C. Schmidt, as I used his code for reference:
   * https://code.woboq.org/userspace/glibc/stdlib/qsort.c.html
   */
  if ((!count | !array))
    return;
  if (count < FIO_SORT_THRESHOLD) {
    FIO_NAME(FIO_SORT_NAME, isort)(array, count);
    return;
  }
  /* no recursion, setup a stack that can hold log2(count). */
  struct {
    FIO_SORT_TYPE *lo;
    FIO_SORT_TYPE *hi;
  } queue[CHAR_BIT * sizeof(count) + 1], *top = queue;
#define fio_sort___queue_push(l, h)                                            \
  top->lo = l;                                                                 \
  top->hi = h;                                                                 \
  ++top;
  /* push all the array as the first queued partition */
  fio_sort___queue_push(array, array + (count - 1));
  for (;;) {
    FIO_SORT_TYPE *lo;
    FIO_SORT_TYPE *hi;
    FIO_SORT_TYPE *mid;
    --top; /* pop stack */
    lo = top->lo;
    hi = top->hi;
    const size_t slice_len = (hi - lo) + 1;

    /* sort small ranges using insert sort */
    if (slice_len < FIO_SORT_THRESHOLD) {
      FIO_NAME(FIO_SORT_NAME, isort)(lo, slice_len);
      if (queue == top)
        return;
      continue;
    }

    /* select a median element (1 of 3, fist, middle, last). */
    /* this also promises ordering between these 3 elements. */
    mid = lo + ((slice_len) >> 1);
    if (FIO_SORT_IS_BIGGER((lo[0]), (hi[0])))
      FIO_SORT_SWAP((lo[0]), (hi[0]));
    if (FIO_SORT_IS_BIGGER((lo[0]), (mid[0])))
      FIO_SORT_SWAP((lo[0]), (mid[0]));
    else if (FIO_SORT_IS_BIGGER((mid[0]), (hi[0])))
      FIO_SORT_SWAP((hi[0]), (mid[0]));

    /* partition: swap elements and pointers so mid is a partition pivot */
    FIO_SORT_TYPE *left = lo + 1;
    FIO_SORT_TYPE *right = hi - 2;
    /* place mid in the lower partition and update pointer, as it's known */
    FIO_SORT_SWAP((right[1]), (mid[0]));
    mid = right + 1;
    for (;;) {
      /* while order is fine, move on. */
      while (FIO_SORT_IS_BIGGER((mid[0]), (left[0])))
        ++left;
      while (FIO_SORT_IS_BIGGER((right[0]), (mid[0])))
        --right;
      /* order issue encountered (relative to pivot / mid)... */
      if (left < right) {
        /* right now, left is bigger than mid *and* right is smaller... swap. */
        FIO_SORT_SWAP(left[0], right[0]);
        ++left;
        --right;
        continue;
      }
      /* we passed the middle point and so, we can finish partitioning */
      if (left > right)
        break;
      /* left == right (odd numbered array) */
      ++left;
      --right;
      break;
    }
    /* push partitions in order of size to the stack (clears smaller first) */
    if ((right - lo) > (hi - left)) {
      fio_sort___queue_push(lo, right);
      fio_sort___queue_push(left, hi);
    } else {
      fio_sort___queue_push(left, hi);
      fio_sort___queue_push(lo, right);
    }
  }
}
#undef fio_sort___queue_push

/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_SORT_TYPE
#undef FIO_SORT_TEST
#undef FIO_SORT_SWAP
#undef FIO_SORT_IS_BIGGER
#undef FIO_SORT_NAME
#endif /* FIO_SORT_NAME */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_THREADS            /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                        Simple Portable Threads



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_THREADS) && !defined(H___FIO_THREADS___H)
#define H___FIO_THREADS___H

/* *****************************************************************************
Module Settings

At this point, define any MACROs and customizable settings available to the
developer.
***************************************************************************** */

#if FIO_OS_POSIX /* POSIX Systems */
#include <pthread.h>
#include <sys/types.h>
#include <sys/wait.h>

#ifndef FIO_THREADS_BYO
typedef pthread_t fio_thread_t;
#endif

#ifndef FIO_THREADS_FORK_BYO
typedef pid_t fio_thread_pid_t;
#endif

#ifndef FIO_THREADS_MUTEX_BYO
typedef pthread_mutex_t fio_thread_mutex_t;
/** Used this macro for static initialization. */
#define FIO_THREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER
#endif

#ifndef FIO_THREADS_COND_BYO
typedef pthread_cond_t fio_thread_cond_t;
#endif

#elif FIO_OS_WIN /* Windows Systems */
#include <synchapi.h>

#ifndef FIO_THREADS_BYO
typedef HANDLE fio_thread_t;
#endif

#ifndef FIO_THREADS_FORK_BYO
typedef DWORD fio_thread_pid_t;
#endif

#ifndef FIO_THREADS_MUTEX_BYO
typedef CRITICAL_SECTION fio_thread_mutex_t;
/** Used this macro for static initialization. */
#define FIO_THREAD_MUTEX_INIT ((fio_thread_mutex_t){0})
#endif

#ifndef FIO_THREADS_COND_BYO
typedef CONDITION_VARIABLE fio_thread_cond_t;
#endif

#else /* No Known System */
#if !defined(FIO_THREADS_BYO) || !defined(FIO_THREADS_FORK_BYO) ||             \
    !defined(FIO_THREADS_MUTEX_BYO) || !defined(FIO_THREADS_COND_BYO)
#error facil.io Simple Portable Threads require a POSIX system or Windows
#endif
#endif /* system detection */

/* *****************************************************************************
API for forking processes
***************************************************************************** */

/** Should behave the same as the POSIX system call `fork`. */
FIO_IFUNC fio_thread_pid_t fio_thread_fork(void);

/** Should behave the same as the POSIX system call `getpid`. */
FIO_IFUNC fio_thread_pid_t fio_thread_getpid(void);

/** Should behave the same as the POSIX system call `kill`. */
FIO_IFUNC int fio_thread_kill(fio_thread_pid_t pid, int sig);

/** Should behave the same as the POSIX system call `waitpid`. */
FIO_IFUNC int fio_thread_waitpid(fio_thread_pid_t pid,
                                 int *stat_loc,
                                 int options);

/* *****************************************************************************
API for spawning threads
***************************************************************************** */

/** Starts a new thread, returns 0 on success and -1 on failure. */
FIO_IFUNC int fio_thread_create(fio_thread_t *t,
                                void *(*fn)(void *),
                                void *arg);

/** Waits for the thread to finish. */
FIO_IFUNC int fio_thread_join(fio_thread_t *t);

/** Detaches the thread, so thread resources are freed automatically. */
FIO_IFUNC int fio_thread_detach(fio_thread_t *t);

/** Ends the current running thread. */
FIO_IFUNC void fio_thread_exit(void);

/* Returns non-zero if both threads refer to the same thread. */
FIO_IFUNC int fio_thread_equal(fio_thread_t *a, fio_thread_t *b);

/** Returns the current thread. */
FIO_IFUNC fio_thread_t fio_thread_current(void);

/** Yields thread execution. */
FIO_IFUNC void fio_thread_yield(void);

/** Possible thread priority values. */
typedef enum {
  FIO_THREAD_PRIORITY_ERROR = -1,
  FIO_THREAD_PRIORITY_LOWEST = 0,
  FIO_THREAD_PRIORITY_LOW,
  FIO_THREAD_PRIORITY_NORMAL,
  FIO_THREAD_PRIORITY_HIGH,
  FIO_THREAD_PRIORITY_HIGHEST,
} fio_thread_priority_e;

/** Returns a thread's priority level. */
FIO_SFUNC fio_thread_priority_e fio_thread_priority(void);

/** Sets a thread's priority level. */
FIO_SFUNC int fio_thread_priority_set(fio_thread_priority_e);

/* *****************************************************************************
API for mutexes
***************************************************************************** */

/**
 * Initializes a simple Mutex.
 *
 * Or use the static initialization value: FIO_THREAD_MUTEX_INIT
 */
FIO_IFUNC int fio_thread_mutex_init(fio_thread_mutex_t *m);

/** Locks a simple Mutex, returning -1 on error. */
FIO_IFUNC int fio_thread_mutex_lock(fio_thread_mutex_t *m);

/** Attempts to lock a simple Mutex, returning zero on success. */
FIO_IFUNC int fio_thread_mutex_trylock(fio_thread_mutex_t *m);

/** Unlocks a simple Mutex, returning zero on success or -1 on error. */
FIO_IFUNC int fio_thread_mutex_unlock(fio_thread_mutex_t *m);

/** Destroys the simple Mutex (cleanup). */
FIO_IFUNC void fio_thread_mutex_destroy(fio_thread_mutex_t *m);

/* *****************************************************************************
API for conditional variables
***************************************************************************** */

/** Initializes a simple conditional variable. */
FIO_IFUNC int fio_thread_cond_init(fio_thread_cond_t *c);

/** Waits on a conditional variable (MUST be previously locked). */
FIO_IFUNC int fio_thread_cond_wait(fio_thread_cond_t *c, fio_thread_mutex_t *m);

/** Waits on a conditional variable (MUST be previously locked). */
FIO_IFUNC int fio_thread_cond_timedwait(fio_thread_cond_t *c,
                                        fio_thread_mutex_t *m,
                                        size_t milliseconds);

/** Signals a simple conditional variable. */
FIO_IFUNC int fio_thread_cond_signal(fio_thread_cond_t *c);

/** Destroys a simple conditional variable. */
FIO_IFUNC void fio_thread_cond_destroy(fio_thread_cond_t *c);

/* *****************************************************************************


POSIX Implementation - inlined static functions


***************************************************************************** */
#if FIO_OS_POSIX

#ifndef FIO_THREADS_FORK_BYO
/** Should behave the same as the POSIX system call `getpid`. */
FIO_IFUNC fio_thread_pid_t fio_thread_getpid(void) {
  return (fio_thread_pid_t)getpid();
}
/** Should behave the same as the POSIX system call `fork`. */
FIO_IFUNC fio_thread_pid_t fio_thread_fork(void) {
  return (fio_thread_pid_t)fork();
}

/** Should behave the same as the POSIX system call `kill`. */
FIO_IFUNC int fio_thread_kill(fio_thread_pid_t i, int s) {
  return kill((pid_t)i, s);
}

/** Should behave the same as the POSIX system call `waitpid`. */
FIO_IFUNC int fio_thread_waitpid(fio_thread_pid_t i, int *s, int o) {
  return waitpid((pid_t)i, s, o);
}
#endif /* FIO_THREADS_FORK_BYO */

#ifndef FIO_THREADS_BYO
// clang-format off

/** Starts a new thread, returns 0 on success and -1 on failure. */
FIO_IFUNC int fio_thread_create(fio_thread_t *t, void *(*fn)(void *), void *arg) { return pthread_create(t, NULL, fn, arg); }

FIO_IFUNC int fio_thread_join(fio_thread_t *t) { return pthread_join(*t, NULL); }

/** Detaches the thread, so thread resources are freed automatically. */
FIO_IFUNC int fio_thread_detach(fio_thread_t *t) { return pthread_detach(*t); }

/** Ends the current running thread. */
FIO_IFUNC void fio_thread_exit(void) { pthread_exit(NULL); }

/* Returns non-zero if both threads refer to the same thread. */
FIO_IFUNC int fio_thread_equal(fio_thread_t *a, fio_thread_t *b) { return pthread_equal(*a, *b); }

/** Returns the current thread. */
FIO_IFUNC fio_thread_t fio_thread_current(void) { return pthread_self(); }

/** Yields thread execution. */
FIO_IFUNC void fio_thread_yield(void) { sched_yield(); }
#endif /* FIO_THREADS_BYO */


#if defined(__APPLE__) &&  __has_include("sys/qos.h") /* MacOS with QoS */
#include "sys/qos.h"

/** Returns a thread's priority level. */
FIO_SFUNC fio_thread_priority_e fio_thread_priority(void) {
  qos_class_t qos;
  int rel;
  if(pthread_get_qos_class_np(pthread_self(), &qos, &rel)) return FIO_THREAD_PRIORITY_ERROR;
  switch(qos) {
  case QOS_CLASS_BACKGROUND:       return FIO_THREAD_PRIORITY_LOWEST;
  case QOS_CLASS_UTILITY:          return FIO_THREAD_PRIORITY_LOW;
  case QOS_CLASS_DEFAULT:          return FIO_THREAD_PRIORITY_NORMAL;
  case QOS_CLASS_UNSPECIFIED:      return FIO_THREAD_PRIORITY_NORMAL;
  case QOS_CLASS_USER_INITIATED:   return FIO_THREAD_PRIORITY_HIGH;
  case QOS_CLASS_USER_INTERACTIVE: return FIO_THREAD_PRIORITY_HIGHEST;
  }
  return FIO_THREAD_PRIORITY_ERROR;
}

/** Sets a thread's priority level. */
FIO_SFUNC int fio_thread_priority_set(fio_thread_priority_e pr) {
  // pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t * _Nullable __qos_class, int * _Nullable __relative_priority)
  qos_class_t qos = QOS_CLASS_DEFAULT;
  int rel = 0;
  switch(pr) {
  case FIO_THREAD_PRIORITY_LOWEST:  qos = QOS_CLASS_BACKGROUND;       rel = -4; break;
  case FIO_THREAD_PRIORITY_LOW:     qos = QOS_CLASS_UTILITY;          rel = -2; break;
  case FIO_THREAD_PRIORITY_NORMAL:  qos = QOS_CLASS_DEFAULT;          rel = 0; break;
  case FIO_THREAD_PRIORITY_HIGH:    qos = QOS_CLASS_USER_INITIATED;   rel = 2; break;
  case FIO_THREAD_PRIORITY_HIGHEST: qos = QOS_CLASS_USER_INTERACTIVE; rel = 4; break;
  case FIO_THREAD_PRIORITY_ERROR:   qos = QOS_CLASS_DEFAULT;          rel = 0; break;
  }
  return pthread_set_qos_class_self_np(qos, rel);
}

#else /* portable POSIX */

/** Returns a thread's priority level. */
FIO_SFUNC fio_thread_priority_e fio_thread_priority(void) {
  int policy;
  struct sched_param schd;
  if(pthread_getschedparam(pthread_self(), &policy, &schd))
    return FIO_THREAD_PRIORITY_ERROR;
  int min = sched_get_priority_min(policy);
  int max = sched_get_priority_max(policy);
  size_t steps = (size_t)(max - min) / 5;
  size_t priority_value = (schd.sched_priority - min);
  if(steps) priority_value /= steps; else priority_value = 5;
  switch(priority_value) {
  case 0: return FIO_THREAD_PRIORITY_LOWEST;
  case 1: return FIO_THREAD_PRIORITY_LOW;  
  case 2: return FIO_THREAD_PRIORITY_NORMAL;  
  case 3: return FIO_THREAD_PRIORITY_HIGH;  
  case 4: return FIO_THREAD_PRIORITY_HIGHEST;  
  }
  return FIO_THREAD_PRIORITY_ERROR;
}

/** Sets a thread's priority level. */
FIO_SFUNC int fio_thread_priority_set(fio_thread_priority_e priority_value) {
  int policy;
  struct sched_param schd;
  if(pthread_getschedparam(pthread_self(), &policy, &schd))
    return -1;
  int min = sched_get_priority_min(policy);
  int max = sched_get_priority_max(policy);
  size_t steps = (size_t)(max - min) / 5;
  switch(priority_value) {
  case FIO_THREAD_PRIORITY_LOWEST:  schd.sched_priority = min + steps; break;
  case FIO_THREAD_PRIORITY_LOW:     schd.sched_priority = min + (steps << 1); break; 
  case FIO_THREAD_PRIORITY_NORMAL:  schd.sched_priority = max - (steps << 1); break; 
  case FIO_THREAD_PRIORITY_HIGH:    schd.sched_priority = max - steps; break; 
  case FIO_THREAD_PRIORITY_HIGHEST: schd.sched_priority = max; break; 
  case FIO_THREAD_PRIORITY_ERROR: return -1;
  }
  return pthread_setschedparam(pthread_self(), policy, &schd);
}

#endif /* MacOS vs. portable POSIX */

#ifndef FIO_THREADS_MUTEX_BYO

/** Initializes a simple Mutex. */
FIO_IFUNC int fio_thread_mutex_init(fio_thread_mutex_t *m) { return pthread_mutex_init(m, NULL); }

/** Locks a simple Mutex, returning -1 on error. */
FIO_IFUNC int fio_thread_mutex_lock(fio_thread_mutex_t *m) { return pthread_mutex_lock(m); }

/** Attempts to lock a simple Mutex, returning zero on success. */
FIO_IFUNC int fio_thread_mutex_trylock(fio_thread_mutex_t *m) { return pthread_mutex_trylock(m); }

/** Unlocks a simple Mutex, returning zero on success or -1 on error. */
FIO_IFUNC int fio_thread_mutex_unlock(fio_thread_mutex_t *m) { return pthread_mutex_unlock(m); }

/** Destroys the simple Mutex (cleanup). */
FIO_IFUNC void fio_thread_mutex_destroy(fio_thread_mutex_t *m) { pthread_mutex_destroy(m); *m = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER; }

#endif /* FIO_THREADS_MUTEX_BYO */
// clang-format on

#ifndef FIO_THREADS_COND_BYO
/** Initializes a simple conditional variable. */
FIO_IFUNC int fio_thread_cond_init(fio_thread_cond_t *c) {
  return pthread_cond_init(c, NULL);
}

/** Waits on a conditional variable (MUST be previously locked). */
FIO_IFUNC int fio_thread_cond_wait(fio_thread_cond_t *c,
                                   fio_thread_mutex_t *m) {
  return pthread_cond_wait(c, m);
}

/** Waits on a conditional variable (MUST be previously locked). */
FIO_IFUNC int fio_thread_cond_timedwait(fio_thread_cond_t *c,
                                        fio_thread_mutex_t *m,
                                        size_t milliseconds) {
  struct timespec t;
  clock_gettime(CLOCK_REALTIME, &t);
  milliseconds += t.tv_nsec / 1000000;
  t.tv_sec += (long)(milliseconds / 1000);
  t.tv_nsec = (long)((milliseconds % 1000) * 1000000);
  return pthread_cond_timedwait(c, m, &t);
}

/** Signals a simple conditional variable. */
FIO_IFUNC int fio_thread_cond_signal(fio_thread_cond_t *c) {
  return pthread_cond_signal(c);
}

/** Destroys a simple conditional variable. */
FIO_IFUNC void fio_thread_cond_destroy(fio_thread_cond_t *c) {
  pthread_cond_destroy(c);
}
#endif /* FIO_THREADS_COND_BYO */

/* *****************************************************************************


Windows Implementation - inlined static functions


***************************************************************************** */
#elif FIO_OS_WIN
#include <process.h>
#include <processthreadsapi.h>
#include <tlhelp32.h>

#ifndef FIO_THREADS_FORK_BYO

FIO_IFUNC fio_thread_pid_t fio_thread_getpid(void) {
  return (fio_thread_pid_t)GetCurrentProcessId();
}

#if defined(fork) && defined(WEXITSTATUS) /* unix features pre-patched */
FIO_IFUNC fio_thread_pid_t fio_thread_fork(void) {
  return (fio_thread_pid_t)fork();
}
FIO_IFUNC int fio_thread_kill(fio_thread_pid_t i, int s) {
  return kill((pid_t)i, s);
}
FIO_IFUNC int fio_thread_waitpid(fio_thread_pid_t i, int *s, int o) {
  return waitpid((pid_t)i, s, o);
}

#else /* defined(fork) && defined(WEXITSTATUS) */

FIO_IFUNC fio_thread_pid_t fio_thread_fork(void) {
  FIO_LOG_ERROR("`fork` not implemented, cannot spawn child processes.");
  return (fio_thread_pid_t)-1;
}

FIO_IFUNC int fio_thread_kill(fio_thread_pid_t pid, int sig) {
  /* Credit to Jan Biedermann (GitHub: @janbiedermann) */
  HANDLE handle;
  DWORD status;
  if (sig < 0 || sig >= NSIG) {
    errno = EINVAL;
    return -1;
  }
#ifdef SIGCONT
  if (sig == SIGCONT) {
    errno = ENOSYS;
    return -1;
  }
#endif

  if (pid == -1)
    pid = 0;

  if (!pid)
    handle = GetCurrentProcess();
  else
    handle =
        OpenProcess(PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION, FALSE, pid);
  if (!handle)
    goto something_went_wrong;

  switch (sig) {
#ifdef SIGKILL
  case SIGKILL:
#endif
  case SIGTERM:
  case SIGINT: /* terminate */
    if (!TerminateProcess(handle, 1))
      goto something_went_wrong;
    break;
  case 0: /* check status */
    if (!GetExitCodeProcess(handle, &status))
      goto something_went_wrong;
    if (status != STILL_ACTIVE) {
      errno = ESRCH;
      goto cleanup_after_error;
    }
    break;
  default: /* not supported? */ errno = ENOSYS; goto cleanup_after_error;
  }

  if (pid) {
    CloseHandle(handle);
  }
  return 0;

something_went_wrong:

  switch (GetLastError()) {
  case ERROR_INVALID_PARAMETER: errno = ESRCH; break;
  case ERROR_ACCESS_DENIED:
    errno = EPERM;
    if (handle && GetExitCodeProcess(handle, &status) && status != STILL_ACTIVE)
      errno = ESRCH;
    break;
  default: errno = GetLastError();
  }
cleanup_after_error:
  if (handle && pid)
    CloseHandle(handle);
  return -1;
}

#ifndef WNOHANG
#define WNOHANG 1
#endif /* WNOHANG */

#ifndef WUNTRACED
#define WUNTRACED 2
#endif /* WUNTRACED */

#ifndef WCONTINUED
#define WCONTINUED 8
#endif /* WCONTINUED */

#ifndef WNOWAIT
#define WNOWAIT 0x01000000
#endif /* WNOWAIT */

#ifndef WEXITSTATUS
#define WEXITSTATUS(status) (((status)&0xFF00) >> 8)
#endif /* WEXITSTATUS */

#ifndef WIFEXITED
#define WIFEXITED(status) (WTERMSIG(status) == 0)
#endif /* WIFEXITED */

#ifndef WIFSIGNALED
#define WIFSIGNALED(status) (((signed char)(__WTERMSIG(status) + 1) >> 1) > 0)
#endif /* WIFSIGNALED */

#ifndef WTERMSIG
#define WTERMSIG(status) ((status)&0x7F)
#endif /* WTERMSIG */

#ifndef WIFSTOPPED
#define WIFSTOPPED(status) (((status)&0xFF) == 0x7F)
#endif /* WIFSTOPPED */

#ifndef WSTOPSIG
#define WSTOPSIG(status) WEXITSTATUS(status)
#endif /* WSTOPSIG */

static int fio___thread_waitpid_anychild(PROCESSENTRY32W *pe, DWORD pid) {
  return pe->th32ParentProcessID == GetCurrentProcessId();
}

static int fio___thread_waitpid_pid(PROCESSENTRY32W *pe, DWORD pid) {
  return pe->th32ProcessID == pid;
}

FIO_IFUNC int fio_thread_waitpid(fio_thread_pid_t pid, int *status, int opt) {
  /* adopted from:
   * https://github.com/win32ports/sys_wait_h/blob/master/sys/wait.h Copyright
   * Copyright (c) 2019 win32ports, MIT license
   */
  int saved_status = 0;
  HANDLE hProcess = INVALID_HANDLE_VALUE, hSnapshot = INVALID_HANDLE_VALUE;
  int (*are_these_the_druides_were_looking_for)(PROCESSENTRY32W *, DWORD);
  PROCESSENTRY32W pe;
  DWORD wait_status = 0, exit_code = 0;
  int nohang = WNOHANG == (WNOHANG & opt);
  opt &= ~(WUNTRACED | WNOWAIT | WCONTINUED | WNOHANG);
  if (opt) {
    errno = -EINVAL;
    return -1;
  }

  if (pid > 0 || pid == -1) {
    FIO_LOG_ERROR(
        "fio_thread_waitpid not implemented for pid < -1 || pid ==0.");
    return -1;
  }

  are_these_the_druides_were_looking_for = fio___thread_waitpid_pid;
  if (pid == -1) /* wait for any child */
    are_these_the_druides_were_looking_for = fio___thread_waitpid_anychild;

  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) {
    errno = ECHILD;
    return -1;
  }

  pe.dwSize = sizeof(pe);
  if (!Process32FirstW(hSnapshot, &pe)) {
    CloseHandle(hSnapshot);
    errno = ECHILD;
    return -1;
  }
  do {
    if (are_these_the_druides_were_looking_for(&pe, pid)) {
      hProcess = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,
                             0,
                             pe.th32ProcessID);
      if (INVALID_HANDLE_VALUE == hProcess) {
        CloseHandle(hSnapshot);
        errno = ECHILD;
        return -1;
      }
      break;
    }
  } while (Process32NextW(hSnapshot, &pe));
  if (INVALID_HANDLE_VALUE == hProcess) {
    CloseHandle(hSnapshot);
    errno = ECHILD;
    return -1;
  }

  wait_status = WaitForSingleObject(hProcess, nohang ? 0 : INFINITE);

  if (WAIT_OBJECT_0 == wait_status) {
    if (GetExitCodeProcess(hProcess, &exit_code))
      saved_status |= (exit_code & 0xFF) << 8;
  } else if (WAIT_TIMEOUT == wait_status && nohang) {
    return 0;
  } else {
    CloseHandle(hProcess);
    CloseHandle(hSnapshot);
    errno = ECHILD;
    return -1;
  }

  CloseHandle(hProcess);
  CloseHandle(hSnapshot);

  if (status)
    *status = saved_status;

  return pe.th32ParentProcessID;
}

#endif /* already patched by some other implementation */
#endif /* FIO_THREADS_FORK_BYO */

#ifndef FIO_THREADS_BYO
/** Starts a new thread, returns 0 on success and -1 on failure. */
FIO_IFUNC int fio_thread_create(fio_thread_t *t,
                                void *(*fn)(void *),
                                void *arg) {
  *t = (HANDLE)_beginthreadex(NULL,
                              0,
                              (_beginthreadex_proc_type)(uintptr_t)fn,
                              arg,
                              0,
                              NULL);
  return (!!t) - 1;
}

FIO_IFUNC int fio_thread_join(fio_thread_t *t) {
  int r = 0;
  if (WaitForSingleObject(*t, INFINITE) == WAIT_FAILED) {
    errno = GetLastError();
    r = -1;
  } else
    CloseHandle(*t);
  return r;
}

// clang-format off
/** Detaches the thread, so thread resources are freed automatically. */
FIO_IFUNC int fio_thread_detach(fio_thread_t *t) { return CloseHandle(*t) - 1; }

/** Ends the current running thread. */
FIO_IFUNC void fio_thread_exit(void) { _endthread(); }

/* Returns non-zero if both threads refer to the same thread. */
FIO_IFUNC int fio_thread_equal(fio_thread_t *a, fio_thread_t *b) { return GetThreadId(*a) == GetThreadId(*b); }

/** Returns the current thread. */
FIO_IFUNC fio_thread_t fio_thread_current(void) { return GetCurrentThread(); }

/** Yields thread execution. */
FIO_IFUNC void fio_thread_yield(void) { Sleep(0); }

#endif /* FIO_THREADS_BYO */

/** Returns a thread's priority level. */
FIO_SFUNC fio_thread_priority_e fio_thread_priority(void) {
  switch(GetThreadPriority(GetCurrentThread())) {
  case THREAD_PRIORITY_LOWEST:       return FIO_THREAD_PRIORITY_LOWEST;
  case THREAD_PRIORITY_BELOW_NORMAL: return FIO_THREAD_PRIORITY_LOW;
  case THREAD_PRIORITY_NORMAL:       return FIO_THREAD_PRIORITY_NORMAL;
  case THREAD_PRIORITY_ABOVE_NORMAL: return FIO_THREAD_PRIORITY_HIGH;
  case THREAD_PRIORITY_HIGHEST:      return FIO_THREAD_PRIORITY_HIGHEST;
  default:                           return FIO_THREAD_PRIORITY_ERROR;
  }
}

/** Sets a thread's priority level. */
FIO_SFUNC int fio_thread_priority_set(fio_thread_priority_e pr) {
  int    priority;
  switch(pr){
  case FIO_THREAD_PRIORITY_ERROR: return -1;
  case FIO_THREAD_PRIORITY_LOWEST:  priority = THREAD_PRIORITY_LOWEST; break;
  case FIO_THREAD_PRIORITY_LOW:     priority = THREAD_PRIORITY_BELOW_NORMAL; break;
  case FIO_THREAD_PRIORITY_NORMAL:  priority = THREAD_PRIORITY_NORMAL; break;
  case FIO_THREAD_PRIORITY_HIGH:    priority = THREAD_PRIORITY_ABOVE_NORMAL; break;
  case FIO_THREAD_PRIORITY_HIGHEST: priority = THREAD_PRIORITY_HIGHEST; break;
  }
  return 0 - !SetThreadPriority(GetCurrentThread(), priority);
}

#ifndef FIO_THREADS_MUTEX_BYO

SFUNC int fio___thread_mutex_lazy_init(fio_thread_mutex_t *m);

FIO_IFUNC int fio_thread_mutex_init(fio_thread_mutex_t *m) { InitializeCriticalSection(m); return 0; }

/** Destroys the simple Mutex (cleanup). */
FIO_IFUNC void fio_thread_mutex_destroy(fio_thread_mutex_t *m) { DeleteCriticalSection(m); memset(m,0,sizeof(*m)); }
// clang-format on
/** Unlocks a simple Mutex, returning zero on success or -1 on error. */
FIO_IFUNC int fio_thread_mutex_unlock(fio_thread_mutex_t *m) {
  if (!m)
    return -1;
  LeaveCriticalSection(m);
  return 0;
}

/** Locks a simple Mutex, returning -1 on error. */
FIO_IFUNC int fio_thread_mutex_lock(fio_thread_mutex_t *m) {
  const fio_thread_mutex_t zero = {0};
  if (!FIO_MEMCMP(m, &zero, sizeof(zero)) && fio___thread_mutex_lazy_init(m))
    return -1;
  EnterCriticalSection(m);
  return 0;
}

/** Attempts to lock a simple Mutex, returning zero on success. */
FIO_IFUNC int fio_thread_mutex_trylock(fio_thread_mutex_t *m) {
  const fio_thread_mutex_t zero = {0};
  if (!FIO_MEMCMP(m, &zero, sizeof(zero)) && fio___thread_mutex_lazy_init(m))
    return -1;
  return TryEnterCriticalSection(m) - 1;
}
#endif /* FIO_THREADS_MUTEX_BYO */

#ifndef FIO_THREADS_COND_BYO
/** Initializes a simple conditional variable. */
FIO_IFUNC int fio_thread_cond_init(fio_thread_cond_t *c) {
  InitializeConditionVariable(c);
  return 0;
}

/** Waits on a conditional variable (MUST be previously locked). */
FIO_IFUNC int fio_thread_cond_wait(fio_thread_cond_t *c,
                                   fio_thread_mutex_t *m) {
  return 0 - !SleepConditionVariableCS(c, m, INFINITE);
}

/** Waits on a conditional variable (MUST be previously locked). */
FIO_IFUNC int fio_thread_cond_timedwait(fio_thread_cond_t *c,
                                        fio_thread_mutex_t *m,
                                        size_t milliseconds) {
  return 0 - !SleepConditionVariableCS(c, m, milliseconds);
}

/** Signals a simple conditional variable. */
FIO_IFUNC int fio_thread_cond_signal(fio_thread_cond_t *c) {
  WakeConditionVariable(c);
  return 0;
}

/** Destroys a simple conditional variable. */
FIO_IFUNC void fio_thread_cond_destroy(fio_thread_cond_t *c) { (void)(c); }
#endif /* FIO_THREADS_COND_BYO */

#endif /* FIO_OS_WIN */

/* *****************************************************************************


Multi-Threaded `memcpy` (naive and slow)


***************************************************************************** */

#ifndef FIO_MEMCPY_THREADS
#define FIO_MEMCPY_THREADS 8
#endif
#ifndef FIO_MEMCPY_THREADS___MINCPY
#define FIO_MEMCPY_THREADS___MINCPY (1ULL << 23)
#endif
typedef struct {
  char *restrict dest;
  const char *restrict src;
  size_t bytes;
} fio___thread_memcpy_s;

FIO_SFUNC void *fio___thread_memcpy_task(void *v_) {
  fio___thread_memcpy_s *v = (fio___thread_memcpy_s *)v_;
  FIO_MEMCPY(v->dest, (const void *)(v->src), v->bytes);
  return NULL;
}

/** Multi-threaded memcpy using up to FIO_MEMCPY_THREADS threads */
FIO_SFUNC size_t fio_thread_memcpy(void *restrict dest,
                                   const void *restrict src,
                                   size_t bytes) {
  size_t i = 0, r;
  char *restrict d = (char *restrict)dest;
  const char *restrict s = (const char *restrict)src;
  fio_thread_t threads[FIO_MEMCPY_THREADS - 1];
  fio___thread_memcpy_s info[FIO_MEMCPY_THREADS - 1];
  size_t bytes_per_thread = bytes / FIO_MEMCPY_THREADS;
  if (bytes < FIO_MEMCPY_THREADS___MINCPY)
    goto finished_creating_thread;

  for (; i < (FIO_MEMCPY_THREADS - 1); ++i) {
    info[i] = (fio___thread_memcpy_s){d, s, bytes_per_thread};
    if (fio_thread_create(threads + i, fio___thread_memcpy_task, info + i))
      goto finished_creating_thread;
    d += bytes_per_thread;
    s += bytes_per_thread;
    bytes -= bytes_per_thread;
  }
finished_creating_thread:
  r = i + 1;
  FIO_MEMCPY(d, (const void *)s, bytes); /* memcpy reminder */
  while (i) {
    --i;
    fio_thread_join(threads + i);
  }
  return r;
}

/* *****************************************************************************
Module Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
#if FIO_OS_WIN
#ifndef FIO_THREADS_MUTEX_BYO
/** Initializes a simple Mutex */
SFUNC int fio___thread_mutex_lazy_init(fio_thread_mutex_t *m) {
  int r = 0;
  static fio_lock_i lock = FIO_LOCK_INIT;
  /* lazy initialization */
  fio_thread_mutex_t zero = {0};
  fio_lock(&lock);
  if (!FIO_MEMCMP(m,
                  &zero,
                  sizeof(zero))) { /* retest, as this may have changed... */
    r = fio_thread_mutex_init(m);
  }
  fio_unlock(&lock);
  return r;
}
#endif /* FIO_THREADS_MUTEX_BYO */
#endif /* FIO_OS_WIN */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_THREADS */
#undef FIO_THREADS
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_URL                /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                  URI Parsing



Copyright: Boaz Segev, 2019-2021; License: ISC / MIT (choose your license)
***************************************************************************** */
#if (defined(FIO_URL) || defined(FIO_URI)) && !defined(H___FIO_URL___H)
#define H___FIO_URL___H
/** the result returned by `fio_url_parse` */
typedef struct {
  fio_buf_info_s scheme;
  fio_buf_info_s user;
  fio_buf_info_s password;
  fio_buf_info_s host;
  fio_buf_info_s port;
  fio_buf_info_s path;
  fio_buf_info_s query;
  fio_buf_info_s target;
} fio_url_s;

/**
 * Parses the URI returning it's components and their lengths (no decoding
 * performed, doesn't accept decoded URIs).
 *
 * The returned string are NOT NUL terminated, they are merely locations within
 * the original string.
 *
 * This function attempts to accept many different formats, including any of the
 * following:
 *
 * * `/complete_path?query#target`
 *
 *   i.e.: /index.html?page=1#list
 *
 * * `host:port/complete_path?query#target`
 *
 *   i.e.:
 *      example.com
 *      example.com:8080
 *      example.com/index.html
 *      example.com:8080/index.html
 *      example.com:8080/index.html?key=val#target
 *
 * * `user:password@host:port/path?query#target`
 *
 *   i.e.: user:1234@example.com:8080/index.html
 *
 * * `username[:password]@host[:port][...]`
 *
 *   i.e.: john:1234@example.com
 *
 * * `schema://user:password@host:port/path?query#target`
 *
 *   i.e.: http://example.com/index.html?page=1#list
 *
 * For performance reasons, no format validation is performed. Function assumes
 * that the `url` string is `len` long and contains a valid URL. Invalid formats
 * might produce unexpected results.
 *
 * NOTE: the `unix`, `file` and `priv` schemas are reserved for file paths.
 */
SFUNC fio_url_s fio_url_parse(const char *url, size_t len);

/** The type used by the `FIO_URL_QUERY_EACH` iterator macro. */
typedef struct {
  fio_buf_info_s name;
  fio_buf_info_s value;
  fio_buf_info_s private___;
} fio_url_query_each_s;

/** A helper function for the `FIO_URL_QUERY_EACH` macro implementation. */
FIO_SFUNC fio_url_query_each_s fio_url_query_each_next(fio_url_query_each_s);

/** Iterates through each of the query elements. */
#define FIO_URL_QUERY_EACH(query_buf, i)                                       \
  for (fio_url_query_each_s i = fio_url_query_each_next(                       \
           (fio_url_query_each_s){.private___ = (query_buf)});                 \
       i.name.buf;                                                             \
       i = fio_url_query_each_next(i))

/* Return type for  `fio_url_is_tls` */
typedef struct {
  fio_buf_info_s key;
  fio_buf_info_s cert;
  fio_buf_info_s pass;
  bool tls;
} fio_url_tls_info_s;

/**
 * Returns TLS data associated with the URL.
 *
 * This function supports implicit TLS by scheme data for the following possible
 * values:
 *
 * - `wss`   - Secure WebSockets.
 * - `sses`  - Secure SSE (Server Sent Events).
 * - `https` - Secure HTTP.
 * - `tcps`  - Secure TCP/IP.
 * - `tls`   - Secure TCP/IP.
 * - `udps`  - Secure UDP.
 *
 * i.e.:
 *     tls://example.com/
 *     tcps://example.com/
 *     udps://example.com/
 *
 *     wss://example.com/
 *     https://example.com/
 *     sses://example.com/
 *
 * This function also supports explicit TLS by query data for the following
 * possible key-pair values:
 *
 * - `tls`                   - self-signed TLS (unless key / cert are provided).
 * - `tls=true`              - self-signed TLS (unless key / cert are provided).
 * - `tls=<file>`            - key and certificate files (same path, different
 *                             file extensions).
 * - `key=<file/env_data>`   - path or env variable name for the private key.
 * - `cert=<file/env_data>`  - path or env variable name for the public
 *                             certificate.
 *
 * - `pass`                  - password for decrypting key / cert data.
 *
 *i.e.:
 *
 *     tcp://example.com/?tls          (anonymous TLS)
 *     udp://example.com/?tls=true
 *
 *     https://example.com/?tls=key_cert_folder_or_prefix&pass=key_password
 *
 *     https://example.com/?key=key_file_or_env_var&cert=cert_file_or_env_var&pass=key_password
 *     wss://example.com/?key=key_file_or_env_var&cert=cert_file_or_env_var&pass=key_password
 *     tcp://example.com/?key=key_file_or_env_var&cert=cert_file_or_env_var&pass=key_password
 */
SFUNC fio_url_tls_info_s fio_url_is_tls(fio_url_s u);
/* *****************************************************************************
FIO_URL - Implementation (static)
***************************************************************************** */

/** A helper function for the `FIO_URL_QUERY_EACH` macro implementation. */
FIO_SFUNC fio_url_query_each_s fio_url_query_each_next(fio_url_query_each_s i) {
  i.name = i.private___;
  if (!i.name.buf)
    return i;
  char *amp = (char *)FIO_MEMCHR(i.name.buf, '&', i.name.len);
  if (amp) {
    i.name.len = amp - i.name.buf;
    i.private___.len -= i.name.len + 1;
    i.private___.buf += i.name.len + 1;
  } else {
    i.private___ = FIO_BUF_INFO0;
  }
  char *equ = (char *)FIO_MEMCHR(i.name.buf, '=', i.name.len);
  if (equ) {
    i.value.buf = equ + 1;
    i.value.len = (i.name.buf + i.name.len) - i.value.buf;
    i.name.len = equ - i.name.buf;
  } else {
    i.value = FIO_BUF_INFO0;
  }
  return i;
}

/* *****************************************************************************
FIO_URL - Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/**
 * Parses the URI returning it's components and their lengths (no decoding
 * performed, doesn't accept decoded URIs).
 *
 * The returned string are NOT NUL terminated, they are merely locations within
 * the original string.
 *
 * This function expects any of the following formats:
 *
 * * `/complete_path?query#target`
 *
 *   i.e.: /index.html?page=1#list
 *
 * * `host:port/complete_path?query#target`
 *
 *   i.e.:
 *      example.com/index.html
 *      example.com:8080/index.html
 *
 * * `schema://user:password@host:port/path?query#target`
 *
 *   i.e.: http://example.com/index.html?page=1#list
 *
 * For performance reasons, no format validation is performed. Function assumes
 * that the `url` string is `len` long and contains a valid URL. Invalid formats
 * might produce unexpected results.
 */
SFUNC fio_url_s fio_url_parse(const char *url, size_t len) {
  /*
  Intention:
  [schema://][[user][:password]@][host.com][:port][path][?quary][#target]
  */
  const char *end = url + len;
  const char *pos = url;
  fio_url_s r = {.scheme = {.buf = (char *)url}};
  if (len == 0) {
    goto finish;
  }

  if (*pos == '/') /* start at path */
    goto start_path;

  while (pos < end && *pos && *pos != ':' && *pos != '/' && *pos != '@' &&
         *pos != '#' && *pos != '?')
    ++pos;

  if (pos == end) {
    /* was only host (path starts with '/') */
    r.host = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    goto finish;
  }

  switch (*pos) {
  case '@':
    /* username@[host] */
    r.user = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    ++pos;
    goto start_host;
  case '/':
    /* host[/path] */
    r.host = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    goto start_path;
  case '?':
    /* host?[query] */
    r.host = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    ++pos;
    goto start_query;
  case '#':
    /* host#[target] */
    r.host = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    ++pos;
    goto start_target;
  case ':':
    if (pos + 2 <= end && pos[1] == '/' && pos[2] == '/') {
      /* scheme:// */
      r.scheme.len = pos - url;
      pos += 3;
    } else {
      /* username:[password] OR */
      /* host:[port] */
      r.user = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
      ++pos;
      goto start_password;
    }
    break;
  }

  /* start_username: */
  url = pos;
  while (pos < end && *pos && *pos != ':' && *pos != '/' && *pos != '@' &&
         *pos != '#' && *pos != '?')
    ++pos;

  if (pos >= end) { /* scheme://host */
    r.host = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    goto finish;
  }

  switch (*pos) {
  case '/':
    /* scheme://host[/path] */
    r.host = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    goto start_path;
  case '@':
    /* scheme://username@[host]... */
    r.user = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    ++pos;
    goto start_host;
  case '?':
    /* scheme://host[?query] (bad)*/
    r.host = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    ++pos;
    goto start_query;
  case '#':
    /* scheme://host[#target] (bad)*/
    r.host = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    ++pos;
    goto start_query;
  case ':':
    /* scheme://username:[password]@[host]... OR */
    /* scheme://host:[port][/...] */
    r.user = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    ++pos;
    break;
  }

start_password:
  url = pos;
  while (pos < end && *pos && *pos != '/' && *pos != '@' && *pos != '?')
    ++pos;

  if (pos >= end) {
    /* was host:port */
    r.port = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    r.host = r.user;
    r.user.len = 0;
    goto finish;
  }

  switch (*pos) {
  case '?': /* fall through */
  case '/':
    r.port = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    r.host = r.user;
    r.user.len = 0;
    goto start_path;
  case '@':
    r.password = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
    ++pos;
    break;
  }

start_host:
  url = pos;
  while (pos < end && *pos && *pos != '/' && *pos != ':' && *pos != '#' &&
         *pos != '?')
    ++pos;

  r.host = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
  if (pos >= end) {
    goto finish;
  }
  switch (*pos) {
  case '/':
    /* scheme://[...@]host[/path] */
    goto start_path;
  case '?':
    /* scheme://[...@]host?[query] (bad)*/
    ++pos;
    goto start_query;
  case '#':
    /* scheme://[...@]host#[target] (bad)*/
    ++pos;
    goto start_target;
    // case ':':
    /* scheme://[...@]host:[port] */
  }
  ++pos;

  // start_port:
  url = pos;
  while (pos < end && *pos && *pos != '/' && *pos != '#' && *pos != '?')
    ++pos;

  r.port = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));

  if (pos >= end) {
    /* scheme://[...@]host:port */
    goto finish;
  }
  switch (*pos) {
  case '?':
    /* scheme://[...@]host:port?[query] (bad)*/
    ++pos;
    goto start_query;
  case '#':
    /* scheme://[...@]host:port#[target] (bad)*/
    ++pos;
    goto start_target;
    // case '/':
    /* scheme://[...@]host:port[/path] */
  }

start_path:
  url = pos;
  while (pos < end && *pos && *pos != '#' && *pos != '?')
    ++pos;

  r.path = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));

  if (pos >= end) {
    goto finish;
  }
  ++pos;
  if (pos[-1] == '#')
    goto start_target;

start_query:
  url = pos;
  while (pos < end && *pos && *pos != '#')
    ++pos;

  r.query = FIO_BUF_INFO2((char *)url, (size_t)(pos - url));
  ++pos;

  if (pos >= end)
    goto finish;

start_target:
  r.target = FIO_BUF_INFO2((char *)pos, (size_t)(end - pos));

finish:

  if (r.scheme.len == 4 && r.host.buf) { /* recognize file paths */
    uint32_t s, file_str, unix_str, priv_str;
    fio_memcpy4(&file_str, "file");
    fio_memcpy4(&unix_str, "unix");
    fio_memcpy4(&priv_str, "priv");
    fio_memcpy4(&s, r.scheme.buf);
    s |= 0x20202020U; /* downcase */
    if (s == file_str || s == unix_str || s == priv_str) {
      r.path.buf = r.scheme.buf + 7;
      r.path.len = end - (r.scheme.buf + 7);
      if (r.query.len)
        r.path.len = r.query.buf - (r.path.buf + 1);
      else if (r.target.len)
        r.path.len = r.target.buf - (r.path.buf + 1);
      r.user.len = r.password.len = r.port.len = r.host.len = 0;
    }
  } else if (!r.scheme.len && r.host.buf && r.host.buf[0] == '.') {
    r.path.len = end - r.host.buf;
    r.path.buf = r.host.buf;
    r.query.len = r.target.len = r.host.len = 0;
  }

  /* set any empty values to NULL */
  if (!r.scheme.len)
    r.scheme.buf = NULL;
  if (!r.user.len)
    r.user.buf = NULL;
  if (!r.password.len)
    r.password.buf = NULL;
  if (!r.host.len)
    r.host.buf = NULL;
  if (!r.port.len)
    r.port.buf = NULL;
  if (!r.path.len)
    r.path.buf = NULL;
  if (!r.query.len)
    r.query.buf = NULL;
  if (!r.target.len)
    r.target.buf = NULL;

  return r;
}

/* Returns TLS data associated with the URL. */
SFUNC fio_url_tls_info_s fio_url_is_tls(fio_url_s u) {
  fio_url_tls_info_s r = {0};
  switch (u.scheme.len) {
  case 3: /* wss || tls || ssl */
    r.tls =
        ((fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("wss:") ||
         (fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("tls:") ||
         (fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("ssl:"));

    break;
  case 4: /* ssse || sses || tcps || stcp || udps || sudp */
    r.tls =
        ((fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("sses") ||
         (fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("ssse") ||
         (fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("tcps") ||
         (fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("stcp") ||
         (fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("udps") ||
         (fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("sudp"));
    break;
  case 5: /* https */
    r.tls = ((u.scheme.buf[4] | 32) == 's' &&
             (fio_buf2u32u(u.scheme.buf) | 0x20202020) == fio_buf2u32u("http"));
    break;
  }
  if (u.query.len) { /* key=, cert=, pass=, password=*/
    fio_buf_info_s key = {0};
    fio_buf_info_s cert = {0};
    fio_buf_info_s pass = {0};
    uint32_t name;
    const uint32_t wrd_key = fio_buf2u32u("key="); /* keyword's value */
    const uint32_t wrd_tls = fio_buf2u32u("tls=");
    const uint32_t wrd_ssl = fio_buf2u32u("ssl=");
    const uint32_t wrd_cert = fio_buf2u32u("cert");
    const uint32_t wrd_true = fio_buf2u32u("true");
    const uint32_t wrd_pass = fio_buf2u32u("pass");
    const uint64_t wrd_password = fio_buf2u64u("password");
    FIO_URL_QUERY_EACH(u.query, i) { /* iterates each name=value pair */
      switch (i.name.len) {
      case 8:
        if ((fio_buf2u64u(i.name.buf) | 0x2020202020202020ULL) == wrd_password)
          pass = i.value;
        break;
      case 3:
        name = fio_buf2u32u(i.name.buf) | 0x20202020UL; /* '=' stays the same */
        name &= fio_buf2u32u("\xFF\xFF\xFF\x00");
        name |= fio_buf2u32u("\x00\x00\x00="); /* in case there was no = sign */
        if (name == wrd_key) {
          if (i.value.len)
            key = i.value;
        } else if (name == wrd_tls || name == wrd_ssl) {
          r.tls = 1;
          if (i.value.len && !(i.value.len == 1 && i.value.buf[0] == '1') &&
              !(i.value.len == 4 &&
                (fio_buf2u32u(i.value.buf) | 0x20202020UL) == wrd_true))
            cert = key = i.value;
        }
        break;
      case 4:
        name = fio_buf2u32u(i.name.buf) | 0x20202020UL;
        if (name == wrd_cert)
          cert = i.value;
        else if (name == wrd_pass)
          pass = i.value;
        break;
      }
    }
    if (key.len && cert.len) {
      r.key = key;
      r.cert = cert;
      if (pass.len)
        r.pass = pass;
      r.tls = 1;
    }
  }
  FIO_LOG_DDEBUG2(
      "URL TLS detection:\n\t%s\n\tkey: %.*s\n\tcert: %.*s\n\tpass: %.*s",
      (r.tls ? "Secure" : "plaintext"),
      (int)r.key.len,
      r.key.buf,
      (int)r.cert.len,
      r.cert.buf,
      (int)r.pass.len,
      r.pass.buf);
  return r;
}
/* *****************************************************************************
FIO_URL - Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_URL || FIO_URI */
#undef FIO_URL
#undef FIO_URI
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_FILES              /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                   Common File Operations (POSIX style)



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_FILES) && !defined(H___FIO_FILES___H)
#define H___FIO_FILES___H

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

/* *****************************************************************************
File Helper API
***************************************************************************** */

/**
 * Opens `filename`, returning the same as values as `open` on POSIX systems.
 *
 * If `path` starts with a `"~/"` than it will be relative to the user's home
 * folder (on Windows, testing for `"~\"`).
 */
SFUNC int fio_filename_open(const char *filename, int flags);

/** Returns 1 if `path` does folds backwards (OS separator dependent). */
SFUNC int fio_filename_is_unsafe(const char *path);

/** Returns 1 if `path` does folds backwards (has "/../" or "//"). */
SFUNC int fio_filename_is_unsafe_url(const char *path);

/** Creates a temporary file, returning its file descriptor. */
SFUNC int fio_filename_tmp(void);

/**
 * Overwrites `filename` with the data in the buffer.
 *
 * If `path` starts with a `"~/"` than it will be relative to the user's home
 * folder (on Windows, testing for `"~\"`).
 *
 * Returns -1 on error or 0 on success. On error, the state of the file is
 * undefined (may be doesn't exit / nothing written / partially written).
 */
FIO_IFUNC int fio_filename_overwrite(const char *filename,
                                     const void *buf,
                                     size_t len);

/** Returns the file size (or 0 on both error / empty file). */
FIO_IFUNC size_t fio_filename_size(const char *filename);

/** Returns the file size (or 0 on both error / empty file). */
FIO_IFUNC size_t fio_fd_size(int fd);

/**
 * Returns the file type (or 0 on both error).
 *
 * See: https://www.man7.org/linux/man-pages/man7/inode.7.html
 */
FIO_IFUNC size_t fio_filename_type(const char *filename);

/**
 * Returns the file type (or 0 on both error).
 *
 * See: https://www.man7.org/linux/man-pages/man7/inode.7.html
 */
FIO_IFUNC size_t fio_fd_type(int fd);

/** Tests if `filename` references a folder. Returns -1 on error. */
#define fio_filename_is_folder(filename)                                       \
  (fio_filename_type((filename)) == S_IFDIR)

/**
 * Writes data to a file handle, returning the number of bytes written.
 *
 * Returns -1 on error.
 *
 * Since some systems have a limit on the number of bytes that can be written at
 * a time, this function fragments the system calls into smaller `write` blocks,
 * allowing large data to be written.
 *
 * If the file descriptor is non-blocking, test errno for EAGAIN / EWOULDBLOCK.
 */
FIO_IFUNC ssize_t fio_fd_write(int fd, const void *buf, size_t len);

/**
 * Reads up to `len` bytes from `fd`, returning the number of bytes read.
 *
 * Returns 0 if no bytes were read or on error.
 *
 * Since some systems have a limit on the number of bytes that can be read at
 * a time, this function fragments the system calls into smaller `read` blocks,
 * allowing large data to be read.
 *
 * If the file descriptor is non-blocking, test errno for EAGAIN / EWOULDBLOCK.
 */
FIO_IFUNC size_t fio_fd_read(int fd, void *buf, size_t len, off_t start_at);

/** A result type for the filename parsing helper. */
typedef struct {
  fio_buf_info_s folder;
  fio_buf_info_s basename;
  fio_buf_info_s ext;
} fio_filename_s;

/** Parses a file name to folder, base name and extension (zero-copy). */
SFUNC fio_filename_s fio_filename_parse(const char *filename);

/** Parses a file name to folder, base name and extension (zero-copy). */
SFUNC fio_filename_s fio_filename_parse2(const char *filename, size_t len);
/**
 * Returns offset for the next `token` in `fd`, or -1 if reached  EOF.
 *
 * This will use `FIO_FD_FIND_BLOCK` bytes on the stack to read the file in a
 * loop.
 *
 * Pros: limits memory use and (re)allocations, easier overflow protection.
 *
 * Cons: may be slower, as data will most likely be copied again from the file.
 */
SFUNC size_t fio_fd_find_next(int fd, char token, size_t start_at);
/** End of file value for `fio_fd_find_next` */
#define FIO_FD_FIND_EOF ((size_t)-1)
#ifndef FIO_FD_FIND_BLOCK
/** Size on the stack used by `fio_fd_find_next` for each read cycle. */
#define FIO_FD_FIND_BLOCK 4096
#endif

#if FIO_OS_WIN
#define FIO_FOLDER_SEPARATOR '\\'
/** Duplicates the file handle (int)*/
#define fio_file_dup(fd) _dup(fd)
#else
#define FIO_FOLDER_SEPARATOR '/'
/** Duplicates the file handle (int)*/
#define fio_file_dup(fd)     dup(fd)
#endif /* FIO_OS_WIN */

/* *****************************************************************************
File Helper Inline Implementation
***************************************************************************** */

/**
 * Writes data to a file, returning the number of bytes written.
 *
 * Returns -1 on error.
 *
 * Since some systems have a limit on the number of bytes that can be written at
 * a single time, this function fragments the system calls into smaller `write`
 * blocks, allowing large data to be written.
 *
 * If the file descriptor is non-blocking, test errno for EAGAIN / EWOULDBLOCK.
 */
FIO_IFUNC ssize_t fio_fd_write(int fd, const void *buf_, size_t len) {
  if (fd == -1 || !buf_ || !len)
    return -1;
  ssize_t total = 0;
  const char *buf = (const char *)buf_;
  const size_t write_limit = (1ULL << 17);
  while (len > (write_limit - 1)) {
    ssize_t w = write(fd, buf, write_limit);
    if (w > 0) {
      len -= w;
      buf += w;
      total += w;
      continue;
    }
    if (w == -1 && errno == EINTR)
      continue;
    if (total == 0)
      return -1;
    return total;
  }
  while (len) {
    ssize_t w = write(fd, buf, len);
    if (w > 0) {
      len -= w;
      buf += w;
      total += w;
      continue;
    }
    if (w == -1 && errno == EINTR)
      continue;
    if (total == 0)
      return -1;
    return total;
  }
  return total;
}

/**
 * Overwrites `filename` with the data in the buffer.
 *
 * If `path` starts with a `"~/"` than it will be relative to the user's home
 * folder (on Windows, testing for `"~\"`).
 */
FIO_IFUNC int fio_filename_overwrite(const char *filename,
                                     const void *buf,
                                     size_t len) {
  int fd = fio_filename_open(filename, O_RDWR | O_CREAT | O_TRUNC);
  if (fd == -1)
    return -1;
  ssize_t w = fio_fd_write(fd, buf, len);
  close(fd);
  if ((size_t)w != len)
    return -1;
  return 0;
}

/**
 * Reads up to `len` bytes from `fd`, returning the number of bytes read.
 *
 * Since some systems have a limit on the number of bytes that can be read at
 * a time, this function fragments the system calls into smaller `read` blocks,
 * allowing large data to be read.
 *
 * If the file descriptor is non-blocking, test errno for EAGAIN / EWOULDBLOCK.
 */
FIO_IFUNC size_t fio_fd_read(int fd, void *buf, size_t len, off_t start_at) {
  size_t r = 0;
  if (fd == -1 || !len || !buf) {
    errno = ENOENT;
    return r;
  }
  char *d = (char *)buf;
  for (;;) {
    const size_t to_read = /* use read sizes of up to 27 bits */
        (len & (((size_t)1 << 27) - 1)) | ((!!(len >> 27)) << 27);
    ssize_t act;
#if (defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE + 1) > 200809L)
    if ((act = pread(fd, d + r, to_read, start_at)) > 0) {
      r += act;
      len -= act;
      start_at += act;
      if (!len)
        return r;
      continue;
    }
#else
    if ((off_t)lseek(fd,
                     (start_at + (start_at < 0)),
                     ((start_at < 0) ? SEEK_END : SEEK_SET)) == (off_t)-1) {
      if (errno == EINTR)
        continue;
      return -1;
    }
    if ((act = read(fd, d + r, to_read)) > 0) {
      r += act;
      len -= act;
      start_at += act;
      if (!len)
        return r;
      continue;
    }
#endif
    if (act == -1 && errno == EINTR)
      continue;
    return r;
  }
}

/* *****************************************************************************
File Stat In-lined Helpers
***************************************************************************** */

FIO_IFUNC size_t fio_filename_size(const char *filename) {
  size_t r = 0;
  struct stat stt;
  if (stat(filename, &stt))
    return r;
  return (r = stt.st_size);
}

FIO_IFUNC size_t fio_fd_size(int fd) {
  size_t r = 0;
  struct stat stt;
  if (fd == -1)
    return r;
  if (fstat(fd, &stt))
    return r;
  return (r = stt.st_size);
}

FIO_IFUNC size_t fio_filename_type(const char *filename) {
  size_t r = 0;
  struct stat stt;
  if (stat(filename, &stt))
    return r;
  return (r = (size_t)((stt.st_mode & S_IFMT)));
}

FIO_IFUNC size_t fio_fd_type(int fd) {
  size_t r = 0;
  struct stat stt;
  if (fd == -1)
    return r;
  if (fstat(fd, &stt))
    return r;
  return (r = (size_t)((stt.st_mode & S_IFMT)));
}

/* *****************************************************************************
File Helper Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/**
 * Opens `filename`, returning the same as values as `open` on POSIX systems.
 *
 * If `path` starts with a `"~/"` than it will be relative to the user's home
 * folder (on Windows, testing for `"~\"`).
 */
SFUNC int fio_filename_open(const char *filename, int flags) {
  int fd = -1;
  /* POSIX implementations. */
  if (filename == NULL)
    return fd;
  char *path = NULL;
  size_t path_len = 0;

  if (filename[0] == '~' &&
      (filename[1] == FIO_FOLDER_SEPARATOR || filename[1] == '/')) {
    char *home = getenv("HOME");
    if (home) {
      size_t filename_len = FIO_STRLEN(filename);
      size_t home_len = FIO_STRLEN(home);
      if ((home_len + filename_len) >= (1 << 16)) {
        /* too long */
        FIO_LOG_ERROR("couldn't open file, as filename is too long %.*s...",
                      (int)16,
                      (filename_len >= 16 ? filename : home));
        return fd;
      }
      if (home[home_len - 1] == FIO_FOLDER_SEPARATOR ||
          home[home_len - 1] == '/')
        --home_len;
      path_len = home_len + filename_len - 1;
      path =
          (char *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*path) * (path_len + 1), 0);
      if (!path)
        return fd;
      FIO_MEMCPY(path, home, home_len);
      FIO_MEMCPY(path + home_len, filename + 1, filename_len);
      path[path_len] = 0;
      filename = path;
    }
  }
  fd = open(filename, flags, (S_IWUSR | S_IRUSR));
  if (path) {
    FIO_MEM_FREE_(path, path_len + 1);
  }
  return fd;
}

/** Returns 1 if `path` possibly folds backwards (has "/../", "/..", "//"). */
SFUNC int fio___filename_is_unsafe_sep(const char *path, const char sep) {
  if (!path) /* no file is a safe file, nothing to do */
    return 0;
  /* Check for leading "../" which escapes the base directory */
  if (path[0] == '.' && path[1] == '.' && (path[2] == sep || path[2] == '\0'))
    return 1;
  /* Scan through path looking for problematic patterns */
  while (*path) {
    if (path[0] == sep) {
      /* Check for "//" (double separator, potential path confusion) */
      if (path[1] == sep)
        return 1;
      /* Check for "/../" or "/.." at end (path traversal) */
      if (path[1] == '.' && path[2] == '.' &&
          (path[3] == sep || path[3] == '\0'))
        return 1;
    }
    ++path;
  }
  return 0;
}

/** Returns 1 if `path` does folds backwards (has "/../" or "//"). */
SFUNC int fio_filename_is_unsafe(const char *path) {
#if FIO_OS_WIN
  return fio___filename_is_unsafe_sep(path, '\\');
#else
  return fio___filename_is_unsafe_sep(path, '/');
#endif
}

/** Returns 1 if `path` does folds backwards (has "/../" or "//"). */
SFUNC int fio_filename_is_unsafe_url(const char *path) {
  return fio___filename_is_unsafe_sep(path, '/');
}

/** Creates a temporary file, returning its file descriptor. */
SFUNC int fio_filename_tmp(void) {
  // create a temporary file to contain the data.
  int fd;
  char name_template[512];
  size_t len = 0;
  const char sep = FIO_FOLDER_SEPARATOR;
  const char *tmp = NULL;

  if (!tmp)
    tmp = getenv("TMPDIR");
  if (!tmp)
    tmp = getenv("TMP");
  if (!tmp)
    tmp = getenv("TEMP");
#if defined(P_tmpdir)
  if (!tmp && sizeof(P_tmpdir) < 464 && sizeof(P_tmpdir) > 0) {
    tmp = P_tmpdir;
  }
#endif
  if (tmp && (len = FIO_STRLEN(tmp)) && len < 464) {
    FIO_MEMCPY(name_template, tmp, len);
    len -= (tmp[len - 1] == sep || tmp[len - 1] == '/');
  } else {
    /* use current folder */
    name_template[len++] = '.';
  }
#ifdef O_TMPFILE
  name_template[len] = 0;
  fd = open(name_template, O_TMPFILE | O_EXCL | O_RDWR, S_IRUSR | S_IWUSR);
  if (fd != -1)
    return fd;
#endif
  name_template[len++] = sep;
  FIO_MEMCPY(name_template + len, "facil_io_tmp_", 13);
  len += 13;
  len += fio_ltoa(name_template + len, fio_rand64(), 32);
  do {
    fio_ltoa(name_template + len, fio_rand64(), 32);
    fd = open(name_template, O_CREAT | O_EXCL | O_RDWR, S_IRUSR | S_IWUSR);
  } while (fd == -1 && errno == EEXIST);
  return fd;
  (void)tmp;
}

/** Parses a file name to folder, base name and extension (zero-copy). */
SFUNC fio_filename_s fio_filename_parse(const char *filename) {
  fio_filename_s r = {{0}};
  if (!filename || !filename[0])
    return r;
  const char *pos = filename;
  r.basename.buf = (char *)filename;
  for (;;) {
    switch (*pos) {
    case 0:
      if (r.ext.buf) {
        r.ext.len = pos - r.ext.buf;
        if (!r.basename.len) {
          r.basename = FIO_BUF_INFO2(--r.ext.buf, ++r.ext.len);
          r.ext.buf = NULL;
          r.ext.len = 0;
        }
      } else {
        r.basename.len = (size_t)(pos - r.basename.buf);
      }
      if (!r.folder.len)
        r.folder.buf = NULL;
      if (!r.basename.len)
        r.basename.buf = NULL;
      if (!r.ext.len)
        r.ext.buf = NULL;
      return r;
#if FIO_OS_WIN
    case '/': /* pass through (on windows test both variants) */
#endif
    case FIO_FOLDER_SEPARATOR:
      r.folder.buf = (char *)filename;
      r.folder.len = (size_t)(pos - filename) + 1;
      r.basename.buf = (char *)pos + 1;
      r.ext.buf = NULL;
      r.basename.len = 0;
      break;
    case '.':
      if (!r.ext.buf) {
        r.ext.buf = (char *)pos + 1;
        r.basename.len = (char *)pos - r.basename.buf;
      }
      break;
    }
    ++pos;
  }
}

/** Parses a file name to folder, base name and extension (zero-copy). */
SFUNC fio_filename_s fio_filename_parse2(const char *filename, size_t len) {
  fio_filename_s r = {{0}};
  if (!filename || !filename[0])
    return r;
  const char *pos = filename;
  const char *end = filename + len;
  r.basename.buf = (char *)filename;
  for (;;) {
    if (pos == end)
      goto done;
    switch (*pos) {
    case 0:
    done:
      if (r.ext.buf) {
        r.ext.len = pos - r.ext.buf;
        if (!r.basename.len) {
          r.basename = FIO_BUF_INFO2(--r.ext.buf, ++r.ext.len);
          r.ext.buf = NULL;
          r.ext.len = 0;
        }
      } else {
        r.basename.len = (size_t)(pos - r.basename.buf);
      }
      if (!r.folder.len)
        r.folder.buf = NULL;
      if (!r.basename.len)
        r.basename.buf = NULL;
      if (!r.ext.len)
        r.ext.buf = NULL;
      return r;
#if FIO_OS_WIN
    case '/': /* pass through (on windows test both variants) */
#endif
    case FIO_FOLDER_SEPARATOR:
      r.folder.buf = (char *)filename;
      r.folder.len = (size_t)(pos - filename) + 1;
      r.basename.buf = (char *)pos + 1;
      r.ext.buf = NULL;
      r.basename.len = 0;
      break;
    case '.':
      if (!r.ext.buf) {
        r.ext.buf = (char *)pos + 1;
        r.basename.len = (char *)pos - r.basename.buf;
      }
      break;
    }
    ++pos;
  }
}
/** Returns index for next `token` in `fd`, or -1 at EOF. */
SFUNC size_t fio_fd_find_next(int fd, char token, size_t start_at) {
  size_t r = FIO_FD_FIND_EOF;
  if (fd == -1 || start_at == FIO_FD_FIND_EOF)
    return r;
  char buf[FIO_FD_FIND_BLOCK];
  for (;;) {
    size_t l = fio_fd_read(fd, buf, (size_t)FIO_FD_FIND_BLOCK, (off_t)start_at);
    if (!l)
      return r;
    char *pos = (char *)FIO_MEMCHR(buf, token, l);
    if (!pos) {
      start_at += l;
      continue;
    }
    r = start_at + (size_t)(pos - buf);
    return r;
  }
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_FILES */
#undef FIO_FILES
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_ATOL               /* Development inclusion - ignore line */
#define FIO_JSON               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                JSON Parsing


Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_JSON) && !defined(H___FIO_JSON___H)
#define H___FIO_JSON___H

#ifndef FIO_JSON_MAX_DEPTH
/**
 * Maximum allowed JSON nesting level. MUST be less then 65536
 *
 * Values above 65536 might cause the stack to overflow and cause a failure.
 */
#define FIO_JSON_MAX_DEPTH 128
#endif

FIO_ASSERT_STATIC(FIO_JSON_MAX_DEPTH < 65536, "FIO_JSON_MAX_DEPTH too big");

#ifndef FIO_JSON_USE_FIO_ATON
#define FIO_JSON_USE_FIO_ATON 0
#endif

/**
 * The JSON parser settings (callbacks).
 *
 * **Ownership**: Callbacks that return `void *` objects transfer ownership to
 * the parser. The parser will either pass these objects to `map_push` /
 * `array_push` (transferring ownership to the container), or call
 * `free_unused_object` if the object is not used (e.g., on error or NULL map
 * key). The `on_error` callback receives ownership of any partial result.
 */
typedef struct {
  /** NULL object was detected. Returns new object as `void *`. */
  void *(*on_null)(void);
  /** TRUE object was detected. Returns new object as `void *`. */
  void *(*on_true)(void);
  /** FALSE object was detected. Returns new object as `void *`. */
  void *(*on_false)(void);
  /** Number was detected (long long). Returns new object as `void *`. */
  void *(*on_number)(int64_t i);
  /** Float was detected (double).Returns new object as `void *`.  */
  void *(*on_float)(double f);
  /** (escaped) String was detected. Returns a new String as `void *`. */
  void *(*on_string)(const void *start, size_t len);
  /** (unescaped) String was detected. Returns a new String as `void *`. */
  void *(*on_string_simple)(const void *start, size_t len);
  /** Dictionary was detected. Returns ctx to hash map or NULL on error. */
  void *(*on_map)(void *ctx, void *at);
  /** Array was detected. Returns ctx to array or NULL on error. */
  void *(*on_array)(void *ctx, void *at);
  /** Map entry detected. Returns non-zero on error. Owns key and value. */
  int (*map_push)(void *ctx, void *key, void *value);
  /** Array entry detected. Returns non-zero on error. Owns value. */
  int (*array_push)(void *ctx, void *value);
  /** Called when an array object (`ctx`) appears done. */
  int (*array_finished)(void *ctx);
  /** Called when a map object (`ctx`) appears done. */
  int (*map_finished)(void *ctx);
  /** Called when context is expected to be an array (i.e., fio_json_update). */
  int (*is_array)(void *ctx);
  /** Called when context is expected to be a map (i.e., fio_json_update). */
  int (*is_map)(void *ctx);
  /** Called for unused objects (e.g., key on error). Must free the object. */
  void (*free_unused_object)(void *ctx);
  /** The JSON parsing encountered an error. Owns ctx, should free or return. */
  void *(*on_error)(void *ctx);
} fio_json_parser_callbacks_s;

/** The JSON return type. */
typedef struct {
  void *ctx;
  size_t stop_pos;
  int err;
} fio_json_result_s;

/**
 * The facil.io JSON parser is a non-strict parser, with support for trailing
 * commas in collections, new-lines in strings, extended escape characters and
 * octal, hex and binary numbers.
 *
 * The parser allows for streaming data and decouples the parsing process from
 * the resulting data-structure by calling static callbacks for JSON related
 * events.
 *
 * Returns the number of bytes consumed before parsing stopped (due to either
 * error or end of data). Stops as close as possible to the end of the buffer or
 * once an object parsing was completed.
 */
SFUNC fio_json_result_s fio_json_parse(fio_json_parser_callbacks_s *settings,
                                       const char *json_string,
                                       const size_t len);

/* *****************************************************************************
JSON Parsing - Implementation - Helpers and Callbacks


Note: static Callacks must be implemented in the C file that uses the parser

Note: a Helper API is provided for the parsing implementation.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

// typedef struct {
//   struct {
//     uintptr_t start;
//     uintptr_t end;
//   } instructions[16];
//   uint32_t count;
// } fio___json_cb_queue_s;

typedef struct {
  fio_json_parser_callbacks_s cb;
  void *ctx;
  void *key;
  const char *pos;
  const char *end;
  uint32_t depth;
  int32_t error;
} fio___json_state_s;

FIO_SFUNC void *fio___json_consume(fio___json_state_s *s);

#if 0 /* Used for Debugging */
#define FIO_JSON___PRINT_STEP(s, step_name)                                    \
  FIO_LOG_DEBUG2("JSON " step_name " starting at: %.*s",                       \
                 (int)((s->end - s->pos) > 16 ? 16 : (s->end - s->pos)),       \
                 s->pos)
#else
#define FIO_JSON___PRINT_STEP(s, step_name)
#endif

FIO_IFUNC int fio___json_consume_whitespace(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "white space");
  while (s->pos < s->end) {
    if (!(((uint8_t)*s->pos == 0x09U) | ((uint8_t)*s->pos == 0x0AU) |
          ((uint8_t)*s->pos == 0x0DU) | ((uint8_t)*s->pos == 0x20U)))
      return 0;
    ++s->pos;
  }
  return (s->error = -1);
}
FIO_IFUNC int fio___json_consume_comma(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "comma");
  fio___json_consume_whitespace(s);
  if (*s->pos != ',')
    return -1;
  fio___json_consume_whitespace(s);
  return 0;
}
FIO_IFUNC int fio___json_consume_colon(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "colon");
  fio___json_consume_whitespace(s);
  if (*s->pos != ':')
    return -1;
  fio___json_consume_whitespace(s);
  return 0;
}

FIO_SFUNC void *fio___json_consume_infinit(fio___json_state_s *s,
                                           _Bool negative) {
  FIO_JSON___PRINT_STEP(s, "infinity");
  const uint64_t inf64 = fio_buf2u64u("infinity");
  const uint16_t inf16 = fio_buf2u16u("nf");
  uint64_t tst64;
  uint16_t tst16;
  if (s->pos + 3 > s->end)
    goto buffer_error;
  tst16 = (fio_buf2u16u(s->pos + 1) | (uint16_t)0x2020U);
  if (tst16 == inf16) {
    if (s->pos + 7 < s->end) {
      tst64 = (fio_buf2u64u(s->pos) | (uint64_t)0x2020202020202020ULL);
      s->pos += (tst64 == inf64) * 5;
    }
    s->pos += 3;
    return s->cb.on_float(negative ? (INFINITY * -1) : INFINITY);
  }
buffer_error:
  s->error = 1;
  return NULL;
}

FIO_SFUNC void *fio___json_consume_number(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "number");
#if FIO_JSON_USE_FIO_ATON
  fio_aton_s aton = fio_aton((char **)&s->pos);
  return aton.is_float ? s->cb.on_float(aton.f) : s->cb.on_number(aton.i);
#else
  const char *tst = s->pos;
  uint64_t i;
  double f;
  _Bool negative = (tst[0] == '-') | (tst[0] == '+');
  _Bool hex = 0;
  _Bool binary = 0;
  long ilimit = 19 + negative;
  tst += negative;
  if (tst + 1 > s->end)
    goto buffer_overflow;
  if ((tst[0] | 0x20) == 'i')
    goto is_inifinity;
  tst += (tst[0] == '0' && tst + 2 < s->end);
  if ((tst[0] | 32) == 'x') {
    hex = 1;
    while ((tst < s->end) & (((tst[0] >= '0') & (tst[0] <= '9')) |
                             (((tst[0] | 32) >= 'a') & ((tst[0] | 32) <= 'f'))))
      ++tst;
  } else if ((tst[0] | 32) == 'b') {
    binary = 1;
    ilimit = 66 + negative;
    while (((tst < s->end) & (tst[0] >= '0') & (tst[0] <= '1')))
      ++tst;
  } else {
    while (((tst < s->end) & (tst[0] >= '0') & (tst[0] <= '9')))
      ++tst;
  }
  if (tst > (s->pos + ilimit) ||
      ((tst < s->end) &&
       (tst[0] == '.' || (tst[0] | 32) == 'e' || (tst[0] | 32) == 'p')))
    goto is_float;
  tst = s->pos;
  s->pos += negative;
  errno = 0;
  i = (hex              ? fio_atol16u((char **)&s->pos)
       : binary         ? fio_atol_bin((char **)&s->pos)
       : *s->pos == '0' ? fio_atol8u((char **)&s->pos)
                        : fio_atol10u((char **)&s->pos));
  if (errno == E2BIG || (((uint64_t)(1 ^ hex ^ binary) << 63) & i))
    goto is_float_from_error;
  // s->error = (errno == E2BIG);
  return s->cb.on_number(fio_u2i_limit(i, negative));
is_float_from_error:
  s->pos = tst;
  errno = 0;

is_float:
  f = fio_atof((char **)&s->pos);
  s->error = (errno == E2BIG);
  return s->cb.on_float(f);

buffer_overflow:
  s->error = 1;
  return NULL;
is_inifinity:
  ++s->pos;
  return fio___json_consume_infinit(s, negative);
#endif /* FIO_JSON_USE_FIO_ATON */
}

FIO_SFUNC void *fio___json_consume_string(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "string");
  void *(*cb)(const void *start, size_t len) = s->cb.on_string_simple;
  const char *start = ++s->pos;
  for (; s->pos < s->end; ++s->pos) {
    if (*s->pos == '"')
      return cb(start, (s->pos++) - start);
    if (*s->pos == '\\')
      cb = s->cb.on_string;
    s->pos += (*s->pos == '\\');
  }
  s->error = 1;
  return NULL;
}

FIO_SFUNC void *fio___json_consume_map(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "map");
  void *old = s->ctx;
  void *old_key = s->key;
  void *map = s->cb.on_map(s, s->key);
  s->ctx = map;
  s->key = NULL;
  if (++s->depth == FIO_JSON_MAX_DEPTH)
    goto too_deep;
  for (;;) {
    ++s->pos;
    s->key = fio___json_consume(s);
    if (s->error || !s->key)
      break;
    if (*s->pos != ':')
      break;
    ++s->pos;
    if (fio___json_consume_whitespace(s))
      break;
    void *value = fio___json_consume(s);
    s->error |= s->cb.map_push(s->ctx, s->key, value);
    s->key = NULL;
    if (s->error || fio___json_consume_whitespace(s))
      break;
    if (*s->pos != ',')
      break;
  }
  if (s->key) {
    s->error = 1;
    s->cb.free_unused_object(s->key);
  } else if (*s->pos != '}' || s->error) {
    s->error = 1;
  } else {
    ++s->pos;
  }
  --s->depth;
  s->ctx = old;
  s->key = old_key;
  s->error |= s->cb.map_finished(map);
  return map;
too_deep:
  s->ctx = old;
  s->key = old_key;
  s->error = 1;
  --s->depth;
  return map;
}
FIO_SFUNC void *fio___json_consume_array(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "array");
  void *old = s->ctx;
  void *array = s->ctx = s->cb.on_array(s, s->key);
  if (++s->depth == FIO_JSON_MAX_DEPTH)
    goto too_deep;
  for (;;) {
    ++s->pos;
    if (fio___json_consume_whitespace(s))
      break;
    if (*s->pos == ']')
      break;
    void *value = fio___json_consume(s);
    if (value)
      s->error |= s->cb.array_push(s->ctx, value);
    if (s->error || fio___json_consume_comma(s))
      break;
    if (*s->pos != ',')
      break;
  }
  if (*s->pos != ']' || s->error) {
    s->error = 1;
  } else {
    ++s->pos;
  }
  s->ctx = old;
  --s->depth;
  s->error |= s->cb.array_finished(array);
  return array;
too_deep:
  s->ctx = old;
  s->error = 1;
  --s->depth;
  return array;
}
FIO_SFUNC void *fio___json_consume_null(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "null");
  const uint32_t wrd = fio_buf2u32u("null");
  uint32_t data;
  if (s->end - s->pos < 4)
    goto on_error;
  data = fio_buf2u32u(s->pos) | (uint32_t)0x20202020;
  if (data != wrd)
    goto on_error;
  s->pos += 4;
  return s->cb.on_null();
on_error:
  s->error = 1;
  return NULL;
}
FIO_SFUNC void *fio___json_consume_true(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "true");
  const uint32_t wrd = fio_buf2u32u("true");
  uint32_t data;
  if (s->end - s->pos < 4)
    goto on_error;
  data = fio_buf2u32u(s->pos) | (uint32_t)0x20202020;
  if (data != wrd)
    goto on_error;
  s->pos += 4;
  return s->cb.on_true();
on_error:
  s->error = 1;
  return NULL;
}
FIO_SFUNC void *fio___json_consume_false(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "false");
  const uint32_t wrd = fio_buf2u32u("alse");
  uint32_t data;
  if (s->end - s->pos < 5)
    goto on_error;
  data = fio_buf2u32u(s->pos + 1) | (uint32_t)0x20202020;
  if (data != wrd)
    goto on_error;
  s->pos += 5;
  return s->cb.on_false();
on_error:
  s->error = 1;
  return NULL;
}
FIO_SFUNC void *fio___json_consume_nan(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "nan");
  const uint16_t wrd = fio_buf2u16u("an");
  uint16_t data;
  if (s->end - s->pos < 3)
    goto on_error;
  data = fio_buf2u16u(s->pos + 1) | (uint16_t)0x2020;
  if (data != wrd)
    goto on_error;
  s->pos += 3;
  return s->cb.on_float(NAN);
on_error:
  s->error = 1;
  return NULL;
}
FIO_SFUNC int fio___json_consume_comment(fio___json_state_s *s) {
  FIO_JSON___PRINT_STEP(s, "comment");
  const size_t len = (size_t)(s->end - s->pos);
  if (*s->pos == '#' || (len > 2 && s->pos[0] == '/' && s->pos[1] == '/')) {
    /* EOL style comment, C style or Bash/Ruby style*/
    const char *tmp = (const char *)FIO_MEMCHR(s->pos, '\n', len);
    if (tmp) {
      s->pos = tmp;
      return 0;
    }
    s->error = 1;
    return -1;
  }
  if ((len > 3 && s->pos[0] == '/' && s->pos[1] == '*')) {
    const char *tmp = s->pos + 2; /* skip past the opening slash-star */
    while (tmp < s->end &&
           (tmp = (const char *)FIO_MEMCHR(tmp, '/', s->end - tmp))) {
      s->pos = ++tmp;
      if (tmp[-2] == '*')
        return 0;
    }
    s->error = 1;
    return -1;
  }
  s->error = 1;
  return -1;
}

void *fio___json_consume(fio___json_state_s *s) {
  for (;;) {
    FIO_JSON___PRINT_STEP(s, "consumption type test");
    switch (*s->pos) {
    case 0x09: /* fall through */
    case 0x0A: /* fall through */
    case 0x0D: /* fall through */
    case 0x20:
      ++s->pos;
      if (fio___json_consume_whitespace(s))
        goto set_error;
      continue;
    case '+': /* fall through */
    case '-': /* fall through */
    case '0': /* fall through */
    case '1': /* fall through */
    case '2': /* fall through */
    case '3': /* fall through */
    case '4': /* fall through */
    case '5': /* fall through */
    case '6': /* fall through */
    case '7': /* fall through */
    case '8': /* fall through */
    case '9': /* fall through */
    case 'x': /* fall through */
    case '.': /* fall through */
    case 'e': /* fall through */
    case 'E': return fio___json_consume_number(s);
    case 'i': /* fall through */
    case 'I': return fio___json_consume_infinit(s, 0);
    case '"': return fio___json_consume_string(s);
    case '{': return fio___json_consume_map(s);
    case '}': return NULL; /* don't progress, just stop. */
    case '[': return fio___json_consume_array(s);
    case ']': return NULL; /* don't progress, just stop. */
    case 'T':              /* fall through */
    case 't': return fio___json_consume_true(s);
    case 'F': /* fall through */
    case 'f': return fio___json_consume_false(s);
    case 'N': /* fall through */
    case 'n':
      return (((s->pos[1] | 32) == 'u') ? fio___json_consume_null
                                        : fio___json_consume_nan)(s);
    case '#':
    case '/':
      if (fio___json_consume_comment(s))
        goto set_error;
      continue;
    }
  set_error:
    s->error = 1;
    return NULL;
  }
}

static int fio___json_callback_noop(void *ctx) {
  return 0;
  (void)ctx;
}
static void *fio___json_callback_noop2(void *ctx) { return ctx; }

FIO_SFUNC int fio___json_callbacks_validate(fio_json_parser_callbacks_s *cb) {
  if (!cb)
    goto is_invalid;

  if (!cb->on_string)
    cb->on_string = cb->on_string_simple;
  if (!cb->on_string_simple)
    cb->on_string_simple = cb->on_string;

  if (!cb->on_null)
    goto is_invalid;
  if (!cb->on_true)
    goto is_invalid;
  if (!cb->on_false)
    goto is_invalid;
  if (!cb->on_number)
    goto is_invalid;
  if (!cb->on_float)
    goto is_invalid;
  if (!cb->on_string)
    goto is_invalid;
  if (!cb->on_map)
    goto is_invalid;
  if (!cb->on_array)
    goto is_invalid;
  if (!cb->map_push)
    goto is_invalid;
  if (!cb->array_push)
    goto is_invalid;
  if (!cb->free_unused_object)
    goto is_invalid;
  if (!cb->array_finished)
    cb->array_finished = fio___json_callback_noop;
  if (!cb->map_finished)
    cb->map_finished = fio___json_callback_noop;
  if (!cb->is_array)
    cb->is_array = fio___json_callback_noop;
  if (!cb->is_map)
    cb->is_map = fio___json_callback_noop;
  if (!cb->on_error)
    cb->on_error = fio___json_callback_noop2;
  return 0;
is_invalid:
  return -1;
}
/**
 * Returns the number of bytes consumed. Stops as close as possible to the end
 * of the buffer or once an object parsing was completed.
 */
SFUNC fio_json_result_s fio_json_parse(fio_json_parser_callbacks_s *callbacks,
                                       const char *start,
                                       const size_t len) {
  fio_json_result_s r = {.stop_pos = 0, .err = 0};
  fio___json_state_s state;
  if (fio___json_callbacks_validate(callbacks))
    goto missing_callback;

  state = (fio___json_state_s){
      .cb = callbacks[0],
      .pos = start,
      .end = start + len,
  };

  /* skip BOM, if exists */
  if (len >= 3 && state.pos[0] == (char)0xEF && state.pos[1] == (char)0xBB &&
      state.pos[2] == (char)0xBF) {
    state.pos += 3;
    if (len == 3)
      goto finish;
  }
  r.ctx = fio___json_consume(&state);
  r.err = state.error;
  r.stop_pos = state.pos - start;
  if (state.error)
    goto failed;
finish:
  return r;
failed:
  FIO_LOG_DEBUG(
      "JSON parsing failed after:\n%.*s",
      ((state.end - state.pos > 48) ? 48 : ((int)(state.end - state.pos))),
      state.pos);
  r.ctx = callbacks->on_error(r.ctx);
  return r;

missing_callback:
  FIO_LOG_ERROR("JSON parser missing a critical callback!");
  r.err = 1;
  return r;
}

/** Dictionary was detected. Returns ctx to hash map or NULL on error. */
FIO_SFUNC void *fio___json_parse_update_on_map(void *ctx, void *at) {
  void **ex_data = (void **)ctx;
  fio_json_parser_callbacks_s *cb = (fio_json_parser_callbacks_s *)ex_data[0];
  ctx = ex_data[1];
  fio___json_state_s *s = (fio___json_state_s *)ex_data[2];
  s->cb.on_map = cb->on_map;
  s->cb.on_array = cb->on_array;
  if (ctx && !s->cb.is_map(ctx))
    return NULL;
  else if (!ctx)
    ctx = cb->on_map(ctx, at);
  return ctx;
}
/** Array was detected. Returns ctx to array or NULL on error. */
FIO_SFUNC void *fio___json_parse_update_on_array(void *ctx, void *at) {
  void **ex_data = (void **)ctx;
  fio_json_parser_callbacks_s *cb = (fio_json_parser_callbacks_s *)ex_data[0];
  ctx = ex_data[1];
  fio___json_state_s *s = (fio___json_state_s *)ex_data[2];
  s->cb.on_map = cb->on_map;
  s->cb.on_array = cb->on_array;
  if (ctx && !s->cb.is_array(ctx))
    return NULL;
  else if (!ctx)
    ctx = cb->on_array(ctx, at);

  return ctx;
}

/**
 * Use only when `ctx` is an object and JSON data is wrapped in an object (of
 * the same type).
 *
 * i.e., update an array or hash map.
 */
SFUNC fio_json_result_s fio_json_parse_update(fio_json_parser_callbacks_s *s,
                                              void *ctx,
                                              const char *start,
                                              const size_t len) {
  fio_json_result_s r = {.stop_pos = 0, .err = 0};
  fio_json_parser_callbacks_s callbacks;
  callbacks.on_map = fio___json_parse_update_on_map;
  callbacks.on_array = fio___json_parse_update_on_array;
  fio___json_state_s state;
  void *ex_data[3] = {s, ctx, &state};

  if (!s->is_array)
    goto missing_callback;
  if (!s->is_map)
    goto missing_callback;
  if (fio___json_callbacks_validate(s))
    goto missing_callback;

  callbacks = *s;
  state = (fio___json_state_s){
      .cb = callbacks,
      .pos = start,
      .end = start + len,
  };
  state.ctx = (void *)ex_data;
  /* skip BOM, if exists */
  if (len >= 3 && state.pos[0] == (char)0xEF && state.pos[1] == (char)0xBB &&
      state.pos[2] == (char)0xBF) {
    state.pos += 3;
    if (len == 3)
      goto finish;
  }
  r.ctx = fio___json_consume(&state);
  r.err = state.error;
  r.stop_pos = state.pos - start;
  if (state.error)
    goto failed;
finish:
  return r;
failed:
  FIO_LOG_DEBUG(
      "JSON parsing failed after:\n%.*s",
      ((state.end - state.pos > 48) ? 48 : ((int)(state.end - state.pos))),
      state.pos);
  r.ctx = s->on_error(r.ctx);
  return r;
missing_callback:
  FIO_LOG_ERROR("JSON parser missing a critical callback!");
  r.err = 1;
  return r;
}
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_JSON
#endif /* FIO_JSON */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_MULTIPART          /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                          MIME Multipart Parser Module




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_MULTIPART) && !defined(H___FIO_MULTIPART___H)
#define H___FIO_MULTIPART___H

/* *****************************************************************************
MIME Multipart Parser - Overview

This is a non-allocating, streaming callback-based MIME multipart parser
implementing the multipart/form-data format as used in HTTP file uploads.

The parser uses callbacks to handle form fields and file uploads:
- Regular form fields (no filename) trigger on_field callback
- File uploads trigger on_file_start, on_file_data, on_file_end callbacks

Multipart Format:
    --boundary\r\n
    Content-Disposition: form-data; name="field1"\r\n
    \r\n
    value1\r\n
    --boundary\r\n
    Content-Disposition: form-data; name="file1"; filename="test.txt"\r\n
    Content-Type: text/plain\r\n
    \r\n
    file content here\r\n
    --boundary--\r\n

Usage:
    static const fio_multipart_parser_callbacks_s callbacks = {
        .on_field = my_on_field,
        .on_file_start = my_on_file_start,
        .on_file_data = my_on_file_data,
        .on_file_end = my_on_file_end,
    };

    fio_multipart_result_s result = fio_multipart_parse(
        &callbacks,
        my_context,
        FIO_BUF_INFO2(boundary_str, boundary_len),
        data,
        data_len);

    if (result.err == 0) {
        // Success - all data parsed
    } else if (result.err == -2) {
        // Need more data - call again with more data
    } else {
        // Error
    }

***************************************************************************** */

/* *****************************************************************************
MIME Multipart Parser Types
***************************************************************************** */

/** The MIME multipart parser callbacks. */
typedef struct {
  /**
   * Called for each regular form field (no filename).
   * Returns user-defined context (can be NULL).
   *
   * Note: If on_field_start is provided, this callback is ignored and the
   * streaming field callbacks (on_field_start/on_field_data/on_field_end)
   * are used instead.
   */
  void *(*on_field)(void *udata,
                    fio_buf_info_s name,
                    fio_buf_info_s value,
                    fio_buf_info_s content_type);

  /**
   * Called when a large field starts (optional).
   * If NULL but on_field exists, on_field is used instead (backward
   * compatible). Returns context for this field (passed to
   * on_field_data/on_field_end).
   */
  void *(*on_field_start)(void *udata,
                          fio_buf_info_s name,
                          fio_buf_info_s content_type);

  /**
   * Called with field data chunk.
   * May be called multiple times per field for streaming.
   * Returns non-zero to abort parsing.
   */
  int (*on_field_data)(void *udata, void *field_ctx, fio_buf_info_s data);

  /**
   * Called when field ends.
   */
  void (*on_field_end)(void *udata, void *field_ctx);

  /**
   * Called when a file upload starts.
   * Returns context for this file (passed to on_file_data/on_file_end).
   */
  void *(*on_file_start)(void *udata,
                         fio_buf_info_s name,
                         fio_buf_info_s filename,
                         fio_buf_info_s content_type);

  /**
   * Called with file data chunk.
   * May be called multiple times per file for streaming.
   * Returns non-zero to abort parsing.
   */
  int (*on_file_data)(void *udata, void *file_ctx, fio_buf_info_s data);

  /**
   * Called when file upload ends.
   */
  void (*on_file_end)(void *udata, void *file_ctx);

  /**
   * Called on parse error (optional).
   */
  void (*on_error)(void *udata);

} fio_multipart_parser_callbacks_s;

/** The MIME multipart parse result type. */
typedef struct {
  /** Number of bytes consumed from the input buffer. */
  size_t consumed;
  /** Number of form fields parsed. */
  size_t field_count;
  /** Number of files parsed. */
  size_t file_count;
  /** Error code: 0 = success, -1 = error, -2 = need more data. */
  int err;
} fio_multipart_result_s;

/* *****************************************************************************
MIME Multipart Parser API
***************************************************************************** */

/**
 * Parse MIME multipart data.
 *
 * `callbacks` contains the callback functions (should be static const).
 * `udata` is user data passed to all callbacks.
 * `boundary` is the multipart boundary string (without leading "--").
 * `data` is the data to parse.
 * `len` is the length of the data.
 *
 * Returns a result struct containing:
 * - `consumed`: Number of bytes consumed from the buffer
 * - `field_count`: Number of form fields parsed
 * - `file_count`: Number of files parsed
 * - `err`: 0 = success, -1 = error, -2 = need more data
 *
 * For streaming, call again with remaining data appended to unconsumed data.
 */
SFUNC fio_multipart_result_s
fio_multipart_parse(const fio_multipart_parser_callbacks_s *callbacks,
                    void *udata,
                    fio_buf_info_s boundary,
                    const char *data,
                    size_t len);

/* *****************************************************************************
MIME Multipart Parser - Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Internal Helper: No-op callbacks
***************************************************************************** */

FIO_IFUNC void *fio___multipart_noop_field(void *udata,
                                           fio_buf_info_s name,
                                           fio_buf_info_s value,
                                           fio_buf_info_s content_type) {
  (void)udata;
  (void)name;
  (void)value;
  (void)content_type;
  return NULL;
}

FIO_IFUNC void *fio___multipart_noop_field_start(void *udata,
                                                 fio_buf_info_s name,
                                                 fio_buf_info_s content_type) {
  (void)udata;
  (void)name;
  (void)content_type;
  return NULL;
}

FIO_IFUNC int fio___multipart_noop_field_data(void *udata,
                                              void *field_ctx,
                                              fio_buf_info_s data) {
  (void)udata;
  (void)field_ctx;
  (void)data;
  return 0;
}

FIO_IFUNC void fio___multipart_noop_field_end(void *udata, void *field_ctx) {
  (void)udata;
  (void)field_ctx;
}

FIO_IFUNC void *fio___multipart_noop_file_start(void *udata,
                                                fio_buf_info_s name,
                                                fio_buf_info_s filename,
                                                fio_buf_info_s content_type) {
  (void)udata;
  (void)name;
  (void)filename;
  (void)content_type;
  return NULL;
}

FIO_IFUNC int fio___multipart_noop_file_data(void *udata,
                                             void *file_ctx,
                                             fio_buf_info_s data) {
  (void)udata;
  (void)file_ctx;
  (void)data;
  return 0;
}

FIO_IFUNC void fio___multipart_noop_file_end(void *udata, void *file_ctx) {
  (void)udata;
  (void)file_ctx;
}

FIO_IFUNC void fio___multipart_noop_error(void *udata) { (void)udata; }

/* *****************************************************************************
Internal: Validated callbacks wrapper
***************************************************************************** */

typedef struct {
  void *(*on_field)(void *udata,
                    fio_buf_info_s name,
                    fio_buf_info_s value,
                    fio_buf_info_s content_type);
  void *(*on_field_start)(void *udata,
                          fio_buf_info_s name,
                          fio_buf_info_s content_type);
  int (*on_field_data)(void *udata, void *field_ctx, fio_buf_info_s data);
  void (*on_field_end)(void *udata, void *field_ctx);
  void *(*on_file_start)(void *udata,
                         fio_buf_info_s name,
                         fio_buf_info_s filename,
                         fio_buf_info_s content_type);
  int (*on_file_data)(void *udata, void *file_ctx, fio_buf_info_s data);
  void (*on_file_end)(void *udata, void *file_ctx);
  void (*on_error)(void *udata);
  /** Flag: use streaming field callbacks instead of on_field */
  int use_field_streaming;
} fio___multipart_cb_s;

FIO_SFUNC fio___multipart_cb_s
fio___multipart_callbacks_validate(const fio_multipart_parser_callbacks_s *cb) {
  fio___multipart_cb_s r;
  static const fio_multipart_parser_callbacks_s empty_cb = {0};
  if (!cb)
    cb = &empty_cb;
  r.on_field = cb->on_field ? cb->on_field : fio___multipart_noop_field;
  /* Streaming field callbacks: use if on_field_start is provided */
  r.use_field_streaming = (cb->on_field_start != NULL);
  r.on_field_start = cb->on_field_start ? cb->on_field_start
                                        : fio___multipart_noop_field_start;
  r.on_field_data =
      cb->on_field_data ? cb->on_field_data : fio___multipart_noop_field_data;
  r.on_field_end =
      cb->on_field_end ? cb->on_field_end : fio___multipart_noop_field_end;
  /* File callbacks */
  r.on_file_start =
      cb->on_file_start ? cb->on_file_start : fio___multipart_noop_file_start;
  r.on_file_data =
      cb->on_file_data ? cb->on_file_data : fio___multipart_noop_file_data;
  r.on_file_end =
      cb->on_file_end ? cb->on_file_end : fio___multipart_noop_file_end;
  r.on_error = cb->on_error ? cb->on_error : fio___multipart_noop_error;
  return r;
}

/* *****************************************************************************
Internal Helper: Find substring in buffer
***************************************************************************** */

FIO_SFUNC const char *fio___multipart_find(const char *haystack,
                                           size_t haystack_len,
                                           const char *needle,
                                           size_t needle_len) {
  if (!needle_len || needle_len > haystack_len)
    return NULL;
  const char *end = haystack + haystack_len - needle_len + 1;
  for (const char *p = haystack; p < end; ++p) {
    p = (const char *)FIO_MEMCHR(p, needle[0], (size_t)(end - p));
    if (!p)
      return NULL;
    if (!FIO_MEMCMP(p, needle, needle_len))
      return p;
  }
  return NULL;
}

/* *****************************************************************************
Internal Helper: Skip whitespace
***************************************************************************** */

FIO_IFUNC const char *fio___multipart_skip_ws(const char *p, const char *end) {
  while (p < end && (*p == ' ' || *p == '\t'))
    ++p;
  return p;
}

/* *****************************************************************************
Internal Helper: Skip optional whitespace and CRLF
***************************************************************************** */

FIO_IFUNC const char *fio___multipart_skip_lwsp(const char *p,
                                                const char *end) {
  while (p < end) {
    if (*p == ' ' || *p == '\t') {
      ++p;
      continue;
    }
    /* Check for folded header (CRLF followed by space/tab) */
    if (p + 2 < end && p[0] == '\r' && p[1] == '\n' &&
        (p[2] == ' ' || p[2] == '\t')) {
      p += 3;
      continue;
    }
    break;
  }
  return p;
}

/* *****************************************************************************
Internal Helper: Case-insensitive prefix match
***************************************************************************** */

FIO_SFUNC int fio___multipart_prefix_icase(const char *str,
                                           size_t str_len,
                                           const char *prefix,
                                           size_t prefix_len) {
  if (str_len < prefix_len)
    return 0;
  for (size_t i = 0; i < prefix_len; ++i) {
    char c1 = str[i];
    char c2 = prefix[i];
    /* Convert to lowercase */
    c1 |= (char)((uint8_t)(c1 >= 'A' && c1 <= 'Z') << 5);
    c2 |= (char)((uint8_t)(c2 >= 'A' && c2 <= 'Z') << 5);
    if (c1 != c2)
      return 0;
  }
  return 1;
}

/* *****************************************************************************
Internal Helper: Extract quoted or unquoted value from header parameter
***************************************************************************** */

FIO_SFUNC fio_buf_info_s fio___multipart_extract_param(const char *header,
                                                       size_t header_len,
                                                       const char *param_name,
                                                       size_t param_name_len) {
  fio_buf_info_s result = FIO_BUF_INFO0;
  const char *end = header + header_len;
  const char *p = header;

  /* Search for parameter name followed by '=' */
  while (p < end) {
    /* Find the parameter name */
    const char *found =
        fio___multipart_find(p, (size_t)(end - p), param_name, param_name_len);
    if (!found)
      return result;

    /* Check if it's at start or preceded by ; or whitespace */
    if (found > header) {
      char prev = found[-1];
      if (prev != ';' && prev != ' ' && prev != '\t') {
        p = found + 1;
        continue;
      }
    }

    /* Skip parameter name */
    p = found + param_name_len;
    p = fio___multipart_skip_ws(p, end);

    /* Expect '=' */
    if (p >= end || *p != '=') {
      continue;
    }
    ++p;
    p = fio___multipart_skip_ws(p, end);

    if (p >= end)
      return result;

    /* Extract value - quoted or unquoted */
    if (*p == '"') {
      /* Quoted value */
      ++p;
      const char *value_start = p;
      while (p < end && *p != '"') {
        if (*p == '\\' && p + 1 < end) {
          p += 2; /* Skip escaped character */
        } else {
          ++p;
        }
      }
      result.buf = (char *)value_start;
      result.len = (size_t)(p - value_start);
      return result;
    } else {
      /* Unquoted value - ends at ; or whitespace or end */
      const char *value_start = p;
      while (p < end && *p != ';' && *p != ' ' && *p != '\t' && *p != '\r' &&
             *p != '\n') {
        ++p;
      }
      result.buf = (char *)value_start;
      result.len = (size_t)(p - value_start);
      return result;
    }
  }

  return result;
}

/* *****************************************************************************
Internal Helper: Parse Content-Disposition header
***************************************************************************** */

typedef struct {
  fio_buf_info_s name;
  fio_buf_info_s filename;
} fio___multipart_disposition_s;

FIO_SFUNC fio___multipart_disposition_s
fio___multipart_parse_disposition(const char *value, size_t value_len) {
  fio___multipart_disposition_s result = {{0}, {0}};

  result.name = fio___multipart_extract_param(value, value_len, "name", 4);
  result.filename =
      fio___multipart_extract_param(value, value_len, "filename", 8);

  return result;
}

/* *****************************************************************************
Internal Helper: Find header value in part headers
***************************************************************************** */

FIO_SFUNC fio_buf_info_s fio___multipart_find_header(const char *headers,
                                                     size_t headers_len,
                                                     const char *header_name,
                                                     size_t header_name_len) {
  fio_buf_info_s result = FIO_BUF_INFO0;
  const char *p = headers;
  const char *end = headers + headers_len;

  while (p < end) {
    /* Find end of current line */
    const char *line_end = (const char *)FIO_MEMCHR(p, '\n', (size_t)(end - p));
    if (!line_end)
      line_end = end;

    /* Calculate line length (excluding \r\n) */
    size_t line_len = (size_t)(line_end - p);
    if (line_len > 0 && p[line_len - 1] == '\r')
      --line_len;

    /* Check if this line starts with the header name */
    if (fio___multipart_prefix_icase(p,
                                     line_len,
                                     header_name,
                                     header_name_len)) {
      const char *value_start = p + header_name_len;
      /* Skip optional whitespace after colon */
      if (value_start < p + line_len && *value_start == ':') {
        ++value_start;
        value_start = fio___multipart_skip_ws(value_start, p + line_len);
        result.buf = (char *)value_start;
        result.len = (size_t)((p + line_len) - value_start);
        return result;
      }
    }

    /* Move to next line */
    p = line_end + 1;
  }

  return result;
}

/* *****************************************************************************
MIME Multipart Main Parse Function
***************************************************************************** */

SFUNC fio_multipart_result_s
fio_multipart_parse(const fio_multipart_parser_callbacks_s *callbacks,
                    void *udata,
                    fio_buf_info_s boundary,
                    const char *data,
                    size_t len) {
  fio_multipart_result_s result = {.consumed = 0,
                                   .field_count = 0,
                                   .file_count = 0,
                                   .err = 0};

  if (!data || !len || !boundary.buf || !boundary.len) {
    result.err = -1;
    return result;
  }

  fio___multipart_cb_s cb = fio___multipart_callbacks_validate(callbacks);

  const char *pos = data;
  const char *end = data + len;

  /* Build boundary markers:
   * - delimiter: "\r\n--" + boundary (for finding boundaries between parts)
   * - first_delimiter: "--" + boundary (at start of data)
   *
   * Buffer layout: [\r][\n][-][-][boundary...]
   *                 ^       ^
   *                 |       +-- first_delimiter (offset 2)
   *                 +---------- delimiter (offset 0)
   */
  char delimiter_buf[256 + 6]; /* "\r\n--" + boundary + NUL */
  char *delimiter = delimiter_buf;
  char *first_delimiter = delimiter_buf + 2;
  size_t first_delimiter_len = boundary.len + 2;
  size_t delimiter_len = boundary.len + 4;

  if (boundary.len > 250) {
    result.err = -1;
    cb.on_error(udata);
    return result;
  }

  /* Build delimiter: "\r\n--" + boundary */
  delimiter[0] = '\r';
  delimiter[1] = '\n';
  delimiter[2] = '-';
  delimiter[3] = '-';
  FIO_MEMCPY(delimiter + 4, boundary.buf, boundary.len);
  /* first_delimiter now points to "--" + boundary (at offset 2) */

  /* Check for initial boundary */
  if ((size_t)(end - pos) < first_delimiter_len) {
    result.err = -2; /* Need more data */
    return result;
  }

  /* First boundary may or may not have leading CRLF */
  if (pos[0] == '\r' && pos[1] == '\n') {
    pos += 2;
  }

  if ((size_t)(end - pos) < first_delimiter_len ||
      FIO_MEMCMP(pos, first_delimiter, first_delimiter_len) != 0) {
    result.err = -1;
    cb.on_error(udata);
    return result;
  }

  pos += first_delimiter_len;

  /* Check for immediate close (empty multipart) */
  if ((size_t)(end - pos) >= 2 && pos[0] == '-' && pos[1] == '-') {
    /* Empty multipart - just the closing boundary */
    pos += 2;
    /* Skip optional trailing CRLF */
    if ((size_t)(end - pos) >= 2 && pos[0] == '\r' && pos[1] == '\n')
      pos += 2;
    result.consumed = (size_t)(pos - data);
    return result;
  }

  /* Expect CRLF after boundary */
  if ((size_t)(end - pos) < 2) {
    result.err = -2;
    return result;
  }
  if (pos[0] != '\r' || pos[1] != '\n') {
    result.err = -1;
    cb.on_error(udata);
    return result;
  }
  pos += 2;

  /* Parse parts */
  while (pos < end) {
    /* Find end of headers (double CRLF) */
    const char *headers_end =
        fio___multipart_find(pos, (size_t)(end - pos), "\r\n\r\n", 4);
    if (!headers_end) {
      result.err = -2; /* Need more data */
      result.consumed = (size_t)((pos - 2 - delimiter_len) - data);
      if (result.consumed > len)
        result.consumed = 0;
      return result;
    }

    const char *headers_start = pos;
    size_t headers_len = (size_t)(headers_end - headers_start);
    const char *body_start = headers_end + 4;

    /* Parse Content-Disposition header */
    fio_buf_info_s disposition_value =
        fio___multipart_find_header(headers_start,
                                    headers_len,
                                    "Content-Disposition",
                                    19);

    if (!disposition_value.buf) {
      result.err = -1;
      cb.on_error(udata);
      return result;
    }

    fio___multipart_disposition_s disposition =
        fio___multipart_parse_disposition(disposition_value.buf,
                                          disposition_value.len);

    /* Parse Content-Type header (optional) */
    fio_buf_info_s content_type = fio___multipart_find_header(headers_start,
                                                              headers_len,
                                                              "Content-Type",
                                                              12);

    /* Find the next boundary to determine body end */
    const char *next_boundary = fio___multipart_find(body_start,
                                                     (size_t)(end - body_start),
                                                     delimiter,
                                                     delimiter_len);

    if (!next_boundary) {
      /* Check if we might have partial data */
      /* We need at least delimiter_len bytes after body to be sure */
      result.err = -2; /* Need more data */
      /* Rewind to before this part's headers */
      result.consumed = (size_t)((pos - 2 - delimiter_len) - data);
      if (result.consumed > len)
        result.consumed = 0;
      return result;
    }

    /* Body is from body_start to next_boundary */
    size_t body_len = (size_t)(next_boundary - body_start);

    /* Determine if this is a file or field */
    if (disposition.filename.buf && disposition.filename.len > 0) {
      /* File upload */
      void *file_ctx = cb.on_file_start(udata,
                                        disposition.name,
                                        disposition.filename,
                                        content_type);

      /* Send file data */
      fio_buf_info_s file_data = FIO_BUF_INFO2((char *)body_start, body_len);
      int abort = cb.on_file_data(udata, file_ctx, file_data);

      cb.on_file_end(udata, file_ctx);

      if (abort) {
        result.err = -1;
        result.consumed = (size_t)(next_boundary - data);
        return result;
      }

      ++result.file_count;
    } else {
      /* Regular form field */
      fio_buf_info_s value = FIO_BUF_INFO2((char *)body_start, body_len);
      if (cb.use_field_streaming) {
        /* Use streaming field callbacks */
        void *field_ctx =
            cb.on_field_start(udata, disposition.name, content_type);

        /* Send field data */
        int abort = cb.on_field_data(udata, field_ctx, value);

        cb.on_field_end(udata, field_ctx);

        if (abort) {
          result.err = -1;
          result.consumed = (size_t)(next_boundary - data);
          return result;
        }
      } else {
        /* Use legacy on_field callback */
        cb.on_field(udata, disposition.name, value, content_type);
      }
      ++result.field_count;
    }

    /* Move past the boundary */
    pos = next_boundary + delimiter_len;

    /* Check for closing boundary (--) or continuation (CRLF) */
    if ((size_t)(end - pos) < 2) {
      result.err = -2; /* Need more data */
      result.consumed = (size_t)(next_boundary - data);
      return result;
    }

    if (pos[0] == '-' && pos[1] == '-') {
      /* Closing boundary */
      pos += 2;
      /* Skip optional trailing CRLF */
      if ((size_t)(end - pos) >= 2 && pos[0] == '\r' && pos[1] == '\n')
        pos += 2;
      result.consumed = (size_t)(pos - data);
      return result;
    }

    if (pos[0] != '\r' || pos[1] != '\n') {
      result.err = -1;
      cb.on_error(udata);
      result.consumed = (size_t)(pos - data);
      return result;
    }

    pos += 2; /* Skip CRLF, continue to next part */
  }

  /* Reached end of data without finding closing boundary */
  result.err = -2;
  return result;
}

/* *****************************************************************************
MIME Multipart Parser - Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_MULTIPART
#endif /* FIO_MULTIPART */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_RESP3              /* Development inclusion - ignore line */
#define FIO_ATOL               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                RESP 3 Parser Module




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_RESP3) && !defined(FIO___RECURSIVE_INCLUDE) &&                 \
    !defined(H___FIO_RESP3___H)
#define H___FIO_RESP3___H

/* *****************************************************************************
RESP3 Parser - Overview

This is a non-allocating, streaming callback-based RESP3 parser implementing
the full RESP3 specification.

The parser uses a context-stack pattern similar to the JSON parser, where:
- Primitive callbacks return the created object as `void*`
- Container callbacks receive parent context and return new context
- Push callbacks add children to containers
- The parser manages the context stack internally

RESP3 Types Supported:
- Simple types: +, -, :, _, ,, #, (
- Blob types: $, !, =
- Aggregate types: *, %, ~, >, |
- Streaming: $?, *?, %?, ~?

Usage:
    static const fio_resp3_callbacks_s callbacks = {
        .on_null = my_on_null,
        .on_number = my_on_number,
        .on_string = my_on_string,
        .on_array = my_on_array,
        .array_push = my_array_push,
        // ... other callbacks ...
    };

    fio_resp3_parser_s parser = {.udata = my_context};
    fio_resp3_result_s result = fio_resp3_parse(&parser, &callbacks, buf, len);
    if (result.err) { handle_error(); }
    // result.obj is the parsed top-level object
    // result.consumed indicates bytes consumed

***************************************************************************** */

/* *****************************************************************************
RESP3 Parser Settings
***************************************************************************** */

/** The maximum number of nested layers in object responses (2...32,768) */
#ifndef FIO_RESP3_MAX_NESTING
#define FIO_RESP3_MAX_NESTING 32
#endif

/* *****************************************************************************
RESP3 Type Constants
***************************************************************************** */

/* Single Line Types */
/** Simple String: `+<string>\r\n` */
#define FIO_RESP3_SIMPLE_STR '+'
/** Simple Error: `-<string>\r\n` */
#define FIO_RESP3_SIMPLE_ERR '-'
/** Number: `:<number>\r\n` */
#define FIO_RESP3_NUMBER ':'
/** Null: `_\r\n` */
#define FIO_RESP3_NULL '_'
/** Double: `,<floating-point-number>\r\n` */
#define FIO_RESP3_DOUBLE ','
/** Boolean: `#t\r\n` or `#f\r\n` */
#define FIO_RESP3_BOOL '#'
/** Big Number: `(<big number>\r\n` */
#define FIO_RESP3_BIGNUM '('

/* Blob Types */
/** Blob String: `$<length>\r\n<bytes>\r\n` */
#define FIO_RESP3_BLOB_STR '$'
/** Blob Error: `!<length>\r\n<bytes>\r\n` */
#define FIO_RESP3_BLOB_ERR '!'
/** Verbatim String: `=<length>\r\n<type:><bytes>\r\n` */
#define FIO_RESP3_VERBATIM '='

/* Aggregate Types */
/** Array: `*<count>\r\n...elements...` */
#define FIO_RESP3_ARRAY '*'
/** Map: `%<count>\r\n...key-value pairs...` */
#define FIO_RESP3_MAP '%'
/** Set: `~<count>\r\n...elements...` */
#define FIO_RESP3_SET '~'
/** Push: `><count>\r\n...elements...` */
#define FIO_RESP3_PUSH '>'
/** Attribute: `|<count>\r\n...key-value pairs...` */
#define FIO_RESP3_ATTR '|'

/* Streaming */
/** Streamed string chunk: `;` */
#define FIO_RESP3_STREAM_CHUNK ';'
/** Streamed aggregate end: `.` */
#define FIO_RESP3_STREAM_END '.'

/* *****************************************************************************
RESP3 Parser Types
***************************************************************************** */

/** Parser frame for tracking nested structures */
typedef struct {
  /** Context for this container (returned by on_array/on_map/etc) */
  void *ctx;
  /** For maps: the pending key waiting for its value */
  void *key;
  /** Expected remaining elements */
  int64_t remaining;
  /** Type of this frame */
  uint8_t type;
  /** Is this a streaming type? */
  uint8_t streaming;
  /** For maps: are we expecting a key (0) or value (1)? */
  uint8_t expecting_value;
  /** Set treated as map: need to duplicate values as key+value */
  uint8_t set_as_map;
} fio_resp3_frame_s;

/** RESP3 parser state */
typedef struct {
  /** User data passed to all callbacks */
  void *udata;
  /** Current nesting depth */
  uint32_t depth;
  /** Protocol error flag */
  uint8_t error;
  /** Streaming string in progress flag */
  uint8_t streaming_string;
  /** Streaming string type (FIO_RESP3_BLOB_STR, FIO_RESP3_BLOB_ERR, etc.) */
  uint8_t streaming_string_type;
  /** Reserved */
  uint8_t reserved[1];
  /** Context for streaming string (from on_start_string) */
  void *streaming_string_ctx;
  /** Stack for nested structures */
  fio_resp3_frame_s stack[FIO_RESP3_MAX_NESTING];
} fio_resp3_parser_s;

/**
 * The RESP3 parser callbacks (designed to be static const).
 *
 * All callbacks receive `udata` from the parser state as their first argument.
 */
typedef struct {
  /* ===== Primitive Callbacks - return the created object ===== */

  /** Called when NULL (`_`) is received. Returns new object. */
  void *(*on_null)(void *udata);

  /** Called when Boolean (`#t` or `#f`) is received. Returns new object. */
  void *(*on_bool)(void *udata, int is_true);

  /** Called when a Number (`:`) is parsed. Returns new object. */
  void *(*on_number)(void *udata, int64_t num);

  /** Called when a Double (`,`) is parsed. Returns new object. */
  void *(*on_double)(void *udata, double num);

  /** Called when a Big Number (`(`) is parsed. Returns new object. */
  void *(*on_bignum)(void *udata, const void *data, size_t len);

  /**
   * Called when a complete String is received.
   * `type` is FIO_RESP3_SIMPLE_STR, FIO_RESP3_BLOB_STR, or FIO_RESP3_VERBATIM.
   * Returns new object.
   */
  void *(*on_string)(void *udata, const void *data, size_t len, uint8_t type);

  /**
   * Called when an error message is received (simple `-` or blob `!`).
   * `type` is FIO_RESP3_SIMPLE_ERR or FIO_RESP3_BLOB_ERR.
   * Returns new object.
   */
  void *(*on_error)(void *udata, const void *data, size_t len, uint8_t type);

  /* ===== Container Callbacks - receive parent ctx, return new ctx ===== */

  /** Called when an Array starts. Returns new array context. */
  void *(*on_array)(void *udata, void *parent_ctx, int64_t len);

  /** Called when a Map starts. Returns new map context. */
  void *(*on_map)(void *udata, void *parent_ctx, int64_t len);

  /** Called when a Set starts. Returns new set context. */
  void *(*on_set)(void *udata, void *parent_ctx, int64_t len);

  /** Called when a Push message starts. Returns new push context. */
  void *(*on_push)(void *udata, void *parent_ctx, int64_t len);

  /** Called when an Attribute starts. Returns new attribute context. */
  void *(*on_attr)(void *udata, void *parent_ctx, int64_t len);

  /* ===== Push Callbacks - add child to container ===== */

  /** Add value to array. Returns non-zero on error. */
  int (*array_push)(void *udata, void *ctx, void *value);

  /** Add key-value pair to map. Returns non-zero on error. */
  int (*map_push)(void *udata, void *ctx, void *key, void *value);

  /** Add value to set. Returns non-zero on error. */
  int (*set_push)(void *udata, void *ctx, void *value);

  /** Add value to push message. Returns non-zero on error. */
  int (*push_push)(void *udata, void *ctx, void *value);

  /** Add key-value pair to attribute. Returns non-zero on error. */
  int (*attr_push)(void *udata, void *ctx, void *key, void *value);

  /* ===== Done Callbacks (optional) - finalize container ===== */

  /** Called when array is complete. Returns final object. */
  void *(*array_done)(void *udata, void *ctx);

  /** Called when map is complete. Returns final object. */
  void *(*map_done)(void *udata, void *ctx);

  /** Called when set is complete. Returns final object. */
  void *(*set_done)(void *udata, void *ctx);

  /** Called when push is complete. Returns final object. */
  void *(*push_done)(void *udata, void *ctx);

  /** Called when attribute is complete. Returns final object. */
  void *(*attr_done)(void *udata, void *ctx);

  /* ===== Error Handling ===== */

  /** Free an unused object (e.g., orphaned key on error). */
  void (*free_unused)(void *udata, void *obj);

  /** Called on protocol error. */
  void *(*on_error_protocol)(void *udata);

  /* ===== Streaming String Callbacks (optional) ===== */

  /**
   * Called when a blob string starts (before data arrives).
   * `len` is the declared length of the string ((size_t)-1 for streaming).
   * `type` is FIO_RESP3_BLOB_STR, FIO_RESP3_BLOB_ERR, or FIO_RESP3_VERBATIM.
   * Returns a context for the string being built (e.g., a string buffer).
   * If NULL is returned, falls back to buffering and calling on_string when
   * complete.
   */
  void *(*on_start_string)(void *udata, size_t len, uint8_t type);

  /**
   * Called with partial string data (may be called multiple times).
   * `ctx` is the context returned by on_start_string.
   * Returns 0 on success, non-zero to abort parsing.
   */
  int (*on_string_write)(void *udata, void *ctx, const void *data, size_t len);

  /**
   * Called when the string is complete.
   * `ctx` is the context returned by on_start_string.
   * Returns the final string object to be used as a value.
   */
  void *(*on_string_done)(void *udata, void *ctx, uint8_t type);

} fio_resp3_callbacks_s;

/** The RESP3 parse result type. */
typedef struct {
  /** The parsed top-level object (or NULL on error/incomplete) */
  void *obj;
  /** Number of bytes consumed from the buffer */
  size_t consumed;
  /** Non-zero if an error occurred */
  int err;
} fio_resp3_result_s;

/* *****************************************************************************
RESP3 Parser API
***************************************************************************** */

/**
 * Parse RESP3 data from buffer.
 *
 * `parser` is the parser state. Initialize with `{.udata = my_data}` for first
 *          call. For continuation after partial parse, pass the same parser.
 * `callbacks` contains the callback functions (should be static const).
 * `buf` is the data to parse.
 * `len` is the length of the data.
 *
 * Returns a result struct containing:
 * - `obj`: The parsed top-level object (NULL if incomplete or error)
 * - `consumed`: Number of bytes consumed from the buffer
 * - `err`: Non-zero if a protocol error occurred
 *
 * For partial data, the parser state is preserved. Call again with remaining
 * data appended to unconsumed data.
 */
SFUNC fio_resp3_result_s fio_resp3_parse(fio_resp3_parser_s *parser,
                                         const fio_resp3_callbacks_s *callbacks,
                                         const void *buf,
                                         size_t len);

/* *****************************************************************************
RESP3 Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Internal Helper: No-op callbacks
***************************************************************************** */

FIO_IFUNC void *fio___resp3_noop_obj(void *udata) {
  return (void *)(uintptr_t)1; /* Return non-NULL sentinel */
  (void)udata;
}

FIO_IFUNC void *fio___resp3_noop_bool(void *udata, int v) {
  return (void *)(uintptr_t)1;
  (void)udata;
  (void)v;
}

FIO_IFUNC void *fio___resp3_noop_i64(void *udata, int64_t v) {
  return (void *)(uintptr_t)1;
  (void)udata;
  (void)v;
}

FIO_IFUNC void *fio___resp3_noop_dbl(void *udata, double v) {
  return (void *)(uintptr_t)1;
  (void)udata;
  (void)v;
}

FIO_IFUNC void *fio___resp3_noop_data(void *udata,
                                      const void *d,
                                      size_t l,
                                      uint8_t t) {
  return (void *)(uintptr_t)1;
  (void)udata;
  (void)d;
  (void)l;
  (void)t;
}

FIO_IFUNC void *fio___resp3_noop_bignum(void *udata, const void *d, size_t l) {
  return (void *)(uintptr_t)1;
  (void)udata;
  (void)d;
  (void)l;
}

FIO_IFUNC void *fio___resp3_noop_container(void *udata,
                                           void *parent,
                                           int64_t len) {
  return (void *)(uintptr_t)1;
  (void)udata;
  (void)parent;
  (void)len;
}

FIO_IFUNC int fio___resp3_noop_push(void *udata, void *ctx, void *value) {
  return 0;
  (void)udata;
  (void)ctx;
  (void)value;
}

FIO_IFUNC int fio___resp3_noop_push_kv(void *udata,
                                       void *ctx,
                                       void *key,
                                       void *value) {
  return 0;
  (void)udata;
  (void)ctx;
  (void)key;
  (void)value;
}

FIO_IFUNC void *fio___resp3_noop_done(void *udata, void *ctx) {
  return ctx;
  (void)udata;
}

FIO_IFUNC void fio___resp3_noop_free(void *udata, void *obj) {
  (void)udata;
  (void)obj;
}

FIO_IFUNC void *fio___resp3_noop_error(void *udata) {
  return NULL;
  (void)udata;
}

/* *****************************************************************************
Internal: Validated callbacks wrapper
***************************************************************************** */

typedef struct {
  void *(*on_null)(void *udata);
  void *(*on_bool)(void *udata, int is_true);
  void *(*on_number)(void *udata, int64_t num);
  void *(*on_double)(void *udata, double num);
  void *(*on_bignum)(void *udata, const void *data, size_t len);
  void *(*on_string)(void *udata, const void *data, size_t len, uint8_t type);
  void *(*on_error)(void *udata, const void *data, size_t len, uint8_t type);
  void *(*on_array)(void *udata, void *parent_ctx, int64_t len);
  void *(*on_map)(void *udata, void *parent_ctx, int64_t len);
  void *(*on_set)(void *udata, void *parent_ctx, int64_t len);
  void *(*on_push)(void *udata, void *parent_ctx, int64_t len);
  void *(*on_attr)(void *udata, void *parent_ctx, int64_t len);
  int (*array_push)(void *udata, void *ctx, void *value);
  int (*map_push)(void *udata, void *ctx, void *key, void *value);
  int (*set_push)(void *udata, void *ctx, void *value);
  int (*push_push)(void *udata, void *ctx, void *value);
  int (*attr_push)(void *udata, void *ctx, void *key, void *value);
  void *(*array_done)(void *udata, void *ctx);
  void *(*map_done)(void *udata, void *ctx);
  void *(*set_done)(void *udata, void *ctx);
  void *(*push_done)(void *udata, void *ctx);
  void *(*attr_done)(void *udata, void *ctx);
  void (*free_unused)(void *udata, void *obj);
  void *(*on_error_protocol)(void *udata);
  /* Streaming string callbacks (NULL if not provided) */
  void *(*on_start_string)(void *udata, size_t len, uint8_t type);
  int (*on_string_write)(void *udata, void *ctx, const void *data, size_t len);
  void *(*on_string_done)(void *udata, void *ctx, uint8_t type);
  /** Flag: treat sets as maps (when set callbacks are missing) */
  uint8_t set_as_map;
} fio___resp3_cb_s;

FIO_SFUNC fio___resp3_cb_s
fio___resp3_callbacks_validate(const fio_resp3_callbacks_s *cb) {
  fio___resp3_cb_s r;
  static const fio_resp3_callbacks_s empty_cb = {0};
  if (!cb) {
    cb = &empty_cb;
  }
  r.on_null = cb->on_null ? cb->on_null : fio___resp3_noop_obj;
  r.on_bool = cb->on_bool ? cb->on_bool : fio___resp3_noop_bool;
  r.on_number = cb->on_number ? cb->on_number : fio___resp3_noop_i64;
  r.on_double = cb->on_double ? cb->on_double : fio___resp3_noop_dbl;
  r.on_bignum = cb->on_bignum ? cb->on_bignum : fio___resp3_noop_bignum;
  r.on_string = cb->on_string ? cb->on_string : fio___resp3_noop_data;
  r.on_error = cb->on_error ? cb->on_error : fio___resp3_noop_data;
  r.on_array = cb->on_array ? cb->on_array : fio___resp3_noop_container;
  r.on_map = cb->on_map ? cb->on_map : fio___resp3_noop_container;
  r.on_set = cb->on_set ? cb->on_set : fio___resp3_noop_container;
  r.on_push = cb->on_push ? cb->on_push : fio___resp3_noop_container;
  r.on_attr = cb->on_attr ? cb->on_attr : fio___resp3_noop_container;
  r.array_push = cb->array_push ? cb->array_push : fio___resp3_noop_push;
  r.map_push = cb->map_push ? cb->map_push : fio___resp3_noop_push_kv;
  r.set_push = cb->set_push ? cb->set_push : fio___resp3_noop_push;
  r.push_push = cb->push_push ? cb->push_push : fio___resp3_noop_push;
  r.attr_push = cb->attr_push ? cb->attr_push : fio___resp3_noop_push_kv;
  r.array_done = cb->array_done ? cb->array_done : fio___resp3_noop_done;
  r.map_done = cb->map_done ? cb->map_done : fio___resp3_noop_done;
  r.set_done = cb->set_done ? cb->set_done : fio___resp3_noop_done;
  r.push_done = cb->push_done ? cb->push_done : fio___resp3_noop_done;
  r.attr_done = cb->attr_done ? cb->attr_done : fio___resp3_noop_done;
  r.free_unused = cb->free_unused ? cb->free_unused : fio___resp3_noop_free;
  r.on_error_protocol =
      cb->on_error_protocol ? cb->on_error_protocol : fio___resp3_noop_error;
  /* Streaming string callbacks - keep NULL if not provided (no fallback) */
  r.on_start_string = cb->on_start_string;
  r.on_string_write = cb->on_string_write;
  r.on_string_done = cb->on_string_done;
  /* Treat sets as maps when set callbacks are missing but map callbacks exist
   */
  r.set_as_map = (!cb->on_set && !cb->set_push && !cb->set_done) &&
                 (cb->on_map || cb->map_push || cb->map_done);
  return r;
}

/* *****************************************************************************
Internal Helper: Find newline
***************************************************************************** */

FIO_IFUNC const uint8_t *fio___resp3_find_eol(const uint8_t *pos,
                                              const uint8_t *end) {
  if (pos >= end)
    return NULL;
  const uint8_t *nl =
      (const uint8_t *)FIO_MEMCHR(pos, '\n', (size_t)(end - pos));
  return nl;
}

/* *****************************************************************************
Internal Helper: Parse integer from buffer
***************************************************************************** */

FIO_IFUNC int64_t fio___resp3_parse_int(const uint8_t **pos,
                                        const uint8_t *eol) {
  int64_t result = 0;
  int negative = 0;
  const uint8_t *p = *pos;

  if (p < eol && *p == '-') {
    negative = 1;
    ++p;
  } else if (p < eol && *p == '+') {
    ++p;
  }

  while (p < eol && *p >= '0' && *p <= '9') {
    result = (result * 10) + (*p - '0');
    ++p;
  }

  *pos = p;
  return negative ? -result : result;
}

/* *****************************************************************************
Internal Helper: Parse double from buffer
***************************************************************************** */

FIO_IFUNC double fio___resp3_parse_double(const uint8_t *start,
                                          const uint8_t *eol) {
  size_t len = (size_t)(eol - start);
  if (len >= 3) {
    if ((start[0] == 'i' || start[0] == 'I') &&
        (start[1] == 'n' || start[1] == 'N') &&
        (start[2] == 'f' || start[2] == 'F')) {
      return (double)INFINITY;
    }
    if (start[0] == '-' && (start[1] == 'i' || start[1] == 'I') &&
        (start[2] == 'n' || start[2] == 'N')) {
      return (double)-INFINITY;
    }
    if ((start[0] == 'n' || start[0] == 'N') &&
        (start[1] == 'a' || start[1] == 'A') &&
        (start[2] == 'n' || start[2] == 'N')) {
      return (double)NAN;
    }
  }
  char *p = (char *)start;
  return fio_atof(&p);
}

/* *****************************************************************************
Internal Helper: Get parent context
***************************************************************************** */

FIO_IFUNC void *fio___resp3_parent_ctx(fio_resp3_parser_s *p) {
  if (p->depth == 0)
    return NULL;
  return p->stack[p->depth - 1].ctx;
}

/* *****************************************************************************
Internal Helper: Push value to current container
***************************************************************************** */

FIO_SFUNC int fio___resp3_push_value(fio_resp3_parser_s *p,
                                     fio___resp3_cb_s *cb,
                                     void *value) {
  if (p->depth == 0)
    return 0;

  fio_resp3_frame_s *f = &p->stack[p->depth - 1];

  switch (f->type) {
  case FIO_RESP3_ARRAY: return cb->array_push(p->udata, f->ctx, value);
  case FIO_RESP3_SET:
    /* When set_as_map is enabled, treat set elements as map key=value pairs */
    if (f->set_as_map)
      return cb->map_push(p->udata, f->ctx, value, value);
    return cb->set_push(p->udata, f->ctx, value);
  case FIO_RESP3_PUSH: return cb->push_push(p->udata, f->ctx, value);
  case FIO_RESP3_MAP:
  case FIO_RESP3_ATTR:
    if (!f->expecting_value) {
      f->key = value;
      f->expecting_value = 1;
      return 0;
    } else {
      void *key = f->key;
      f->key = NULL;
      f->expecting_value = 0;
      if (f->type == FIO_RESP3_MAP)
        return cb->map_push(p->udata, f->ctx, key, value);
      else
        return cb->attr_push(p->udata, f->ctx, key, value);
    }
  default: return 0;
  }
}

/* *****************************************************************************
Internal Helper: Complete container and pop from stack
***************************************************************************** */

FIO_SFUNC void *fio___resp3_complete_frame(fio_resp3_parser_s *p,
                                           fio___resp3_cb_s *cb) {
  fio_resp3_frame_s *f = &p->stack[p->depth - 1];
  void *result = f->ctx;

  switch (f->type) {
  case FIO_RESP3_ARRAY: result = cb->array_done(p->udata, f->ctx); break;
  case FIO_RESP3_MAP: result = cb->map_done(p->udata, f->ctx); break;
  case FIO_RESP3_SET:
    /* When set_as_map is enabled, use map_done instead of set_done */
    if (f->set_as_map)
      result = cb->map_done(p->udata, f->ctx);
    else
      result = cb->set_done(p->udata, f->ctx);
    break;
  case FIO_RESP3_PUSH: result = cb->push_done(p->udata, f->ctx); break;
  case FIO_RESP3_ATTR: result = cb->attr_done(p->udata, f->ctx); break;
  default: break;
  }

  if (f->key) {
    cb->free_unused(p->udata, f->key);
    f->key = NULL;
  }

  --p->depth;
  return result;
}

/* *****************************************************************************
Internal Helper: Handle value completion and container unwinding
***************************************************************************** */

FIO_SFUNC void *fio___resp3_on_value(fio_resp3_parser_s *p,
                                     fio___resp3_cb_s *cb,
                                     void *value) {
  int attr_completed_at_top = 0;

  /* Push to parent if nested */
  if (p->depth > 0) {
    if (fio___resp3_push_value(p, cb, value)) {
      p->error = 1;
      return NULL;
    }
  }

  /* Unwind completed containers */
  while (p->depth > 0) {
    fio_resp3_frame_s *f = &p->stack[p->depth - 1];

    if (f->streaming)
      return NULL; /* Wait for end marker */

    if (f->remaining > 0)
      --f->remaining;

    if (f->remaining > 0)
      return NULL; /* More elements expected */

    /* Frame complete */
    uint8_t type = f->type;
    value = fio___resp3_complete_frame(p, cb);

    /* Attributes don't count as elements */
    if (type == FIO_RESP3_ATTR) {
      if (p->depth == 0)
        attr_completed_at_top = 1;
      continue;
    }

    /* Push completed container to parent */
    if (p->depth > 0) {
      if (fio___resp3_push_value(p, cb, value)) {
        p->error = 1;
        return NULL;
      }
    }
  }

  /* If attribute completed at top level, return NULL to continue parsing */
  if (attr_completed_at_top)
    return NULL;

  return value;
}

/* *****************************************************************************
Internal Helper: Push new frame
***************************************************************************** */

FIO_IFUNC int fio___resp3_push_frame(fio_resp3_parser_s *p,
                                     fio___resp3_cb_s *cb,
                                     uint8_t type,
                                     void *ctx,
                                     int64_t count,
                                     int streaming,
                                     int set_as_map) {
  if (p->depth >= FIO_RESP3_MAX_NESTING) {
    p->error = 1;
    cb->on_error_protocol(p->udata);
    return -1;
  }

  fio_resp3_frame_s *f = &p->stack[p->depth];
  f->type = type;
  f->ctx = ctx;
  f->key = NULL;
  f->remaining = count;
  f->streaming = (uint8_t)streaming;
  f->expecting_value = 0;
  f->set_as_map = (uint8_t)set_as_map;
  ++p->depth;
  return 0;
}

/* *****************************************************************************
RESP3 Main Parse Function
***************************************************************************** */

SFUNC fio_resp3_result_s fio_resp3_parse(fio_resp3_parser_s *parser,
                                         const fio_resp3_callbacks_s *callbacks,
                                         const void *buf,
                                         size_t len) {
  fio_resp3_result_s result = {.obj = NULL, .consumed = 0, .err = 0};
  const uint8_t *pos = (const uint8_t *)buf;
  const uint8_t *start = pos;
  const uint8_t *end = pos + len;
  void *obj = NULL;

  if (!parser) {
    FIO_LOG_ERROR("RESP3 parser: parser state is NULL");
    result.err = 1;
    return result;
  }

  fio___resp3_cb_s cb = fio___resp3_callbacks_validate(callbacks);

  if (parser->error) {
    result.err = 1;
    return result;
  }

  while (pos < end) {
    const uint8_t *eol = fio___resp3_find_eol(pos, end);
    if (!eol)
      break; /* Need more data */

    uint8_t type = *pos++;

    switch (type) {
    /* ===== Simple String: +<string>\r\n ===== */
    case FIO_RESP3_SIMPLE_STR: {
      const uint8_t *str_end = eol;
      if (str_end > pos && *(str_end - 1) == '\r')
        --str_end;
      obj = cb.on_string(parser->udata,
                         pos,
                         (size_t)(str_end - pos),
                         FIO_RESP3_SIMPLE_STR);
      pos = eol + 1;
      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Simple Error: -<string>\r\n ===== */
    case FIO_RESP3_SIMPLE_ERR: {
      const uint8_t *str_end = eol;
      if (str_end > pos && *(str_end - 1) == '\r')
        --str_end;
      obj = cb.on_error(parser->udata,
                        pos,
                        (size_t)(str_end - pos),
                        FIO_RESP3_SIMPLE_ERR);
      pos = eol + 1;
      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Number: :<number>\r\n ===== */
    case FIO_RESP3_NUMBER: {
      int64_t num = fio___resp3_parse_int(&pos, eol);
      obj = cb.on_number(parser->udata, num);
      pos = eol + 1;
      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Null: _\r\n ===== */
    case FIO_RESP3_NULL: {
      obj = cb.on_null(parser->udata);
      pos = eol + 1;
      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Double: ,<double>\r\n ===== */
    case FIO_RESP3_DOUBLE: {
      const uint8_t *num_end = eol;
      if (num_end > pos && *(num_end - 1) == '\r')
        --num_end;
      double num = fio___resp3_parse_double(pos, num_end);
      obj = cb.on_double(parser->udata, num);
      pos = eol + 1;
      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Boolean: #t\r\n or #f\r\n ===== */
    case FIO_RESP3_BOOL: {
      int is_true = (*pos == 't' || *pos == 'T');
      obj = cb.on_bool(parser->udata, is_true);
      pos = eol + 1;
      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Big Number: (<big number>\r\n ===== */
    case FIO_RESP3_BIGNUM: {
      const uint8_t *num_end = eol;
      if (num_end > pos && *(num_end - 1) == '\r')
        --num_end;
      obj = cb.on_bignum(parser->udata, pos, (size_t)(num_end - pos));
      pos = eol + 1;
      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Blob String: $<length>\r\n<bytes>\r\n or $?\r\n (streaming) =====
     */
    case FIO_RESP3_BLOB_STR: {
      /* Streaming blob string: $?\r\n followed by ;len\r\ndata... chunks */
      if (*pos == '?') {
        pos = eol + 1;
        /* Start streaming string if callbacks available */
        if (cb.on_start_string) {
          void *ctx =
              cb.on_start_string(parser->udata, (size_t)-1, FIO_RESP3_BLOB_STR);
          if (ctx) {
            parser->streaming_string = 1;
            parser->streaming_string_type = FIO_RESP3_BLOB_STR;
            parser->streaming_string_ctx = ctx;
            break;
          }
        }
        /* No streaming callbacks - error (can't buffer unknown length) */
        parser->error = 1;
        result.err = 1;
        cb.on_error_protocol(parser->udata);
        goto done;
      }

      int64_t blob_len = fio___resp3_parse_int(&pos, eol);
      pos = eol + 1;

      if (blob_len < 0) {
        /* Null blob (RESP2 compat) */
        obj = cb.on_null(parser->udata);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      /* Check if we have complete blob data */
      if ((size_t)(end - pos) < (size_t)blob_len + 2) {
        /* Not enough data - rewind to start of this message */
        pos = start + result.consumed;
        goto done;
      }

      /* Use streaming callbacks if available */
      if (cb.on_start_string) {
        void *ctx = cb.on_start_string(parser->udata,
                                       (size_t)blob_len,
                                       FIO_RESP3_BLOB_STR);
        if (ctx) {
          if (cb.on_string_write(parser->udata, ctx, pos, (size_t)blob_len)) {
            parser->error = 1;
            result.err = 1;
            goto done;
          }
          obj = cb.on_string_done(parser->udata, ctx, FIO_RESP3_BLOB_STR);
          pos += blob_len;
          if (pos < end && *pos == '\r')
            ++pos;
          if (pos < end && *pos == '\n')
            ++pos;
          obj = fio___resp3_on_value(parser, &cb, obj);
          if (parser->error) {
            result.err = 1;
            goto done;
          }
          if (obj && parser->depth == 0) {
            result.obj = obj;
            goto done;
          }
          break;
        }
        /* on_start_string returned NULL, fall back to on_string */
      }

      obj = cb.on_string(parser->udata,
                         pos,
                         (size_t)blob_len,
                         FIO_RESP3_BLOB_STR);
      pos += blob_len;
      if (pos < end && *pos == '\r')
        ++pos;
      if (pos < end && *pos == '\n')
        ++pos;

      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Blob Error: !<length>\r\n<bytes>\r\n ===== */
    case FIO_RESP3_BLOB_ERR: {
      int64_t blob_len = fio___resp3_parse_int(&pos, eol);
      pos = eol + 1;

      if (blob_len <= 0) {
        obj = cb.on_error(parser->udata, "", 0, FIO_RESP3_BLOB_ERR);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      if ((size_t)(end - pos) < (size_t)blob_len + 2) {
        pos = start + result.consumed;
        goto done;
      }

      /* Use streaming callbacks if available */
      if (cb.on_start_string) {
        void *ctx = cb.on_start_string(parser->udata,
                                       (size_t)blob_len,
                                       FIO_RESP3_BLOB_ERR);
        if (ctx) {
          if (cb.on_string_write(parser->udata, ctx, pos, (size_t)blob_len)) {
            parser->error = 1;
            result.err = 1;
            goto done;
          }
          obj = cb.on_string_done(parser->udata, ctx, FIO_RESP3_BLOB_ERR);
          pos += blob_len;
          if (pos < end && *pos == '\r')
            ++pos;
          if (pos < end && *pos == '\n')
            ++pos;
          obj = fio___resp3_on_value(parser, &cb, obj);
          if (parser->error) {
            result.err = 1;
            goto done;
          }
          if (obj && parser->depth == 0) {
            result.obj = obj;
            goto done;
          }
          break;
        }
        /* on_start_string returned NULL, fall back to on_error */
      }

      obj =
          cb.on_error(parser->udata, pos, (size_t)blob_len, FIO_RESP3_BLOB_ERR);
      pos += blob_len;
      if (pos < end && *pos == '\r')
        ++pos;
      if (pos < end && *pos == '\n')
        ++pos;

      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Verbatim String: =<length>\r\n<type:><bytes>\r\n ===== */
    case FIO_RESP3_VERBATIM: {
      int64_t blob_len = fio___resp3_parse_int(&pos, eol);
      pos = eol + 1;

      if (blob_len < 0) {
        obj = cb.on_null(parser->udata);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      if ((size_t)(end - pos) < (size_t)blob_len + 2) {
        pos = start + result.consumed;
        goto done;
      }

      /* Use streaming callbacks if available */
      if (cb.on_start_string) {
        void *ctx = cb.on_start_string(parser->udata,
                                       (size_t)blob_len,
                                       FIO_RESP3_VERBATIM);
        if (ctx) {
          if (cb.on_string_write(parser->udata, ctx, pos, (size_t)blob_len)) {
            parser->error = 1;
            result.err = 1;
            goto done;
          }
          obj = cb.on_string_done(parser->udata, ctx, FIO_RESP3_VERBATIM);
          pos += blob_len;
          if (pos < end && *pos == '\r')
            ++pos;
          if (pos < end && *pos == '\n')
            ++pos;
          obj = fio___resp3_on_value(parser, &cb, obj);
          if (parser->error) {
            result.err = 1;
            goto done;
          }
          if (obj && parser->depth == 0) {
            result.obj = obj;
            goto done;
          }
          break;
        }
        /* on_start_string returned NULL, fall back to on_string */
      }

      obj = cb.on_string(parser->udata,
                         pos,
                         (size_t)blob_len,
                         FIO_RESP3_VERBATIM);
      pos += blob_len;
      if (pos < end && *pos == '\r')
        ++pos;
      if (pos < end && *pos == '\n')
        ++pos;

      obj = fio___resp3_on_value(parser, &cb, obj);
      if (parser->error) {
        result.err = 1;
        goto done;
      }
      if (obj && parser->depth == 0) {
        result.obj = obj;
        goto done;
      }
      break;
    }

    /* ===== Array: *<count>\r\n ===== */
    case FIO_RESP3_ARRAY: {
      int streaming = 0;
      int64_t count;

      if (*pos == '?') {
        streaming = 1;
        count = -1;
      } else {
        count = fio___resp3_parse_int(&pos, eol);
      }
      pos = eol + 1;

      if (count < 0 && !streaming) {
        obj = cb.on_null(parser->udata);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      void *parent = fio___resp3_parent_ctx(parser);
      void *ctx = cb.on_array(parser->udata, parent, count);

      if (count == 0) {
        obj = cb.array_done(parser->udata, ctx);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      if (fio___resp3_push_frame(parser,
                                 &cb,
                                 FIO_RESP3_ARRAY,
                                 ctx,
                                 count,
                                 streaming,
                                 0)) {
        result.err = 1;
        goto done;
      }
      break;
    }

    /* ===== Map: %<count>\r\n ===== */
    case FIO_RESP3_MAP: {
      int streaming = 0;
      int64_t count;

      if (*pos == '?') {
        streaming = 1;
        count = -1;
      } else {
        count = fio___resp3_parse_int(&pos, eol);
      }
      pos = eol + 1;

      if (count < 0 && !streaming) {
        obj = cb.on_null(parser->udata);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      void *parent = fio___resp3_parent_ctx(parser);
      void *ctx = cb.on_map(parser->udata, parent, count);

      if (count == 0) {
        obj = cb.map_done(parser->udata, ctx);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      /* Maps: count is pairs, need count*2 elements */
      int64_t elements = streaming ? -1 : count * 2;
      if (fio___resp3_push_frame(parser,
                                 &cb,
                                 FIO_RESP3_MAP,
                                 ctx,
                                 elements,
                                 streaming,
                                 0)) {
        result.err = 1;
        goto done;
      }
      break;
    }

    /* ===== Set: ~<count>\r\n ===== */
    case FIO_RESP3_SET: {
      int streaming = 0;
      int64_t count;

      if (*pos == '?') {
        streaming = 1;
        count = -1;
      } else {
        count = fio___resp3_parse_int(&pos, eol);
      }
      pos = eol + 1;

      if (count < 0 && !streaming) {
        obj = cb.on_null(parser->udata);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      void *parent = fio___resp3_parent_ctx(parser);
      /* When set_as_map is enabled, use on_map instead of on_set */
      void *ctx = cb.set_as_map ? cb.on_map(parser->udata, parent, count)
                                : cb.on_set(parser->udata, parent, count);

      if (count == 0) {
        /* When set_as_map is enabled, use map_done instead of set_done */
        obj = cb.set_as_map ? cb.map_done(parser->udata, ctx)
                            : cb.set_done(parser->udata, ctx);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      if (fio___resp3_push_frame(parser,
                                 &cb,
                                 FIO_RESP3_SET,
                                 ctx,
                                 count,
                                 streaming,
                                 cb.set_as_map)) {
        result.err = 1;
        goto done;
      }
      break;
    }

    /* ===== Push: ><count>\r\n ===== */
    case FIO_RESP3_PUSH: {
      int64_t count = fio___resp3_parse_int(&pos, eol);
      pos = eol + 1;

      if (count < 0) {
        obj = cb.on_null(parser->udata);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      void *parent = fio___resp3_parent_ctx(parser);
      void *ctx = cb.on_push(parser->udata, parent, count);

      if (count == 0) {
        obj = cb.push_done(parser->udata, ctx);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      if (fio___resp3_push_frame(parser,
                                 &cb,
                                 FIO_RESP3_PUSH,
                                 ctx,
                                 count,
                                 0,
                                 0)) {
        result.err = 1;
        goto done;
      }
      break;
    }

    /* ===== Attribute: |<count>\r\n ===== */
    case FIO_RESP3_ATTR: {
      int64_t count = fio___resp3_parse_int(&pos, eol);
      pos = eol + 1;

      if (count < 0) {
        /* Skip null attribute */
        break;
      }

      void *parent = fio___resp3_parent_ctx(parser);
      void *ctx = cb.on_attr(parser->udata, parent, count);

      if (count == 0) {
        cb.attr_done(parser->udata, ctx);
        break;
      }

      if (fio___resp3_push_frame(parser,
                                 &cb,
                                 FIO_RESP3_ATTR,
                                 ctx,
                                 count * 2,
                                 0,
                                 0)) {
        result.err = 1;
        goto done;
      }
      break;
    }

    /* ===== Streamed string chunk: ;<length>\r\n<bytes>\r\n ===== */
    case FIO_RESP3_STREAM_CHUNK: {
      /* This is only valid when we're in a streaming string */
      if (!parser->streaming_string) {
        parser->error = 1;
        result.err = 1;
        cb.on_error_protocol(parser->udata);
        goto done;
      }

      int64_t chunk_len = fio___resp3_parse_int(&pos, eol);
      pos = eol + 1;

      /* Length 0 means end of streaming string */
      if (chunk_len == 0) {
        obj = cb.on_string_done(parser->udata,
                                parser->streaming_string_ctx,
                                parser->streaming_string_type);
        parser->streaming_string = 0;
        parser->streaming_string_ctx = NULL;
        parser->streaming_string_type = 0;
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      /* Check if we have complete chunk data */
      if ((size_t)(end - pos) < (size_t)chunk_len + 2) {
        /* Not enough data - rewind to start of this chunk */
        pos = start + result.consumed;
        goto done;
      }

      /* Write chunk data */
      if (cb.on_string_write(parser->udata,
                             parser->streaming_string_ctx,
                             pos,
                             (size_t)chunk_len)) {
        parser->error = 1;
        result.err = 1;
        goto done;
      }

      pos += chunk_len;
      if (pos < end && *pos == '\r')
        ++pos;
      if (pos < end && *pos == '\n')
        ++pos;
      break;
    }

    /* ===== Streamed aggregate end: .\r\n ===== */
    case FIO_RESP3_STREAM_END: {
      pos = eol + 1;

      /* Handle streaming string end (alternative to ;0\r\n) */
      if (parser->streaming_string) {
        obj = cb.on_string_done(parser->udata,
                                parser->streaming_string_ctx,
                                parser->streaming_string_type);
        parser->streaming_string = 0;
        parser->streaming_string_ctx = NULL;
        parser->streaming_string_type = 0;
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
        break;
      }

      if (parser->depth > 0 && parser->stack[parser->depth - 1].streaming) {
        obj = fio___resp3_complete_frame(parser, &cb);
        obj = fio___resp3_on_value(parser, &cb, obj);
        if (parser->error) {
          result.err = 1;
          goto done;
        }
        if (obj && parser->depth == 0) {
          result.obj = obj;
          goto done;
        }
      }
      break;
    }

    default:
      parser->error = 1;
      result.err = 1;
      cb.on_error_protocol(parser->udata);
      goto done;
    }

    /* Update consumed position after each complete element */
    result.consumed = (size_t)(pos - start);
  }

done:
  result.consumed = (size_t)(pos - start);
  return result;
}

/* *****************************************************************************
RESP3 Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_RESP3
#endif /* FIO_RESP3 */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_SOCK               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                            Basic Socket Helpers



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_SOCK) && !defined(H___FIO_SOCK___H)
#define H___FIO_SOCK___H

/* *****************************************************************************
OS specific patches.
***************************************************************************** */
#if FIO_OS_WIN
#if _MSC_VER
#pragma comment(lib, "Ws2_32.lib")
#endif
#include <iphlpapi.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#ifdef AF_UNIX
#include <afunix.h>
#endif
#ifndef FIO_SOCK_FD_ISVALID
#define FIO_SOCK_FD_ISVALID(fd) ((size_t)(fd) <= (size_t)0x7FFFFFFF)
#endif
/** Acts as POSIX write. Use this macro for portability with WinSock2. */
#define fio_sock_write(fd, data, len) send((fd), (data), (len), 0)
/** Acts as POSIX read. Use this macro for portability with WinSock2. */
#define fio_sock_read(fd, buf, len) recv((fd), (buf), (len), 0)
/** Acts as POSIX close. Use this macro for portability with WinSock2. */
#define fio_sock_close(fd) closesocket(fd)
/** Protects against type size overflow on Windows, where FD > MAX_INT. */
FIO_IFUNC int fio_sock_accept(int s, struct sockaddr *addr, int *addrlen) {
  int r = -1;
  SOCKET c = accept(s, addr, addrlen);
  if (c == INVALID_SOCKET)
    return r;
  if (FIO_SOCK_FD_ISVALID(c)) {
    r = (int)c;
    return r;
  }
  closesocket(c);
  errno = ERANGE;
  FIO_LOG_ERROR("Windows SOCKET value overflowed int limits (was: %zu)",
                (size_t)c);
  return r;
}
#define accept fio_sock_accept
#define poll   WSAPoll
/** Acts as POSIX dup. Use this for portability with WinSock2. */
FIO_IFUNC int fio_sock_dup(int original) {
  int fd = -1;
  SOCKET tmpfd = INVALID_SOCKET;
  WSAPROTOCOL_INFO info;
  if (!WSADuplicateSocket(original, GetCurrentProcessId(), &info) &&
      (tmpfd = WSASocket(AF_UNSPEC, SOCK_STREAM, IPPROTO_TCP, &info, 0, 0)) !=
          INVALID_SOCKET) {
    if (FIO_SOCK_FD_ISVALID(tmpfd))
      fd = (int)tmpfd;
    else
      fio_sock_close(tmpfd);
  }
  return fd;
}

#elif FIO_HAVE_UNIX_TOOLS
#include <arpa/inet.h>
#include <fcntl.h>
#include <netdb.h>
#include <poll.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/un.h>
#include <unistd.h>
#ifndef FIO_SOCK_FD_ISVALID
#define FIO_SOCK_FD_ISVALID(fd) ((int)(fd) != (int)-1)
#endif
/** Acts as POSIX write. Use this macro for portability with WinSock2. */
#define fio_sock_write(fd, data, len)      write((fd), (data), (len))
/** Acts as POSIX read. Use this macro for portability with WinSock2. */
#define fio_sock_read(fd, buf, len)        read((fd), (buf), (len))
/** Acts as POSIX dup. Use this macro for portability with WinSock2. */
#define fio_sock_dup(fd)                   dup(fd)
/** Acts as POSIX close. Use this macro for portability with WinSock2. */
#define fio_sock_close(fd)                 close(fd)
/** Acts as POSIX accept. Use this macro for portability with WinSock2. */
#define fio_sock_accept(fd, addr, addrlen) accept(fd, addr, addrlen)
#else
#error FIO_SOCK requires a supported OS (Windows / POSIX).
#endif

/* Set to 1 if in need to debug unexpected IO closures. */
#if defined(DEBUG) && 0
#define close(fd)                                                              \
  do {                                                                         \
    FIO_LOG_DWARNING("(%d) (" FIO__FILE__ ":" FIO_MACRO2STR(                   \
                         __LINE__) ") fio_sock_close called for fd %d",        \
                     fio_getpid(),                                             \
                     (int)fd);                                                 \
    close(fd);                                                                 \
  } while (0)
#endif /* DEBUG */

/* *****************************************************************************
Socket OS abstraction - API
***************************************************************************** */

#ifndef FIO_SOCK_DEFAULT_MAXIMIZE_LIMIT
#define FIO_SOCK_DEFAULT_MAXIMIZE_LIMIT (1ULL << 24)
#endif

/** Socket type flags */
typedef enum {
  FIO_SOCK_SERVER = 0,
  FIO_SOCK_CLIENT = 1,
  FIO_SOCK_NONBLOCK = 2,
  FIO_SOCK_TCP = 4,
  FIO_SOCK_UDP = 8,
#ifdef AF_UNIX
  FIO_SOCK_UNIX = 16,
  FIO_SOCK_UNIX_PRIVATE = (16 | 32),
#else
#define FIO_SOCK_UNIX         0
#define FIO_SOCK_UNIX_PRIVATE 0
#endif
} fio_sock_open_flags_e;

/**
 * Creates a new socket according to the provided flags.
 *
 * The `port` string will be ignored when `FIO_SOCK_UNIX` is set.
 */
FIO_IFUNC int fio_sock_open(const char *restrict address,
                            const char *restrict port,
                            uint16_t flags);

/** Creates a new socket, according to the provided flags. */
SFUNC int fio_sock_open2(const char *url, uint16_t flags);

/**
 * Attempts to resolve an address to a valid IP6 / IP4 address pointer.
 *
 * The `sock_type` element should be a socket type, such as `SOCK_DGRAM` (UDP)
 * or `SOCK_STREAM` (TCP/IP).
 *
 * The address should be freed using `fio_sock_address_free`.
 */
FIO_IFUNC struct addrinfo *fio_sock_address_new(const char *restrict address,
                                                const char *restrict port,
                                                int sock_type);

/** Frees the pointer returned by `fio_sock_address_new`. */
FIO_IFUNC void fio_sock_address_free(struct addrinfo *a);

/**
 * Returns a human readable address representation of the socket's peer address.
 *
 * On error, returns a NULL buffer with zero length.
 *
 * Buffer lengths are limited to 63 bytes.
 *
 * This function is limited in its thread safety to 128 threads / calls.
 */
SFUNC fio_buf_info_s fio_sock_peer_addr(int s);

/** Creates a new network socket and binds it to a local address. */
SFUNC int fio_sock_open_local(struct addrinfo *addr, int nonblock);

/** Creates a new network socket and connects it to a remote address. */
SFUNC int fio_sock_open_remote(struct addrinfo *addr, int nonblock);

/** Creates a new Unix socket and binds it to a local address. */
SFUNC int fio_sock_open_unix(const char *address, uint16_t flags);

/** Sets a file descriptor / socket to non blocking state. */
SFUNC int fio_sock_set_non_block(int fd);

/** Attempts to maximize the allowed open file limits. returns known limit */
SFUNC size_t fio_sock_maximize_limits(size_t maximum_limit);

/**
 * Returns 0 on timeout, -1 on error or the events that are valid.
 *
 * A zero timeout returns immediately.
 *
 * Possible events include POLLIN | POLLOUT
 *
 * Possible return values include POLLIN | POLLOUT | POLLHUP | POLLNVAL
 */
SFUNC short fio_sock_wait_io(int fd, short events, int timeout);

/** A helper macro that waits on a single IO with no callbacks (0 = no event) */
#define FIO_SOCK_WAIT_RW(fd, timeout_)                                         \
  fio_sock_wait_io(fd, POLLIN | POLLOUT, timeout_)

/** A helper macro that waits on a single IO with no callbacks (0 = no event) */
#define FIO_SOCK_WAIT_R(fd, timeout_) fio_sock_wait_io(fd, POLLIN, timeout_)

/** A helper macro that waits on a single IO with no callbacks (0 = no event) */
#define FIO_SOCK_WAIT_W(fd, timeout_) fio_sock_wait_io(fd, POLLOUT, timeout_)

#ifdef POLLRDHUP
/** A helper macro that tests if a socket was closed.  */
#define FIO_SOCK_IS_OPEN(fd)                                                   \
  (!(fio_sock_wait_io(fd, (POLLOUT | POLLRDHUP), 0) &                          \
     (POLLRDHUP | POLLHUP | POLLNVAL)))
#else
#define FIO_SOCK_IS_OPEN(fd)                                                   \
  (!(fio_sock_wait_io(fd, POLLOUT, 0) & (POLLHUP | POLLNVAL)))
#endif

/* *****************************************************************************
IO Poll - Implementation (always static / inlined)
***************************************************************************** */

/**
 * Creates a new socket according to the provided flags.
 *
 * The `port` string will be ignored when `FIO_SOCK_UNIX` is set.
 */
FIO_IFUNC int fio_sock_open(const char *restrict address,
                            const char *restrict port,
                            uint16_t flags) {
  struct addrinfo *addr = NULL;
  int fd;
#ifdef AF_UNIX
  if ((flags & FIO_SOCK_UNIX))
    return fio_sock_open_unix(address, flags);
#endif

  switch ((flags & ((uint16_t)FIO_SOCK_TCP | (uint16_t)FIO_SOCK_UDP))) {
  case 0: /* fall through - default to TCP/IP*/
  case FIO_SOCK_TCP:
    addr = fio_sock_address_new(address, port, SOCK_STREAM);
    if (!addr) {
      FIO_LOG_ERROR("(fio_sock_open) address error: %s", strerror(errno));
      return -1;
    }
    if ((flags & FIO_SOCK_CLIENT)) {
      fd = fio_sock_open_remote(addr, (flags & FIO_SOCK_NONBLOCK));
    } else {
      fd = fio_sock_open_local(addr, (flags & FIO_SOCK_NONBLOCK));
      if (fd != -1 && listen(fd, SOMAXCONN) == -1) {
        FIO_LOG_ERROR("(fio_sock_open) failed on call to listen: %s",
                      strerror(errno));
        fio_sock_close(fd);
        fd = -1;
      }
    }
    fio_sock_address_free(addr);
    return fd;
  case FIO_SOCK_UDP:
    addr = fio_sock_address_new(address, port, SOCK_DGRAM);
    if (!addr) {
      FIO_LOG_ERROR("(fio_sock_open) address error: %s", strerror(errno));
      return -1;
    }
    if ((flags & FIO_SOCK_CLIENT)) {
      fd = fio_sock_open_remote(addr, (flags & FIO_SOCK_NONBLOCK));
    } else {
      fd = fio_sock_open_local(addr, (flags & FIO_SOCK_NONBLOCK));
    }
    fio_sock_address_free(addr);
    return fd;
  }

  FIO_LOG_ERROR(
      "(fio_sock_open) the FIO_SOCK_TCP and FIO_SOCK_UDP flags are exclusive");
  return -1;
}

FIO_IFUNC struct addrinfo *fio_sock_address_new(
    const char *restrict address,
    const char *restrict port,
    int sock_type /*i.e., SOCK_DGRAM */) {
  struct addrinfo addr_hints = (struct addrinfo){0}, *a;
  int e;
  addr_hints.ai_family = AF_UNSPEC; // set to AF_INET to force IPv4
  addr_hints.ai_socktype = sock_type;
  addr_hints.ai_flags = AI_PASSIVE; // use my IP

  size_t port_len = (port ? FIO_STRLEN(port) : 0U);
  switch (port_len) { /* skip system service lookup for common web stuff */
  case 2:
    if ((port[0] | 32) == 'w' && (port[1] | 32) == 's')
      port = "80";
    break;
  case 3:
    if ((port[0] | 32) == 'w' && (port[1] | 32) == 's' && (port[2] | 32) == 's')
      port = "443";
    else if ((port[0] | 32) == 's' && (port[1] | 32) == 's' &&
             (port[2] | 32) == 'e')
      port = "80";
    break;
  case 4:
    if ((port[0] | 32) == 'h' && (port[1] | 32) == 't' &&
        (port[2] | 32) == 't' && (port[3] | 32) == 'p')
      port = "80";
    else if ((port[0] | 32) == 's' && (port[1] | 32) == 's' &&
             (port[2] | 32) == 'e' && (port[3] | 32) == 's')
      port = "443";
    break;
  case 5:
    if ((port[0] | 32) == 'h' && (port[1] | 32) == 't' &&
        (port[2] | 32) == 't' && (port[3] | 32) == 'p' && (port[4] | 32) == 's')
      port = "443";
    break;
  }

#if 1 /* override system resolution for localhost ? */
  size_t address_len = (address ? FIO_STRLEN(address) : 0U);
  if (address && address_len == 9 && (address[0] | 32) == 'l' &&
      (fio_buf2u64u(address + 1) | (uint64_t)0x2020202020202020ULL) ==
          fio_buf2u64u("ocalhost"))
    address = "127.0.0.1";
  else if (sock_type != SOCK_DGRAM && address_len == 7 &&
           (fio_buf2u64u("0.0.0.0") |
            fio_buf2u64u("\x00\x00\x00\x00\x00\x00\x00\xFF")) ==
               (fio_buf2u64u(address) |
                fio_buf2u64u("\x00\x00\x00\x00\x00\x00\x00\xFF")))
    address = NULL; /* bind to everything INADDR_ANY */
#endif
  /* call for OS address resolution */
  if ((e = getaddrinfo(address, (port ? port : "0"), &addr_hints, &a)) != 0) {
    FIO_LOG_ERROR("(fio_sock_address_new(\"%s\", \"%s\")) error: %s",
                  (address ? address : "NULL"),
                  (port ? port : "0"),
                  gai_strerror(e));
    return NULL;
  }
  return a;
}

FIO_IFUNC void fio_sock_address_free(struct addrinfo *a) { freeaddrinfo(a); }

/* *****************************************************************************
FIO_SOCK - Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/** Creates a new socket, according to the provided flags. */
SFUNC int fio_sock_open2(const char *url, uint16_t flags) {
  char buf[2048];
  char port[64];
  char *addr = buf;
  char *pr = port;

  /* parse URL */
  fio_url_s u = fio_url_parse(url, FIO_STRLEN(url));
#ifdef AF_UNIX
  if (!u.host.buf && !u.port.buf && u.path.buf) {
    /* Unix socket - force flag validation */
    flags &= ~((uint16_t)(FIO_SOCK_UNIX | FIO_SOCK_TCP));
    flags |= (u.scheme.len == 4 &&
              fio_buf2u32u(u.scheme.buf) == fio_buf2u32u("priv"))
                 ? FIO_SOCK_UNIX_PRIVATE
                 : FIO_SOCK_UNIX;
    if (u.path.len > 2047) {
      errno = EINVAL;
      FIO_LOG_ERROR(
          "Couldn't open unix socket to %s - host name too long (%zu).",
          url,
          u.path.len);
      return -1;
    }
    FIO_MEMCPY(buf, u.path.buf, u.path.len);
    buf[u.path.len] = 0;
    pr = NULL;
    return fio_sock_open_unix(buf, flags);
  }
#endif
  if (!u.port.len)
    u.port = u.scheme;
  if (!u.port.len) {
    pr = NULL;
  } else {
    if (u.port.len > 63) {
      errno = EINVAL;
      FIO_LOG_ERROR("Couldn't open socket to %s - port / scheme too long.",
                    url);
      return -1;
    }
    FIO_MEMCPY(port, u.port.buf, u.port.len);
    port[u.port.len] = 0;
    if (!(flags & (FIO_SOCK_TCP | FIO_SOCK_UDP))) {
      if (u.scheme.len == 3 && (u.scheme.buf[0] | 32) == 't' &&
          (u.scheme.buf[1] | 32) == 'c' && (u.scheme.buf[2] | 32) == 'p')
        flags |= FIO_SOCK_TCP;
      else if (u.scheme.len == 3 && (u.scheme.buf[0] | 32) == 'u' &&
               (u.scheme.buf[1] | 32) == 'd' && (u.scheme.buf[2] | 32) == 'p')
        flags |= FIO_SOCK_UDP;
      else if ((u.scheme.len == 4 || u.scheme.len == 5) &&
               (u.scheme.buf[0] | 32) == 'h' && (u.scheme.buf[1] | 32) == 't' &&
               (u.scheme.buf[2] | 32) == 't' && (u.scheme.buf[3] | 32) == 'p' &&
               (u.scheme.len == 4 ||
                (u.scheme.len == 5 && (u.scheme.buf[4] | 32) == 's')))
        flags |= FIO_SOCK_TCP;
    }
  }
  if (u.host.len) {
    if (u.host.len > 2047) {
      errno = EINVAL;
      FIO_LOG_ERROR("Couldn't open socket to %s - host name too long.", url);
      return -1;
    }
    FIO_MEMCPY(buf, u.host.buf, u.host.len);
    buf[u.host.len] = 0;
  } else {
    addr = NULL;
  }
  return fio_sock_open(addr, pr, flags);
}

/** Sets a file descriptor / socket to non blocking state. */
SFUNC int fio_sock_set_non_block(int fd) {
/* If they have O_NONBLOCK, use the Posix way to do it */
#if defined(O_NONBLOCK) && defined(F_GETFL) && defined(F_SETFL)
  /* Fixme: O_NONBLOCK is defined but broken on SunOS 4.1.x and AIX 3.2.5. */
  int flags;
  if (-1 == (flags = fcntl(fd, F_GETFL, 0)))
    flags = 0;
#if defined(O_CLOEXEC)
  return fcntl(fd, F_SETFL, flags | O_NONBLOCK | O_CLOEXEC);
#else
  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
#endif
#elif defined(FIONBIO)
  /* Otherwise, use the old way of doing it */
#if FIO_OS_WIN
  unsigned long flags = 1;
  if (ioctlsocket(fd, FIONBIO, &flags) == SOCKET_ERROR) {
    switch (WSAGetLastError()) {
    case WSANOTINITIALISED:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSANOTINITIALISED");
      break;
    case WSAENETDOWN:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSAENETDOWN");
      break;
    case WSAEINPROGRESS:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSAEINPROGRESS");
      break;
    case WSAENOTSOCK:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSAENOTSOCK");
      break;
    case WSAEFAULT:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSAEFAULT");
      break;
    }
    return -1;
  }
  return 0;
#else
  int flags = 1;
  return ioctl(fd, FIONBIO, &flags);
#endif /* FIO_OS_WIN */
#else
#error No functions / argumnet macros for non-blocking sockets.
#endif
}

/** Creates a new network socket and binds it to a local address. */
SFUNC int fio_sock_open_local(struct addrinfo *addr, int nonblock) {
  int fd = -1;
  for (struct addrinfo *p = addr; p != NULL; p = p->ai_next) {
#if FIO_OS_WIN
    SOCKET fd_tmp;
    if ((fd_tmp = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) ==
        INVALID_SOCKET) {
      FIO_LOG_DEBUG("socket creation error %s", strerror(errno));
      continue;
    }
    if (!FIO_SOCK_FD_ISVALID(fd_tmp)) {
      FIO_LOG_DEBUG("windows socket value out of valid portable range.");
      errno = ERANGE;
    }
    fd = (int)fd_tmp;
#else
    if ((fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
      FIO_LOG_DEBUG("socket creation error %s", strerror(errno));
      continue;
    }
#endif
    { // avoid the "address taken"
      int optval = 1;
      setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void *)&optval, sizeof(optval));
    }
    if (nonblock && fio_sock_set_non_block(fd) == -1) {
      FIO_LOG_DEBUG("Couldn't set socket (%d) to non-blocking mode %s",
                    fd,
                    strerror(errno));
      fio_sock_close(fd);
      fd = -1;
      continue;
    }
    if (bind(fd, p->ai_addr, p->ai_addrlen) == -1) {
      FIO_LOG_DEBUG("Failed attempt to bind socket (%d) to address %s",
                    fd,
                    strerror(errno));
      fio_sock_close(fd);
      fd = -1;
      continue;
    }
    break;
  }
  if (fd == -1) {
    FIO_LOG_DEBUG("socket binding/creation error %s", strerror(errno));
  }
  return fd;
}

/** Creates a new network socket and connects it to a remote address. */
SFUNC int fio_sock_open_remote(struct addrinfo *addr, int nonblock) {
  int fd = -1;
  for (struct addrinfo *p = addr; p != NULL; p = p->ai_next) {
#if FIO_OS_WIN
    SOCKET fd_tmp;
    if ((fd_tmp = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) ==
        INVALID_SOCKET) {
      FIO_LOG_DEBUG("socket creation error %s", strerror(errno));
      continue;
    }
    if (!FIO_SOCK_FD_ISVALID(fd_tmp)) {
      FIO_LOG_DEBUG("windows socket value out of valid portable range.");
      errno = ERANGE;
    }
    fd = (int)fd_tmp;
#else
    if ((fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
      FIO_LOG_DEBUG("socket creation error %s", strerror(errno));
      continue;
    }
#endif

    if (nonblock && fio_sock_set_non_block(fd) == -1) {
      FIO_LOG_DEBUG(
          "Failed attempt to set client socket (%d) to non-blocking %s",
          fd,
          strerror(errno));
      fio_sock_close(fd);
      fd = -1;
      continue;
    }
    if (connect(fd, p->ai_addr, p->ai_addrlen) == -1 &&
#if FIO_OS_WIN
        (WSAGetLastError() != WSAEWOULDBLOCK || errno != EINPROGRESS)
#else
        errno != EINPROGRESS
#endif
    ) {
#if FIO_OS_WIN
      FIO_LOG_DEBUG(
          "Couldn't connect client socket (%d) to remote address %s (%d)",
          fd,
          strerror(errno),
          WSAGetLastError());
#else
      FIO_LOG_DEBUG("Couldn't connect client socket (%d) to remote address %s",
                    fd,
                    strerror(errno));
#endif
      fio_sock_close(fd);
      fd = -1;
      continue;
    }
    break;
  }
  if (fd == -1) {
    FIO_LOG_DEBUG("socket connection/creation error %s", strerror(errno));
  }
  return fd;
}

/** Returns 0 on timeout, -1 on error or the events that are valid. */
SFUNC short fio_sock_wait_io(int fd, short events, int timeout) {
  short r = 0;
#if FIO_OS_WIN
  if (fd == -1) {
    FIO_THREAD_WAIT((timeout * 1000000));
    return r;
  }
#endif
  struct pollfd pfd = {.fd = fd, .events = events};
  r = (short)poll(&pfd, 1, timeout);
  if (r == 1)
    r = pfd.revents;
  return r;
}

/** Attempts to maximize the allowed open file limits. returns known limit */
SFUNC size_t fio_sock_maximize_limits(size_t max_limit) {
  ssize_t capa = 0;
  if (!max_limit)
    max_limit = FIO_SOCK_DEFAULT_MAXIMIZE_LIMIT;
#if FIO_OS_POSIX

#ifdef _SC_OPEN_MAX
  capa = sysconf(_SC_OPEN_MAX);
#elif defined(FOPEN_MAX)
  capa = FOPEN_MAX;
#endif
  // try to maximize limits - collect max and set to max
  struct rlimit rlim = {.rlim_max = 0};
  if (getrlimit(RLIMIT_NOFILE, &rlim) == -1) {
    FIO_LOG_WARNING("`getrlimit` failed (%d): %s", errno, strerror(errno));
    return capa;
  }

  FIO_LOG_DEBUG2("existing / maximum open file limit detected: %zd / %zd",
                 (ssize_t)rlim.rlim_cur,
                 (ssize_t)rlim.rlim_max);

  if (rlim.rlim_cur >= max_limit) {
    FIO_LOG_DEBUG2("open file limit can't be maximized any further (%zd / %zu)",
                   (ssize_t)rlim.rlim_cur,
                   max_limit);
    return rlim.rlim_cur;
  }

  rlim_t original = rlim.rlim_cur;
  rlim.rlim_cur = rlim.rlim_max > max_limit ? max_limit : rlim.rlim_max;
  while (setrlimit(RLIMIT_NOFILE, &rlim) == -1 && rlim.rlim_cur > original)
    rlim.rlim_cur >>= 1;

  FIO_LOG_DEBUG2("new open file limit: %zd", (ssize_t)rlim.rlim_cur);

  getrlimit(RLIMIT_NOFILE, &rlim);
  capa = rlim.rlim_cur;
#elif FIO_OS_WIN
  capa = 1ULL << 10;
  while (_setmaxstdio(capa) > 0)
    capa <<= 1;
  capa >>= 1;
  FIO_LOG_DEBUG("new open file limit: %zd", (ssize_t)capa);
#else
  FIO_LOG_ERROR("No OS detected, couldn't maximize open file limit.");
#endif
  return capa;
}

#ifdef AF_UNIX
/** Creates a new Unix socket and binds it to a local address. */
SFUNC int fio_sock_open_unix(const char *address, uint16_t flags) {
  /* Unix socket */
  struct sockaddr_un addr = {0};
  size_t addr_len = strlen(address);
  if (addr_len >= sizeof(addr.sun_path)) {
    FIO_LOG_ERROR(
        "(fio_sock_open_unix) address too long (%zu bytes > %zu bytes).",
        addr_len,
        sizeof(addr.sun_path) - 1);
    errno = ENAMETOOLONG;
    return -1;
  }
  addr.sun_family = AF_UNIX;
  FIO_MEMCPY(addr.sun_path, address, addr_len + 1); /* copy the NUL byte. */
#if defined(__APPLE__)
  addr.sun_len = addr_len;
#endif
  int fd =
      socket(AF_UNIX, (flags & FIO_SOCK_UDP) ? SOCK_DGRAM : SOCK_STREAM, 0);
  if (fd == -1) {
    FIO_LOG_DEBUG("couldn't open unix socket (flags == %d) %s",
                  (int)flags,
                  strerror(errno));
    return -1;
  }
  if ((flags & FIO_SOCK_NONBLOCK) && fio_sock_set_non_block(fd) == -1) {
    FIO_LOG_DEBUG("couldn't set socket to non-blocking mode");
    fio_sock_close(fd);
    unlink(addr.sun_path);
    return -1;
  }
  if ((flags & FIO_SOCK_CLIENT)) {
    if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1 &&
        errno != EINPROGRESS) {
      FIO_LOG_DEBUG("couldn't connect unix client @ %s : %s",
                    addr.sun_path,
                    strerror(errno));
      fio_sock_close(fd);
      return -1;
    }
  } else {
    unlink(addr.sun_path);
    int btmp; // the bind result
#if !defined(FIO_SOCK_AVOID_UMASK) && !defined(FIO_OS_WIN)
    if ((flags & FIO_SOCK_UNIX_PRIVATE) == FIO_SOCK_UNIX) {
      int umask_org = umask(0x1FF);
      btmp = bind(fd, (struct sockaddr *)&addr, sizeof(addr));
      int old_err = errno;
      umask(umask_org);
      errno = old_err;
      FIO_LOG_DEBUG("umask was used temporarily for Unix Socket (was 0x%04X)",
                    umask_org);
    } else
#endif /* FIO_SOCK_AVOID_UMASK */
      /* else */ btmp = bind(fd, (struct sockaddr *)&addr, sizeof(addr));
    if (btmp == -1) {
      FIO_LOG_DEBUG("couldn't bind unix socket to %s\n\terrno(%d): %s",
                    address,
                    errno,
                    strerror(errno));
      fio_sock_close(fd);
      // unlink(addr.sun_path);
      return -1;
    }
#ifndef FIO_OS_WIN
    if ((flags & FIO_SOCK_UNIX_PRIVATE) == FIO_SOCK_UNIX) {
      chmod(address, S_IRWXO | S_IRWXG | S_IRWXU);
      fchmod(fd, S_IRWXO | S_IRWXG | S_IRWXU);
    }
#endif
    if (!(flags & FIO_SOCK_UDP) && listen(fd, SOMAXCONN) < 0) {
      FIO_LOG_DEBUG("couldn't start listening to unix socket at %s", address);
      fio_sock_close(fd);
      unlink(addr.sun_path);
      return -1;
    }
  }
  return fd;
}
#else
SFUNC int fio_sock_open_unix(const char *address, uint16_t flags) {
  (void)address, (void)flags;
  FIO_ASSERT(0, "this system does not support Unix sockets.");
}
#endif /* AF_UNIX */

/* *****************************************************************************
Peer Address
***************************************************************************** */

/**
 * Returns a human readable address representation of the socket's peer address.
 *
 * On error, returns a NULL buffer with zero length.
 *
 * Buffer lengths are limited to 63 bytes.
 *
 * This function is limited in its thread safety to 128 threads / calls.
 */
SFUNC fio_buf_info_s fio_sock_peer_addr(int s) {
  static char buffer[8129]; /* 64 byte per buffer x 128 threads */
  static unsigned pos = 0;
  fio_buf_info_s r =
      FIO_BUF_INFO2(buffer + (fio_atomic_add(&pos, 63) & 127), 0);
  struct sockaddr addr[8] = {0};
  socklen_t len = sizeof(addr);
  if (!FIO_SOCK_FD_ISVALID(s))
    goto finish;
  if (getpeername(s, addr, &len))
    goto finish;
  if (getnameinfo(addr, len, r.buf, 64, NULL, 0, NI_NUMERICHOST))
    goto finish;
  r.len = FIO_STRLEN(r.buf);
finish:
  if (!r.len)
    r.buf = NULL;
  return r;
}

/* *****************************************************************************
WinSock initialization
***************************************************************************** */
#if FIO_OS_WIN
static WSADATA fio___sock_useless_windows_data;
FIO_CONSTRUCTOR(fio___sock_win_init) {
  static uint8_t flag = 0;
  if (!flag) {
    flag |= 1;
    if (WSAStartup(MAKEWORD(2, 2), &fio___sock_useless_windows_data)) {
      FIO_LOG_FATAL("WinSock2 unavailable.");
      exit(-1);
    }
    atexit((void (*)(void))(WSACleanup));
  }
}
#endif /* FIO_OS_WIN / FIO_OS_POSIX */

/* *****************************************************************************
FIO_SOCK - cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_SOCK
#endif
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_STATE              /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                      State Callback Management API



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_STATE) && !defined(H___FIO_STATE___H) &&                       \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_STATE___H
/* *****************************************************************************
State Callback API
***************************************************************************** */

/* *****************************************************************************
Startup / State Callbacks (fork, start up, idle, etc')
***************************************************************************** */

/** a callback type enum */
typedef enum {
  /** Called once during library initialization. */
  FIO_CALL_ON_INITIALIZE,
  /** Called once before starting up the IO reactor. */
  FIO_CALL_PRE_START,
  /** Called before each time the IO reactor forks a new worker. */
  FIO_CALL_BEFORE_FORK,
  /** Called after each fork (both parent and child), before FIO_CALL_IN_XXX */
  FIO_CALL_AFTER_FORK,
  /** Called by a worker process right after forking. */
  FIO_CALL_IN_CHILD,
  /** Called by the master process after spawning a worker (after forking). */
  FIO_CALL_IN_MASTER,
  /** Called by each worker thread in a Server Async queue as it starts. */
  FIO_CALL_ON_WORKER_THREAD_START,
  /** Called every time a *Worker* process starts. */
  FIO_CALL_ON_START,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED1,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED2,
  /** User state event queue (unused, available for the user). */
  FIO_CALL_ON_USER1,
  /** User state event queue (unused, available for the user). */
  FIO_CALL_ON_USER2,
  /** Called when facil.io enters idling mode. */
  FIO_CALL_ON_IDLE,
  /** A reversed user state event queue (unused, available for the user). */
  FIO_CALL_ON_USER1_REVERSE,
  /** A reversed user state event queue (unused, available for the user). */
  FIO_CALL_ON_USER2_REVERSE,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED1_REVERSED,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED2_REVERSED,
  /** Called before starting the shutdown sequence. */
  FIO_CALL_ON_SHUTDOWN,
  /** Called by each worker the moment it detects the master process crashed. */
  FIO_CALL_ON_PARENT_CRUSH,
  /** Called by the parent (master) after a worker process crashed. */
  FIO_CALL_ON_CHILD_CRUSH,
  /** Called by each worker thread in a Server Async queue as it ends. */
  FIO_CALL_ON_WORKER_THREAD_END,
  /** Called when wither a *Worker* or *Master* stopped. */
  FIO_CALL_ON_STOP,
  /** An alternative to the system's at_exit. */
  FIO_CALL_AT_EXIT,
  /** used for testing and array allocation - must be last. */
  FIO_CALL_NEVER
} fio_state_event_type_e;

/** Adds a callback to the list of callbacks to be called for the event. */
SFUNC void fio_state_callback_add(fio_state_event_type_e,
                                  void (*func)(void *),
                                  void *arg);

/** Removes a callback from the list of callbacks to be called for the event. */
SFUNC int fio_state_callback_remove(fio_state_event_type_e,
                                    void (*func)(void *),
                                    void *arg);

/**
 * Forces all the existing callbacks to run, as if the event occurred.
 *
 * Callbacks for all initialization / idling tasks are called in order of
 * creation (where fio_state_event_type_e <= FIO_CALL_ON_IDLE).
 *
 * Callbacks for all cleanup oriented tasks are called in reverse order of
 * creation (where fio_state_event_type_e >= FIO_CALL_ON_SHUTDOWN).
 *
 * During an event, changes to the callback list are ignored (callbacks can't
 * add or remove other callbacks for the same event).
 */
SFUNC void fio_state_callback_force(fio_state_event_type_e);

/* *****************************************************************************
State Callback Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
State Callback Map - I'd use the global mapping types...
(Ordered Hash Map)   but we can't depend on types yet, possible collisions.
***************************************************************************** */

typedef struct {
  void (*func)(void *);
  void *arg;
} fio___state_task_s;

FIO_IFUNC uint64_t fio___state_callback_hash_fn(fio___state_task_s *t) {
  uint64_t hash = fio_risky_ptr((void *)(uintptr_t)(t->func));
  hash ^= hash + fio_risky_ptr(t->arg);
  return hash;
}

#define FIO_STATE_CALLBACK_IS_VALID(pobj) ((pobj)->func)
#define FIO_STATE_CALLBACK_CMP(a, b)                                           \
  ((a)->func == (b)->func && (a)->arg == (b)->arg)
FIO_TYPEDEF_IMAP_ARRAY(fio___state_map,
                       fio___state_task_s,
                       uint32_t,
                       fio___state_callback_hash_fn,
                       FIO_STATE_CALLBACK_CMP,
                       FIO_STATE_CALLBACK_IS_VALID)
#undef FIO_STATE_CALLBACK_CMP
#undef FIO_STATE_CALLBACK_IS_VALID

/* *****************************************************************************
Names.
***************************************************************************** */

static const char *FIO___STATE_TASKS_NAMES[FIO_CALL_NEVER + 1] = {
    [FIO_CALL_ON_INITIALIZE] = "ON_INITIALIZE",
    [FIO_CALL_PRE_START] = "PRE_START",
    [FIO_CALL_BEFORE_FORK] = "BEFORE_FORK",
    [FIO_CALL_AFTER_FORK] = "AFTER_FORK",
    [FIO_CALL_IN_CHILD] = "IN_CHILD",
    [FIO_CALL_IN_MASTER] = "IN_MASTER",
    [FIO_CALL_ON_WORKER_THREAD_START] = "ON_WORKER_THREAD_START",
    [FIO_CALL_ON_START] = "ON_START",
    [FIO_CALL_RESERVED1] = "RESERVED1",
    [FIO_CALL_RESERVED2] = "RESERVED2",
    [FIO_CALL_ON_USER1] = "ON_USER1",
    [FIO_CALL_ON_USER2] = "ON_USER2",
    [FIO_CALL_ON_IDLE] = "ON_IDLE",
    [FIO_CALL_ON_USER1_REVERSE] = "ON_USER1_REVERSE",
    [FIO_CALL_ON_USER2_REVERSE] = "ON_USER2_REVERSE",
    [FIO_CALL_RESERVED1_REVERSED] = "RESERVED1_REVERSED",
    [FIO_CALL_RESERVED2_REVERSED] = "RESERVED2_REVERSED",
    [FIO_CALL_ON_SHUTDOWN] = "ON_SHUTDOWN",
    [FIO_CALL_ON_PARENT_CRUSH] = "ON_PARENT_CRUSH",
    [FIO_CALL_ON_CHILD_CRUSH] = "ON_CHILD_CRUSH",
    [FIO_CALL_ON_WORKER_THREAD_END] = "ON_WORKER_THREAD_END",
    [FIO_CALL_ON_STOP] = "ON_STOP",
    [FIO_CALL_AT_EXIT] = "AT_EXIT",
    [FIO_CALL_NEVER] = "NEVER",
};

/* *****************************************************************************
State Callback Global State and Locks
***************************************************************************** */
/* use `weak` instead of `static` to make sure state callbacks are global. */
FIO_WEAK fio___state_map_s FIO___STATE_TASKS_ARRAY[FIO_CALL_NEVER + 1];
FIO_WEAK fio_lock_i FIO___STATE_TASKS_ARRAY_LOCK[FIO_CALL_NEVER + 1];

FIO_IFUNC void fio_state_callback_clear_all(void) {
  for (size_t i = 0; i < FIO_CALL_NEVER; ++i) {
    fio___state_map_destroy(FIO___STATE_TASKS_ARRAY + i);
  }
  FIO_LOG_DEBUG2("(%d) fio_state_callback maps have been cleared.",
                 fio_getpid());
}

/** Adds a callback to the list of callbacks to be called for the event. */
SFUNC void fio_state_callback_add(fio_state_event_type_e e,
                                  void (*func)(void *),
                                  void *arg) {
  if ((uintptr_t)e >= FIO_CALL_NEVER)
    return;
  fio___state_task_s t = {.func = func, .arg = arg};
  fio_lock(FIO___STATE_TASKS_ARRAY_LOCK + (uintptr_t)e);
  fio___state_map_set(FIO___STATE_TASKS_ARRAY + (uintptr_t)e, t, 0);
  fio_unlock(FIO___STATE_TASKS_ARRAY_LOCK + (uintptr_t)e);
  if (e == FIO_CALL_ON_INITIALIZE &&
      FIO___STATE_TASKS_ARRAY_LOCK[FIO_CALL_NEVER]) {
    /* initialization tasks already performed, perform this without delay */
    func(arg);
  }
}

/** Removes a callback from the list of callbacks to be called for the event. */
SFUNC int fio_state_callback_remove(fio_state_event_type_e e,
                                    void (*func)(void *),
                                    void *arg) {
  if ((uintptr_t)e >= FIO_CALL_NEVER)
    return -1;
  int ret;
  fio___state_task_s t = {.func = func, .arg = arg};
  fio_lock(FIO___STATE_TASKS_ARRAY_LOCK + (uintptr_t)e);
  ret = fio___state_map_remove(FIO___STATE_TASKS_ARRAY + (uintptr_t)e, t);
  fio_unlock(FIO___STATE_TASKS_ARRAY_LOCK + (uintptr_t)e);
  return ret;
}

/** Clears all the existing callbacks for the event. */
SFUNC void fio_state_callback_clear(fio_state_event_type_e e) {
  if ((uintptr_t)e >= FIO_CALL_NEVER)
    return;
  fio_lock(FIO___STATE_TASKS_ARRAY_LOCK + (uintptr_t)e);
  fio___state_map_destroy(FIO___STATE_TASKS_ARRAY + (uintptr_t)e);
  fio_unlock(FIO___STATE_TASKS_ARRAY_LOCK + (uintptr_t)e);
}

FIO_SFUNC void fio_state_callback_force___task(void *fn_p, void *arg) {
  union {
    void *p;
    void (*fn)(void *);
  } u = {.p = fn_p};
  u.fn(arg);
}
/**
 * Forces all the existing callbacks to run, as if the event occurred.
 *
 * Callbacks are called from last to first (last callback executes first).
 *
 * During an event, changes to the callback list are ignored (callbacks can't
 * remove other callbacks for the same event).
 */
SFUNC void fio_state_callback_force(fio_state_event_type_e e) {
  /** a type-to-string map for callback types */

  if ((uintptr_t)e >= FIO_CALL_NEVER)
    return;
  if (e == FIO_CALL_AFTER_FORK) {
    /* make sure the `after_fork` events re-initializes all locks. */
    for (size_t i = 0; i < FIO_CALL_NEVER; ++i) {
      FIO___STATE_TASKS_ARRAY_LOCK[i] = FIO_LOCK_INIT;
    }
  }
  if (e == FIO_CALL_IN_CHILD)
    fio_rand_reseed(); /* re-seed random state in child processes */
  fio___state_task_s *ary = NULL;
  size_t ary_capa = (sizeof(*ary) * FIO___STATE_TASKS_ARRAY[e].count);
  size_t len = 0;
  if (e == FIO_CALL_ON_INITIALIZE) {
    fio_trylock(FIO___STATE_TASKS_ARRAY_LOCK + FIO_CALL_NEVER);
  }

  FIO_LOG_DEBUG2("(%d) scheduling %s callbacks (%zu tasks).",
                 (int)(fio_getpid()),
                 FIO___STATE_TASKS_NAMES[e],
                 (size_t)FIO___STATE_TASKS_ARRAY[e].count);
  if (!FIO___STATE_TASKS_ARRAY[e].count)
    return;
  /* copy task queue */
  fio_lock(FIO___STATE_TASKS_ARRAY_LOCK + (uintptr_t)e);
  if (FIO___STATE_TASKS_ARRAY[e].w) {
    ary = (fio___state_task_s *)FIO_MEM_REALLOC(NULL, 0, ary_capa, 0);
    FIO_ASSERT_ALLOC(ary);
    for (size_t i = 0; i < FIO___STATE_TASKS_ARRAY[e].w; ++i) {
      if (!FIO___STATE_TASKS_ARRAY[e].ary[i].func)
        continue;
      ary[len++] = FIO___STATE_TASKS_ARRAY[e].ary[i];
    }
  }
  fio_unlock(FIO___STATE_TASKS_ARRAY_LOCK + (uintptr_t)e);

  /* perform copied tasks in correct order */
  if (e <= FIO_CALL_ON_IDLE) {
    /* perform tasks in order */
    for (size_t i = 0; i < len; ++i)
      ary[i].func(ary[i].arg);
  } else {
    /* perform tasks in reverse */
    while (len--)
      ary[len].func(ary[len].arg);
  }
  /* cleanup */
  FIO_MEM_FREE(ary, ary_capa);

  (void)FIO___STATE_TASKS_NAMES; /* if unused */
}

/* *****************************************************************************
Debug Helpers
***************************************************************************** */

FIO_IFUNC void fio_state_callback_print_state(void) {
  FIO_LOG2STDERR("DEBUG:    fio_state_callback maps state:");
  for (size_t i = 0; i < FIO_CALL_NEVER; ++i) {
    fprintf(stderr,
            "\t%-32s %-4zu out of %-4zu\n",
            FIO___STATE_TASKS_NAMES[i],
            (size_t)FIO___STATE_TASKS_ARRAY[i].count,
            fio___state_map_capa(FIO___STATE_TASKS_ARRAY + i));
  }
}

/* *****************************************************************************
State constructor / destructor
***************************************************************************** */

FIO_SFUNC void fio___state_cleanup_task_at_exit(void *ignr_) {
  fio_state_callback_clear_all();
  (void)ignr_;
}

FIO_CONSTRUCTOR(fio___state_constructor) {
  FIO_LOG_DEBUG2("fio_state_callback maps are now active.");
  fio_state_callback_force(FIO_CALL_ON_INITIALIZE);
  fio_state_callback_add(FIO_CALL_AT_EXIT,
                         fio___state_cleanup_task_at_exit,
                         NULL);
}

FIO_DESTRUCTOR(fio___state_at_exit_hook) {
  fio_state_callback_force(FIO_CALL_AT_EXIT);
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_STATE
#endif /* FIO_STATE */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_TIME               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                  Time Helpers



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_TIME) && !defined(H___FIO_TIME___H)
#define H___FIO_TIME___H

/* *****************************************************************************
Collecting Monotonic / Real Time
***************************************************************************** */

/** Returns human (watch) time... this value isn't as safe for measurements. */
FIO_IFUNC struct timespec fio_time_real(void);

/** Returns monotonic time. */
FIO_IFUNC struct timespec fio_time_mono(void);

/** Returns monotonic time in nano-seconds (now in 1 billionth of a second). */
FIO_IFUNC int64_t fio_time_nano(void);

/** Returns monotonic time in micro-seconds (now in 1 millionth of a second). */
FIO_IFUNC int64_t fio_time_micro(void);

/** Returns monotonic time in milliseconds. */
FIO_IFUNC int64_t fio_time_milli(void);

/** Converts a `struct timespec` to milliseconds. */
FIO_IFUNC int64_t fio_time2milli(struct timespec);

/** Converts a `struct timespec` to microseconds. */
FIO_IFUNC int64_t fio_time2micro(struct timespec);

/**
 * A faster (yet less localized) alternative to `gmtime_r`.
 *
 * See the libc `gmtime_r` documentation for details.
 *
 * Falls back to `gmtime_r` for dates before epoch.
 */
SFUNC struct tm fio_time2gm(time_t time);

/** Converts a `struct tm` to time in seconds (assuming UTC). */
SFUNC time_t fio_gm2time(struct tm tm);

/**
 * Writes an RFC 7231 date representation (HTTP date format) to target.
 *
 * Usually requires 29 characters, although this may vary.
 */
SFUNC size_t fio_time2rfc7231(char *target, time_t time);

/**
 * Writes an RFC 2109 date representation to target (HTTP Cookie Format).
 *
 * Usually requires 31 characters, although this may vary.
 */
SFUNC size_t fio_time2rfc2109(char *target, time_t time);

/**
 * Writes an RFC 2822 date representation to target (Internet Message Format).
 *
 * Usually requires 28 to 29 characters, although this may vary.
 */
SFUNC size_t fio_time2rfc2822(char *target, time_t time);

/**
 * Writes a date representation to target in common log format. i.e.,
 *
 *         [DD/MMM/yyyy:hh:mm:ss +0000]
 *
 * Usually requires 29 characters (including square brackets and NUL).
 */
SFUNC size_t fio_time2log(char *target, time_t time);

/**
 * Writes a date representation to target in ISO 8601 format. i.e.,
 *
 *         YYYY-MM-DD HH:MM:SS
 *
 * Usually requires 20 characters (including NUL).
 */
SFUNC size_t fio_time2iso(char *target, time_t time);

/** Adds two `struct timespec` objects. */
FIO_IFUNC struct timespec fio_time_add(struct timespec t, struct timespec t2);

/** Adds milliseconds to a `struct timespec` object. */
FIO_IFUNC struct timespec fio_time_add_milli(struct timespec t, int64_t milli);

/** Compares two `struct timespec` objects. */
FIO_IFUNC int fio_time_cmp(struct timespec t1, struct timespec t2);

/* *****************************************************************************
Time Inline Helpers
***************************************************************************** */

/** Returns human (watch) time... this value isn't as safe for measurements. */
FIO_IFUNC struct timespec fio_time_real(void) {
  struct timespec t;
  clock_gettime(CLOCK_REALTIME, &t);
  return t;
}

/** Returns monotonic time. */
FIO_IFUNC struct timespec fio_time_mono(void) {
  struct timespec t;
  clock_gettime(CLOCK_MONOTONIC, &t);
  return t;
}

/** Returns monotonic time in nano-seconds (now in 1 micro of a second). */
FIO_IFUNC int64_t fio_time_nano(void) {
  struct timespec t = fio_time_mono();
  return ((int64_t)t.tv_sec * 1000000000) + (int64_t)t.tv_nsec;
}

/** Returns monotonic time in micro-seconds (now in 1 millionth of a second). */
FIO_IFUNC int64_t fio_time_micro(void) {
  struct timespec t = fio_time_mono();
  return ((int64_t)t.tv_sec * 1000000) + (int64_t)t.tv_nsec / 1000;
}

/** Returns monotonic time in milliseconds. */
FIO_IFUNC int64_t fio_time_milli(void) {
  return fio_time2milli(fio_time_mono());
}

/** Converts a `struct timespec` to milliseconds. */
FIO_IFUNC int64_t fio_time2milli(struct timespec t) {
  return ((int64_t)t.tv_sec * 1000) + (int64_t)t.tv_nsec / 1000000;
}

/** Converts a `struct timespec` to microseconds. */
FIO_IFUNC int64_t fio_time2micro(struct timespec t) {
  return ((int64_t)t.tv_sec * 1000000) + (int64_t)t.tv_nsec / 1000;
}

/* Normalizes a timespec struct after an `add` or `sub` operation. */
FIO_IFUNC void fio_time___normalize(struct timespec *t) {
  const long ns_norm[2] = {0, 1000000000LL};
  t->tv_nsec += ns_norm[(t->tv_nsec < 0)];
  t->tv_sec += (t->tv_nsec < 0);
  t->tv_nsec -= ns_norm[(1000000000LL < t->tv_nsec)];
  t->tv_sec += (1000000000LL < t->tv_nsec);
}

/** Adds to timespec. */
FIO_IFUNC struct timespec fio_time_add(struct timespec t, struct timespec t2) {
  t.tv_sec += t2.tv_sec;
  t.tv_nsec += t2.tv_nsec;
  fio_time___normalize(&t);
  return t;
}

/** Adds milliseconds to timespec. */
FIO_IFUNC struct timespec fio_time_add_milli(struct timespec t, int64_t milli) {
  t.tv_sec += milli >> 10; /* 1024 is close enough, will be normalized */
  t.tv_nsec += (milli & 1023) * 1000000;
  fio_time___normalize(&t);
  return t;
}

/** Compares two timespecs. */
FIO_IFUNC int fio_time_cmp(struct timespec t1, struct timespec t2) {
  size_t a = (t2.tv_sec < t1.tv_sec) << 1;
  a |= (t2.tv_nsec < t1.tv_nsec);
  size_t b = (t1.tv_sec < t2.tv_sec) << 1;
  b |= (t1.tv_nsec < t2.tv_nsec);
  return (0 - (a < b)) + (b < a);
}

/* *****************************************************************************
Time Implementation
***************************************************************************** */
#if !defined(FIO_EXTERN) || defined(FIO_EXTERN_COMPLETE)

/**
 * A faster (yet less localized) alternative to `gmtime_r`.
 *
 * See the libc `gmtime_r` documentation for details.
 *
 * Falls back to `gmtime_r` for dates before epoch.
 */
SFUNC struct tm fio_time2gm(time_t timer) {
  struct tm tm;
  ssize_t a, b;
#if (defined(HAVE_TM_TM_ZONE) && HAVE_TM_TM_ZONE) || defined(BSD)
  tm = (struct tm){
      .tm_isdst = 0,
      .tm_zone = (char *)"UTC",
  };
#else
  tm = (struct tm){
      .tm_isdst = 0,
  };
#endif

  // convert seconds from epoch to days from epoch + extract data
  if (timer >= 0) {
    // for seconds up to weekdays, we reduce the reminder every step.
    a = (ssize_t)timer;
    b = a / 60; // b == time in minutes
    tm.tm_sec = (int)(a - (b * 60));
    a = b / 60; // b == time in hours
    tm.tm_min = (int)(b - (a * 60));
    b = a / 24; // b == time in days since epoch
    tm.tm_hour = (int)(a - (b * 24));
    // b == number of days since epoch
    // day of epoch was a thursday. Add + 4 so sunday == 0...
    tm.tm_wday = (b + 4) % 7;
  } else {
    // for seconds up to weekdays, we reduce the reminder every step.
    a = (ssize_t)timer;
    b = a / 60; // b == time in minutes
    if (b * 60 != a) {
      /* seconds passed */
      tm.tm_sec = (int)((a - (b * 60)) + 60);
      --b;
    } else {
      /* no seconds */
      tm.tm_sec = 0;
    }
    a = b / 60; // b == time in hours
    if (a * 60 != b) {
      /* minutes passed */
      tm.tm_min = (int)((b - (a * 60)) + 60);
      --a;
    } else {
      /* no minutes */
      tm.tm_min = 0;
    }
    b = a / 24; // b == time in days since epoch?
    if (b * 24 != a) {
      /* hours passed */
      tm.tm_hour = (int)((a - (b * 24)) + 24);
      --b;
    } else {
      /* no hours */
      tm.tm_hour = 0;
    }
    // day of epoch was a thursday. Add + 4 so sunday == 0...
    tm.tm_wday = ((b - 3) % 7);
    if (tm.tm_wday)
      tm.tm_wday += 7;
    /* b == days from epoch */
  }

  // at this point we can apply the algorithm described here:
  // http://howardhinnant.github.io/date_algorithms.html#civil_from_days
  // Credit to Howard Hinnant.
  {
    b += 719468L; // adjust to March 1st, 2000 (post leap of 400 year era)
    // 146,097 = days in era (400 years)
    const size_t era = (b >= 0 ? b : b - 146096) / 146097;
    const uint32_t doe = (uint32_t)(b - (era * 146097)); // day of era
    const uint16_t yoe =
        (uint16_t)((doe - doe / 1460 + doe / 36524 - doe / 146096) /
                   365); // year of era
    a = yoe;
    a += era * 400; // a == year number, assuming year starts on March 1st...
    const uint16_t doy = (uint16_t)(doe - (365 * yoe + yoe / 4 - yoe / 100));
    const uint16_t mp = (uint16_t)((5U * doy + 2) / 153);
    const uint16_t d = (uint16_t)(doy - (153U * mp + 2) / 5 + 1);
    const uint8_t m = (uint8_t)(mp + (mp < 10 ? 2 : -10));
    a += (m <= 1);
    tm.tm_year = (int)(a - 1900); // tm_year == years since 1900
    tm.tm_mon = m;
    tm.tm_mday = d;
    const uint8_t is_leap = (a % 4 == 0 && (a % 100 != 0 || a % 400 == 0));
    tm.tm_yday = (doy + (is_leap) + 28 + 31) % (365 + is_leap);
  }

  return tm;
}

/** Converts a `struct tm` to time in seconds (assuming UTC). */
SFUNC time_t fio_gm2time(struct tm tm) {
  int64_t time = 0;
  // we start with the algorithm described here:
  // http://howardhinnant.github.io/date_algorithms.html#days_from_civil
  // Credit to Howard Hinnant.
  {
    const int32_t y = (tm.tm_year + 1900) - (tm.tm_mon < 2);
    const int32_t era = (y >= 0 ? y : y - 399) / 400;
    const uint16_t yoe = (y - era * 400L); // 0-399
    const uint32_t doy =
        (153L * (tm.tm_mon + (tm.tm_mon > 1 ? -2 : 10)) + 2) / 5 + tm.tm_mday -
        1;                                                       // 0-365
    const uint32_t doe = yoe * 365L + yoe / 4 - yoe / 100 + doy; // 0-146096
    time = era * 146097LL + doe - 719468LL; // time == days from epoch
  }

  /* Adjust for hour, minute and second */
  time = time * 24LL + tm.tm_hour;
  time = time * 60LL + tm.tm_min;
  time = time * 60LL + tm.tm_sec;

  if (tm.tm_isdst > 0) {
    time -= 60 * 60;
  }
#if (defined(HAVE_TM_TM_ZONE) && HAVE_TM_TM_ZONE) || defined(BSD)
  if (tm.tm_gmtoff) {
    time += tm.tm_gmtoff;
  }
#endif
  return (time_t)time;
}

FIO_SFUNC char *fio_time_write_day(char *dest, const struct tm *tm) {
  static const char *FIO___DAY_NAMES[] =
      {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
  dest[0] = FIO___DAY_NAMES[tm->tm_wday][0];
  dest[1] = FIO___DAY_NAMES[tm->tm_wday][1];
  dest[2] = FIO___DAY_NAMES[tm->tm_wday][2];
  return dest + 3;
}

FIO_SFUNC char *fio_time_write_month(char *dest, const struct tm *tm) {
  // clang-format off
  static const char *FIO___MONTH_NAMES[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
  // clang-format on
  dest[0] = FIO___MONTH_NAMES[tm->tm_mon][0];
  dest[1] = FIO___MONTH_NAMES[tm->tm_mon][1];
  dest[2] = FIO___MONTH_NAMES[tm->tm_mon][2];
  return dest + 3;
}

FIO_SFUNC char *fio_time_write_year(char *dest, const struct tm *tm) {
  int64_t year = tm->tm_year + 1900;
  const size_t digits = fio_digits10(year);
  fio_ltoa10(dest, year, digits);
  return dest + digits;
}

/** Writes an RFC 7231 date representation (HTTP date format) to target. */
SFUNC size_t fio_time2rfc7231(char *target, time_t time) {
  const struct tm tm = fio_time2gm(time);
  /* note: day of month is always 2 digits */
  char *pos = target;
  uint16_t tmp;
  pos = fio_time_write_day(pos, &tm);
  *pos++ = ',';
  *pos++ = ' ';
  tmp = tm.tm_mday / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_mday - (tmp * 10));
  *pos++ = ' ';
  pos = fio_time_write_month(pos, &tm);
  *pos++ = ' ';
  pos = fio_time_write_year(pos, &tm);
  *pos++ = ' ';
  tmp = tm.tm_hour / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_hour - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_min / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_min - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_sec / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_sec - (tmp * 10));
  *pos++ = ' ';
  *pos++ = 'G';
  *pos++ = 'M';
  *pos++ = 'T';
  *pos = 0;
  return pos - target;
}
/** Writes an RFC 2109 date representation to target. */
SFUNC size_t fio_time2rfc2109(char *target, time_t time) {
  const struct tm tm = fio_time2gm(time);
  /* note: day of month is always 2 digits */
  char *pos = target;
  uint16_t tmp;
  pos = fio_time_write_day(pos, &tm);
  *pos++ = ',';
  *pos++ = ' ';
  tmp = tm.tm_mday / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_mday - (tmp * 10));
  *pos++ = ' ';
  pos = fio_time_write_month(pos, &tm);
  *pos++ = ' ';
  pos = fio_time_write_year(pos, &tm);
  *pos++ = ' ';
  tmp = tm.tm_hour / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_hour - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_min / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_min - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_sec / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_sec - (tmp * 10));
  *pos++ = ' ';
  *pos++ = '-';
  *pos++ = '0';
  *pos++ = '0';
  *pos++ = '0';
  *pos++ = '0';
  *pos = 0;
  return pos - target;
}

/** Writes an RFC 2822 date representation to target. */
SFUNC size_t fio_time2rfc2822(char *target, time_t time) {
  const struct tm tm = fio_time2gm(time);
  /* note: day of month is either 1 or 2 digits */
  char *pos = target;
  uint16_t tmp;
  pos = fio_time_write_day(pos, &tm);
  *pos++ = ',';
  *pos++ = ' ';
  if (tm.tm_mday < 10) {
    *pos++ = '0' + (uint8_t)tm.tm_mday;
  } else {
    tmp = tm.tm_mday / 10;
    *pos++ = '0' + (uint8_t)tmp;
    *pos++ = '0' + (uint8_t)(tm.tm_mday - (tmp * 10));
  }
  *pos++ = '-';
  pos = fio_time_write_month(pos, &tm);
  *pos++ = '-';
  pos = fio_time_write_year(pos, &tm);
  *pos++ = ' ';
  tmp = tm.tm_hour / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_hour - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_min / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_min - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_sec / 10;
  *pos++ = '0' + (uint8_t)tmp;
  *pos++ = '0' + (uint8_t)(tm.tm_sec - (tmp * 10));
  *pos++ = ' ';
  *pos++ = 'G';
  *pos++ = 'M';
  *pos++ = 'T';
  *pos = 0;
  return pos - target;
}

/**
 * Writes a date representation to target in common log format. i.e.,
 *
 *         [DD/MMM/yyyy:hh:mm:ss +0000]
 *
 * Usually requires 29 characters (including square brackets and NUL).
 */
SFUNC size_t fio_time2log(char *target, time_t time) {
  {
    const struct tm tm = fio_time2gm(time);
    /* note: day of month is either 1 or 2 digits */
    char *pos = target;
    uint16_t tmp;
    *pos++ = '[';
    tmp = tm.tm_mday / 10;
    *pos++ = '0' + (uint8_t)tmp;
    *pos++ = '0' + (uint8_t)(tm.tm_mday - (tmp * 10));
    *pos++ = '/';
    pos = fio_time_write_month(pos, &tm);
    *pos++ = '/';
    pos = fio_time_write_year(pos, &tm);
    *pos++ = ':';
    tmp = tm.tm_hour / 10;
    *pos++ = '0' + (uint8_t)tmp;
    *pos++ = '0' + (uint8_t)(tm.tm_hour - (tmp * 10));
    *pos++ = ':';
    tmp = tm.tm_min / 10;
    *pos++ = '0' + (uint8_t)tmp;
    *pos++ = '0' + (uint8_t)(tm.tm_min - (tmp * 10));
    *pos++ = ':';
    tmp = tm.tm_sec / 10;
    *pos++ = '0' + (uint8_t)tmp;
    *pos++ = '0' + (uint8_t)(tm.tm_sec - (tmp * 10));
    *pos++ = ' ';
    *pos++ = '+';
    *pos++ = '0';
    *pos++ = '0';
    *pos++ = '0';
    *pos++ = '0';
    *pos++ = ']';
    *(pos) = 0;
    return pos - target;
  }
}

/**
 * Writes a date representation to target in ISO 8601 format. i.e.,
 *
 *         YYYY-MM-DD HH:MM:SS
 *
 * Usually requires 20 characters (including NUL).
 */
SFUNC size_t fio_time2iso(char *target, time_t time) {
  {
    const struct tm tm = fio_time2gm(time);
    /* note: day of month is either 1 or 2 digits */
    char *pos = target;
    uint16_t tmp;
    pos = fio_time_write_year(pos, &tm);
    *pos++ = '-';
    pos = fio_time_write_month(pos, &tm);
    *pos++ = '-';
    tmp = tm.tm_mday / 10;
    *pos++ = '0' + tmp;
    *pos++ = '0' + (tm.tm_mday - (tmp * 10));
    *pos++ = ' ';
    tmp = tm.tm_hour / 10;
    *pos++ = '0' + tmp;
    *pos++ = '0' + (tm.tm_hour - (tmp * 10));
    *pos++ = ':';
    tmp = tm.tm_min / 10;
    *pos++ = '0' + tmp;
    *pos++ = '0' + (tm.tm_min - (tmp * 10));
    *pos++ = ':';
    tmp = tm.tm_sec / 10;
    *pos++ = '0' + tmp;
    *pos++ = '0' + (tm.tm_sec - (tmp * 10));
    *(pos) = 0;
    return pos - target;
  }
}
/* *****************************************************************************
Time Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_TIME
#endif /* FIO_TIME */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_URL_ENCODED        /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                          URL-Encoded Parser Module




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_URL_ENCODED) && !defined(H___FIO_URL_ENCODED___H)
#define H___FIO_URL_ENCODED___H

/* *****************************************************************************
URL-Encoded Parser - Overview

This is a non-allocating, callback-based URL-encoded (application/x-www-form-
urlencoded) parser.

The parser finds boundaries between name=value pairs without decoding the data.
Decoding is the caller's responsibility (use `fio_string_write_url_dec`).

URL-encoded format:
- Pairs separated by `&`
- Name and value separated by `=`
- Special characters are percent-encoded (%XX)

Usage:
    static void *my_on_pair(void *udata, fio_buf_info_s name, fio_buf_info_s
value) {
        // Process name=value pair
        // name and value point directly into the original data
        return udata;
    }

    static const fio_url_encoded_parser_callbacks_s callbacks = {
        .on_pair = my_on_pair,
    };

    fio_url_encoded_result_s result = fio_url_encoded_parse(&callbacks,
                                                            my_context,
                                                            data,
                                                            len);
    if (result.err) { handle_error(); }
    // result.consumed indicates bytes consumed
    // result.count indicates number of pairs found

***************************************************************************** */

/* *****************************************************************************
URL-Encoded Parser Types
***************************************************************************** */

/**
 * The URL-encoded parser callbacks.
 *
 * Callbacks receive `udata` as their first argument.
 */
typedef struct {
  /**
   * Called for each name=value pair found.
   *
   * `name` and `value` point directly into the original input data.
   * The data is NOT decoded - caller must decode if needed.
   *
   * Returns the (possibly updated) udata, or NULL to stop parsing.
   */
  void *(*on_pair)(void *udata, fio_buf_info_s name, fio_buf_info_s value);

  /**
   * Called on parsing error (optional).
   *
   * Currently not used since URL-encoded parsing is very permissive,
   * but reserved for future use.
   */
  void (*on_error)(void *udata);

} fio_url_encoded_parser_callbacks_s;

/** The URL-encoded parse result type. */
typedef struct {
  /** Number of bytes consumed from the buffer. */
  size_t consumed;
  /** Number of name=value pairs found. */
  size_t count;
  /** Non-zero if an error occurred (callback returned NULL). */
  int err;
} fio_url_encoded_result_s;

/* *****************************************************************************
URL-Encoded Parser API
***************************************************************************** */

/**
 * Parse URL-encoded data from buffer.
 *
 * `callbacks` contains the callback functions (should be static const).
 * `udata` is user data passed to callbacks.
 * `data` is the URL-encoded data to parse.
 * `len` is the length of the data.
 *
 * Returns a result struct containing:
 * - `consumed`: Number of bytes consumed from the buffer
 * - `count`: Number of name=value pairs found
 * - `err`: Non-zero if parsing was stopped (callback returned NULL)
 *
 * Parsing rules:
 * - Pairs are separated by `&`
 * - Name and value are separated by `=`
 * - Empty value is valid: `name=`  value.len = 0
 * - Missing `=` means value is empty: `name`  name="name", value.len = 0
 * - Empty name with value: `=value`  name.len = 0, value="value"
 * - Empty pairs (`&&`) are skipped
 *
 * Note: The parser does NOT decode percent-encoded characters.
 * Use `fio_string_write_url_dec` to decode if needed.
 */
SFUNC fio_url_encoded_result_s
fio_url_encoded_parse(const fio_url_encoded_parser_callbacks_s *callbacks,
                      void *udata,
                      const char *data,
                      size_t len);

/* *****************************************************************************
URL-Encoded Parser Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Internal Helper: No-op callbacks
***************************************************************************** */

FIO_IFUNC void *fio___url_encoded_noop_on_pair(void *udata,
                                               fio_buf_info_s name,
                                               fio_buf_info_s value) {
  /* Return non-NULL sentinel to continue parsing even if udata is NULL */
  return udata ? udata : (void *)(uintptr_t)1;
  (void)name;
  (void)value;
}

FIO_IFUNC void fio___url_encoded_noop_on_error(void *udata) { (void)udata; }

/* *****************************************************************************
Internal: Validated callbacks wrapper
***************************************************************************** */

typedef struct {
  void *(*on_pair)(void *udata, fio_buf_info_s name, fio_buf_info_s value);
  void (*on_error)(void *udata);
} fio___url_encoded_cb_s;

FIO_SFUNC fio___url_encoded_cb_s fio___url_encoded_callbacks_validate(
    const fio_url_encoded_parser_callbacks_s *cb) {
  fio___url_encoded_cb_s r;
  static const fio_url_encoded_parser_callbacks_s empty_cb = {0};
  if (!cb)
    cb = &empty_cb;
  r.on_pair = cb->on_pair ? cb->on_pair : fio___url_encoded_noop_on_pair;
  r.on_error = cb->on_error ? cb->on_error : fio___url_encoded_noop_on_error;
  return r;
}

/* *****************************************************************************
URL-Encoded Main Parse Function
***************************************************************************** */

SFUNC fio_url_encoded_result_s
fio_url_encoded_parse(const fio_url_encoded_parser_callbacks_s *callbacks,
                      void *udata,
                      const char *data,
                      size_t len) {
  fio_url_encoded_result_s result = {.consumed = 0, .count = 0, .err = 0};
  const char *pos = data;
  const char *end = data + len;

  fio___url_encoded_cb_s cb = fio___url_encoded_callbacks_validate(callbacks);

  while (pos < end) {
    /* Find the end of this pair (next '&' or end of data) */
    const char *pair_end = pos;
    while (pair_end < end && *pair_end != '&')
      ++pair_end;

    /* Skip empty pairs (e.g., "&&" or leading "&") */
    if (pair_end == pos) {
      ++pos;
      continue;
    }

    /* Find the '=' separator within this pair */
    const char *eq = pos;
    while (eq < pair_end && *eq != '=')
      ++eq;

    fio_buf_info_s name;
    fio_buf_info_s value;

    if (eq < pair_end) {
      /* Found '=' - split into name and value */
      name.buf = (char *)pos;
      name.len = (size_t)(eq - pos);
      value.buf = (char *)(eq + 1);
      value.len = (size_t)(pair_end - (eq + 1));
    } else {
      /* No '=' found - entire segment is the name, value is empty */
      name.buf = (char *)pos;
      name.len = (size_t)(pair_end - pos);
      value.buf = (char *)pair_end; /* Points to end, len = 0 */
      value.len = 0;
    }

    /* Call the callback */
    udata = cb.on_pair(udata, name, value);
    ++result.count;

    /* Check if callback wants to stop parsing */
    if (!udata) {
      result.err = 1;
      result.consumed = (size_t)(pair_end - data);
      return result;
    }

    /* Move past this pair */
    pos = pair_end;
    if (pos < end && *pos == '&')
      ++pos;
  }

  result.consumed = (size_t)(pos - data);
  return result;
}

/* *****************************************************************************
URL-Encoded Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_URL_ENCODED
#endif /* FIO_URL_ENCODED */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_CLI                /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                  CLI helpers - command line interface parsing


Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_CLI) && !defined(H___FIO_CLI___H) &&                           \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_CLI___H 1

/* *****************************************************************************
Internal Macro Implementation
***************************************************************************** */

/** Used internally. */
typedef enum {
  /** A String CLI argument */
  FIO_CLI_ARG_STRING,
  /** A Boolean CLI argument */
  FIO_CLI_ARG_BOOL,
  /** An integer CLI argument */
  FIO_CLI_ARG_INT,
  FIO_CLI_ARG_PRINT,
  FIO_CLI_ARG_PRINT_LINE,
  FIO_CLI_ARG_PRINT_HEADER,
} fio_cli_arg_e;

#define FIO_CLI_ARG_NONE FIO_CLI_ARG_PRINT_HEADER

typedef struct {
  fio_cli_arg_e t;
  const char *l;
} fio___cli_line_s;

/** Indicates the CLI argument should be a String (default). */
#define FIO_CLI_STRING(line)                                                   \
  ((fio___cli_line_s){.t = FIO_CLI_ARG_STRING, .l = line})
/** Indicates the CLI argument is a Boolean value. */
#define FIO_CLI_BOOL(line)                                                     \
  ((fio___cli_line_s){.t = FIO_CLI_ARG_BOOL, .l = line})
/** Indicates the CLI argument should be an Integer (numerical). */
#define FIO_CLI_INT(line) ((fio___cli_line_s){.t = FIO_CLI_ARG_INT, .l = line})
/** Indicates the CLI string should be printed as is with proper offset. */
#define FIO_CLI_PRINT(line)                                                    \
  ((fio___cli_line_s){.t = FIO_CLI_ARG_PRINT, .l = line})
/** Indicates the CLI string should be printed as is with no offset. */
#define FIO_CLI_PRINT_LINE(line)                                               \
  ((fio___cli_line_s){.t = FIO_CLI_ARG_PRINT_LINE, .l = line})
/** Indicates the CLI string should be printed as a header. */
#define FIO_CLI_PRINT_HEADER(line)                                             \
  ((fio___cli_line_s){.t = FIO_CLI_ARG_PRINT_HEADER, .l = line})

/* *****************************************************************************
CLI API
***************************************************************************** */

/**
 * This function parses the Command Line Interface (CLI), creating a temporary
 * "dictionary" that allows easy access to the CLI using their names or aliases.
 *
 * Command line arguments may be typed. If an optional type requirement is
 * provided and the provided arument fails to match the required type, execution
 * will end and an error message will be printed along with a short "help".
 *
 * The function / macro accepts the following arguments:
 * - `argc`: command line argument count.
 * - `argv`: command line argument list (array).
 * - `unnamed_min`: the required minimum of un-named arguments.
 * - `unnamed_max`: the maximum limit of un-named arguments.
 * - `description`: a C string containing the program's description.
 * - named arguments list: a list of C strings describing named arguments.
 *
 * The following optional type requirements are:
 *
 * * FIO_CLI_STRING(desc_line)       - (default) string argument.
 * * FIO_CLI_BOOL(desc_line)         - boolean argument (no value).
 * * FIO_CLI_INT(desc_line)          - integer argument.
 * * FIO_CLI_PRINT_HEADER(desc_line) - extra header for output.
 * * FIO_CLI_PRINT(desc_line)        - extra information for output.
 *
 * Argument names MUST start with the '-' character. The first word starting
 * without the '-' character will begin the description for the CLI argument.
 *
 * The arguments "-?", "-h", "-help" and "--help" are automatically handled
 * unless overridden.
 *
 * Un-named arguments shouldn't be listed in the named arguments list.
 *
 * Example use:
 *
 *    fio_cli_start(argc, argv, 0, 0, "The NAME example accepts the following:",
 *                        FIO_CLI_PRINT_HREADER("Concurrency:"),
 *                        FIO_CLI_INT("-t -thread number of threads to run."),
 *                        FIO_CLI_INT("-w -workers number of workers to run."),
 *                        FIO_CLI_PRINT_HREADER("Address Binding:"),
 *                        "-b, -address the address to bind to.",
 *                        FIO_CLI_INT("-p,-port the port to bind to."),
 *                        FIO_CLI_PRINT("\t\tset port to zero (0) for Unix s."),
 *                        FIO_CLI_PRINT_HREADER("Logging:"),
 *                        FIO_CLI_BOOL("-v -log enable logging.")
 *                  );
 *
 *
 * This would allow access to the named arguments:
 *
 *      fio_cli_get("-b") == fio_cli_get("-address");
 *
 *
 * Once all the data was accessed, free the parsed data dictionary using:
 *
 *      fio_cli_end();
 *
 * It should be noted, arguments will be recognized in a number of forms, i.e.:
 *
 *      app -t=1 -p3000 -a localhost
 *
 * This function is NOT thread safe.
 */
#define fio_cli_start(argc, argv, unnamed_min, unnamed_max, description, ...)  \
  fio_cli_start((argc),                                                        \
                (argv),                                                        \
                (unnamed_min),                                                 \
                (unnamed_max),                                                 \
                (description),                                                 \
                (fio___cli_line_s[]){__VA_ARGS__, {0}})
/**
 * Never use the function directly, always use the MACRO, because the macro
 * attaches a NULL marker at the end of the `names` argument collection.
 */
SFUNC void fio_cli_start FIO_NOOP(int argc,
                                  char const *argv[],
                                  int unnamed_min,
                                  int unnamed_max,
                                  char const *description,
                                  fio___cli_line_s *arguments);
/**
 * Clears the memory used by the CLI dictionary, removing all parsed data.
 *
 * This function is NOT thread safe.
 */
SFUNC void fio_cli_end(void);

/** Returns the argument's value as a NUL terminated C String. */
SFUNC char const *fio_cli_get(char const *name);

/** Returns the argument's value as a NUL terminated `fio_buf_info_s`. */
SFUNC fio_buf_info_s fio_cli_get_str(char const *name);

/** Returns the argument's value as an integer. */
SFUNC int64_t fio_cli_get_i(char const *name);

/** This MACRO returns the argument's value as a boolean. */
#define fio_cli_get_bool(name) (fio_cli_get((name)) != NULL)

/** Returns the number of unnamed argument. */
SFUNC unsigned int fio_cli_unnamed_count(void);

/** Returns the unnamed argument using a 0 based `index`. */
SFUNC char const *fio_cli_unnamed(unsigned int index);

/** Returns the unnamed argument using a 0 based `index`. */
SFUNC fio_buf_info_s fio_cli_unnamed_str(unsigned int index);

/**
 * Sets the argument's value as a NUL terminated C String.
 *
 *     fio_cli_set("-p", "hello");
 *
 * This function is NOT thread safe.
 */
SFUNC void fio_cli_set(char const *name, char const *value);

/**
 * Sets the argument's value as a NUL terminated C String.
 *
 *     fio_cli_start(argc, argv,
 *                  "this is example accepts the following options:",
 *                  "-p -port the port to bind to", FIO_CLI_INT;
 *
 *     fio_cli_set("-p", "hello"); // fio_cli_get("-p") == fio_cli_get("-port");
 *
 * This function is NOT thread safe.
 */
SFUNC void fio_cli_set_i(char const *name, int64_t i);

/** Sets / adds an unnamed argument to the 0 based array of unnamed elements. */
SFUNC unsigned int fio_cli_set_unnamed(unsigned int index, const char *);

/** Calls `task` for every argument received. */
SFUNC size_t fio_cli_each(int (*task)(fio_buf_info_s name,
                                      fio_buf_info_s value,
                                      fio_cli_arg_e arg_type,
                                      void *udata),
                          void *udata);

/** Returns the argument's expected content type. */
SFUNC fio_cli_arg_e fio_cli_type(char const *name);

/* *****************************************************************************
CLI Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
String for CLI
***************************************************************************** */
FIO_LEAK_COUNTER_DEF(fio_cli_str)

typedef struct {
  uint8_t em;     /* embedded? const? how long? */
  uint8_t pad[3]; /* padding - embedded buffer starts here */
  uint32_t len;   /* if not embedded, otherwise see `em` */
  char *str;      /* if not embedded, otherwise see `pad` */
} fio_cli_str_s;

/** CLI String free / destroy by context */
FIO_SFUNC void fio_cli_str_destroy(fio_cli_str_s *s) {
  if (!s || s->em || !s->str)
    return;
  FIO_LEAK_COUNTER_ON_FREE(fio_cli_str);
  FIO_MEM_FREE_(s->str, s->len);
  *s = (fio_cli_str_s){0};
}

/** CLI String info */
FIO_IFUNC fio_buf_info_s fio_cli_str_buf(fio_cli_str_s *s) {
  fio_buf_info_s r = {0};
  if (s && (s->em || s->len))
    r = ((s->em) & 127) ? (FIO_BUF_INFO2((char *)s->pad, (size_t)s->em))
                        : (FIO_BUF_INFO2(s->str, (size_t)s->len));
  return r;
}

/** CLI String copy */
FIO_SFUNC fio_cli_str_s fio_cli_str_new(fio_buf_info_s s) {
  fio_cli_str_s r = {0};
  if (s.len < sizeof(r) - 1) {
    r.em = s.len;
    if (s.len)
      FIO_MEMCPY(r.pad, s.buf, s.len);
    return r;
  }
  r.len = (uint32_t)s.len;
  r.str = (char *)FIO_MEM_REALLOC_(NULL, 0, s.len + 1, 0);
  FIO_ASSERT_ALLOC(r.str);
  FIO_LEAK_COUNTER_ON_ALLOC(fio_cli_str);
  FIO_MEMCPY(r.str, s.buf, s.len);
  r.str[r.len] = 0;
  return r;
}

/** CLI String tmp copy */
FIO_SFUNC fio_cli_str_s fio_cli_str_tmp(fio_buf_info_s s) {
  fio_cli_str_s r = {0};
  if (s.len < sizeof(r) - 1) {
    r.em = s.len;
    FIO_MEMCPY(r.pad, s.buf, s.len);
    return r;
  }
  r.em = 128; /* mark as const, memory shouldn't be freed */
  r.len = (uint32_t)s.len;
  r.str = s.buf;
  return r;
}

/* *****************************************************************************
String array for CLI
***************************************************************************** */
FIO_LEAK_COUNTER_DEF(fio_cli_ary)

typedef struct {
  fio_cli_str_s *ary;
  uint32_t capa;
  uint32_t w;
} fio___cli_ary_s;

FIO_SFUNC void fio___cli_ary_destroy(fio___cli_ary_s *a) {
  if (!a || !a->ary)
    return;
  for (size_t i = 0; i < a->w; ++i)
    fio_cli_str_destroy(a->ary + i);
  FIO_LEAK_COUNTER_ON_FREE(fio_cli_ary);
  FIO_MEM_FREE_(a->ary, sizeof(*a->ary) * a->capa);
  *a = (fio___cli_ary_s){0};
}
FIO_SFUNC uint32_t fio___cli_ary_new_index(fio___cli_ary_s *a) {
  FIO_ASSERT(a, "Internal CLI Error - no CLI array given!");
  if (a->w == a->capa) {
    /* increase capacity */
    if (!a->ary)
      FIO_LEAK_COUNTER_ON_ALLOC(fio_cli_ary);
    size_t new_capa = a->capa + 8;
    FIO_ASSERT(new_capa < 0xFFFFFFFFU, "fio_cli data overflow");
    fio_cli_str_s *tmp =
        (fio_cli_str_s *)FIO_MEM_REALLOC_(a->ary,
                                          sizeof(*a->ary) * a->capa,
                                          sizeof(*a->ary) * new_capa,
                                          a->capa);
    FIO_ASSERT_ALLOC(tmp);
    a->ary = tmp;
    a->capa = (uint32_t)new_capa;
    if (!(FIO_MEM_REALLOC_IS_SAFE_))
      FIO_MEMSET(a->ary + a->w, 0, sizeof(*a->ary) * (new_capa - a->w));
  }
  FIO_ASSERT_DEBUG(a->w < (uint32_t)a->capa, "CLI array index error!");
  return a->w++;
}

FIO_IFUNC fio_buf_info_s fio___cli_ary_get(fio___cli_ary_s *a, uint32_t index) {
  fio_buf_info_s r = {0};
  if (index >= a->w)
    return r;
  return fio_cli_str_buf(a->ary + index);
}
FIO_IFUNC void fio___cli_ary_set(fio___cli_ary_s *a,
                                 uint32_t index,
                                 fio_buf_info_s str) {
  FIO_ASSERT(a, "Internal CLI Error - no CLI array given!");
  if (index >= a->w)
    return;
  fio_cli_str_destroy(a->ary + index);
  a->ary[index] = fio_cli_str_new(str);
}

/* *****************************************************************************
CLI Alias Index Map
***************************************************************************** */

typedef struct {
  fio_cli_str_s name;
  fio_cli_arg_e t;
  uint32_t index;
} fio___cli_aliases_s;

#define FIO___CLI_ALIAS_HASH(o)                                                \
  fio_risky_hash(fio_cli_str_buf(&o->name).buf,                                \
                 fio_cli_str_buf(&o->name).len,                                \
                 (uint64_t)(uintptr_t)fio_cli_str_destroy)
#define FIO___CLI_ALIAS_IS_EQ(a, b)                                            \
  FIO_BUF_INFO_IS_EQ(fio_cli_str_buf(&a->name), fio_cli_str_buf(&b->name))
FIO_TYPEDEF_IMAP_ARRAY(fio___cli_amap,
                       fio___cli_aliases_s,
                       uint32_t,
                       FIO___CLI_ALIAS_HASH,
                       FIO___CLI_ALIAS_IS_EQ,
                       FIO_IMAP_ALWAYS_VALID)
#undef FIO___CLI_ALIAS_HASH
#undef FIO___CLI_ALIAS_IS_EQ

/* *****************************************************************************
CLI Alias and Value Data Store
***************************************************************************** */

static struct fio___cli_data_s {
  /* maps alias names to value indexes (array) */
  fio___cli_amap_s aliases;
  fio___cli_ary_s indexed, unnamed;
  const char *description;
  fio___cli_line_s *args;
  const char *app_name;
} fio___cli_data = {{0}};

FIO_SFUNC void fio___cli_data_destroy(void) {
  fio___cli_ary_destroy(&fio___cli_data.indexed);
  fio___cli_ary_destroy(&fio___cli_data.unnamed);
  FIO_IMAP_EACH(fio___cli_amap, &fio___cli_data.aliases, i) {
    fio_cli_str_destroy(&fio___cli_data.aliases.ary[i].name);
  }
  fio___cli_amap_destroy(&fio___cli_data.aliases);
  fio___cli_data = (struct fio___cli_data_s){{0}};
}

FIO_SFUNC void fio___cli_data_alias(fio_buf_info_s key,
                                    fio_buf_info_s alias,
                                    fio_cli_arg_e t) {
  fio___cli_aliases_s o = {.name = fio_cli_str_tmp(key)};
  fio___cli_aliases_s *a = fio___cli_amap_get(&fio___cli_data.aliases, o);
  if (!a) {
    o.name = fio_cli_str_new(key);
    o.index = fio___cli_ary_new_index(&fio___cli_data.indexed);
    o.t = t;
    fio___cli_amap_set(&fio___cli_data.aliases, o, 1);
  }
  if (!alias.len)
    return;
  o.name = fio_cli_str_tmp(alias);
  fio___cli_aliases_s *old = fio___cli_amap_get(&fio___cli_data.aliases, o);
  if (old) {
    FIO_LOG_WARNING("(fio_cli) CLI alias %s already exists! overwriting...",
                    fio_cli_str_buf(&o.name).buf);
    old->index = a->index;
  } else {
    o.name = fio_cli_str_new(alias);
    o.index = a->index;
    o.t = a->t;
    fio___cli_amap_set(&fio___cli_data.aliases, o, 1);
  }
}

FIO_SFUNC void fio___cli_print_help(void);

FIO_SFUNC void fio___cli_data_set(fio_buf_info_s key, fio_buf_info_s value) {
  fio___cli_aliases_s o = {.name = fio_cli_str_tmp(key)};
  fio___cli_aliases_s *a = fio___cli_amap_get(&fio___cli_data.aliases, o);
  if (!a) {
    fio___cli_data_alias(key, (fio_buf_info_s){0}, FIO_CLI_ARG_STRING);
    a = fio___cli_amap_get(&fio___cli_data.aliases, o);
  }
  FIO_ASSERT(a && a->index < fio___cli_data.indexed.w,
             "(fio_cli) CLI alias initialization error!");
  if (a->t == FIO_CLI_ARG_INT) {
    char *start = value.buf;
    fio_atol(&start);
    if (start != value.buf + value.len) {
      FIO_LOG_FATAL("(CLI) %.*s should be an integer!",
                    (int)value.len,
                    value.buf);
      fio___cli_print_help();
    }
  }
  fio___cli_ary_set(&fio___cli_data.indexed, a->index, value);
}

FIO_SFUNC fio_buf_info_s fio___cli_data_get(fio_buf_info_s key) {
  fio_buf_info_s r = {0};
  fio___cli_aliases_s o = {.name = fio_cli_str_tmp(key)};
  fio___cli_aliases_s *a = fio___cli_amap_get(&fio___cli_data.aliases, o);
  if (a)
    r = fio___cli_ary_get(&fio___cli_data.indexed, a->index);
  if (!r.len)
    r.buf = NULL;
  return r;
}

FIO_SFUNC uint32_t fio___cli_data_get_index(fio_buf_info_s key) {
  uint32_t r = (uint32_t)-1;
  fio___cli_aliases_s o = {.name = fio_cli_str_tmp(key)};
  fio___cli_aliases_s *a = fio___cli_amap_get(&fio___cli_data.aliases, o);
  if (a)
    r = a->index;
  return r;
}

/* *****************************************************************************
CLI Destruction
***************************************************************************** */

SFUNC void fio_cli_end(void) { fio___cli_data_destroy(); }

FIO_DESTRUCTOR(fio___cli_end_destructor) { fio_cli_end(); }

/* *****************************************************************************
CLI Public Get/Set API
***************************************************************************** */

/** Returns the argument's expected content type. */
SFUNC fio_cli_arg_e fio_cli_type(char const *name) {
  fio_cli_arg_e r = FIO_CLI_ARG_NONE;
  fio___cli_aliases_s o = {.name =
                               fio_cli_str_tmp(FIO_BUF_INFO1((char *)name))};
  fio___cli_aliases_s *a = fio___cli_amap_get(&fio___cli_data.aliases, o);
  if (a)
    r = a->t;
  return r;
}

/** Returns the argument's value as a NUL terminated C String. */
SFUNC char const *fio_cli_get(char const *name) {
  if (!name)
    return fio_cli_unnamed(0);
  fio_buf_info_s key = FIO_BUF_INFO1((char *)name);
  return fio___cli_data_get(key).buf;
}

/** Returns the argument's value as a NUL terminated C String. */
SFUNC fio_buf_info_s fio_cli_get_str(char const *name) {
  if (!name)
    goto unnamed_zero;
  return fio___cli_data_get(FIO_BUF_INFO1((char *)name));
unnamed_zero:
  if (!fio___cli_data.unnamed.w)
    return FIO_BUF_INFO0;
  return fio___cli_ary_get(&fio___cli_data.unnamed, 0);
}

/** Returns the argument's value as an integer. */
SFUNC int64_t fio_cli_get_i(char const *name) {
  char *val = (char *)fio_cli_get(name);
  if (!val)
    return 0;
  return fio_atol(&val);
}

/** Returns the number of unnamed argument. */
SFUNC unsigned int fio_cli_unnamed_count(void) {
  return fio___cli_data.unnamed.w;
}

/** Returns the unnamed argument using a 0 based `index`. */
SFUNC char const *fio_cli_unnamed(unsigned int index) {
  if (index >= fio___cli_data.unnamed.w)
    return NULL;
  return fio___cli_ary_get(&fio___cli_data.unnamed, (uint32_t)index).buf;
}

/** Returns the unnamed argument using a 0 based `index`. */
SFUNC fio_buf_info_s fio_cli_unnamed_str(unsigned int index) {
  if (index >= fio___cli_data.unnamed.w)
    return FIO_BUF_INFO0;
  return fio___cli_ary_get(&fio___cli_data.unnamed, (uint32_t)index);
}

/**
 * Sets the argument's value as a NUL terminated C String.
 *
 *     fio_cli_set("-p", "hello");
 *
 * This function is NOT thread safe.
 */
SFUNC void fio_cli_set(char const *name, char const *value) {
  fio_buf_info_s key = FIO_BUF_INFO1((char *)name);
  fio_buf_info_s val = FIO_BUF_INFO1((char *)value);
  if (!name) {
    if (!value)
      return;
    uint32_t i = fio___cli_ary_new_index(&fio___cli_data.unnamed);
    fio___cli_ary_set(&fio___cli_data.unnamed, i, val);
    return;
  }
  fio___cli_data_set(key, val);
}

/**
 * Sets the argument's value as a NUL terminated C String.
 *
 *     fio_cli_start(argc, argv,
 *                  "this is example accepts the following options:",
 *                  "-p -port the port to bind to", FIO_CLI_INT;
 *
 *     fio_cli_set("-p", "hello"); // fio_cli_get("-p") == fio_cli_get("-port");
 *
 * This function is NOT thread safe.
 */
SFUNC void fio_cli_set_i(char const *name, int64_t i) {
  char buf[32];
  size_t len = fio_digits10(i);
  fio_ltoa10(buf, i, len);
  buf[len] = 0;
  fio_cli_set(name, buf);
}

/** Sets / adds an unnamed argument to the 0 based array of unnamed elements. */
SFUNC unsigned int fio_cli_set_unnamed(unsigned int index, const char *value) {
  if (!value)
    return (uint32_t)-1;
  fio_buf_info_s val = FIO_BUF_INFO1((char *)value);
  if (!val.len)
    return (uint32_t)-1;
  if (index >= fio___cli_data.unnamed.w)
    index = fio___cli_ary_new_index(&fio___cli_data.unnamed);
  fio___cli_ary_set(&fio___cli_data.unnamed, index, val);
  return index;
}

/** Calls `task` for every argument received. */
SFUNC size_t fio_cli_each(int (*task)(fio_buf_info_s name,
                                      fio_buf_info_s value,
                                      fio_cli_arg_e arg_type,
                                      void *udata),
                          void *udata) {
  size_t r = 0;
  if (!task)
    return r;
  FIO_IMAP_EACH(fio___cli_amap, &(fio___cli_data.aliases), i) {
    fio_buf_info_s value = fio_cli_str_buf(fio___cli_data.indexed.ary +
                                           fio___cli_data.aliases.ary[i].index);
    if (!value.len)
      continue;
    ++r;
    if (task(fio_cli_str_buf(&fio___cli_data.aliases.ary[i].name),
             value,
             fio___cli_data.aliases.ary[i].t,
             udata))
      break;
  }
  for (size_t i = 0; i < fio___cli_data.unnamed.w; ++i) {
    fio_buf_info_s value = fio_cli_str_buf(fio___cli_data.unnamed.ary + i);
    if (!value.len)
      continue;
    ++r;
    if (task(FIO_BUF_INFO2(NULL, 0),
             value,
             fio___cli_data.aliases.ary[i].t,
             udata))
      break;
  }
  return r;
}

/* *****************************************************************************
CLI Name Iterator
***************************************************************************** */

typedef struct {
  fio___cli_line_s *args;
  fio_buf_info_s line;
  fio_buf_info_s desc;
  size_t index;
  fio_cli_arg_e line_type;
} fio___cli_iterator_args_s;

#define FIO___CLI_EACH_ARG(args_, i)                                           \
  for (fio___cli_iterator_args_s i =                                           \
           {                                                                   \
               .args = args_,                                                  \
              .line = FIO_BUF_INFO1((char *)((args_)[0].l)),                   \
              .line_type = (args_)[0].t,                                       \
           };                                                                  \
       i.line.buf;                                                             \
       (++i.index,                                                             \
        i.line = FIO_BUF_INFO1((char *)i.args[i.index].l),                     \
        i.line_type = i.args[i.index].t))

typedef struct {
  fio_buf_info_s line;
  fio_buf_info_s alias;
} fio___cli_iterator_alias_s;

FIO_IFUNC fio_buf_info_s fio___cli_iterator_alias_first(fio___cli_line_s *arg,
                                                        fio_buf_info_s line) {
  fio_buf_info_s a = {0};
  if (arg->t > FIO_CLI_ARG_INT)
    return a;
  if (!line.buf || line.buf[0] != '-')
    return a;
  char *pos = (char *)FIO_MEMCHR(line.buf, ' ', line.len);
  if (!pos)
    pos = line.buf + line.len;
  a = FIO_BUF_INFO2(line.buf, (size_t)(pos - line.buf));
  return a;
}
FIO_IFUNC fio_buf_info_s fio___cli_iterator_alias_next(fio_buf_info_s line,
                                                       fio_buf_info_s prev) {
  fio_buf_info_s a = {0};
  if (!prev.buf[prev.len])
    return a; /* eol */
  prev.buf += prev.len + 1;
  if (prev.buf[0] != '-')
    return a; /* no more aliases */
  char *pos =
      (char *)FIO_MEMCHR(prev.buf, ' ', ((line.buf + line.len) - prev.buf));
  if (!pos)
    pos = line.buf + line.len;
  a = FIO_BUF_INFO2(prev.buf, (size_t)(pos - prev.buf));
  return a;
}

#define FIO___CLI_EACH_ALIAS(i, alias)                                         \
  for (fio_buf_info_s alias =                                                  \
           fio___cli_iterator_alias_first(i.args + i.index, i.line);           \
       alias.buf;                                                              \
       alias = fio___cli_iterator_alias_next(i.line, alias))

FIO_IFUNC fio_buf_info_s
fio___cli_iterator_default_val(fio___cli_iterator_args_s *i) {
  fio_buf_info_s a = {0};
  fio_buf_info_s line = i->line;
  if (!line.buf || line.buf[0] != '-') {
    i->desc = line;
    return a;
  }
  for (;;) {
    char *pos = (char *)FIO_MEMCHR(line.buf, ' ', line.len);
    if (!pos)
      return a;
    ++pos;
    if (pos[0] == '-') {
      line.len = (line.buf + line.len) - pos;
      line.buf = pos;
      continue;
    }
    if (pos[0] != '(') {
      i->desc.len = (line.buf + line.len) - pos;
      i->desc.buf = pos;
      return a;
    }
    if (pos[1] == '"') {
      pos += 2;
      a.buf = pos;
      while (*pos && !(pos[0] == '"' && pos[1] == ')'))
        ++pos;
      if (!pos[0]) {
        /* no default value? */
        i->desc.len = (line.buf + line.len) - a.buf;
        i->desc.buf = a.buf;
        a = (fio_buf_info_s){0};
        return a;
      }
      a.len = pos - a.buf;
      pos += 2;
    } else {
      pos += 1;
      a.buf = pos;
      while (*pos && pos[0] != ')')
        ++pos;
      if (!pos[0]) {
        /* no default value? */
        i->desc.len = (line.buf + line.len) - a.buf;
        i->desc.buf = a.buf;
        a = (fio_buf_info_s){0};
        return a;
      }
      a.len = pos - a.buf;
      ++pos;
    }
    pos += *pos == ' ';
    line = i->line;
    i->desc.len = (line.buf + line.len) - pos;
    i->desc.buf = pos;
    return a;
  }
}

#define FIO___CLI_EACH_DESC(i, desc_)                                          \
  for (fio_buf_info_s desc_ = i.desc;                                          \
       desc_.len || i.args[i.index + 1].t == FIO_CLI_ARG_PRINT;                \
       desc_ = (i.args[i.index + 1].t == FIO_CLI_ARG_PRINT                     \
                    ? (++i.index, FIO_BUF_INFO1((char *)i.args[i.index].l))    \
                    : FIO_BUF_INFO2(0, 0)))

/* *****************************************************************************
CLI Build + Parsing Arguments
***************************************************************************** */

FIO_SFUNC void fio___cli_build_argument_aliases(char const *argv[],
                                                char const *description,
                                                fio___cli_line_s *args) {
  /**   Setup the CLI argument alias indexing   **/
  fio___cli_data.description = description;
  fio___cli_data.args = args;
  fio___cli_data.app_name = argv[0];
  FIO___CLI_EACH_ARG(args, i) {
    fio_buf_info_s first_alias = {0};
    fio_buf_info_s def = fio___cli_iterator_default_val(&i);
    switch (i.line_type) {
    case FIO_CLI_ARG_STRING: /* fall through */
    case FIO_CLI_ARG_BOOL:   /* fall through */
    case FIO_CLI_ARG_INT:    /* fall through */
      FIO_ASSERT(
          i.line.buf[0] == '-',
          "(CLI) argument lines MUST start with an '-argument-name':\n\t%s",
          i.line.buf);
      FIO___CLI_EACH_ALIAS(i, alias) {
        if (first_alias.buf) {
          fio___cli_data_alias(first_alias, alias, i.line_type);
          continue;
        }
        fio___cli_data_alias(alias, first_alias, i.line_type);
        first_alias = alias;
      }
      if (def.len) {
        FIO_ASSERT(
            i.line_type != FIO_CLI_ARG_BOOL,
            "(CLI) boolean CLI arguments cannot have a default value:\n\t%s",
            i.line.buf);
        fio___cli_data_set(first_alias, def);
      }
      continue;
    case FIO_CLI_ARG_PRINT:      /* fall through */
    case FIO_CLI_ARG_PRINT_LINE: /* fall through */
    case FIO_CLI_ARG_PRINT_HEADER: continue;
    }
  }
}

void fio_cli_start___(void); /* sublime text marker */
SFUNC void fio_cli_start FIO_NOOP(int argc,
                                  char const *argv[],
                                  int unnamed_min,
                                  int unnamed_max,
                                  char const *description,
                                  fio___cli_line_s *args) {
  uint32_t help_value32 = fio_buf2u32u("help");

  fio___cli_build_argument_aliases(argv, description, args);
  if (unnamed_min == -1) {
    unnamed_max = -1;
    unnamed_min = 0;
  }

  /**   Consume Arguments   **/
  for (size_t i = 1; i < (size_t)argc; ++i) {
    fio_buf_info_s key = FIO_BUF_INFO1((char *)argv[i]);
    fio_buf_info_s value = {0};
    fio___cli_aliases_s *a = NULL;
    if (!key.buf || !key.len)
      continue;
    if (key.buf[0] != '-')
      goto process_unnamed;
    /* --help / -h / -? */
    if ((key.len == 2 && ((key.buf[1] | 32) == 'h' || key.buf[1] == '?')) ||
        (key.len == 5 &&
         (fio_buf2u32u(key.buf + 1) | 0x20202020UL) == help_value32) ||
        (key.len == 6 && key.buf[1] == '-' &&
         (fio_buf2u32u(key.buf + 2) | 0x20202020UL) == help_value32))
      fio___cli_print_help();
    if (key.len == 2 && key.buf[1] == '-') /* "--" detected, skip the rest */
      break;
    /* look for longest argument match for argument (find, i.e. -arg=val) */
    for (;;) {
      fio___cli_aliases_s o = {.name = fio_cli_str_tmp(key)};
      a = fio___cli_amap_get(&fio___cli_data.aliases, o);
      if (a)
        break;
      ++value.len;
      --key.len;
      value.buf = key.buf + key.len;
      if (!key.len) {
        key = value;
        goto process_unnamed;
      }
    }
    /* boolean values can be chained, but cannot have an actual value. */
    if (a->t == FIO_CLI_ARG_BOOL) {
      fio_buf_info_s bool_value = FIO_BUF_INFO2((char *)"1", 1);
      char bool_buf[3] = {'-', 0, 0};
      for (;;) {
        fio___cli_ary_set(&fio___cli_data.indexed, a->index, bool_value);
        while (value.len && value.buf[0] == ',')
          (--value.len, ++value.buf);
        if (!value.len)
          break;
        bool_buf[1] = value.buf[0];
        --value.len;
        ++value.buf;
        key = FIO_BUF_INFO2(bool_buf, 2);
        fio___cli_aliases_s o = {.name = fio_cli_str_tmp(key)};
        a = fio___cli_amap_get(&fio___cli_data.aliases, o);
        if (!a || a->t != FIO_CLI_ARG_BOOL) {
          FIO_LOG_FATAL(
              "(CLI) unrecognized boolean value (%s) embedded in argument %s",
              bool_buf,
              argv[i]);
          fio___cli_print_help();
        }
      }
      continue;
    }

    if (value.len) { /* values such as `-arg34` / `-arg=32` */
      value.len -= (value.buf[0] == '=');
      value.buf += (value.buf[0] == '=');
    } else { /* values such as `-arg 32` (using 2 argv elements)*/
      if ((i + 1) == (size_t)argc) {
        FIO_LOG_FATAL("(CLI) argument value missing for (%s)",
                      key.buf,
                      argv[i]);
        fio___cli_print_help();
      }
      ++i;
      value = FIO_BUF_INFO1((char *)argv[i]);
    }
    fio___cli_data_set(key, value); /* use this for type validation */
    continue;
  process_unnamed:

    if (!unnamed_max) {
      FIO_LOG_FATAL("(CLI) unnamed arguments limit reached at argument: %s",
                    key.buf);
      fio___cli_print_help();
    }
    fio___cli_ary_set(&fio___cli_data.unnamed,
                      fio___cli_ary_new_index(&fio___cli_data.unnamed),
                      key);
    --unnamed_max;
    continue;
  }
  if (unnamed_min && fio___cli_data.unnamed.w < (uint32_t)unnamed_min) {
    FIO_LOG_FATAL("(CLI) missing required arguments");
    fio___cli_print_help();
  }
}

/* *****************************************************************************
CLI Help Output
***************************************************************************** */
FIO_LEAK_COUNTER_DEF(fio_cli_help_writer)

FIO_IFUNC fio_str_info_s fio___cli_write2line(fio_str_info_s d,
                                              fio_buf_info_s s,
                                              uint8_t static_memory) {
  if (d.len + s.len + 2 > d.capa) {
    size_t new_capa = (d.len + s.len) << 1;
    char *tmp = (char *)FIO_MEM_REALLOC_(NULL, 0, new_capa, 0);
    FIO_ASSERT_ALLOC(tmp);
    FIO_LEAK_COUNTER_ON_ALLOC(fio_cli_help_writer);
    FIO_MEMCPY(tmp, d.buf, d.len);
    if (!static_memory) {
      FIO_LEAK_COUNTER_ON_FREE(fio_cli_help_writer);
      FIO_MEM_FREE_(d.buf, d.capa);
    }
    d.capa = new_capa;
    d.buf = tmp;
  }
  FIO_MEMCPY(d.buf + d.len, s.buf, s.len);
  d.len += s.len;
  return d;
}

FIO_SFUNC fio_str_info_s fio___cli_write2line_finalize(fio_str_info_s d,
                                                       fio_buf_info_s app_name,
                                                       uint8_t static_memory) {
  /* replace "NAME" with `app_name` */
  size_t additional_bytes = app_name.len > 4 ? app_name.len - 4 : 0;
  char *pos = (char *)FIO_MEMCHR(d.buf, 'N', d.len);
  uint32_t name_val = fio_buf2u32u("NAME");
  while (pos) {
    if (fio_buf2u32u(pos) != name_val) {
      if (pos + 4 > d.buf + d.len)
        break;
      pos = (char *)FIO_MEMCHR(pos + 1, 'N', (d.buf + d.len) - pos);
      continue;
    }
    if (d.len + additional_bytes + 2 > d.capa) { /* not enough room? */
      size_t new_capa = d.len + ((additional_bytes + 2) << 2);
      char *tmp = (char *)FIO_MEM_REALLOC_(NULL, 0, new_capa, 0);
      FIO_ASSERT_ALLOC(tmp);
      FIO_LEAK_COUNTER_ON_ALLOC(fio_cli_help_writer);
      FIO_MEMCPY(tmp, d.buf, d.len);
      if (!static_memory) {
        FIO_LEAK_COUNTER_ON_FREE(fio_cli_help_writer);
        FIO_MEM_FREE_(d.buf, d.capa);
      }
      static_memory = 0;
      pos = tmp + (pos - d.buf);
      d.capa = new_capa;
      d.buf = tmp;
    }
    FIO_MEMMOVE(pos + app_name.len, pos + 4, ((d.buf + d.len) - (pos + 4)));
    FIO_MEMCPY(pos, app_name.buf, app_name.len);
    d.len -= 4;
    d.len += app_name.len;
    pos += app_name.len;
  }
  d.buf[d.len] = 0;
  return d;
}

FIO_SFUNC void fio___cli_print_help(void) {
  char const *description = fio___cli_data.description;
  fio___cli_line_s *args = fio___cli_data.args;

  fio_buf_info_s app_name = FIO_BUF_INFO2(
      (char *)fio___cli_data.app_name,
      (fio___cli_data.app_name ? FIO_STRLEN(fio___cli_data.app_name) : 0));
  FIO_STR_INFO_TMP_VAR(help, 8191);
  fio_str_info_s help_org_state = help;

  help = fio___cli_write2line(help,
                              FIO_BUF_INFO1((char *)"\n"),
                              help_org_state.buf == help.buf);
  help = fio___cli_write2line(help,
                              FIO_BUF_INFO1((char *)description),
                              help_org_state.buf == help.buf);
  help = fio___cli_write2line(help,
                              FIO_BUF_INFO1((char *)"\n"),
                              help_org_state.buf == help.buf);

  FIO___CLI_EACH_ARG(args, i) {
    fio_buf_info_s first_alias = {0};
    fio_buf_info_s def = fio___cli_iterator_default_val(&i);
    fio_buf_info_s argument_type_txt = {0};
    switch (i.line_type) {
    case FIO_CLI_ARG_STRING:
      argument_type_txt = FIO_BUF_INFO1(
          (char *)"\x1B[0m \x1B[2m<string value>"); /* fall through */
    case FIO_CLI_ARG_BOOL:
      FIO_ASSERT(i.line_type != FIO_CLI_ARG_BOOL || !def.len,
                 "(CLI) boolean values cannot have a default value:\n\t%s",
                 i.line.buf);
      if (!argument_type_txt.buf)
        argument_type_txt = FIO_BUF_INFO1(
            (char *)"\x1B[0m \x1B[2m(boolean flag)"); /* fall through */
    case FIO_CLI_ARG_INT:
      if (!argument_type_txt.buf)
        argument_type_txt =
            FIO_BUF_INFO1((char *)"\x1B[0m \x1B[2m<integer value>");
      FIO_ASSERT(
          i.line.buf[0] == '-',
          "(CLI) argument lines MUST start with an '-argument-name':\n\t%s",
          i.line.buf);
      FIO___CLI_EACH_ALIAS(i, al) {
        if (!first_alias.buf)
          help = fio___cli_write2line(help,
                                      FIO_BUF_INFO1((char *)"  \x1B[1m"),
                                      help_org_state.buf == help.buf);
        else
          help = fio___cli_write2line(help,
                                      FIO_BUF_INFO1((char *)"\x1B[0m, \x1B[1m"),
                                      help_org_state.buf == help.buf);
        first_alias = al;
        help = fio___cli_write2line(help,
                                    FIO_STR2BUF_INFO(al),
                                    help_org_state.buf == help.buf);
      }
      help = fio___cli_write2line(help,
                                  argument_type_txt,
                                  help_org_state.buf == help.buf);
      if (def.len) {
        help = fio___cli_write2line(help,
                                    FIO_BUF_INFO1((char *)", defaults to: "),
                                    help_org_state.buf == help.buf);
        help = fio___cli_write2line(help,
                                    FIO_STR2BUF_INFO(def),
                                    help_org_state.buf == help.buf);
      }
      help = fio___cli_write2line(help,
                                  FIO_BUF_INFO1((char *)"\x1B[0m\n"),
                                  help_org_state.buf == help.buf);
      FIO___CLI_EACH_DESC(i, desc) {
        help = fio___cli_write2line(help,
                                    FIO_BUF_INFO1((char *)"\t"),
                                    help_org_state.buf == help.buf);
        help = fio___cli_write2line(help,
                                    FIO_STR2BUF_INFO(desc),
                                    help_org_state.buf == help.buf);
        help = fio___cli_write2line(help,
                                    FIO_BUF_INFO1((char *)"\n"),
                                    help_org_state.buf == help.buf);
      }
      continue;
    case FIO_CLI_ARG_PRINT:
      help = fio___cli_write2line(help,
                                  FIO_BUF_INFO1((char *)"\t"),
                                  help_org_state.buf ==
                                      help.buf); /* fall through */
    case FIO_CLI_ARG_PRINT_LINE:
      help = fio___cli_write2line(help,
                                  FIO_STR2BUF_INFO(i.line),
                                  help_org_state.buf == help.buf);
      help = fio___cli_write2line(help,
                                  FIO_BUF_INFO1((char *)"\n"),
                                  help_org_state.buf == help.buf);
      continue;
    case FIO_CLI_ARG_PRINT_HEADER:
      help = fio___cli_write2line(help,
                                  FIO_BUF_INFO1((char *)"\n\x1B[4m"),
                                  help_org_state.buf == help.buf);
      help = fio___cli_write2line(help,
                                  FIO_STR2BUF_INFO(i.line),
                                  help_org_state.buf == help.buf);
      help = fio___cli_write2line(help,
                                  FIO_BUF_INFO1((char *)"\x1B[0m\n"),
                                  help_org_state.buf == help.buf);
      continue;
    }
  }
  help = fio___cli_write2line(
      help,
      FIO_BUF_INFO1((char *)"\nUse any of the following input formats:\n"
                            "\t-arg <value>\t-arg=<value>\t-arg<value>\n"
                            "\n"
                            "Use \x1B[1m-h\x1B[0m , \x1B[1m-help\x1B[0m or "
                            "\x1B[1m-?\x1B[0m "
                            "to get this information again.\n"
                            "\n"),
      help_org_state.buf == help.buf);
  help = fio___cli_write2line_finalize(help,
                                       app_name,
                                       help_org_state.buf == help.buf);
  fwrite(help.buf, 1, help.len, stdout);
  if (help_org_state.buf != help.buf) {
    FIO_LEAK_COUNTER_ON_FREE(fio_cli_help_writer);
    FIO_MEM_FREE_(help.buf, help.capa);
  }
  fio_cli_end();
  exit(0);
}
/* *****************************************************************************
CLI - cleanup
***************************************************************************** */
#undef FIO___CLI_ON_ALLOC
#undef FIO___CLI_ON_FREE
#endif /* FIO_EXTERN_COMPLETE*/
#endif /* FIO_CLI */
#undef FIO_CLI
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_MEMORY_NAME fio    /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                      Custom Memory Allocator / Pooling



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */

/* *****************************************************************************
Memory Allocation - Setup Alignment Info
***************************************************************************** */
#if defined(FIO_MEMORY_NAME) && !defined(FIO___RECURSIVE_INCLUDE)

#undef FIO_MEM_ALIGN
#undef FIO_MEM_ALIGN_NEW

#ifndef FIO_MEMORY_ALIGN_LOG
/** Allocation alignment, MUST be >= 3 and <= 10*/
#define FIO_MEMORY_ALIGN_LOG 6

#elif FIO_MEMORY_ALIGN_LOG < 3
#undef FIO_MEMORY_ALIGN_LOG
#define FIO_MEMORY_ALIGN_LOG 3
#elif FIO_MEMORY_ALIGN_LOG > 10
#undef FIO_MEMORY_ALIGN_LOG
#define FIO_MEMORY_ALIGN_LOG 10
#endif

/* Helper macro, don't change this */
#undef FIO_MEMORY_ALIGN_SIZE
/** The minimal allocation size & alignment. */
#define FIO_MEMORY_ALIGN_SIZE (1UL << (FIO_MEMORY_ALIGN_LOG))

/* inform the compiler that the returned value is aligned on 16 byte marker */
#if __clang__ || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 8)
#define FIO_MEM_ALIGN __attribute__((assume_aligned(FIO_MEMORY_ALIGN_SIZE)))
#define FIO_MEM_ALIGN_NEW                                                      \
  __attribute__((malloc, assume_aligned(FIO_MEMORY_ALIGN_SIZE)))
#else
#define FIO_MEM_ALIGN
#define FIO_MEM_ALIGN_NEW
#endif /* (__clang__ || __GNUC__)... */

/* *****************************************************************************
Memory Allocation - API
***************************************************************************** */

/**
 * Allocates memory using a per-CPU core block memory pool.
 * Memory is zeroed out.
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 *
 * `mempool_malloc` promises a best attempt at providing locality between
 * consecutive calls, but locality can't be guaranteed.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, malloc)(size_t size);

/**
 * same as calling `fio_malloc(size_per_unit * unit_count)`;
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                       calloc)(size_t size_per_unit,
                                               size_t unit_count);

/** Frees memory that was allocated using this library. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, free)(void *ptr);

/**
 * Re-allocates memory. An attempt to avoid copying the data is made only for
 * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).
 */
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc)(void *ptr,
                                                             size_t new_size);

/**
 * Re-allocates memory. An attempt to avoid copying the data is made only for
 * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).
 *
 * This variation can perform better, as it might copy less data.
 */
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc2)(void *ptr,
                                                              size_t new_size,
                                                              size_t copy_len);

/**
 * Allocates memory directly using `mmap`, this is preferred for objects that
 * both require almost a page of memory (or more) and expect a long lifetime.
 *
 * However, since this allocation will invoke the system call (`mmap`), it will
 * be inherently slower.
 *
 * `mempoll_free` can be used for deallocating the memory.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, mmap)(size_t size);

/**
 * When forking is called manually, call this function to reset the facil.io
 * memory allocator's locks.
 */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)(void);

/* *****************************************************************************
Memory Allocation - configuration macros

NOTE: most configuration values should be a power of 2 or a logarithmic value.
***************************************************************************** */

/* Make sure the system's allocator is marked as unsafe. */
#if defined(FIO_MALLOC_TMP_USE_SYSTEM) && FIO_MALLOC_TMP_USE_SYSTEM
#undef FIO_MEMORY_INITIALIZE_ALLOCATIONS
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 0
#endif

#ifndef FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG
/**
 * The logarithmic size of a single allocation "chunk" (16 blocks).
 *
 * Limited to >=17 and <=24.
 *
 * By default 22, which is a ~2Mb allocation per system call, resulting in a
 * maximum allocation size of 131Kb.
 */
#define FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG 21
#endif

#ifndef FIO_MEMORY_CACHE_SLOTS
/**
 * The number of system allocation "chunks" to cache even if they are not in
 * use.
 */
#define FIO_MEMORY_CACHE_SLOTS 4
#endif

#ifndef FIO_MEMORY_INITIALIZE_ALLOCATIONS
/**
 * Forces the allocator to zero out memory early and often, so allocations
 * return initialized memory (bytes are all zeros).
 *
 * This will make the realloc2 safe for use (all data not copied is zero).
 */
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS                                      \
  FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT
#elif FIO_MEMORY_INITIALIZE_ALLOCATIONS
#undef FIO_MEMORY_INITIALIZE_ALLOCATIONS
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 1
#else
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 0
#endif

#ifndef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
/**
 * The number of blocks per system allocation.
 *
 * More blocks protect against fragmentation, but lower the maximum number that
 * can be allocated without reverting to mmap.
 *
 * Range: 0-4
 * Recommended: depends on object allocation sizes, usually 1 or 2.
 */
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 2
#endif

#ifndef FIO_MEMORY_ENABLE_BIG_ALLOC
/**
 * Uses a whole system allocation to support bigger allocations.
 *
 * Could increase fragmentation costs.
 */
#define FIO_MEMORY_ENABLE_BIG_ALLOC 1
#endif

#ifndef FIO_MEMORY_ARENA_COUNT
/**
 * Memory arenas mitigate thread contention while using more memory.
 *
 * Note that at some point arenas are statistically irrelevant... except when
 * benchmarking contention in multi-core machines.
 *
 * Negative values will result in dynamic selection based on CPU core count.
 */
#define FIO_MEMORY_ARENA_COUNT -1
#endif

#ifndef FIO_MEMORY_ARENA_COUNT_FALLBACK
/*
 * Used when dynamic arena count calculations fail.
 *
 * NOTE: if FIO_MEMORY_ARENA_COUNT is negative, dynamic arena calculation is
 * performed using CPU core calculation.
 */
#define FIO_MEMORY_ARENA_COUNT_FALLBACK 24
#endif

#ifndef FIO_MEMORY_ARENA_COUNT_MAX
/*
 * Used when dynamic arena count calculations fail.
 *
 * NOTE: if FIO_MEMORY_ARENA_COUNT is negative, dynamic arena calculation is
 * performed using CPU core calculation.
 */
#define FIO_MEMORY_ARENA_COUNT_MAX 64
#endif

#ifndef FIO_MEMORY_WARMUP
#define FIO_MEMORY_WARMUP 0
#endif

#ifndef FIO_MEMORY_USE_THREAD_MUTEX
#if FIO_USE_THREAD_MUTEX_TMP
#define FIO_MEMORY_USE_THREAD_MUTEX FIO_USE_THREAD_MUTEX
#else
#if FIO_MEMORY_ARENA_COUNT > 0
/**
 * If arena count isn't linked to the CPU count, threads might busy-spin.
 * It is better to slow wait than fast busy spin when the work in the lock is
 * longer... and system allocations are performed inside arena locks.
 */
#define FIO_MEMORY_USE_THREAD_MUTEX 1
#else
/* defaults to use a spinlock when no contention is expected. */
#define FIO_MEMORY_USE_THREAD_MUTEX 0
#endif
#endif
#endif

#if !defined(FIO_MEM_SYS_ALLOC) || !defined(FIO_MEM_SYS_REALLOC) ||            \
    !defined(FIO_MEM_SYS_FREE)
/**
 * The following MACROS, when all of them are defined, allow the memory
 * allocator to collect memory from the system using an alternative method.
 *
 * - FIO_MEM_SYS_ALLOC(pages, alignment_log)
 *
 * - FIO_MEM_SYS_REALLOC(ptr, old_pages, new_pages, alignment_log)
 *
 * - FIO_MEM_SYS_FREE(ptr, pages) FIO_MEM_SYS_FREE_def_func((ptr), (pages))
 *
 * Note that the alignment property for the allocated memory is essential and
 * may me quite large.
 */
#undef FIO_MEM_SYS_ALLOC
#undef FIO_MEM_SYS_REALLOC
#undef FIO_MEM_SYS_FREE
#endif /* undefined FIO_MEM_SYS_ALLOC... */

/* *****************************************************************************
Memory Allocation - configuration value - results and constants
***************************************************************************** */

/* Helper macros, don't change their values */
#undef FIO_MEMORY_BLOCKS_PER_ALLOCATION
#undef FIO_MEMORY_SYS_ALLOCATION_SIZE
#undef FIO_MEMORY_BLOCK_ALLOC_LIMIT

#if FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG < 0 ||                                \
    FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG > 5
#undef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 3
#endif

/** the number of allocation blocks per system allocation. */
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION                                       \
  (1UL << FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG)

/** the total number of bytes consumed per system allocation. */
#define FIO_MEMORY_SYS_ALLOCATION_SIZE                                         \
  (1UL << FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG)

/**
 * The maximum allocation size, after which a big/system allocation is used.
 */
#define FIO_MEMORY_BLOCK_ALLOC_LIMIT                                           \
  (FIO_MEMORY_SYS_ALLOCATION_SIZE >> (FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG + 2))

#if FIO_MEMORY_ENABLE_BIG_ALLOC
/** the limit of a big allocation, if enabled */
#define FIO_MEMORY_BIG_ALLOC_LIMIT                                             \
  (FIO_MEMORY_SYS_ALLOCATION_SIZE >>                                           \
   (FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG > 3                                   \
        ? 3                                                                    \
        : FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG))
#define FIO_MEMORY_ALLOC_LIMIT FIO_MEMORY_BIG_ALLOC_LIMIT
#else
#define FIO_MEMORY_ALLOC_LIMIT FIO_MEMORY_BLOCK_ALLOC_LIMIT
#endif

/* *****************************************************************************
Memory Allocation - configuration access - UNSTABLE API!!!
***************************************************************************** */

/** Arena count for the allocator. */
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_arenas)(void);

/** System allocation sizes (bytes per system allocation). */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_sys_alloc_size)(void) {
  return FIO_MEMORY_SYS_ALLOCATION_SIZE;
}

/** Cached system allocations (free, but held on to). */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_cache_slots)(void) {
  return FIO_MEMORY_CACHE_SLOTS;
}
/** Allocations alignment. */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_alignment)(void) {
  return FIO_MEMORY_ALIGN_SIZE;
}
/** Allocations alignment log (base 2). */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_alignment_log)(void) {
  return FIO_MEMORY_ALIGN_LOG;
}
/** Allocation limit (at which point do we switch to system allocations?). */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_alloc_limit)(void) {
  return (FIO_MEMORY_BLOCK_ALLOC_LIMIT > FIO_MEMORY_ALLOC_LIMIT)
             ? FIO_MEMORY_BLOCK_ALLOC_LIMIT
             : FIO_MEMORY_ALLOC_LIMIT;
}

/** Allocation limit for arena based allocation (vs. big allocations). */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_arena_alloc_limit)(void) {
  return FIO_MEMORY_BLOCK_ALLOC_LIMIT;
}

/* will realloc2 return junk data? */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, realloc_is_safe)(void) {
  return FIO_MEMORY_INITIALIZE_ALLOCATIONS;
}

/* Returns the calculated block size. */
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_block_size)(void);

/** Prints the allocator's data structure. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_state)(void);

/** Prints the allocator's free block list. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_free_block_list)(void);

/** Prints the settings used to define the allocator. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings)(void);

/* *****************************************************************************
Set global macros to use this allocator if FIO_MALLOC
***************************************************************************** */
#ifdef FIO_MALLOC
/* prevent double declaration of FIO_MALLOC */
#define H___FIO_MALLOC___H
#undef FIO_MEM_REALLOC
#define FIO_MEM_REALLOC(ptr, old_size, new_size, copy_len)                     \
  fio_realloc2((ptr), (new_size), (copy_len))
#undef FIO_MEM_FREE
#define FIO_MEM_FREE(ptr, size) fio_free((ptr))
#undef FIO_MEM_REALLOC_IS_SAFE
#define FIO_MEM_REALLOC_IS_SAFE fio_realloc_is_safe()
#undef FIO_MEM_ALIGNMENT_SIZE
#define FIO_MEM_ALIGNMENT_SIZE fio_malloc_alignment()
#undef FIO_MALLOC
#endif /* FIO_MALLOC */

/* *****************************************************************************
Temporarily (at least) set memory allocation macros to use this allocator
***************************************************************************** */
#ifndef FIO_MALLOC_TMP_USE_SYSTEM

#undef FIO_MEM_REALLOC_
#undef FIO_MEM_FREE_
#undef FIO_MEM_REALLOC_IS_SAFE_
#undef FIO_MEM_ALIGNMENT_SIZE_
#define FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)                    \
  FIO_NAME(FIO_MEMORY_NAME, realloc2)((ptr), (new_size), (copy_len))
#define FIO_MEM_FREE_(ptr, size) FIO_NAME(FIO_MEMORY_NAME, free)((ptr))
#define FIO_MEM_REALLOC_IS_SAFE_ FIO_NAME(FIO_MEMORY_NAME, realloc_is_safe)()
#define FIO_MEM_ALIGNMENT_SIZE_  FIO_NAME(FIO_MEMORY_NAME, malloc_alignment)()

#endif /* FIO_MALLOC_TMP_USE_SYSTEM */

/* *****************************************************************************





Memory Allocation - start implementation





***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
/* internal workings start here */

/* *****************************************************************************







Helpers and System Memory Allocation




***************************************************************************** */
#ifndef H___FIO_MEM_INCLUDE_ONCE___H
#define H___FIO_MEM_INCLUDE_ONCE___H

#define FIO_MEM_BYTES2PAGES(size)                                              \
  (((size_t)(size) + ((1UL << FIO_MEM_PAGE_SIZE_LOG) - 1)) &                   \
   ((~(size_t)0) << FIO_MEM_PAGE_SIZE_LOG))

/* *****************************************************************************



POSIX Allocation



***************************************************************************** */
#if FIO_OS_POSIX || __has_include("sys/mman.h")
#include <sys/mman.h>

/* Mitigates MAP_ANONYMOUS not being defined on older versions of MacOS */
#if !defined(MAP_ANONYMOUS)
#if defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#else
#define MAP_ANONYMOUS 0
#endif /* defined(MAP_ANONYMOUS) */
#endif /* FIO_MEM_SYS_ALLOC */

/* inform the compiler that the returned value is aligned on 16 byte marker */
#if __clang__ || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 8)
#define FIO_PAGE_ALIGN                                                         \
  __attribute__((assume_aligned((1UL << FIO_MEM_PAGE_SIZE_LOG))))
#define FIO_PAGE_ALIGN_NEW                                                     \
  __attribute__((malloc, assume_aligned((1UL << FIO_MEM_PAGE_SIZE_LOG))))
#else
#define FIO_PAGE_ALIGN
#define FIO_PAGE_ALIGN_NEW
#endif /* (__clang__ || __GNUC__)... */

/*
 * allocates memory using `mmap`, but enforces alignment.
 */
FIO_SFUNC void *FIO_MEM_SYS_ALLOC_def_func(size_t bytes,
                                           uint8_t alignment_log) {
  void *result;
  FIO_ASSERT((alignment_log < 25),
             "`alignment_log > 24` out of range in FIO_MEM_SYS_ALLOC");
  static void *next_alloc = (void *)0x01;
  const size_t alignment_mask = (1ULL << alignment_log) - 1;
  const size_t alignment_size = (1ULL << alignment_log);
  bytes = FIO_MEM_BYTES2PAGES(bytes);
  next_alloc =
      (void *)(((uintptr_t)next_alloc + alignment_mask) & alignment_mask);
/* hope for the best? */
#ifdef MAP_ALIGNED
  result = mmap(next_alloc,
                bytes,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS | MAP_ALIGNED(alignment_log),
                -1,
                0);
#else
  result = mmap(next_alloc,
                bytes,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS,
                -1,
                0);
#endif /* MAP_ALIGNED */
  if (result == MAP_FAILED)
    return (void *)NULL;
  if (((uintptr_t)result & alignment_mask)) {
    munmap(result, bytes);
    result = mmap(NULL,
                  bytes + alignment_size,
                  PROT_READ | PROT_WRITE,
                  MAP_PRIVATE | MAP_ANONYMOUS,
                  -1,
                  0);
    if (result == MAP_FAILED) {
      return (void *)NULL;
    }
    const uintptr_t offset =
        (alignment_size - ((uintptr_t)result & alignment_mask));
    if (offset) {
      munmap(result, offset);
      result = (void *)((uintptr_t)result + offset);
    }
    munmap((void *)((uintptr_t)result + bytes), alignment_size - offset);
  }
  next_alloc = (void *)((uintptr_t)result + (bytes << 2));
  return result;
}

/*
 * Re-allocates memory using `mmap`, enforcing alignment.
 */
FIO_SFUNC void *FIO_MEM_SYS_REALLOC_def_func(void *mem,
                                             size_t old_len,
                                             size_t new_len,
                                             uint8_t alignment_log) {
  old_len = FIO_MEM_BYTES2PAGES(old_len);
  new_len = FIO_MEM_BYTES2PAGES(new_len);
  if (new_len > old_len) {
    void *result;
#if defined(__linux__)
    result = mremap(mem, old_len, new_len, 0);
    if (result != MAP_FAILED)
      return result;
#endif
    result = mmap((void *)((uintptr_t)mem + old_len),
                  new_len - old_len,
                  PROT_READ | PROT_WRITE,
                  MAP_PRIVATE | MAP_ANONYMOUS,
                  -1,
                  0);
    if (result == (void *)((uintptr_t)mem + old_len)) {
      result = mem;
    } else {
      /* copy and free */
      munmap(result, new_len - old_len); /* free the failed attempt */
      result =
          FIO_MEM_SYS_ALLOC_def_func(new_len,
                                     alignment_log); /* allocate new memory */
      if (!result) {
        return (void *)NULL;
      }
      FIO_MEMCPY(result, mem, old_len); /* copy data */
      munmap(mem, old_len);             /* free original memory */
    }
    return result;
  }
  if (old_len != new_len) /* remove dangling pages */
    munmap((void *)((uintptr_t)mem + new_len), old_len - new_len);
  return mem;
}

/* frees memory using `munmap`. */
FIO_IFUNC void FIO_MEM_SYS_FREE_def_func(void *mem, size_t bytes) {
  bytes = FIO_MEM_BYTES2PAGES(bytes);
  munmap(mem, bytes);
}

/* *****************************************************************************



Windows Allocation



***************************************************************************** */
#elif FIO_OS_WIN
#include <memoryapi.h>

FIO_IFUNC void FIO_MEM_SYS_FREE_def_func(void *mem, size_t bytes) {
  bytes = FIO_MEM_BYTES2PAGES(bytes);
  if (!VirtualFree(mem, 0, MEM_RELEASE))
    FIO_LOG_ERROR("Memory address at %p couldn't be returned to the system",
                  mem);
  (void)bytes;
}

FIO_IFUNC void *FIO_MEM_SYS_ALLOC_def_func(size_t bytes,
                                           uint8_t alignment_log) {
  // return aligned_alloc((pages << 12), (1UL << alignment_log));
  void *result;
  size_t attempts = 0;
  static void *next_alloc = (void *)0x01;
  const uintptr_t alignment_rounder = (1ULL << alignment_log) - 1;
  const uintptr_t alignment_mask = ~alignment_rounder;
  bytes = FIO_MEM_BYTES2PAGES(bytes);
  do {
    next_alloc =
        (void *)(((uintptr_t)next_alloc + alignment_rounder) & alignment_mask);
    FIO_ASSERT_DEBUG(!((uintptr_t)next_alloc & alignment_rounder),
                     "alignment allocation rounding error?");
    result =
        VirtualAlloc(next_alloc, (bytes << 2), MEM_RESERVE, PAGE_READWRITE);
    next_alloc = (void *)((uintptr_t)next_alloc + (bytes << 2));
  } while (!result && (attempts++) < 1024);
  if (result) {
    result = VirtualAlloc(result, bytes, MEM_COMMIT, PAGE_READWRITE);
    FIO_ASSERT_DEBUG(result, "couldn't commit memory after reservation?!");

  } else {
    FIO_LOG_ERROR("Couldn't allocate memory from the system, error %zu."
                  "\n\t%zu attempts with final address %p",
                  GetLastError(),
                  attempts,
                  next_alloc);
  }
  return result;
}

FIO_IFUNC void *FIO_MEM_SYS_REALLOC_def_func(void *mem,
                                             size_t old_len,
                                             size_t new_len,
                                             uint8_t alignment_log) {
  if (!new_len)
    goto free_mem;
  old_len = FIO_MEM_BYTES2PAGES(old_len);
  new_len = FIO_MEM_BYTES2PAGES(new_len);
  if (new_len > old_len) {
    /* extend allocation */
    void *tmp = VirtualAlloc((void *)((uintptr_t)mem + old_len),
                             new_len - old_len,
                             MEM_COMMIT,
                             PAGE_READWRITE);
    if (tmp)
      return mem;
    /* Alloc, Copy, Free... sorry... */
    tmp = FIO_MEM_SYS_ALLOC_def_func(new_len, alignment_log);
    if (!tmp) {
      FIO_LOG_ERROR("sysem realloc failed to allocate memory.");
      return NULL;
    }
    FIO_MEMCPY(tmp, mem, old_len);
    FIO_MEM_SYS_FREE_def_func(mem, old_len);
    mem = tmp;
  } else if (old_len > new_len) {
    /* shrink allocation */
    if (!VirtualFree((void *)((uintptr_t)mem + new_len),
                     old_len - new_len,
                     MEM_DECOMMIT))
      FIO_LOG_ERROR("failed to decommit memory range @ %p.", mem);
  }
  return mem;
free_mem:
  FIO_MEM_SYS_FREE_def_func(mem, old_len);
  mem = NULL;
  return NULL;
}

/* *****************************************************************************


Unknown OS... Unsupported?


***************************************************************************** */
#else /* FIO_OS_POSIX / FIO_OS_WIN => unknown...? */

FIO_IFUNC void *FIO_MEM_SYS_ALLOC_def_func(size_t bytes,
                                           uint8_t alignment_log) {
  // return aligned_alloc((pages << 12), (1UL << alignment_log));
  exit(-1);
  (void)bytes;
  (void)alignment_log;
}

FIO_IFUNC void *FIO_MEM_SYS_REALLOC_def_func(void *mem,
                                             size_t old_len,
                                             size_t new_len,
                                             uint8_t alignment_log) {
  (void)old_len;
  (void)alignment_log;
  new_len = FIO_MEM_BYTES2PAGES(new_len);
  return realloc(mem, new_len);
}

FIO_IFUNC void FIO_MEM_SYS_FREE_def_func(void *mem, size_t bytes) {
  free(mem);
  (void)bytes;
}

#endif /* FIO_OS_POSIX / FIO_OS_WIN */
/* *****************************************************************************
Overridable system allocation macros
***************************************************************************** */
#ifndef FIO_MEM_SYS_ALLOC
#define FIO_MEM_SYS_ALLOC(pages, alignment_log)                                \
  FIO_MEM_SYS_ALLOC_def_func((pages), (alignment_log))
#define FIO_MEM_SYS_REALLOC(ptr, old_pages, new_pages, alignment_log)          \
  FIO_MEM_SYS_REALLOC_def_func((ptr), (old_pages), (new_pages), (alignment_log))
#define FIO_MEM_SYS_FREE(ptr, pages) FIO_MEM_SYS_FREE_def_func((ptr), (pages))
#endif /* FIO_MEM_SYS_ALLOC */

#endif /* H___FIO_MEM_INCLUDE_ONCE___H */

/* *****************************************************************************
FIO_MEMORY_DISABLE - use the system allocator
***************************************************************************** */
#if defined(FIO_MALLOC_TMP_USE_SYSTEM)

SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, malloc)(size_t size) {
#if FIO_MEMORY_INITIALIZE_ALLOCATIONS
  return calloc(size, 1);
#elif defined(DEBUG) && DEBUG
  void *ret = malloc(size);
  if (ret)
    FIO_MEMSET(ret, 0xFA, size);
  return ret;
#else
  return malloc(size);
#endif
}
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                       calloc)(size_t size_per_unit,
                                               size_t unit_count) {
  return calloc(size_per_unit, unit_count);
}
SFUNC void FIO_NAME(FIO_MEMORY_NAME, free)(void *ptr) { free(ptr); }
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc)(void *ptr,
                                                             size_t new_size) {
  return realloc(ptr, new_size);
}
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc2)(void *ptr,
                                                              size_t new_size,
                                                              size_t copy_len) {
  return realloc(ptr, new_size);
  (void)copy_len;
}
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, mmap)(size_t size) {
  return calloc(size, 1);
}

SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)(void) {}
/** Prints the allocator's data structure. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_state)(void) {}
/** Prints the allocator's free block list. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_free_block_list)(void) {}
/** Prints the settings used to define the allocator. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings)(void) {}
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_block_size)(void) { return 0; }
void fio_malloc_arenas___(void);
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_arenas)(void) { return 0; }

#ifdef FIO_TEST_ALL
SFUNC void FIO_NAME_TEST(FIO_NAME(stl, FIO_MEMORY_NAME), mem)(void) {
  fprintf(stderr, "\t* Custom memory allocator bypassed.\n");
}
#endif /* FIO_TEST_ALL */

#else /* FIO_MEMORY_DISABLE */

/* *****************************************************************************





                  Memory allocation implementation starts here
                    helper function and setup are complete





***************************************************************************** */

/* *****************************************************************************
Lock type choice
***************************************************************************** */
#if FIO_MEMORY_USE_THREAD_MUTEX
#define FIO_MEMORY_LOCK_TYPE fio_thread_mutex_t
#define FIO_MEMORY_LOCK_TYPE_INIT(lock)                                        \
  ((lock) = (fio_thread_mutex_t)FIO_THREAD_MUTEX_INIT)
#define FIO_MEMORY_TRYLOCK(lock) fio_thread_mutex_trylock(&(lock))
#define FIO_MEMORY_LOCK(lock)    fio_thread_mutex_lock(&(lock))
#define FIO_MEMORY_UNLOCK(lock)                                                \
  do {                                                                         \
    int tmp__ = fio_thread_mutex_unlock(&(lock));                              \
    if (tmp__) {                                                               \
      FIO_LOG_ERROR("Couldn't free mutex! error (%d): %s",                     \
                    tmp__,                                                     \
                    strerror(tmp__));                                          \
    }                                                                          \
  } while (0)

#define FIO_MEMORY_LOCK_NAME "pthread_mutex"
#else
#define FIO_MEMORY_LOCK_TYPE            fio_lock_i
#define FIO_MEMORY_LOCK_TYPE_INIT(lock) ((lock) = FIO_LOCK_INIT)
#define FIO_MEMORY_TRYLOCK(lock)        fio_trylock(&(lock))
#define FIO_MEMORY_LOCK(lock)           fio_lock(&(lock))
#define FIO_MEMORY_UNLOCK(lock)         fio_unlock(&(lock))
#define FIO_MEMORY_LOCK_NAME            "facil.io spinlocks"
#endif

/* *****************************************************************************
Allocator debugging helpers
***************************************************************************** */

#if defined(DEBUG) || defined(FIO_LEAK_COUNTER)
FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_MEMORY_NAME, __malloc_chunk))
FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_MEMORY_NAME, malloc))
static volatile size_t FIO_NAME(FIO_MEMORY_NAME, __malloc_total);
#define FIO_MEMORY_ON_CHUNK_ALLOC(ptr)                                         \
  do {                                                                         \
    FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_MEMORY_NAME, __malloc_chunk));      \
    FIO_LOG_DEBUG2("(%d) MEMORY CHUNK-ALLOC allocated      %p",                \
                   fio_getpid(),                                               \
                   ptr);                                                       \
  } while (0);
#define FIO_MEMORY_ON_CHUNK_FREE(ptr)                                          \
  do {                                                                         \
    FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_MEMORY_NAME, __malloc_chunk));       \
    FIO_LOG_DEBUG2("(%d) MEMORY CHUNK-DEALLOC de-allocated %p",                \
                   fio_getpid(),                                               \
                   ptr);                                                       \
  } while (0);
#define FIO_MEMORY_ON_CHUNK_CACHE(ptr)                                         \
  do {                                                                         \
    FIO_LOG_DEBUG2("(%d) MEMORY CACHE-PUSH placed          %p in cache",       \
                   fio_getpid(),                                               \
                   ptr);                                                       \
  } while (0);
#define FIO_MEMORY_ON_CHUNK_UNCACHE(ptr)                                       \
  do {                                                                         \
    FIO_LOG_DEBUG2("(%d) MEMORY CACHE-POP retrieved        %p from cache",     \
                   fio_getpid(),                                               \
                   ptr);                                                       \
  } while (0);

#define FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK(ptr, blk)                            \
  do {                                                                         \
    if (0)                                                                     \
      FIO_LOG_DEBUG2("(%d) MEMORY chunk %p block %zu reset in lock",           \
                     ptr,                                                      \
                     (size_t)blk);                                             \
  } while (0);

#define FIO_MEMORY_ON_BIG_BLOCK_SET(ptr)                                       \
  do {                                                                         \
    if (1)                                                                     \
      FIO_LOG_DEBUG2("(%d) MEMORY chunk %p used as big-block",                 \
                     fio_getpid(),                                             \
                     ptr);                                                     \
  } while (0);

#define FIO_MEMORY_ON_BIG_BLOCK_UNSET(ptr)                                     \
  do {                                                                         \
    if (1)                                                                     \
      FIO_LOG_DEBUG2("(%d) MEMORY chunk %p no longer used as big-block",       \
                     fio_getpid(),                                             \
                     ptr);                                                     \
  } while (0);
#define FIO_MEMORY_PRINT_STATS_END()                                           \
  do {                                                                         \
    FIO_LOG_DEBUG2(                                                            \
        "(%d) (" FIO_MACRO2STR(                                                \
            FIO_NAME(FIO_MEMORY_NAME, malloc)) ") total allocations: %zu",     \
        fio_getpid(),                                                          \
        FIO_NAME(FIO_MEMORY_NAME, __malloc_total));                            \
  } while (0)
#define FIO_MEMORY_ON_ALLOC_FUNC()                                             \
  do {                                                                         \
    FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_MEMORY_NAME, malloc));              \
    fio_atomic_add(&FIO_NAME(FIO_MEMORY_NAME, __malloc_total), 1);             \
  } while (0)
#define FIO_MEMORY_ON_FREE_FUNC()                                              \
  FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_MEMORY_NAME, malloc))
#else /* defined(DEBUG) || defined(FIO_LEAK_COUNTER) */
#define FIO_MEMORY_ON_CHUNK_ALLOC(ptr)              ((void)0)
#define FIO_MEMORY_ON_CHUNK_FREE(ptr)               ((void)0)
#define FIO_MEMORY_ON_CHUNK_CACHE(ptr)              ((void)0)
#define FIO_MEMORY_ON_CHUNK_UNCACHE(ptr)            ((void)0)
#define FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK(ptr, blk) ((void)0)
#define FIO_MEMORY_ON_BIG_BLOCK_SET(ptr)            ((void)0)
#define FIO_MEMORY_ON_BIG_BLOCK_UNSET(ptr)          ((void)0)
#define FIO_MEMORY_PRINT_STATS_END()                ((void)0)
#define FIO_MEMORY_ON_ALLOC_FUNC()                  ((void)0)
#define FIO_MEMORY_ON_FREE_FUNC()                   ((void)0)
#endif /* defined(DEBUG) || defined(FIO_LEAK_COUNTER) */

/* *****************************************************************************






Memory chunk headers and block data (in chunk header)






***************************************************************************** */

/* *****************************************************************************
Chunk and Block data / header
***************************************************************************** */

typedef struct {
  volatile int32_t ref;
  volatile int32_t pos;
} FIO_NAME(FIO_MEMORY_NAME, __mem_block_s);

typedef struct {
  /* the head of the chunk... node->next says a lot */
  uint32_t marker;
  volatile int32_t ref;
  FIO_NAME(FIO_MEMORY_NAME, __mem_block_s)
  blocks[FIO_MEMORY_BLOCKS_PER_ALLOCATION];
} FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s);

#if FIO_MEMORY_ENABLE_BIG_ALLOC
/* big-blocks consumes a chunk, sizeof header MUST be <= chunk header */
typedef struct {
  /* marker and ref MUST overlay chunk header */
  uint32_t marker;
  volatile int32_t ref;
  volatile int32_t pos;
} FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s);
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

/* *****************************************************************************
Arena type
***************************************************************************** */
#define FIO___MEM_ARENA_CACHE_ALIGN_VAL                                        \
  (sizeof(void *) + sizeof(int32_t) + sizeof(FIO_MEMORY_LOCK_TYPE))
typedef struct {
  void *block;
  int32_t last_pos;
  FIO_MEMORY_LOCK_TYPE lock;
  /* cache line padding */
  uint8_t pad_for_cache___[FIO___MEM_ARENA_CACHE_ALIGN_VAL >= 128
                               ? 0
                               : (128 - FIO___MEM_ARENA_CACHE_ALIGN_VAL)];
} FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s);
#undef FIO___MEM_ARENA_CACHE_ALIGN_VAL
/* *****************************************************************************
Allocator State
***************************************************************************** */

typedef struct FIO_NAME(FIO_MEMORY_NAME, __mem_state_s)
    FIO_NAME(FIO_MEMORY_NAME, __mem_state_s);

static struct FIO_NAME(FIO_MEMORY_NAME, __mem_state_s) {
#if FIO_MEMORY_CACHE_SLOTS
  /** cache array container for available memory chunks */
  struct {
    /* chunk slot array */
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * a[FIO_MEMORY_CACHE_SLOTS];
    size_t pos;
  } cache;
#endif /* FIO_MEMORY_CACHE_SLOTS */

#if FIO_MEMORY_ENABLE_BIG_ALLOC
  /** a block for big allocations, shared (no arena) */
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) * big_block;
  int32_t big_last_pos;
  /** big allocation lock */
  FIO_MEMORY_LOCK_TYPE big_lock;
  uint8_t pad_for_cache___[115]; /* cache line padding */
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */
  /** main memory state lock */
  FIO_MEMORY_LOCK_TYPE lock;
  /** free list for available blocks */
  FIO_LIST_HEAD blocks;
  /** the arena count for the allocator */
  uint8_t pad_for_cache2___[111]; /* cache line padding */
  size_t arena_count;
  FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s) arena[];
} * FIO_NAME(FIO_MEMORY_NAME, __mem_state);

/* *****************************************************************************
Arena assignment
***************************************************************************** */

/* SublimeText marker */
void fio___mem_arena_unlock___(void);
/** Unlocks the thread's arena. */
FIO_SFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_arena_unlock)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s) * a) {
  FIO_ASSERT_DEBUG(a, "unlocking a NULL arena?!");
  FIO_MEMORY_UNLOCK(a->lock);
}

/* SublimeText marker */
void fio___mem_arena_lock___(void);
#if 1
/** Locks and returns the thread's arena. */
FIO_SFUNC FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s) *
    FIO_NAME(FIO_MEMORY_NAME, __mem_arena_lock)(void) {
#if FIO_MEMORY_ARENA_COUNT == 1
  FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[0].lock);
  return FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena;

#else /* FIO_MEMORY_ARENA_COUNT != 1 */

#if defined(DEBUG) && FIO_MEMORY_ARENA_COUNT > 0 && !defined(FIO_TEST_ALL)
  static size_t warning_printed = 0;
#define FIO___MEMORY_ARENA_LOCK_WARNING()                                      \
  do {                                                                         \
    if (!warning_printed)                                                      \
      FIO_LOG_WARNING(FIO_MACRO2STR(FIO_NAME(                                  \
          FIO_MEMORY_NAME,                                                     \
          malloc)) " high arena contention.\n"                                 \
                   "          Consider recompiling with more arenas.");        \
    warning_printed = 1;                                                       \
  } while (0)
#else /* !DEBUG || FIO_MEMORY_ARENA_COUNT <= 0 */
#define FIO___MEMORY_ARENA_LOCK_WARNING()
#endif
  /** thread arena value */
  const size_t arena_count =
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
  size_t arena_index;
  {
    /* select the default arena selection using a thread ID. */
    union {
      void *p;
      fio_thread_t t;
    } u = {.t = fio_thread_current()};
    arena_index = fio_risky_ptr(u.p) % arena_count;
  }
  for (size_t i = 0; i < arena_count; ++i) {
    if (!FIO_MEMORY_TRYLOCK(
            FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[arena_index].lock))
      return (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena + arena_index);
    FIO_LOG_DDEBUG("thread %p had to switch arena from %zu / %zu",
                   fio_thread_current(),
                   arena_index,
                   (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count);
    ++arena_index;
    arena_index %= arena_count;
  }
  /* wait for base arena to become available */
  FIO___MEMORY_ARENA_LOCK_WARNING();
#undef FIO___MEMORY_ARENA_LOCK_WARNING
  /* slow wait for arena */
  FIO_MEMORY_LOCK(
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[arena_index].lock);
  return FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena + arena_index;
#endif /* FIO_MEMORY_ARENA_COUNT != 1 */
}
#else
/** Locks and returns the thread's arena. */
FIO_SFUNC FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s) *
    FIO_NAME(FIO_MEMORY_NAME, __mem_arena_lock)(void) {
#if FIO_MEMORY_ARENA_COUNT == 1
  FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[0].lock);
  return FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena;

#else /* FIO_MEMORY_ARENA_COUNT != 1 */

#if defined(DEBUG) && FIO_MEMORY_ARENA_COUNT > 0 && !defined(FIO_TEST_ALL)
  static size_t warning_printed = 0;
#define FIO___MEMORY_ARENA_LOCK_WARNING()                                      \
  do {                                                                         \
    if (!warning_printed)                                                      \
      FIO_LOG_WARNING(FIO_MACRO2STR(FIO_NAME(                                  \
          FIO_MEMORY_NAME,                                                     \
          malloc)) " high arena contention.\n"                                 \
                   "          Consider recompiling with more arenas.");        \
    warning_printed = 1;                                                       \
  } while (0)
#else /* !DEBUG || FIO_MEMORY_ARENA_COUNT <= 0 */
#define FIO___MEMORY_ARENA_LOCK_WARNING()
#endif
  /** thread arena value */
  size_t arena_index;
  size_t loop_count = 0;
  {
    /* select the default arena selection using a thread ID. */
    union {
      void *p;
      fio_thread_t t;
    } u = {.t = fio_thread_current()};
    arena_index = (fio_risky_ptr(u.p) & 1023) %
                  FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
#if (defined(DEBUG) && 0)
    static void *pthread_last = NULL;
    if (pthread_last != u.p) {
      FIO_LOG_DEBUG(
          "thread %p (%p) associated with arena %zu / %zu",
          u.p,
          (void *)fio_risky_ptr(u.p),
          arena_index,
          (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count);
      pthread_last = u.p;
    }
#endif
  }
  for (;;) {
    /* rotate all arenas to find one that's available */
    if (!FIO_MEMORY_TRYLOCK(
            FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[arena_index].lock))
      return (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena + arena_index);
    FIO_LOG_DDEBUG("thread %p had to switch arena from %zu / %zu",
                   fio_thread_current(),
                   arena_index,
                   (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count);
    ++arena_index;
    if (arena_index == FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count)
      arena_index = 0;
    if (++loop_count <
        (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count << 1))
      continue;
    FIO___MEMORY_ARENA_LOCK_WARNING();
#undef FIO___MEMORY_ARENA_LOCK_WARNING
#if FIO_MEMORY_USE_THREAD_MUTEX && FIO_OS_POSIX
    /* slow wait for arena */
    FIO_MEMORY_LOCK(
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[arena_index].lock);
    return FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena + arena_index;
#else
    // FIO_THREAD_RESCHEDULE();
#endif /* FIO_MEMORY_USE_THREAD_MUTEX */
  }
#endif /* FIO_MEMORY_ARENA_COUNT != 1 */
}
#endif
/* *****************************************************************************
Converting between chunk & block data to pointers (and back)
***************************************************************************** */

#define FIO_MEMORY_HEADER_SIZE                                                 \
  ((sizeof(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s)) +                         \
    (FIO_MEMORY_ALIGN_SIZE - 1)) &                                             \
   (~(FIO_MEMORY_ALIGN_SIZE - 1)))

#define FIO_MEMORY_BLOCK_SIZE                                                  \
  (((FIO_MEMORY_SYS_ALLOCATION_SIZE - FIO_MEMORY_HEADER_SIZE) /                \
    FIO_MEMORY_BLOCKS_PER_ALLOCATION) &                                        \
   (~(FIO_MEMORY_ALIGN_SIZE - 1)))

#define FIO_MEMORY_UNITS_PER_BLOCK                                             \
  (FIO_MEMORY_BLOCK_SIZE / FIO_MEMORY_ALIGN_SIZE)

/* SublimeText marker */
void fio___mem_chunk2ptr___(void);
/** returns a pointer within a chunk, given it's block and offset value. */
FIO_IFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c,
    size_t block,
    size_t offset) {
  return (void *)(((uintptr_t)(c) + FIO_MEMORY_HEADER_SIZE) +
                  (block * FIO_MEMORY_BLOCK_SIZE) +
                  (offset << FIO_MEMORY_ALIGN_LOG));
}

/* SublimeText marker */
void fio___mem_ptr2chunk___(void);
/** returns a chunk given a pointer. */
FIO_IFUNC FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *
    FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(void *p) {
  return FIO_PTR_MATH_RMASK(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s),
                            p,
                            FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);
}

/* SublimeText marker */
void fio___mem_ptr2index___(void);
/** returns a pointer's block index within it's chunk. */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c,
    void *p) {
  FIO_ASSERT_DEBUG(c == FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(p),
                   "chunk-pointer offset argument error");
  size_t i =
      (size_t)FIO_PTR_MATH_LMASK(void, p, FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);
  i -= FIO_MEMORY_HEADER_SIZE;
  i /= FIO_MEMORY_BLOCK_SIZE;
  return i;
  (void)c;
}

/* *****************************************************************************
Allocator State Initialization & Cleanup
***************************************************************************** */
#define FIO_MEMORY_STATE_SIZE(arena_count)                                     \
  FIO_MEM_BYTES2PAGES(                                                         \
      (sizeof(*FIO_NAME(FIO_MEMORY_NAME, __mem_state)) +                       \
       (sizeof(FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s)) * (arena_count))))

/* function declarations for functions called during cleanup */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c);
FIO_IFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)(void);
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)(void *ptr);
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)(void *ptr);
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_free)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c);

/* IDE marker */
void fio___mem_state_cleanup___(void);
FIO_SFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_state_cleanup)(void *ignr_) {
  if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)) {
    FIO_LOG_DEBUG2(FIO_MACRO2STR(
        FIO_NAME(FIO_MEMORY_NAME,
                 __mem_state_cleanup)) " called more than once (NULL state).");
    return;
  }
  (void)ignr_;
  FIO_LOG_DDEBUG2(
      "starting facil.io memory allocator cleanup for " FIO_MACRO2STR(
          FIO_NAME(FIO_MEMORY_NAME, malloc)) ".");
  /* free arena blocks */
  for (size_t i = 0; i < FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
       ++i) {
    if (FIO_MEMORY_TRYLOCK(
            FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock)) {
      FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock);
      FIO_LOG_ERROR(FIO_MACRO2STR(
          FIO_NAME(FIO_MEMORY_NAME,
                   malloc)) "cleanup called while some arenas are in use!");
    }
    FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock);
    FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)
    (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block = NULL;
    FIO_MEMORY_LOCK_TYPE_INIT(
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock);
  }

#if FIO_MEMORY_ENABLE_BIG_ALLOC
  /* cleanup big-alloc chunk */
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block) {
    if ((uint32_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block->ref > 1) {
      FIO_LOG_WARNING("(" FIO_MACRO2STR(FIO_NAME(
          FIO_MEMORY_NAME,
          malloc)) ") active big-block reference count error at %p\n"
                   "          Possible memory leaks for big-block allocation.");
    }
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)
    (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block = NULL;
    FIO_MEMORY_LOCK_TYPE_INIT(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
  }
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

#if FIO_MEMORY_CACHE_SLOTS
  /* deallocate all chunks in the cache */
  while (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos) {
    const size_t pos = --FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos;
    FIO_MEMORY_ON_CHUNK_UNCACHE(
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.a[pos]);
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)
    (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.a[pos]);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.a[pos] = NULL;
  }
#endif /* FIO_MEMORY_CACHE_SLOTS */

  /* report any blocks in the allocation list - even if not in DEBUG mode */
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.next !=
      &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks) {
    struct t_s {
      FIO_LIST_NODE node;
    };
    void *last_chunk = NULL;
    FIO_LOG_WARNING("(%d) (" FIO_MACRO2STR(FIO_NAME(
                        FIO_MEMORY_NAME,
                        malloc)) ") blocks left after cleanup - memory leaks?",
                    fio_getpid());
    FIO_LIST_EACH(struct t_s,
                  node,
                  &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks,
                  pos) {
      if (last_chunk == (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(pos))
        continue;
      last_chunk = (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(pos);
      FIO_LOG_WARNING("(%d) (" FIO_MACRO2STR(
                          FIO_NAME(FIO_MEMORY_NAME,
                                   malloc)) ") leaked block(s) for chunk %p",
                      fio_getpid(),
                      (void *)pos,
                      last_chunk);
    }
  }

  /* dealloc the state machine */
  const size_t s = FIO_MEMORY_STATE_SIZE(
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count);
  FIO_MEM_SYS_FREE(FIO_NAME(FIO_MEMORY_NAME, __mem_state), s);
  FIO_NAME(FIO_MEMORY_NAME, __mem_state) =
      (FIO_NAME(FIO_MEMORY_NAME, __mem_state_s *))NULL;

  FIO_MEMORY_PRINT_STATS_END();
  FIO_LOG_DDEBUG2(
      "finished facil.io memory allocator cleanup for " FIO_MACRO2STR(
          FIO_NAME(FIO_MEMORY_NAME, malloc)) ".");
}

FIO_SFUNC void FIO_NAME(FIO_MEMORY_NAME,
                        __malloc_after_fork_task)(void *ignr_) {
  (void)ignr_;
  FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)();
}

/* initializes (allocates) the arenas and state machine */
FIO_CONSTRUCTOR(FIO_NAME(FIO_MEMORY_NAME, __mem_state_setup)) {
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state))
    return;
  fio_state_callback_add(FIO_CALL_IN_CHILD,
                         FIO_NAME(FIO_MEMORY_NAME, __malloc_after_fork_task),
                         NULL);
  fio_state_callback_add(FIO_CALL_AT_EXIT,
                         FIO_NAME(FIO_MEMORY_NAME, __mem_state_cleanup),
                         NULL);
  /* allocate the state machine */
  {
#if FIO_MEMORY_ARENA_COUNT > 0
    size_t const arena_count = FIO_MEMORY_ARENA_COUNT;
#else
    size_t arena_count = FIO_MEMORY_ARENA_COUNT_FALLBACK;
#ifdef _SC_NPROCESSORS_ONLN
    arena_count = sysconf(_SC_NPROCESSORS_ONLN);
    if (arena_count == (size_t)-1UL)
      arena_count = FIO_MEMORY_ARENA_COUNT_FALLBACK;
    else /* arenas !> threads (birthday) */
      arena_count = (arena_count << 1) + 2;
#else /* FIO_MEMORY_ARENA_COUNT <= 0 */
#if _MSC_VER || __MINGW32__
    /* https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-system_info
     */
    SYSTEM_INFO win_system_info;
    GetSystemInfo(&win_system_info);
    arena_count = (size_t)win_system_info.dwNumberOfProcessors;
#else
#warning Dynamic CPU core count is unavailable - assuming FIO_MEMORY_ARENA_COUNT_FALLBACK cores.
#endif
#endif /* _SC_NPROCESSORS_ONLN */
#if FIO_MEMORY_ARENA_COUNT < -1
    arena_count = arena_count / (0 - FIO_MEMORY_ARENA_COUNT);
#endif
    if (arena_count >= FIO_MEMORY_ARENA_COUNT_MAX)
      arena_count = FIO_MEMORY_ARENA_COUNT_MAX;
    if (!arena_count)
      arena_count = 1;

#endif /* FIO_MEMORY_ARENA_COUNT <= 0 */

    const size_t s = FIO_MEMORY_STATE_SIZE(arena_count);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state) =
        (FIO_NAME(FIO_MEMORY_NAME, __mem_state_s *))FIO_MEM_SYS_ALLOC(s, 0);
    FIO_ASSERT_ALLOC(FIO_NAME(FIO_MEMORY_NAME, __mem_state));
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count = arena_count;
  }
  FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks =
      FIO_LIST_INIT(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks);
  FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)();

#if defined(FIO_MEMORY_WARMUP) && FIO_MEMORY_WARMUP
  for (size_t i = 0; i < (size_t)FIO_MEMORY_WARMUP &&
                     i < FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
       ++i) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block =
        FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)();
  }
#endif
#ifdef DEBUG
  FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings)();
#endif /* DEBUG */
  (void)FIO_NAME(FIO_MEMORY_NAME, malloc_print_free_block_list);
  (void)FIO_NAME(FIO_MEMORY_NAME, malloc_print_state);
  (void)FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings);
}

/* SublimeText marker */
void fio_after_fork___(void);
/**
 * When forking is called manually, call this function to reset the facil.io
 * memory allocator's locks.
 */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)(void) {
  if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_state_setup)();
    return;
  }
  FIO_LOG_DEBUG2("(%d) MEMORY reinitializing " FIO_MACRO2STR(
                     FIO_NAME(FIO_MEMORY_NAME, malloc)) " state",
                 fio_getpid());
  FIO_MEMORY_LOCK_TYPE_INIT(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
#if FIO_MEMORY_ENABLE_BIG_ALLOC
  FIO_MEMORY_LOCK_TYPE_INIT(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */
  for (size_t i = 0; i < FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
       ++i) {
    FIO_MEMORY_LOCK_TYPE_INIT(
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock);
  }
}

/* *****************************************************************************
Memory Allocation - state printing (debug helper)
***************************************************************************** */

/* SublimeText marker */
void fio_malloc_print_state___(void);
/** Prints the allocator's data structure. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_state)(void) {
  fprintf(stderr,
          "(%d) " FIO_MACRO2STR(
              FIO_NAME(FIO_MEMORY_NAME, malloc)) " allocator state:\n",
          fio_getpid());
  for (size_t i = 0; i < FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
       ++i) {
    fprintf(stderr,
            "\t* arena[%zu] block: %p\n",
            i,
            (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block);
    if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block) {
      FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
          FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(
              FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block);
      size_t b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(
          c,
          FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block);
      fprintf(stderr, "\t\tchunk-ref: %zu (%p)\n", (size_t)c->ref, (void *)c);
      fprintf(stderr,
              "\t\t- block[%zu]-ref: %zu\n"
              "\t\t- block[%zu]-pos: %zu\n",
              b,
              (size_t)c->blocks[b].ref,
              b,
              (size_t)c->blocks[b].pos);
    }
  }
#if FIO_MEMORY_ENABLE_BIG_ALLOC
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block) {
    fprintf(stderr, "\t---big allocations---\n");
    fprintf(stderr,
            "\t* big-block: %p\n"
            "\t\t ref: %zu\n"
            "\t\t pos: %zu\n",
            (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block,
            (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block->ref,
            (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block->pos);
  } else {
    fprintf(stderr,
            "\t---big allocations---\n"
            "\t* big-block: NULL\n");
  }

#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

#if FIO_MEMORY_CACHE_SLOTS
  fprintf(stderr, "\t---caches---\n");
  for (size_t i = 0; i < FIO_MEMORY_CACHE_SLOTS; ++i) {
    fprintf(stderr,
            "\t* cache[%zu] chunk: %p\n",
            i,
            (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.a[i]);
  }
#endif /* FIO_MEMORY_CACHE_SLOTS */
}

void fio_malloc_print_free_block_list___(void);
/** Prints the allocator's free block list. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_free_block_list)(void) {
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.prev ==
      &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks)
    return;
  fprintf(
      stderr,
      "(%d) " FIO_MACRO2STR(
          FIO_NAME(FIO_MEMORY_NAME, malloc)) " allocator free block list:\n",
      fio_getpid());
  FIO_LIST_NODE *n = FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.prev;
  for (size_t i = 0; n != &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks;
       ++i) {
    fprintf(stderr, "\t[%zu] %p\n", i, (void *)n);
    n = n->prev;
  }
}

/* *****************************************************************************
chunk allocation / deallocation
***************************************************************************** */

/* SublimeText marker */
void fio___mem_chunk_dealloc___(void);
/* returns memory to system */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c) {
  if (!c)
    return;
  FIO_MEMORY_ON_CHUNK_FREE(c);
  FIO_MEM_SYS_FREE(((void *)c), FIO_MEMORY_SYS_ALLOCATION_SIZE);
}

FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_cache_or_dealloc)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c) {
#if FIO_MEMORY_CACHE_SLOTS
  /* place in cache...? */
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos <
      FIO_MEMORY_CACHE_SLOTS) {
    FIO_MEMORY_ON_CHUNK_CACHE(c);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)
        ->cache.a[FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos++] = c;
    c = NULL;
  }
#endif /* FIO_MEMORY_CACHE_SLOTS */

  FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)(c);
}

FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_free)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c) {
  /* should we free the chunk? */
  if (!c || fio_atomic_sub_fetch(&c->ref, 1)) {
    FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
    return;
  }

  /* remove all blocks from the block allocation list */
  for (size_t b = 0; b < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++b) {
    FIO_LIST_NODE *n =
        (FIO_LIST_NODE *)FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0);
    if (n->prev && n->next) {
      FIO_LIST_REMOVE(n);
      n->prev = n->next = NULL;
    }
  }
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_cache_or_dealloc)(c);
}

/* SublimeText marker */
void fio___mem_chunk_new___(void);
/* UNSAFE! returns a clean chunk (cache / allocation). */
FIO_IFUNC FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_new)(const size_t needs_lock) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c = NULL;
#if FIO_MEMORY_CACHE_SLOTS
  /* cache allocation */
  if (needs_lock) {
    FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  }
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos) {
    c = FIO_NAME(FIO_MEMORY_NAME, __mem_state)
            ->cache.a[--FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos];
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)
        ->cache.a[FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos] = NULL;
  }
  if (needs_lock) {
    FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  }
  if (c) {
    FIO_MEMORY_ON_CHUNK_UNCACHE(c);
    *c = (FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s)){.ref = 1};
    return c;
  }
#endif /* FIO_MEMORY_CACHE_SLOTS */

  /* system allocation */
  c = (FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)FIO_MEM_SYS_ALLOC(
      FIO_MEMORY_SYS_ALLOCATION_SIZE,
      FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);

  if (!c)
    return c;
  FIO_MEMORY_ON_CHUNK_ALLOC(c);
  c->ref = 1;
  return c;
  (void)needs_lock; /* in case it isn't used */
}

/* *****************************************************************************
block allocation / deallocation
***************************************************************************** */

FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_block__reset_memory)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c,
    size_t b) {
#if FIO_MEMORY_INITIALIZE_ALLOCATIONS
  if (c->blocks[b].pos >= (int32_t)(FIO_MEMORY_UNITS_PER_BLOCK - 4)) {
    /* zero out the whole block */
    FIO_MEMSET(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0),
               0,
               FIO_MEMORY_BLOCK_SIZE);
  } else {
    /* zero out only the memory that was used */
    FIO_MEMSET(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0),
               0,
               (((size_t)c->blocks[b].pos) << FIO_MEMORY_ALIGN_LOG));
  }
#elif defined(DEBUG) && DEBUG
  /* set all bytes to 0xAF to better catch initialization bugs */
  FIO_MEMSET(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0),
             0xFA,
             FIO_MEMORY_BLOCK_SIZE);
#else
  /** only reset a block's free-list header */
  FIO_MEMSET(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0),
             0,
             (((FIO_MEMORY_ALIGN_SIZE - 1) + sizeof(FIO_LIST_NODE)) &
              (~(FIO_MEMORY_ALIGN_SIZE - 1))));
#endif /*FIO_MEMORY_INITIALIZE_ALLOCATIONS*/
  c->blocks[b].pos = 0;
}

/* SublimeText marker */
void fio___mem_block_free___(void);
/** frees a block / decreases it's reference count */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)(void *p) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
      FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(p);
  if (!c)
    return;
  size_t b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(c, p);
  FIO_ASSERT_DEBUG(
      (uint32_t)c->blocks[b].ref <= FIO_MEMORY_UNITS_PER_BLOCK + 1,
      "(%d) block reference count corrupted, possible double free? (%zd)",
      fio_getpid(),
      (size_t)c->blocks[b].ref);
  FIO_ASSERT_DEBUG(
      (uint32_t)c->blocks[b].pos <= FIO_MEMORY_UNITS_PER_BLOCK + 1,
      "(%d) block allocation position corrupted, possible double free? (%zd)",
      fio_getpid(),
      (size_t)c->blocks[b].pos);
  if (fio_atomic_sub_fetch(&c->blocks[b].ref, 1))
    return;

  /* reset memory */
  FIO_NAME(FIO_MEMORY_NAME, __mem_block__reset_memory)(c, b);

  if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state))
    return; /* leak if arena already freed*/

  /* place in free list */
  FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  FIO_LIST_NODE *n =
      (FIO_LIST_NODE *)FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0);
  FIO_LIST_PUSH(&FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks, n);
  /* free chunk reference while in locked state */
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_free)(c);
}

/* SublimeText marker */
void fio___mem_block_new___(void);
/** returns a new block with a reference count of 1 */
FIO_IFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)(void) {
  void *p = NULL;
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c = NULL;
  size_t b = 0;

  FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);

  /* try to collect from list */
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.prev !=
      &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks) {
    FIO_LIST_NODE *n = FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.prev;
    FIO_LIST_REMOVE(n);
    n->next = n->prev = NULL;
    c = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)((void *)n);
    fio_atomic_add_fetch(&c->ref, 1);
    p = (void *)n;
    b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(c, p);
    goto done;
  }

  /* allocate from cache / system (sets chunk reference to 1) */
  c = FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_new)(0);
  if (!c)
    goto done;

  /* use the first block in the chunk as the new block */
  p = FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, 0, 0);

  /* place the rest of the blocks in the block allocation list */
  for (b = 1; b < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++b) {
    FIO_LIST_NODE *n =
        (FIO_LIST_NODE *)FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0);
    FIO_LIST_PUSH(&FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks, n);
  }
  /* set block index to zero */
  b = 0;

done:
  FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  if (!p)
    return p;
  /* update block reference and allocation position */
  c->blocks[b].ref = 1;
  c->blocks[b].pos = 0;
  return p;
}

/* *****************************************************************************
Small allocation internal API
***************************************************************************** */

/* SublimeText marker */
void fio___mem_slice_new___(void);
/** slice a block to allocate a set number of bytes. */
FIO_SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                           __mem_slice_new)(size_t bytes,
                                                            void *is_realloc) {
  void *p = NULL;
  bytes = (bytes + ((1UL << FIO_MEMORY_ALIGN_LOG) - 1)) >> FIO_MEMORY_ALIGN_LOG;
  FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s) *a =
      FIO_NAME(FIO_MEMORY_NAME, __mem_arena_lock)();

  if (!a->block) {
    a->block = FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)();
    a->last_pos = 0;
  }
  for (;;) {
    if (!a->block)
      goto no_mem;
    void *const block = a->block;

    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *const c =
        FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(block);
    const size_t b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(c, block);

    /* add allocation reference */
    /* if we are the only thread holding a reference to this block - reset. */
    if (fio_atomic_add(&c->blocks[b].ref, 1) == 1 && c->blocks[b].pos) {
      FIO_NAME(FIO_MEMORY_NAME, __mem_block__reset_memory)(c, b);
      FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK(c, b);
      a->last_pos = 0;
    }

    /* enough space? allocate */
    if (c->blocks[b].pos + bytes < FIO_MEMORY_UNITS_PER_BLOCK) {
      /* a lucky realloc? */
      if (is_realloc &&
          is_realloc ==
              FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, a->last_pos)) {
        c->blocks[b].pos += bytes;
        fio_atomic_sub(&c->blocks[b].ref, 1); /* release reference added */
        FIO_NAME(FIO_MEMORY_NAME, __mem_arena_unlock)(a);
        return is_realloc;
      }
      p = FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, c->blocks[b].pos);
      a->last_pos = c->blocks[b].pos;
      c->blocks[b].pos += bytes;
      FIO_NAME(FIO_MEMORY_NAME, __mem_arena_unlock)(a);
      return p;
    }
    is_realloc = NULL;

    /*
     * allocate a new block before freeing the existing block
     * this prevents the last chunk from de-allocating and reallocating
     */
    a->block = FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)();
    a->last_pos = 0;

    /* release allocation reference added */
    fio_atomic_sub(&c->blocks[b].ref, 1);
    /* release the reference held by the arena (allocator) */
    FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)(block);
  }

no_mem:
  FIO_NAME(FIO_MEMORY_NAME, __mem_arena_unlock)(a);
  errno = ENOMEM;
  return p;
}

/* SublimeText marker */
void fio_____mem_slice_free___(void);
/** slice a block to allocate a set number of bytes. */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_slice_free)(void *p) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)(p);
}

/* *****************************************************************************
big block allocation / de-allocation
***************************************************************************** */
#if FIO_MEMORY_ENABLE_BIG_ALLOC

#define FIO_MEMORY_BIG_BLOCK_MARKER ((~(uint32_t)0) << 2)
#define FIO_MEMORY_BIG_BLOCK_HEADER_SIZE                                       \
  (((sizeof(FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s)) +                    \
     ((FIO_MEMORY_ALIGN_SIZE - 1))) &                                          \
    ((~(0UL)) << FIO_MEMORY_ALIGN_LOG)))

#define FIO_MEMORY_BIG_BLOCK_SIZE                                              \
  (FIO_MEMORY_SYS_ALLOCATION_SIZE - FIO_MEMORY_BIG_BLOCK_HEADER_SIZE)

#define FIO_MEMORY_UNITS_PER_BIG_BLOCK                                         \
  (FIO_MEMORY_BIG_BLOCK_SIZE / FIO_MEMORY_ALIGN_SIZE)

/* SublimeText marker */
void fio___mem_big_block__reset_memory___(void);
/** zeros out a big-block's memory, keeping it's reference count at 1. */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_big_block__reset_memory)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) * b) {

#if FIO_MEMORY_INITIALIZE_ALLOCATIONS
  /* zero out memory */
  if (b->pos >= (int32_t)(FIO_MEMORY_UNITS_PER_BIG_BLOCK - 10)) {
    /* zero out everything */
    FIO_MEMSET((void *)b, 0, FIO_MEMORY_SYS_ALLOCATION_SIZE);
  } else {
    /* zero out only the used part of the memory */
    FIO_MEMSET((void *)b,
               0,
               (((size_t)b->pos << FIO_MEMORY_ALIGN_LOG) +
                FIO_MEMORY_BIG_BLOCK_HEADER_SIZE));
  }
#else
#if defined(DEBUG) && DEBUG
  /* set all bytes to 0xAF to better catch initialization bugs */
  FIO_MEMSET((void *)b, 0xFA, FIO_MEMORY_SYS_ALLOCATION_SIZE);
#endif /* DEBUG */
  /* reset chunk header, which is always bigger than big_block header*/
  FIO_MEMSET((void *)b, 0, sizeof(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s)));
  /* zero out possible block memory (if required) */
  for (size_t i = 0; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_block__reset_memory)
    ((FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)b, i);
  }
#endif /* FIO_MEMORY_INITIALIZE_ALLOCATIONS */
  b->ref = 1;
}

/* SublimeText marker */
void fio___mem_big_block_free___(void);
/** frees a block / decreases it's reference count */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)(void *p) {
  // FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s)      ;
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *b =
      (FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *)
          FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(p);
  /* should we free the block? */
  if (!b || fio_atomic_sub_fetch(&b->ref, 1))
    return;
  FIO_MEMORY_ON_BIG_BLOCK_UNSET(b);

  /* zero out memory */
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block__reset_memory)(b);
#if FIO_MEMORY_CACHE_SLOTS
  /* lock for chunk de-allocation review () */
  FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_cache_or_dealloc)
  ((FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)b);
#else
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)
  ((FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)b);
#endif
}

/* SublimeText marker */
void fio___mem_big_block_new___(void);
/** returns a new block with a reference count of 1 */
FIO_IFUNC FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_new)(void) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *b =
      (FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *)
          FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_new)(1);
  if (!b)
    goto no_mem;
  b->marker = FIO_MEMORY_BIG_BLOCK_MARKER;
  b->ref = 1;
  b->pos = 0;
  FIO_MEMORY_ON_BIG_BLOCK_SET(b);
  return b;
no_mem:
  errno = ENOMEM;
  return b;
}

/* *****************************************************************************
Big allocation internal API
***************************************************************************** */

/* SublimeText marker */
void fio___mem_big2ptr___(void);
/** returns a pointer within a chunk, given it's block and offset value. */
FIO_IFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_big2ptr)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) * b,
    size_t offset) {
  return (void *)(((uintptr_t)(b) + FIO_MEMORY_BIG_BLOCK_HEADER_SIZE) +
                  (offset << FIO_MEMORY_ALIGN_LOG));
}

/* SublimeText marker */
void fio___mem_big_slice_new___(void);
FIO_SFUNC void *FIO_MEM_ALIGN_NEW
FIO_NAME(FIO_MEMORY_NAME, __mem_big_slice_new)(size_t bytes, void *is_realloc) {
  void *p = NULL;
  bytes = (bytes + ((1UL << FIO_MEMORY_ALIGN_LOG) - 1)) >> FIO_MEMORY_ALIGN_LOG;
  for (;;) {
    FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
    if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block) {
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block =
          FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_new)();
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos = 0;
    }

    if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block)
      goto done;
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *b =
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block;

    /* are we the only thread holding a reference to this block... reset? */
    if (b->ref == 1 && b->pos) {
      FIO_NAME(FIO_MEMORY_NAME, __mem_big_block__reset_memory)(b);
      FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK(b, 0);
      b->marker = FIO_MEMORY_BIG_BLOCK_MARKER;
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos = 0;
    }

    /* enough space? */
    if (b->pos + bytes < FIO_MEMORY_UNITS_PER_BIG_BLOCK) {
      /* a lucky realloc? */
      if (is_realloc &&
          is_realloc ==
              FIO_NAME(FIO_MEMORY_NAME, __mem_big2ptr)(
                  b,
                  FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos)) {
        b->pos += bytes;
        FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
        return is_realloc;
      }

      p = FIO_NAME(FIO_MEMORY_NAME, __mem_big2ptr)(b, b->pos);
      fio_atomic_add(&b->ref, 1); /* keep inside lock to enable reset */
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos = b->pos;
      b->pos += bytes;
      FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
      return p;
    }

    is_realloc = NULL;
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block = NULL;
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos = 0;
    FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)(b);
  }
done:
  FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
  return p;
}

/* SublimeText marker */
void fio_____mem_big_slice_free___(void);
/** slice a block to allocate a set number of bytes. */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_big_slice_free)(void *p) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)(p);
}

#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */
/* *****************************************************************************
Memory Allocation - malloc(0) pointer
***************************************************************************** */

static long double FIO_NAME(
    FIO_MEMORY_NAME,
    malloc_zero)[(FIO_MEMORY_ALIGN_SIZE / sizeof(long double)) + 1];

#define FIO_MEMORY_MALLOC_ZERO_POINTER                                         \
  ((void *)(((uintptr_t)FIO_NAME(FIO_MEMORY_NAME, malloc_zero) +               \
             (FIO_MEMORY_ALIGN_SIZE - 1)) &                                    \
            ((~(uintptr_t)0) << FIO_MEMORY_ALIGN_LOG)))

/* *****************************************************************************
Memory Allocation - API implementation - debugging and info
***************************************************************************** */

/* SublimeText marker */
void fio_malloc_block_size___(void);
/* public API obligation */
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_block_size)(void) {
  return FIO_MEMORY_BLOCK_SIZE;
}

void fio_malloc_arenas___(void);
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_arenas)(void) {
  return FIO_NAME(FIO_MEMORY_NAME, __mem_state)
             ? FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count
             : 0;
}

SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings)(void) {
  // FIO_LOG_DEBUG2(
  fprintf(
      stderr,
      "Custom memory allocator " FIO_MACRO2STR(FIO_NAME(
          FIO_MEMORY_NAME,
          malloc)) " initialized with:\n"
                   "\t* system allocation arenas:                 %zu arenas\n"
                   "\t* system allocation size:                   %zu bytes\n"
                   "\t* system allocation overhead (theoretical): %zu bytes\n"
                   "\t* system allocation overhead (actual):      %zu bytes\n"
                   "\t* cached system allocations (max):          %zu units\n"
                   "\t* memory block size:                        %zu bytes\n"
                   "\t* blocks per system allocation:             %zu blocks\n"
                   "\t* allocation units per block:               %zu units\n"
                   "\t* arena per-allocation limit:               %zu bytes\n"
                   "\t* local per-allocation limit (before mmap): %zu bytes\n"
                   "\t* allocation alignment (non-zero):          %zu bytes\n"
                   "\t* malloc(0) pointer:                        %p\n"
                   "\t* always initializes memory  (zero-out):    %s\n"
                   "\t* " FIO_MEMORY_LOCK_NAME " locking system\n",
      (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count,
      (size_t)FIO_MEMORY_SYS_ALLOCATION_SIZE,
      (size_t)FIO_MEMORY_HEADER_SIZE,
      (size_t)FIO_MEMORY_SYS_ALLOCATION_SIZE % (size_t)FIO_MEMORY_BLOCK_SIZE,
      (size_t)FIO_MEMORY_CACHE_SLOTS,
      (size_t)FIO_MEMORY_BLOCK_SIZE,
      (size_t)FIO_MEMORY_BLOCKS_PER_ALLOCATION,
      (size_t)FIO_MEMORY_UNITS_PER_BLOCK,
      (size_t)FIO_MEMORY_BLOCK_ALLOC_LIMIT,
      (size_t)FIO_MEMORY_ALLOC_LIMIT,
      (size_t)FIO_MEMORY_ALIGN_SIZE,
      FIO_MEMORY_MALLOC_ZERO_POINTER,
      (FIO_MEMORY_INITIALIZE_ALLOCATIONS ? "true" : "false"));
}

/* *****************************************************************************
Malloc implementation
***************************************************************************** */

/* SublimeText marker */
void fio___malloc__(void);
/**
 * Allocates memory using a per-CPU core block memory pool.
 * Memory is zeroed out.
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 *
 * `mempool_malloc` promises a best attempt at providing locality between
 * consecutive calls, but locality can't be guaranteed.
 */
FIO_IFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                           ___malloc)(size_t size,
                                                      void *is_realloc) {
  void *p = NULL;
  if (!size)
    goto malloc_zero;

#if FIO_MEMORY_ENABLE_BIG_ALLOC
  if ((is_realloc && size > (FIO_MEMORY_BIG_BLOCK_SIZE -
                             (FIO_MEMORY_BIG_BLOCK_HEADER_SIZE << 1))) ||
      (!is_realloc && size > FIO_MEMORY_ALLOC_LIMIT))
#else
  if (!is_realloc && size > FIO_MEMORY_ALLOC_LIMIT)
#endif
  {
#ifdef DEBUG
    FIO_LOG_WARNING(
        "(%d) unintended " FIO_MACRO2STR(
            FIO_NAME(FIO_MEMORY_NAME, mmap)) " allocation (slow): %zu bytes",
        fio_getpid(),
        FIO_MEM_BYTES2PAGES(size));
#endif
    p = FIO_NAME(FIO_MEMORY_NAME, mmap)(size);
    return p;
  }
  if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_state_setup)();
  }
#if FIO_MEMORY_ENABLE_BIG_ALLOC
  if ((is_realloc &&
       size > FIO_MEMORY_BLOCK_SIZE - (2 << FIO_MEMORY_ALIGN_LOG)) ||
      (!is_realloc && size > FIO_MEMORY_BLOCK_ALLOC_LIMIT)) {
    p = FIO_NAME(FIO_MEMORY_NAME, __mem_big_slice_new)(size, is_realloc);
    if (p && p != is_realloc) {
      FIO_MEMORY_ON_ALLOC_FUNC();
    }
    return p;
  }
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

  p = FIO_NAME(FIO_MEMORY_NAME, __mem_slice_new)(size, is_realloc);
  if (p && p != is_realloc) {
    FIO_MEMORY_ON_ALLOC_FUNC();
  }
  return p;
malloc_zero:
  p = FIO_MEMORY_MALLOC_ZERO_POINTER;
  return p;
}

/* *****************************************************************************
Memory Allocation - API implementation
***************************************************************************** */

/* SublimeText marker */
void fio_malloc__(void);
/**
 * Allocates memory using a per-CPU core block memory pool.
 * Memory is zeroed out.
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 *
 * `mempool_malloc` promises a best attempt at providing locality between
 * consecutive calls, but locality can't be guaranteed.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, malloc)(size_t size) {
  void *p = FIO_NAME(FIO_MEMORY_NAME, ___malloc)(size, NULL);
#if !FIO_MEMORY_INITIALIZE_ALLOCATIONS && defined(DEBUG) && DEBUG
  /* set all bytes to 0xAF to better catch initialization bugs */
  FIO_MEMSET(p, 0xFA, size);
#endif /* DEBUG dirtify */
  return p;
}

/* SublimeText marker */
void fio_calloc__(void);
/**
 * same as calling `fio_malloc(size_per_unit * unit_count)`;
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                       calloc)(size_t size_per_unit,
                                               size_t unit_count) {
  const size_t total = size_per_unit * unit_count;
  if (total < size_per_unit || total < unit_count)
    return NULL; /* test for size overflow */
#if FIO_MEMORY_INITIALIZE_ALLOCATIONS
  return FIO_NAME(FIO_MEMORY_NAME, malloc)(total);
#else
  void *p;
  /* round up to alignment size. */
  const size_t len = ((total) + (FIO_MEMORY_ALIGN_SIZE - 1)) &
                     (~((size_t)FIO_MEMORY_ALIGN_SIZE - 1));
  p = FIO_NAME(FIO_MEMORY_NAME, malloc)(len);
  /* initialize memory only when required */
  FIO_MEMSET(p, 0, len);
  return p;
#endif /* FIO_MEMORY_INITIALIZE_ALLOCATIONS */
}

/* SublimeText marker */
void fio_free__(void);
/** Frees memory that was allocated using this library. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, free)(void *ptr) {
  if (!ptr || ptr == FIO_MEMORY_MALLOC_ZERO_POINTER)
    return;
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
      FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(ptr);
  if (!c) {
    FIO_LOG_ERROR(FIO_MACRO2STR(
        FIO_NAME(FIO_MEMORY_NAME,
                 free)) " attempting to free a pointer owned by a NULL chunk.");
    return;
  }
  FIO_MEMORY_ON_FREE_FUNC();

#if FIO_MEMORY_ENABLE_BIG_ALLOC
  if (c->marker == FIO_MEMORY_BIG_BLOCK_MARKER) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_slice_free)(ptr);
    return;
  }
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

  /* big mmap allocation? */
  if (((uintptr_t)c + FIO_MEMORY_ALIGN_SIZE) == (uintptr_t)ptr && c->marker)
    goto mmap_free;

  FIO_NAME(FIO_MEMORY_NAME, __mem_slice_free)(ptr);
  return;

mmap_free:
  /* zero out memory before returning it to the system */
  FIO_MEMSET(ptr,
             0,
             ((size_t)c->marker << FIO_MEM_PAGE_SIZE_LOG) -
                 FIO_MEMORY_ALIGN_SIZE);
  FIO_MEMORY_ON_CHUNK_FREE(c);
  FIO_MEM_SYS_FREE(c, (size_t)c->marker << FIO_MEM_PAGE_SIZE_LOG);
}

/* SublimeText marker */
void fio_realloc__(void);
/**
 * Re-allocates memory. An attempt to avoid copying the data is made only for
 * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).
 */
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc)(void *ptr,
                                                             size_t new_size) {
  return FIO_NAME(FIO_MEMORY_NAME, realloc2)(ptr, new_size, new_size);
}

/**
 * Uses system page maps for reallocation.
 */
FIO_SFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_realloc2_big)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c,
    size_t new_size) {
  const size_t new_len = FIO_MEM_BYTES2PAGES(new_size + FIO_MEMORY_ALIGN_SIZE);
  c = (FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)FIO_MEM_SYS_REALLOC(
      c,
      (size_t)c->marker << FIO_MEM_PAGE_SIZE_LOG,
      new_len,
      FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);
  if (!c)
    return NULL;
  c->marker = (uint32_t)(new_len >> FIO_MEM_PAGE_SIZE_LOG);
  return (void *)((uintptr_t)c + FIO_MEMORY_ALIGN_SIZE);
}

/* SublimeText marker */
void fio_realloc2__(void);
/**
 * Re-allocates memory. An attempt to avoid copying the data is made only for
 * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).
 *
 * This variation is slightly faster as it might copy less data.
 */
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc2)(void *ptr,
                                                              size_t new_size,
                                                              size_t copy_len) {
  void *mem = NULL;
  if (!new_size)
    goto act_as_free;
  if (!ptr || ptr == FIO_MEMORY_MALLOC_ZERO_POINTER)
    goto act_as_malloc;

  { /* test for big-paged malloc and limit copy_len */
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
        FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(ptr);
    size_t b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(c, ptr);
    FIO_ASSERT(c,
               "(%d) cannot reallocate a pointer with a NULL system allocation",
               fio_getpid());

    register size_t max_len =
        ((uintptr_t)FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0) +
         FIO_MEMORY_BLOCK_SIZE) -
        ((uintptr_t)ptr);
#if FIO_MEMORY_ENABLE_BIG_ALLOC
    if (c->marker == FIO_MEMORY_BIG_BLOCK_MARKER) {
      /* extend max_len to accommodate possible length */
      max_len =
          ((uintptr_t)c + FIO_MEMORY_SYS_ALLOCATION_SIZE) - ((uintptr_t)ptr);
    } else
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */
      if ((uintptr_t)(c) + FIO_MEMORY_ALIGN_SIZE == (uintptr_t)ptr &&
          c->marker) {
        if (new_size > FIO_MEMORY_ALLOC_LIMIT)
          return (
              mem = FIO_NAME(FIO_MEMORY_NAME, __mem_realloc2_big)(c, new_size));
        max_len = new_size; /* shrinking from mmap to allocator */
      }

    if (copy_len > max_len)
      copy_len = max_len;
    if (copy_len > new_size)
      copy_len = new_size;
  }

  mem = FIO_NAME(FIO_MEMORY_NAME, ___malloc)(new_size, ptr);
  if (!mem || mem == ptr) {
    return mem;
  }

  /* when allocated from the same block, the max length might be adjusted */
  if ((uintptr_t)mem > (uintptr_t)ptr &&
      (uintptr_t)ptr + copy_len >= (uintptr_t)mem) {
    copy_len = (uintptr_t)mem - (uintptr_t)ptr;
  }

  FIO_MEMCPY(mem,
             ptr,
             ((copy_len + (FIO_MEMORY_ALIGN_SIZE - 1)) &
              ((~(size_t)0) << FIO_MEMORY_ALIGN_LOG)));
  // zero out leftover bytes, if any.
  while (copy_len & (FIO_MEMORY_ALIGN_SIZE - 1)) {
    ((uint8_t *)mem)[copy_len++] = 0;
  }

  FIO_NAME(FIO_MEMORY_NAME, free)(ptr);

  return mem;

act_as_malloc:
  mem = FIO_NAME(FIO_MEMORY_NAME, ___malloc)(new_size, NULL);
  return mem;

act_as_free:
  FIO_NAME(FIO_MEMORY_NAME, free)(ptr);
  mem = FIO_MEMORY_MALLOC_ZERO_POINTER;
  return mem;
}

/* SublimeText marker */
void fio_mmap__(void);
/**
 * Allocates memory directly using `mmap`, this is preferred for objects that
 * both require almost a page of memory (or more) and expect a long lifetime.
 *
 * However, since this allocation will invoke the system call (`mmap`), it will
 * be inherently slower.
 *
 * `mempoll_free` can be used for deallocating the memory.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, mmap)(size_t size) {
  if (!size)
    return FIO_NAME(FIO_MEMORY_NAME, malloc)(0);
  size_t pages = FIO_MEM_BYTES2PAGES(size + FIO_MEMORY_ALIGN_SIZE);
  if (((uint64_t)pages >> (31 + FIO_MEM_PAGE_SIZE_LOG)))
    return NULL;
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
      (FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)
          FIO_MEM_SYS_ALLOC(pages, FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);
  if (!c)
    goto no_mem;
  FIO_MEMORY_ON_ALLOC_FUNC();
  FIO_MEMORY_ON_CHUNK_ALLOC(c);
  c->marker = (uint32_t)(pages >> FIO_MEM_PAGE_SIZE_LOG);
  return (void *)((uintptr_t)c + FIO_MEMORY_ALIGN_SIZE);
no_mem:
  errno = ENOMEM;
  return NULL;
}

/* *****************************************************************************
Override the system's malloc functions if required
***************************************************************************** */
#if defined(FIO_MALLOC_OVERRIDE_SYSTEM) && !defined(H___FIO_MALLOC_OVERRIDE___H)
#define H___FIO_MALLOC_OVERRIDE___H
void *malloc(size_t size) { return FIO_NAME(FIO_MEMORY_NAME, malloc)(size); }
void *calloc(size_t size, size_t count) {
  return FIO_NAME(FIO_MEMORY_NAME, calloc)(size, count);
}
void free(void *ptr) { FIO_NAME(FIO_MEMORY_NAME, free)(ptr); }
void *realloc(void *ptr, size_t new_size) {
  return FIO_NAME(FIO_MEMORY_NAME, realloc2)(ptr, new_size, new_size);
}
#endif /* FIO_MALLOC_OVERRIDE_SYSTEM */
#undef FIO_MALLOC_OVERRIDE_SYSTEM

/* *****************************************************************************





Memory Allocation - test - tests specific allocator settings





***************************************************************************** */
#ifdef FIO_TEST_ALL

#ifndef H___FIO_TEST_MEMORY_HELPERS_H
#define H___FIO_TEST_MEMORY_HELPERS_H

FIO_IFUNC void fio___memset_test_aligned(void *restrict dest_,
                                         uint64_t data,
                                         size_t bytes,
                                         const char *msg) {
  uint8_t *r = (uint8_t *)dest_;
  uint8_t *e_group = r + (bytes & (~(size_t)63ULL));
  uint64_t d[8] = {data, data, data, data, data, data, data, data};
  while (r < e_group) {
    fio_memcpy64(d, r);
    FIO_ASSERT(d[0] == data && d[1] == data && d[2] == data && d[3] == data &&
                   d[4] == data && d[5] == data && d[6] == data && d[7] == data,
               "%s memory data was overwritten",
               msg);
    r += 64;
  }
  fio_memcpy63x(d, r, bytes);
  FIO_ASSERT(d[0] == data && d[1] == data && d[2] == data && d[3] == data &&
                 d[4] == data && d[5] == data && d[6] == data && d[7] == data,
             "%s memory data was overwritten",
             msg);
  (void)msg; /* in case FIO_ASSERT is disabled */
}
#endif /* H___FIO_TEST_MEMORY_HELPERS_H */

#ifndef FIO_TEST_MULTI_THREADED
#define FIO_TEST_MULTI_THREADED 0
#endif

/* contention testing (multi-threaded) */
FIO_IFUNC void *FIO_NAME_TEST(FIO_NAME(FIO_MEMORY_NAME, fio),
                              mem_tsk)(void *i_) {
  uintptr_t cycles = (uintptr_t)i_;
  const size_t test_byte_count =
      FIO_MEMORY_SYS_ALLOCATION_SIZE + (FIO_MEMORY_SYS_ALLOCATION_SIZE >> 1);
  uint64_t marker[2];
  do {
    marker[0] = fio_rand64();
    marker[1] = fio_rand64();
  } while (!marker[0] || !marker[1] || marker[0] == marker[1]);

  const size_t limit = (test_byte_count / cycles);
  char **ary = (char **)FIO_NAME(FIO_MEMORY_NAME, calloc)(sizeof(*ary), limit);
  const uintptr_t alignment_mask = (FIO_MEMORY_ALIGN_SIZE - 1);
  FIO_ASSERT(ary, "allocation failed for test container");
  for (size_t i = 0; i < limit; ++i) {
    if (1) {
      /* add some fragmentation */
      char *tmp = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(16);
      FIO_NAME(FIO_MEMORY_NAME, free)(tmp);
      FIO_ASSERT(tmp, "small allocation failed!");
      FIO_ASSERT(!((uintptr_t)tmp & alignment_mask),
                 "allocation alignment error!");
    }
    ary[i] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
    FIO_ASSERT(ary[i], "allocation failed!");
    FIO_ASSERT(!((uintptr_t)ary[i] & alignment_mask),
               "allocation alignment error!");
    FIO_ASSERT(!FIO_MEMORY_INITIALIZE_ALLOCATIONS || !ary[i][(cycles - 1)],
               "allocated memory not zero (end): %p",
               (void *)ary[i]);
    FIO_ASSERT(!FIO_MEMORY_INITIALIZE_ALLOCATIONS || !ary[i][0],
               "allocated memory not zero (start): %p",
               (void *)ary[i]);
    FIO_MEMSET(ary[i], 0, cycles);
    fio_xmask(ary[i], cycles, marker[i & 1]);
  }
  for (size_t i = 0; i < limit; ++i) {
    char *tmp = (char *)FIO_NAME(FIO_MEMORY_NAME,
                                 realloc2)(ary[i], (cycles << 1), (cycles));
    FIO_ASSERT(tmp, "re-allocation failed!");
    ary[i] = tmp;
    FIO_ASSERT(!((uintptr_t)ary[i] & alignment_mask),
               "allocation alignment error!");
    FIO_ASSERT(!FIO_MEMORY_INITIALIZE_ALLOCATIONS || !ary[i][(cycles)],
               "realloc2 copy overflow!");
    fio___memset_test_aligned(ary[i], marker[i & 1], (cycles), "realloc grow");
    tmp =
        (char *)FIO_NAME(FIO_MEMORY_NAME, realloc2)(ary[i], (cycles), (cycles));
    FIO_ASSERT(tmp, "re-allocation (shrinking) failed!");
    ary[i] = tmp;
    fio___memset_test_aligned(ary[i],
                              marker[i & 1],
                              (cycles),
                              "realloc shrink");
  }
  for (size_t i = 0; i < limit; ++i) {
    fio___memset_test_aligned(ary[i], marker[i & 1], (cycles), "mem review");
    FIO_NAME(FIO_MEMORY_NAME, free)(ary[i]);
    ary[i] = NULL;
  }

  uint64_t mark;
  void *old = &mark;
  mark = fio_risky_hash(&old, sizeof(mark), 0);

  for (size_t repeat_cycle_test = 0; repeat_cycle_test < 4;
       ++repeat_cycle_test) {
    for (size_t i = 0; i < limit - 4; i += 4) {
      if (ary[i])
        fio___memset_test_aligned(ary[i], mark, 16, "mark missing at ary[0]");
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i]);
      if (ary[i + 1])
        fio___memset_test_aligned(ary[i + 1],
                                  mark,
                                  cycles,
                                  "mark missing at ary[1]");
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 1]);
      if (ary[i + 2])
        fio___memset_test_aligned(ary[i + 2],
                                  mark,
                                  cycles,
                                  "mark missing at ary[2]");
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 2]);
      if (ary[i + 3])
        fio___memset_test_aligned(ary[i + 3],
                                  mark,
                                  cycles,
                                  "mark missing at ary[3]");
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 3]);

      ary[i] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      FIO_MEMSET(ary[i], 0, cycles);
      fio_xmask(ary[i], cycles, mark);

      ary[i + 1] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 1]);
      ary[i + 1] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      FIO_MEMSET(ary[i + 1], 0, cycles);
      fio_xmask(ary[i + 1], cycles, mark);

      ary[i + 2] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      FIO_MEMSET(ary[i + 2], 0, cycles);
      fio_xmask(ary[i + 2], cycles, mark);
      ary[i + 2] = (char *)FIO_NAME(FIO_MEMORY_NAME,
                                    realloc2)(ary[i + 2], cycles * 2, cycles);

      ary[i + 3] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 3]);
      ary[i + 3] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      FIO_MEMSET(ary[i + 3], 0, cycles);
      fio_xmask(ary[i + 3], cycles, mark);
      ary[i + 3] = (char *)FIO_NAME(FIO_MEMORY_NAME,
                                    realloc2)(ary[i + 3], cycles * 2, cycles);

      for (size_t b = 0; b < 4; ++b) {
        for (size_t pos = 0; pos < (cycles / sizeof(uint64_t)); ++pos) {
          FIO_ASSERT(((uint64_t *)(ary[i + b]))[pos] == mark,
                     "memory mark corrupted at test ptr %zu",
                     i + b);
        }
      }
      for (size_t b = 1; b < 4; ++b) {
        FIO_NAME(FIO_MEMORY_NAME, free)(ary[b]);
        ary[b] = NULL;
        FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + b]);
      }
      for (size_t b = 1; b < 4; ++b) {
        ary[i + b] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
        if (i) {
          ary[b] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
          FIO_MEMSET(ary[b], 0, cycles);
          fio_xmask(ary[b], cycles, mark);
        }
        FIO_MEMSET(ary[i + b], 0, cycles);
        fio_xmask(ary[i + b], cycles, mark);
      }

      for (size_t b = 0; b < 4; ++b) {
        for (size_t pos = 0; pos < (cycles / sizeof(uint64_t)); ++pos) {
          FIO_ASSERT(((uint64_t *)(ary[b]))[pos] == mark,
                     "memory mark corrupted at test ptr %zu",
                     i + b);
          FIO_ASSERT(((uint64_t *)(ary[i + b]))[pos] == mark,
                     "memory mark corrupted at test ptr %zu",
                     i + b);
        }
      }
    }
  }
  for (size_t i = 0; i < limit; ++i) {
    FIO_NAME(FIO_MEMORY_NAME, free)(ary[i]);
    ary[i] = NULL;
  }

  FIO_NAME(FIO_MEMORY_NAME, free)(ary);
  return NULL;
}

/* main test function */
FIO_SFUNC void FIO_NAME_TEST(FIO_NAME(stl, FIO_MEMORY_NAME), mem)(void) {
  fprintf(stderr,
          "\t* Testing core memory allocator " FIO_MACRO2STR(
              FIO_NAME(FIO_MEMORY_NAME, malloc)) ".\n");

  const uintptr_t alignment_mask = (FIO_MEMORY_ALIGN_SIZE - 1);
  fprintf(stderr,
          "\t* Validating allocation alignment on %zu byte border.\n",
          (size_t)(FIO_MEMORY_ALIGN_SIZE));
  for (size_t i = 0; i < alignment_mask; ++i) {
    void *p = FIO_NAME(FIO_MEMORY_NAME, malloc)(i);
    FIO_ASSERT(!((uintptr_t)p & alignment_mask),
               "allocation alignment error allocating %zu bytes!",
               i);
    FIO_NAME(FIO_MEMORY_NAME, free)(p);
  }
  const size_t thread_count =
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count +
      (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count >> 1);

  for (uintptr_t cycles = 16; cycles <= (FIO_MEMORY_ALLOC_LIMIT); cycles *= 2) {
    fprintf(stderr,
            "\t* Testing %zu byte allocation blocks, single threaded.\n",
            (size_t)(cycles));
    FIO_NAME_TEST(FIO_NAME(FIO_MEMORY_NAME, fio), mem_tsk)((void *)cycles);
  }

  if (FIO_TEST_MULTI_THREADED) {

    for (uintptr_t cycles = 16; cycles <= (FIO_MEMORY_ALLOC_LIMIT);
         cycles *= 2) {
#if _MSC_VER
      fio_thread_t threads[(FIO_MEMORY_ARENA_COUNT_MAX + 1) * 2];
      FIO_ASSERT(((FIO_MEMORY_ARENA_COUNT_MAX + 1) * 2) >= thread_count,
                 "Please use CLang or GCC to test this memory allocator");
#else
      fio_thread_t threads[thread_count];
#endif

      fprintf(stderr,
              "\t* Testing %zu byte allocation blocks, using %zu threads.\n",
              (size_t)(cycles),
              (thread_count + 1));
      for (size_t i = 0; i < thread_count; ++i) {
        if (fio_thread_create(
                threads + i,
                FIO_NAME_TEST(FIO_NAME(FIO_MEMORY_NAME, fio), mem_tsk),
                (void *)cycles)) {
          abort();
        }
      }
      FIO_NAME_TEST(FIO_NAME(FIO_MEMORY_NAME, fio), mem_tsk)((void *)cycles);
      for (size_t i = 0; i < thread_count; ++i) {
        fio_thread_join(threads + i);
      }
    }
  }
  fprintf(stderr,
          "\t* Re-validating allocation alignment on %zu byte border.\n",
          (size_t)(FIO_MEMORY_ALIGN_SIZE));
  for (size_t i = 0; i < alignment_mask; ++i) {
    void *p = FIO_NAME(FIO_MEMORY_NAME, malloc)(i);
    FIO_ASSERT(!((uintptr_t)p & alignment_mask),
               "allocation alignment error allocating %zu bytes!",
               i);
    FIO_NAME(FIO_MEMORY_NAME, free)(p);
  }

#if DEBUG
  FIO_NAME(FIO_MEMORY_NAME, malloc_print_state)();
  FIO_NAME(FIO_MEMORY_NAME, __mem_state_cleanup)(NULL);
#endif /* DEBUG */
}
#endif /* FIO_TEST_ALL */

/* *****************************************************************************
Memory pool cleanup
***************************************************************************** */
#undef FIO_MEM_ALIGN
#undef FIO_MEM_ALIGN_NEW
#undef FIO_MEMORY_MALLOC_ZERO_POINTER

#endif /* FIO_MEMORY_DISABLE */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_MEMORY_NAME */

#undef FIO_MEMORY_ON_CHUNK_ALLOC
#undef FIO_MEMORY_ON_CHUNK_FREE
#undef FIO_MEMORY_ON_CHUNK_CACHE
#undef FIO_MEMORY_ON_CHUNK_UNCACHE
#undef FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK
#undef FIO_MEMORY_ON_BIG_BLOCK_SET
#undef FIO_MEMORY_ON_BIG_BLOCK_UNSET
#undef FIO_MEMORY_ON_ALLOC_FUNC
#undef FIO_MEMORY_ON_FREE_FUNC
#undef FIO_MEMORY_PRINT_STATS_END

#undef FIO_MEMORY_ARENA_COUNT
#undef FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG
#undef FIO_MEMORY_CACHE_SLOTS
#undef FIO_MEMORY_ALIGN_LOG
#undef FIO_MEMORY_INITIALIZE_ALLOCATIONS
#undef FIO_MEMORY_USE_THREAD_MUTEX
#undef FIO_MEMORY_BLOCK_SIZE
#undef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
#undef FIO_MEMORY_BLOCKS_PER_ALLOCATION
#undef FIO_MEMORY_ENABLE_BIG_ALLOC
// #undef FIO_MEMORY_ARENA_COUNT_FALLBACK
// #undef FIO_MEMORY_ARENA_COUNT_MAX
#undef FIO_MEMORY_WARMUP

#undef FIO_MEMORY_LOCK_NAME
#undef FIO_MEMORY_LOCK_TYPE
#undef FIO_MEMORY_LOCK_TYPE_INIT
#undef FIO_MEMORY_TRYLOCK
#undef FIO_MEMORY_LOCK
#undef FIO_MEMORY_UNLOCK

/* don't undefine FIO_MEMORY_NAME due to possible use in allocation macros */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_POLL               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                            POSIX Portable Polling



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_POLL) && !defined(H___FIO_POLL___H) &&                         \
    !defined(FIO___RECURSIVE_INCLUDE)

#ifndef FIO_POLL_POSSIBLE_FLAGS
/** The user flags IO events recognize */
#define FIO_POLL_POSSIBLE_FLAGS (POLLIN | POLLOUT | POLLPRI)
#endif

#ifndef FIO_POLL_MAX_EVENTS
#if UINTPTR_MAX <= 0xFFFFFFFF
/** relevant only for epoll and kqueue - maximum number of events per review */
#define FIO_POLL_MAX_EVENTS 256
#else
/** relevant only for epoll and kqueue - maximum number of events per review */
#define FIO_POLL_MAX_EVENTS 128
#endif
#endif

/* *****************************************************************************
Possible polling engine (system call) selection
***************************************************************************** */

#ifndef FIO_POLL_ENGINE_POLL
/** define `FIO_POLL_ENGINE` as `FIO_POLL_ENGINE_POLL` to use `poll` */
#define FIO_POLL_ENGINE_POLL 1
#endif
#ifndef FIO_POLL_ENGINE_EPOLL
/** define `FIO_POLL_ENGINE` as `FIO_POLL_ENGINE_EPOLL` to use `epoll` */
#define FIO_POLL_ENGINE_EPOLL 2
#endif
#ifndef FIO_POLL_ENGINE_KQUEUE
/** define `FIO_POLL_ENGINE` as `FIO_POLL_ENGINE_KQUEUE` to use `kqueue` */
#define FIO_POLL_ENGINE_KQUEUE 3
#endif

/* if `FIO_POLL_ENGINE` wasn't define, detect automatically. */
#if !defined(FIO_POLL_ENGINE)
#if defined(HAVE_EPOLL) || __has_include("sys/epoll.h")
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_EPOLL
#elif (defined(HAVE_KQUEUE) || __has_include("sys/event.h"))
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_KQUEUE
#else
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_POLL
#endif
#endif /* FIO_POLL_ENGINE */

#if FIO_POLL_ENGINE == FIO_POLL_ENGINE_POLL
#ifndef FIO_POLL_ENGINE_STR
#define FIO_POLL_ENGINE_STR "poll"
#endif
#elif FIO_POLL_ENGINE == FIO_POLL_ENGINE_EPOLL
#ifndef FIO_POLL_ENGINE_STR
#define FIO_POLL_ENGINE_STR "epoll"
#endif
#elif FIO_POLL_ENGINE == FIO_POLL_ENGINE_KQUEUE
#ifndef FIO_POLL_ENGINE_STR
#define FIO_POLL_ENGINE_STR "kqueue"
#endif
#endif
/* *****************************************************************************
Polling API
***************************************************************************** */

/** the `fio_poll_s` type should be considered opaque. */
typedef struct fio_poll_s fio_poll_s;

typedef struct {
  /** callback for when data is available in the incoming buffer. */
  void (*on_data)(void *udata);
  /** callback for when the outgoing buffer allows a call to `write`. */
  void (*on_ready)(void *udata);
  /** callback for closed connections and / or connections with errors. */
  void (*on_close)(void *udata);
} fio_poll_settings_s;

/** Initializes the polling object, allocating its resources. */
FIO_IFUNC void fio_poll_init(fio_poll_s *p, fio_poll_settings_s);
/** Initializes the polling object, allocating its resources. */
#define fio_poll_init(p, ...)                                                  \
  fio_poll_init((p), (fio_poll_settings_s){__VA_ARGS__})

/** Destroys the polling object, freeing its resources. */
FIO_IFUNC void fio_poll_destroy(fio_poll_s *p);

/** returns the system call used for polling as a constant string. */
FIO_IFUNC const char *fio_poll_engine(void);

/**
 * Adds a file descriptor to be monitored, adds events to be monitored or
 * updates the monitored file's `udata`.
 *
 * Possible flags are: `POLLIN` and `POLLOUT`. Other flags may be set but might
 * be ignored.
 *
 * Monitoring mode is always one-shot. If an event if fired, it is removed from
 * the monitoring state.
 *
 * Returns -1 on error.
 */
SFUNC int fio_poll_monitor(fio_poll_s *p,
                           int fd,
                           void *udata,
                           unsigned short flags);

/**
 * Reviews if any of the monitored file descriptors has any events.
 *
 * `timeout` is in milliseconds.
 *
 * Returns the number of events called.
 *
 * Polling is thread safe, but has different effects on different threads.
 *
 * Adding a new file descriptor from one thread while polling in a different
 * thread will not poll that IO until `fio_poll_review` is called again.
 */
SFUNC int fio_poll_review(fio_poll_s *p, size_t timeout);

/** Stops monitoring the specified file descriptor (if monitoring). */
SFUNC int fio_poll_forget(fio_poll_s *p, int fd);

/* *****************************************************************************
Implementation Helpers
***************************************************************************** */

/** returns the system call used for polling as a constant string. */
FIO_IFUNC const char *fio_poll_engine(void) { return FIO_POLL_ENGINE_STR; }

/* validate settings */
#define FIO_POLL_VALIDATE(settings_dest)                                       \
  if (!(settings_dest).on_data)                                                \
    (settings_dest).on_data = fio___poll_ev_mock;                              \
  if (!(settings_dest).on_ready)                                               \
    (settings_dest).on_ready = fio___poll_ev_mock;                             \
  if (!(settings_dest).on_close)                                               \
    (settings_dest).on_close = fio___poll_ev_mock;

SFUNC void fio___poll_ev_mock(void *udata);

#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
/* mock event */
SFUNC void fio___poll_ev_mock(void *udata) { (void)udata; }
#endif /* defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN) */
/* *****************************************************************************
Cleanup
***************************************************************************** */
#endif /* FIO_POLL */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE)                /* Dev test - ignore line */
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_EPOLL /* Dev */
#define FIO___DEV___    /* Development inclusion - ignore line */
#define FIO_POLL        /* Development inclusion - ignore line */
#include "./include.h"  /* Development inclusion - ignore line */
#endif                  /* Development inclusion - ignore line */
/* ************************************************************************* */
#if defined(FIO_POLL) &&                                                       \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)) &&                  \
    FIO_POLL_ENGINE == FIO_POLL_ENGINE_EPOLL &&                                \
    !defined(H___FIO_POLL_EGN___H) && !defined(H___FIO_POLL___H) &&            \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_POLL_EGN___H
/* *****************************************************************************




                        POSIX Portable Polling with `epoll`



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#include <sys/epoll.h>

/* *****************************************************************************
Polling API
***************************************************************************** */

/** the `fio_poll_s` type should be considered opaque. */
struct fio_poll_s {
  fio_poll_settings_s settings;
  struct pollfd fds[2];
  int fd[2];
};

FIO_SFUNC void fio___epoll_after_fork(void *p_) {
  fio_poll_s *p = (fio_poll_s *)p_;
  fio_poll_destroy(p);
  fio_poll_init FIO_NOOP(p, p->settings);
}

/** Initializes the polling object, allocating its resources. */
FIO_IFUNC void fio_poll_init FIO_NOOP(fio_poll_s *p, fio_poll_settings_s args) {
  *p = (fio_poll_s){
      .settings = args,
      .fds =
          {
              {.fd = epoll_create1(0), .events = (POLLIN | POLLOUT)},
              {.fd = epoll_create1(0), .events = (POLLIN | POLLOUT)},
          },
  };
  FIO_POLL_VALIDATE(p->settings);
  fio_state_callback_add(FIO_CALL_IN_CHILD, fio___epoll_after_fork, p);
}

/** Destroys the polling object, freeing its resources. */
FIO_IFUNC void fio_poll_destroy(fio_poll_s *p) {
  for (size_t i = 0; i < 2; ++i) {
    if (p->fds[i].fd != -1)
      close(p->fds[i].fd);
    p->fds[i].fd = -1;
  }
  fio_state_callback_remove(FIO_CALL_IN_CHILD, fio___epoll_after_fork, p);
}

/* *****************************************************************************
Poll Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_IFUNC int fio___epoll_add2(int fd,
                               void *udata,
                               uint32_t events,
                               int ep_fd) {
  int ret = 0;
  struct epoll_event chevent;
  do {
    errno = 0;
    chevent = (struct epoll_event){
        .events = events,
        .data.ptr = udata,
    };
    ret = epoll_ctl(ep_fd, EPOLL_CTL_MOD, fd, &chevent);
    if (ret == -1 && errno == ENOENT) {
      errno = 0;
      chevent = (struct epoll_event){
          .events = events,
          .data.ptr = udata,
      };
      ret = epoll_ctl(ep_fd, EPOLL_CTL_ADD, fd, &chevent);
    }
  } while (errno == EINTR);

  return ret;
}

/**
 * Adds a file descriptor to be monitored, adds events to be monitored or
 * updates the monitored file's `udata`.
 *
 * Possible flags are: `POLLIN` and `POLLOUT`. Other flags may be set but might
 * be ignored.
 *
 * Monitoring mode is always one-shot. If an event if fired, it is removed from
 * the monitoring state.
 *
 * Returns -1 on error.
 */
SFUNC int fio_poll_monitor(fio_poll_s *p,
                           int fd,
                           void *udata,
                           unsigned short flags) {
  int r = 0;
  if ((flags & POLLOUT))
    r |= fio___epoll_add2(fd,
                          udata,
                          (EPOLLOUT | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),
                          p->fds[0].fd);
  if ((flags & POLLIN))
    r |= fio___epoll_add2(fd,
                          udata,
                          (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),
                          p->fds[1].fd);
  return r;
}

/**
 * Stops monitoring the specified file descriptor, returning its udata (if any).
 */
SFUNC int fio_poll_forget(fio_poll_s *p, int fd) {
  int r = 0;
  struct epoll_event chevent = {.events = (EPOLLOUT | EPOLLIN)};
  r |= epoll_ctl(p->fds[0].fd, EPOLL_CTL_DEL, fd, &chevent);
  r |= epoll_ctl(p->fds[1].fd, EPOLL_CTL_DEL, fd, &chevent);
  return r;
}

/**
 * Reviews if any of the monitored file descriptors has any events.
 *
 * `timeout` is in milliseconds.
 *
 * Returns the number of events called.
 *
 * Polling is thread safe, but has different effects on different threads.
 *
 * Adding a new file descriptor from one thread while polling in a different
 * thread will not poll that IO until `fio_poll_review` is called again.
 */
SFUNC int fio_poll_review(fio_poll_s *p, size_t timeout) {
  int total = 0;
  struct epoll_event events[FIO_POLL_MAX_EVENTS];
  /* wait for events and handle them */
  int internal_count = poll(p->fds, 2, timeout);
  if (internal_count <= 0)
    return total;
  int active_count = epoll_wait(p->fds[0].fd, events, FIO_POLL_MAX_EVENTS, 0);
  if (active_count > 0) {
    /* TODO! fix error handling*/
    for (unsigned i = 0; i < (unsigned)active_count; i++) {
      // errors are handled as disconnections (on_close) in the EPOLLIN queue
      // if no error, try an active event(s)
      if (events[i].events & EPOLLOUT)
        p->settings.on_ready(events[i].data.ptr);
    } // end for loop
    total += active_count;
  }
  active_count = epoll_wait(p->fds[1].fd, events, FIO_POLL_MAX_EVENTS, 0);
  if (active_count > 0) {
    for (unsigned i = 0; i < (unsigned)active_count; i++) {
      // holds an active event(s)
      if (events[i].events & EPOLLIN)
        p->settings.on_data(events[i].data.ptr);
      // errors are handled as disconnections (on_close), but only once...
      if (events[i].events & (~(EPOLLIN | EPOLLOUT)))
        p->settings.on_close(events[i].data.ptr);
    } // end for loop
    total += active_count;
  }
  return total;
}

/* *****************************************************************************
Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_POLL_ENGINE == FIO_POLL_ENGINE_EPOLL */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE)                 /* Dev test - ignore line */
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_KQUEUE /* Dev */
#define FIO___DEV___    /* Development inclusion - ignore line */
#define FIO_POLL        /* Development inclusion - ignore line */
#include "./include.h"  /* Development inclusion - ignore line */
#endif                  /* Development inclusion - ignore line */
/* ************************************************************************* */
#if defined(FIO_POLL) &&                                                       \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)) &&                  \
    FIO_POLL_ENGINE == FIO_POLL_ENGINE_KQUEUE &&                               \
    !defined(H___FIO_POLL_EGN___H) && !defined(H___FIO_POLL___H) &&            \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_POLL_EGN___H
/* *****************************************************************************




                        POSIX Portable Polling with `kqueue`



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#include <sys/event.h>
/* *****************************************************************************
Polling API
***************************************************************************** */

/** the `fio_poll_s` type should be considered opaque. */
struct fio_poll_s {
  fio_poll_settings_s settings;
  int fd;
};

FIO_SFUNC void fio___kqueue_after_fork(void *p_) {
  fio_poll_s *p = (fio_poll_s *)p_;
  fio_poll_destroy(p);
  fio_poll_init FIO_NOOP(p, p->settings);
}

/** Initializes the polling object, allocating its resources. */
FIO_IFUNC void fio_poll_init FIO_NOOP(fio_poll_s *p, fio_poll_settings_s args) {
  *p = (fio_poll_s){
      .settings = args,
      .fd = kqueue(),
  };
  if (p->fd == -1) {
    FIO_LOG_FATAL("couldn't open kqueue.\n");
    exit(errno);
  }
  FIO_POLL_VALIDATE(p->settings);
  fio_state_callback_add(FIO_CALL_IN_CHILD, fio___kqueue_after_fork, p);
}

/** Destroys the polling object, freeing its resources. */
FIO_IFUNC void fio_poll_destroy(fio_poll_s *p) {
  if (p->fd != -1)
    close(p->fd);
  p->fd = -1;
  fio_state_callback_remove(FIO_CALL_IN_CHILD, fio___kqueue_after_fork, p);
}

/* *****************************************************************************
Poll Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/**
 * Adds a file descriptor to be monitored, adds events to be monitored or
 * updates the monitored file's `udata`.
 *
 * Possible flags are: `POLLIN` and `POLLOUT`. Other flags may be set but might
 * be ignored.
 *
 * Monitoring mode is always one-shot. If an event if fired, it is removed from
 * the monitoring state.
 *
 * Returns -1 on error.
 */
SFUNC int fio_poll_monitor(fio_poll_s *p,
                           int fd,
                           void *udata,
                           unsigned short flags) {
  int r = -1;
  struct kevent chevent[2];
  int i = 0;
  if ((flags & POLLIN)) {
    EV_SET(chevent,
           fd,
           EVFILT_READ,
           EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,
           0,
           0,
           udata);
    ++i;
  }
  if ((flags & POLLOUT)) {
    EV_SET(chevent + i,
           fd,
           EVFILT_WRITE,
           EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,
           0,
           0,
           udata);
    ++i;
  }
  do {
    errno = 0;
  } while ((r = kevent(p->fd, chevent, i, NULL, 0, NULL)) == -1 &&
           errno == EINTR);
  return r;
}

/**
 * Reviews if any of the monitored file descriptors has any events.
 *
 * `timeout` is in milliseconds.
 *
 * Returns the number of events called.
 *
 * Polling is thread safe, but has different effects on different threads.
 *
 * Adding a new file descriptor from one thread while polling in a different
 * thread will not poll that IO until `fio_poll_review` is called again.
 */
SFUNC int fio_poll_review(fio_poll_s *p, size_t timeout_) {
  if (p->fd < 0)
    return -1;
  struct kevent events[FIO_POLL_MAX_EVENTS] = {{0}};

  const struct timespec timeout = {
      .tv_sec = (time_t)(timeout_ / 1000),
      .tv_nsec = (suseconds_t)((timeout_ % 1000) * 1000000)};
  /* wait for events and handle them */
  int active_count =
      kevent(p->fd, NULL, 0, events, FIO_POLL_MAX_EVENTS, &timeout);

  if (active_count > 0) {
    for (unsigned i = 0; i < (unsigned)active_count; i++) {
      // test for event(s) type
      if (events[i].filter == EVFILT_WRITE)
        p->settings.on_ready(events[i].udata);
      if (events[i].filter == EVFILT_READ)
        p->settings.on_data(events[i].udata);
      if (events[i].flags & (EV_EOF | EV_ERROR))
        p->settings.on_close(events[i].udata);
    }
  } else if (active_count < 0) {
    if (errno == EINTR)
      return 0;
    return -1;
  }
  return active_count;
}

/** Stops monitoring the specified file descriptor (if monitoring). */
SFUNC int fio_poll_forget(fio_poll_s *p, int fd) {
  int r = 0;
  if (p->fd == -1)
    return (r = -1);
  struct kevent chevent[2];
  EV_SET(chevent, fd, EVFILT_READ, EV_DELETE, 0, 0, NULL);
  EV_SET(chevent + 1, fd, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
  do {
    errno = 0;
    r = kevent(p->fd, chevent, 2, NULL, 0, NULL);
  } while (errno == EINTR);
  return r;
}

/* *****************************************************************************
Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_POLL_ENGINE == FIO_POLL_ENGINE_KQUEUE */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE)               /* Dev test - ignore line */
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_POLL /* Dev */
#define FIO___DEV___    /* Development inclusion - ignore line */
#define FIO_POLL        /* Development inclusion - ignore line */
#include "./include.h"  /* Development inclusion - ignore line */
#endif                  /* Development inclusion - ignore line */
/* ************************************************************************* */
#if defined(FIO_POLL) &&                                                       \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)) &&                  \
    FIO_POLL_ENGINE == FIO_POLL_ENGINE_POLL &&                                 \
    !defined(H___FIO_POLL_EGN___H) && !defined(H___FIO_POLL___H) &&            \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_POLL_EGN___H
/* *****************************************************************************



                        POSIX Portable Polling with `poll`


Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#ifdef POLLRDHUP
#define FIO_POLL_EX_FLAGS POLLRDHUP
#else
#define FIO_POLL_EX_FLAGS 0
#endif

typedef struct {
  void *udata;
  int fd;
  unsigned short flags;
} fio___poll_i_s;

#define FIO___POLL_IMAP_CMP(a, b) ((a)->fd == (b)->fd)
#define FIO___POLL_IMAP_HASH(o)   (fio_risky_ptr((void *)((uintptr_t)((o)->fd))))
FIO_TYPEDEF_IMAP_ARRAY(fio___poll_map,
                       fio___poll_i_s,
                       uint32_t,
                       FIO___POLL_IMAP_HASH,
                       FIO___POLL_IMAP_CMP,
                       FIO_IMAP_ALWAYS_VALID)
#undef FIO___POLL_IMAP_CMP
#undef FIO___POLL_IMAP_VALID
#undef FIO___POLL_IMAP_HASH

struct fio_poll_s {
  fio_poll_settings_s settings;
  fio___poll_map_s map;
  FIO___LOCK_TYPE lock;
};

/* *****************************************************************************
Poll Monitoring Implementation - inline static functions
***************************************************************************** */

/** Initializes the polling object, allocating its resources. */
FIO_IFUNC void fio_poll_init FIO_NOOP(fio_poll_s *p, fio_poll_settings_s args) {
  if (p) {
    *p = (fio_poll_s){
        .settings = args,
        .map = {0},
        .lock = FIO___LOCK_INIT,
    };
    FIO_POLL_VALIDATE(p->settings);
  }
}

/** Destroys the polling object, freeing its resources. */
FIO_IFUNC void fio_poll_destroy(fio_poll_s *p) {
  if (!p)
    return;
  fio___poll_map_destroy(&p->map);
  FIO___LOCK_DESTROY(p->lock);
}

/* *****************************************************************************
Poll Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* handle events, return a mask for possible remaining flags. */
FIO_IFUNC unsigned short fio___poll_handle_events(fio_poll_s *p,
                                                  void *udata,
                                                  unsigned short flags) {
  if ((flags & POLLOUT))
    p->settings.on_ready(udata);
  if ((flags & (POLLIN | POLLPRI)))
    p->settings.on_data(udata);
  if ((flags & (POLLHUP | POLLERR | POLLNVAL | FIO_POLL_EX_FLAGS))) {
    p->settings.on_close(udata);
    return 0;
  }
  return ~flags;
}

/**
 * Adds a file descriptor to be monitored, adds events to be monitored or
 * updates the monitored file's `udata`.
 *
 * Possible flags are: `POLLIN` and `POLLOUT`. Other flags may be set but might
 * be ignored.
 *
 * Monitoring mode is always one-shot. If an event if fired, it is removed from
 * the monitoring state.
 *
 * Returns -1 on error.
 */
SFUNC int fio_poll_monitor(fio_poll_s *p,
                           int fd,
                           void *udata,
                           unsigned short flags) {
  int r = -1;
  if (!p || fd == -1)
    return r;
  r = 0;
  flags &= FIO_POLL_POSSIBLE_FLAGS;
  flags |= FIO_POLL_EX_FLAGS;
  fio___poll_i_s i = {.udata = udata, .fd = fd, .flags = flags};
  FIO___LOCK_LOCK(p->lock);
  fio___poll_i_s *ptr = fio___poll_map_set(&p->map, i, 0);
  ptr->flags |= flags;
  FIO___LOCK_UNLOCK(p->lock);
  return r;
}

/**
 * Reviews if any of the monitored file descriptors has any events.
 *
 * `timeout` is in milliseconds.
 *
 * Returns the number of events called.
 *
 * Polling is thread safe, but has different effects on different threads.
 *
 * Adding a new file descriptor from one thread while polling in a different
 * thread will not poll that IO until `fio_poll_review` is called again.
 */
SFUNC int fio_poll_review(fio_poll_s *p, size_t timeout) {
  int events = -1;
  int handled = -1;
  if (!p || !(p->map.count)) {
    if (timeout) {
      FIO_THREAD_WAIT((timeout * 1000000));
    }
    return 0;
  }
  /* handle events in a copy, allowing events / threads to mutate it */
  FIO___LOCK_LOCK(p->lock);
  fio_poll_s cpy = *p;
  p->map = (fio___poll_map_s){0};
  FIO___LOCK_UNLOCK(p->lock);

  const size_t max = cpy.map.count;
  const unsigned short flag_mask = FIO_POLL_POSSIBLE_FLAGS | FIO_POLL_EX_FLAGS;

  int w = 0, r = 0, i = 0;
  struct pollfd *pfd = (struct pollfd *)FIO_MEM_REALLOC_(
      NULL,
      0,
      ((max * sizeof(void *)) + (max * sizeof(struct pollfd))),
      0);
  void **uary = (void **)(pfd + max);

  FIO_IMAP_EACH(fio___poll_map, (&cpy.map), pos) {
    if (!(cpy.map.ary[pos].flags & flag_mask))
      continue;
    pfd[r] = (struct pollfd){.fd = cpy.map.ary[pos].fd,
                             .events = (short)cpy.map.ary[pos].flags};
    uary[r] = cpy.map.ary[pos].udata;
    ++r;
  }

#if FIO_OS_WIN
  events = WSAPoll(pfd, r, (int)timeout);
#else
  events = poll(pfd, r, (int)timeout);
#endif

  if (events > 0) {
    /* handle events and remove consumed entries */
    for (i = 0; i < r && handled < events; ++i) {
      if (pfd[i].revents) {
        ++handled;
        pfd[i].events &=
            fio___poll_handle_events(&cpy, uary[i], pfd[i].revents);
      }
      if ((pfd[i].events & (~(FIO_POLL_EX_FLAGS)))) {
        if (i != w) {
          pfd[w] = pfd[i];
          uary[w] = uary[i];
        }
        ++w;
      }
    }
    if (i < r && i != w) {
      FIO_MEMMOVE(pfd + w, pfd + i, ((r - i) * sizeof(*pfd)));
      FIO_MEMMOVE(uary + w, uary + i, ((r - i) * sizeof(*uary)));
    }
  }
  w += r - i;
  i = 0;

  FIO___LOCK_LOCK(p->lock);
  if (!p->map.count && events <= 0) {
    p->map = cpy.map;
    i = 1;
    goto finish;
  }
  if (w) {
    fio___poll_map_reserve(&p->map, w + p->map.count);
    for (i = 0; i < w; ++i) {
      fio___poll_i_s *existing =
          fio___poll_map_get(&p->map, (fio___poll_i_s){.fd = pfd[i].fd});
      if (existing) {
        existing->flags |= existing->flags ? pfd[i].events : 0;
        continue;
      }
      fio___poll_map_set(&p->map,
                         (fio___poll_i_s){
                             .fd = pfd[i].fd,
                             .flags = (unsigned short)pfd[i].events,
                             .udata = uary[i],
                         },
                         1);
    }
  }
  i = 0;

finish:
  FIO___LOCK_UNLOCK(p->lock);
  FIO_MEM_FREE(pfd, ((max * sizeof(void *)) + (max * sizeof(struct pollfd))));
  if (!i)
    fio___poll_map_destroy(&cpy.map);
  return events;
}

/** Stops monitoring the specified file descriptor, returning -1 on error. */
SFUNC int fio_poll_forget(fio_poll_s *p, int fd) {
  int r = 0;
  fio___poll_i_s i = {.fd = fd};
  FIO___LOCK_LOCK(p->lock);
  fio___poll_i_s *ptr = fio___poll_map_set(&p->map, i, 0);
  if (!ptr->flags)
    r = -1;
  ptr->flags = 0;
  FIO___LOCK_UNLOCK(p->lock);
  return r;
}

/** Closes all sockets, calling the `on_close`. */
SFUNC void fio_poll_close_all(fio_poll_s *p) {
  FIO___LOCK_LOCK(p->lock);
  fio_poll_s cpy = *p;
  p->map = (fio___poll_map_s){0};
  FIO___LOCK_UNLOCK(p->lock);
  const unsigned short flag_mask = FIO_POLL_POSSIBLE_FLAGS | FIO_POLL_EX_FLAGS;
  FIO_IMAP_EACH(fio___poll_map, (&cpy.map), pos) {
    if ((cpy.map.ary[pos].flags & flag_mask)) {
      cpy.settings.on_close(cpy.map.ary[pos].udata);
      fio_sock_close(cpy.map.ary[pos].fd);
    }
  }
  fio___poll_map_destroy(&cpy.map);
}
/* *****************************************************************************
Cleanup
***************************************************************************** */
#undef FIO_POLL_EX_FLAGS
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_POLL_ENGINE == FIO_POLL_ENGINE_POLL */

#if defined(FIO_POLL) && !defined(H___FIO_POLL___H) &&                         \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_POLL___H
#undef FIO_POLL
#endif /* FIO_POLL */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_QUEUE              /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                Task / Timer Queues
                                (Event Loop Engine)



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_QUEUE) && !defined(H___FIO_QUEUE___H)
#define H___FIO_QUEUE___H

/* *****************************************************************************
Queue Type(s)
***************************************************************************** */

/* Note: FIO_QUEUE_TASKS_PER_ALLOC can't be more than 65535 */
#ifndef FIO_QUEUE_TASKS_PER_ALLOC
#if UINTPTR_MAX <= 0xFFFFFFFF
/* fits fio_queue_s in one page on most 32 bit machines */
#define FIO_QUEUE_TASKS_PER_ALLOC 338
#else
/* fits fio_queue_s in one page on most 64 bit machines */
#define FIO_QUEUE_TASKS_PER_ALLOC 168
#endif
#endif

/** Task information */
typedef struct {
  /** The function to call */
  void (*fn)(void *, void *);
  /** User opaque data */
  void *udata1;
  /** User opaque data */
  void *udata2;
} fio_queue_task_s;

/* internal use */
typedef struct fio___task_ring_s {
  uint16_t r;   /* reader position */
  uint16_t w;   /* writer position */
  uint16_t dir; /* direction */
  struct fio___task_ring_s *next;
  fio_queue_task_s buf[FIO_QUEUE_TASKS_PER_ALLOC];
} fio___task_ring_s;

/** The queue object - should be considered opaque (or, at least, read only). */
typedef struct {
  /** task read pointer. */
  fio___task_ring_s *r;
  /** task write pointer. */
  fio___task_ring_s *w;
  /** the number of tasks waiting to be performed. */
  uint32_t count;
  /** global queue lock. */
  FIO___LOCK_TYPE lock;
  /** linked lists of consumer threads. */
  FIO_LIST_NODE consumers;
  /** main ring buffer associated with the queue. */
  fio___task_ring_s mem;
} fio_queue_s;

typedef struct {
  FIO_LIST_NODE node;
  fio_queue_s *queue;
  fio_thread_t thread;
  fio_thread_mutex_t mutex;
  fio_thread_cond_t cond;
  size_t workers;
  volatile int stop;
} fio___thread_group_s;

/* *****************************************************************************
Queue API
***************************************************************************** */

#if FIO_USE_THREAD_MUTEX_TMP
/** May be used to initialize global, static memory, queues. */
#define FIO_QUEUE_STATIC_INIT(queue)                                           \
  {                                                                            \
    .r = &(queue).mem, .w = &(queue).mem,                                      \
    .lock = (fio_thread_mutex_t)FIO_THREAD_MUTEX_INIT,                         \
    .consumers = FIO_LIST_INIT((queue).consumers),                             \
  }
#else
/** May be used to initialize global, static memory, queues. */
#define FIO_QUEUE_STATIC_INIT(queue)                                           \
  {                                                                            \
    .r = &(queue).mem, .w = &(queue).mem, .lock = FIO_LOCK_INIT,               \
    .consumers = FIO_LIST_INIT((queue).consumers),                             \
  }
#endif

/** Initializes a fio_queue_s object. */
FIO_IFUNC void fio_queue_init(fio_queue_s *q);

/** Destroys a queue and re-initializes it, after freeing any used resources. */
SFUNC void fio_queue_destroy(fio_queue_s *q);

/** Creates a new queue object (allocated on the heap). */
SFUNC fio_queue_s *fio_queue_new(void);

/** Frees a queue object after calling fio_queue_destroy. */
SFUNC void fio_queue_free(fio_queue_s *q);

/** Pushes a task to the queue. Returns -1 on error. */
SFUNC int fio_queue_push(fio_queue_s *q, fio_queue_task_s task);

/**
 * Pushes a task to the queue, offering named arguments for the task.
 * Returns -1 on error.
 */
#define fio_queue_push(q, ...)                                                 \
  fio_queue_push((q), (fio_queue_task_s){__VA_ARGS__})

/** Pushes a task to the head of the queue. Returns -1 on error (no memory). */
SFUNC int fio_queue_push_urgent(fio_queue_s *q, fio_queue_task_s task);

/**
 * Pushes a task to the queue, offering named arguments for the task.
 * Returns -1 on error.
 */
#define fio_queue_push_urgent(q, ...)                                          \
  fio_queue_push_urgent((q), (fio_queue_task_s){__VA_ARGS__})

/** Pops a task from the queue (FIFO). Returns a NULL task on error. */
SFUNC fio_queue_task_s fio_queue_pop(fio_queue_s *q);

/** Performs a task from the queue. Returns -1 on error (queue empty). */
SFUNC int fio_queue_perform(fio_queue_s *q);

/** Performs all tasks in the queue. */
SFUNC void fio_queue_perform_all(fio_queue_s *q);

/** returns the number of tasks in the queue. */
FIO_IFUNC uint32_t fio_queue_count(fio_queue_s *q);

/** Adds worker / consumer threads to perform the jobs in the queue. */
SFUNC int fio_queue_workers_add(fio_queue_s *q, size_t count);

/** Signals all worker threads to stop performing tasks and terminate. */
SFUNC void fio_queue_workers_stop(fio_queue_s *q);

/** Signals all worker threads to stop, waiting for them to complete. */
SFUNC void fio_queue_workers_join(fio_queue_s *q);

/** Signals all worker threads to go back to work (new tasks added). */
SFUNC void fio_queue_workers_wake(fio_queue_s *q);

/* *****************************************************************************
Timer Queue Types and API
***************************************************************************** */

typedef struct fio___timer_event_s fio___timer_event_s;

typedef struct {
  fio___timer_event_s *next;
  FIO___LOCK_TYPE lock;
} fio_timer_queue_s;

#if FIO_USE_THREAD_MUTEX_TMP
#define FIO_TIMER_QUEUE_INIT                                                   \
  { .lock = ((fio_thread_mutex_t)FIO_THREAD_MUTEX_INIT) }
#else
#define FIO_TIMER_QUEUE_INIT                                                   \
  { .lock = FIO_LOCK_INIT }
#endif

typedef struct {
  /** The timer function. If it returns a non-zero value, the timer stops. */
  int (*fn)(void *, void *);
  /** Opaque user data. */
  void *udata1;
  /** Opaque user data. */
  void *udata2;
  /** Called when the timer is done (finished). */
  void (*on_finish)(void *, void *);
  /** Timer interval, in milliseconds. */
  uint32_t every;
  /** The number of times the timer should be performed. -1 == infinity. */
  int32_t repetitions;
  /** Millisecond at which to start. If missing, filled automatically. */
  int64_t start_at;
} fio_timer_schedule_args_s;

/** Adds a time-bound event to the timer queue. */
SFUNC void fio_timer_schedule(fio_timer_queue_s *timer_queue,
                              fio_timer_schedule_args_s args);

/** A MACRO allowing named arguments to be used. See fio_timer_schedule_args_s.
 */
#define fio_timer_schedule(timer_queue, ...)                                   \
  fio_timer_schedule((timer_queue), (fio_timer_schedule_args_s){__VA_ARGS__})

/** Pushes due events from the timer queue to an event queue. */
SFUNC size_t fio_timer_push2queue(fio_queue_s *queue,
                                  fio_timer_queue_s *timer_queue,
                                  int64_t now_in_milliseconds);

/*
 * Returns the millisecond at which the next event should occur.
 *
 * If no timer is due (list is empty), returns `(uint64_t)-1`.
 *
 * NOTE: unless manually specified, millisecond timers are relative to
 * `fio_time_milli()`.
 */
FIO_IFUNC int64_t fio_timer_next_at(fio_timer_queue_s *timer_queue);

/**
 * Clears any waiting timer bound tasks.
 *
 * NOTE:
 *
 * The timer queue must NEVER be freed when there's a chance that timer tasks
 * are waiting to be performed in a `fio_queue_s`.
 *
 * This is due to the fact that the tasks may try to reschedule themselves (if
 * they repeat).
 */
SFUNC void fio_timer_destroy(fio_timer_queue_s *timer_queue);

/* *****************************************************************************
Queue Inline Helpers
***************************************************************************** */

/** returns the number of tasks in the queue. */
FIO_IFUNC uint32_t fio_queue_count(fio_queue_s *q) { return q->count; }

/** Initializes a fio_queue_s object. */
FIO_IFUNC void fio_queue_init(fio_queue_s *q) {
  /* do this manually, we don't want to reset a whole page */
  q->r = &q->mem;
  q->w = &q->mem;
  q->count = 0;
  q->consumers = FIO_LIST_INIT(q->consumers);
  q->lock = FIO___LOCK_INIT;
  q->mem.next = NULL;
  q->mem.r = q->mem.w = q->mem.dir = 0;
}

/* *****************************************************************************
Timer Queue Inline Helpers
***************************************************************************** */

struct fio___timer_event_s {
  int (*fn)(void *, void *);
  void *udata1;
  void *udata2;
  void (*on_finish)(void *udata1, void *udata2);
  int64_t due;
  uint32_t every;
  int32_t repetitions;
  struct fio___timer_event_s *next;
};

/*
 * Returns the millisecond at which the next event should occur.
 *
 * If no timer is due (list is empty), returns `-1`.
 *
 * NOTE: unless manually specified, millisecond timers are relative to
 * `fio_time_milli()`.
 */
FIO_IFUNC int64_t fio_timer_next_at(fio_timer_queue_s *tq) {
  int64_t v = -1;
  if (!tq)
    goto missing_tq;
  if (!tq || !tq->next)
    return v;
  FIO___LOCK_LOCK(tq->lock);
  if (tq->next)
    v = tq->next->due;
  FIO___LOCK_UNLOCK(tq->lock);
  return v;

missing_tq:
  FIO_LOG_ERROR("`fio_timer_next_at` called with a NULL timer queue!");
  return v;
}

/* *****************************************************************************
Queue Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* task queue leak detection */
FIO_LEAK_COUNTER_DEF(fio_queue)
FIO_LEAK_COUNTER_DEF(fio_queue_task_rings)
/** Destroys a queue and re-initializes it, after freeing any used resources. */
SFUNC void fio_queue_destroy(fio_queue_s *q) {
  for (;;) {
    FIO___LOCK_LOCK(q->lock);
    while (q->r) {
      fio___task_ring_s *tmp = q->r;
      q->r = q->r->next;
      if (tmp != &q->mem)
        FIO_MEM_FREE_(tmp, sizeof(*tmp));
    }
    if (FIO_LIST_IS_EMPTY(&q->consumers)) {
      FIO___LOCK_UNLOCK(q->lock);
      break;
    }
    FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
      fio_atomic_or(&pos->stop, 1);
      for (size_t i = 0; i < pos->workers; ++i)
        fio_thread_cond_signal(&pos->cond);
    }
    FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
      FIO___LOCK_UNLOCK(q->lock);
      fio_thread_join(&pos->thread);
      FIO___LOCK_LOCK(q->lock);
    }
    FIO___LOCK_UNLOCK(q->lock);
    if (FIO_LIST_IS_EMPTY(&q->consumers))
      break;
    FIO_THREAD_RESCHEDULE();
  }
  FIO___LOCK_DESTROY(q->lock);
  fio_queue_init(q);
}

/** Creates a new queue object (allocated on the heap). */
SFUNC fio_queue_s *fio_queue_new(void) {
  fio_queue_s *q = (fio_queue_s *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*q), 0);
  if (!q)
    return NULL;
  fio_queue_init(q);
  FIO_LEAK_COUNTER_ON_ALLOC(fio_queue);
  return q;
}

/** Frees a queue object after calling fio_queue_destroy. */
SFUNC void fio_queue_free(fio_queue_s *q) {
  fio_queue_destroy(q);
  if (q) {
    FIO_LEAK_COUNTER_ON_FREE(fio_queue);
    FIO_MEM_FREE_(q, sizeof(*q));
  }
}

FIO_IFUNC int fio___task_ring_push(fio___task_ring_s *r,
                                   fio_queue_task_s task) {
  if (r->dir && r->r == r->w)
    return -1;
  r->buf[r->w] = task;
  ++(r->w);
  if (r->w == FIO_QUEUE_TASKS_PER_ALLOC) {
    r->w = 0;
    r->dir = ~r->dir;
  }
  return 0;
}

FIO_IFUNC int fio___task_ring_unpop(fio___task_ring_s *r,
                                    fio_queue_task_s task) {
  if (r->dir && r->r == r->w)
    return -1;
  if (!r->r) {
    r->r = FIO_QUEUE_TASKS_PER_ALLOC;
    r->dir = ~r->dir;
  }
  --r->r;
  r->buf[r->r] = task;
  return 0;
}

FIO_IFUNC fio_queue_task_s fio___task_ring_pop(fio___task_ring_s *r) {
  fio_queue_task_s t = {.fn = NULL};
  if (!r->dir && r->r == r->w) {
    return t;
  }
  t = r->buf[r->r];
  r->buf[r->r] = (fio_queue_task_s){.fn = NULL};
  ++r->r;
  if (r->r == FIO_QUEUE_TASKS_PER_ALLOC) {
    r->r = 0;
    r->dir = ~r->dir;
  }
  return t;
}

int fio_queue_push___(void); /* sublime text marker */
/** Pushes a task to the queue. Returns -1 on error. */
SFUNC int fio_queue_push FIO_NOOP(fio_queue_s *q, fio_queue_task_s task) {
  if (!task.fn)
    return 0;
  FIO___LOCK_LOCK(q->lock);
  if (fio___task_ring_push(q->w, task)) {
    if (q->w != &q->mem && q->mem.next == NULL) {
      q->w->next = &q->mem;
      q->mem.w = q->mem.r = q->mem.dir = 0;
    } else {
      void *tmp = (fio___task_ring_s *)
          FIO_MEM_REALLOC_(NULL, 0, sizeof(*q->w->next), 0);
      if (!tmp)
        goto no_mem;
      FIO_LEAK_COUNTER_ON_ALLOC(fio_queue_task_rings);
      q->w->next = (fio___task_ring_s *)tmp;
      if (!FIO_MEM_REALLOC_IS_SAFE_) {
        q->w->next->r = q->w->next->w = q->w->next->dir = 0;

        q->w->next->next = NULL;
      }
    }
    q->w = q->w->next;
    fio___task_ring_push(q->w, task);
  }
  ++q->count;
  if (!FIO_LIST_IS_EMPTY(&q->consumers)) {
    FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
      fio_thread_cond_signal(&pos->cond);
    }
  }
  FIO___LOCK_UNLOCK(q->lock);
  return 0;
no_mem:
  FIO___LOCK_UNLOCK(q->lock);
  FIO_LOG_ERROR("No memory for Queue %p to increase task ring buffer.",
                (void *)q);
  return -1;
}

int fio_queue_push_urgent___(void); /* IDE marker */
/** Pushes a task to the head of the queue. Returns -1 on error (no memory). */
SFUNC int fio_queue_push_urgent FIO_NOOP(fio_queue_s *q,
                                         fio_queue_task_s task) {
  if (!task.fn)
    return 0;
  FIO___LOCK_LOCK(q->lock);
  if (fio___task_ring_unpop(q->r, task)) {
    /* such a shame... but we must allocate a while task block for one task */
    fio___task_ring_s *tmp =
        (fio___task_ring_s *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*q->w->next), 0);
    if (!tmp)
      goto no_mem;
    FIO_LEAK_COUNTER_ON_ALLOC(fio_queue_task_rings);
    tmp->next = q->r;
    q->r = tmp;
    tmp->w = 1;
    tmp->dir = tmp->r = 0;
    tmp->buf[0] = task;
  }
  ++q->count;
  if (!FIO_LIST_IS_EMPTY(&q->consumers)) {
    FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
      fio_thread_cond_signal(&pos->cond);
    }
  }
  FIO___LOCK_UNLOCK(q->lock);
  return 0;
no_mem:
  FIO___LOCK_UNLOCK(q->lock);
  FIO_LOG_ERROR("No memory for Queue %p to increase task ring buffer.",
                (void *)q);
  return -1;
}

/** Pops a task from the queue (FIFO). Returns a NULL task on error. */
SFUNC fio_queue_task_s fio_queue_pop(fio_queue_s *q) {
  fio_queue_task_s t = {.fn = NULL};
  fio___task_ring_s *to_free = NULL;
  fio___task_ring_s *to_free_tst = NULL;
  if (!q->count)
    return t;
  FIO___LOCK_LOCK(q->lock);
  if (!q->count)
    goto finish;
  if (!(t = fio___task_ring_pop(q->r)).fn) {
    to_free = q->r;
    q->r = to_free->next;
    to_free->next = NULL;
    t = fio___task_ring_pop(q->r);
  }
  if (t.fn && !(--q->count) && q->r != &q->mem) {
    if (to_free && to_free != &q->mem) { // edge case
      FIO_LEAK_COUNTER_ON_FREE(fio_queue_task_rings);
      FIO_MEM_FREE_(to_free, sizeof(*to_free));
    }
    to_free = q->r;
    q->r = q->w = &q->mem;
    q->mem.w = q->mem.r = q->mem.dir = 0;
  }
  to_free_tst = &q->mem;
finish:
  FIO___LOCK_UNLOCK(q->lock);
  if (to_free && to_free != to_free_tst) {
    FIO_LEAK_COUNTER_ON_FREE(fio_queue_task_rings);
    FIO_MEM_FREE_(to_free, sizeof(*to_free));
  }
  return t;
}

/** Performs a task from the queue. Returns -1 on error (queue empty). */
SFUNC int fio_queue_perform(fio_queue_s *q) {
  fio_queue_task_s t = fio_queue_pop(q);
  if (!t.fn)
    return -1;
  t.fn(t.udata1, t.udata2);
  return 0;
}

/** Performs all tasks in the queue. */
SFUNC void fio_queue_perform_all(fio_queue_s *q) {
  fio_queue_task_s t;
  while ((t = fio_queue_pop(q)).fn)
    t.fn(t.udata1, t.udata2);
}

/* *****************************************************************************
Queue Consumer Threads
***************************************************************************** */

FIO_SFUNC void *fio___queue_worker_task(void *g_) {
  fio___thread_group_s *grp = (fio___thread_group_s *)g_;
  fio_state_callback_force(FIO_CALL_ON_WORKER_THREAD_START);
  while (!grp->stop) {
    fio_queue_perform_all(grp->queue);
    fio_thread_mutex_lock(&grp->mutex);
    if (!grp->stop)
      fio_thread_cond_wait(&grp->cond, &grp->mutex);
    fio_thread_mutex_unlock(&grp->mutex);
    fio_queue_perform_all(grp->queue);
  }
  fio_state_callback_force(FIO_CALL_ON_WORKER_THREAD_END);
  return NULL;
}
FIO_SFUNC void *fio___queue_worker_manager(void *g_) {
  fio_thread_t threads_buf[256];
  fio___thread_group_s grp = *(fio___thread_group_s *)g_;
  FIO_LIST_PUSH(&grp.queue->consumers, &grp.node);
  grp.stop = 0;
  fio_thread_t *threads =
      grp.workers > 256
          ? ((fio_thread_t *)
                 FIO_MEM_REALLOC_(NULL, 0, sizeof(*threads) * grp.workers, 0))
          : threads_buf;
  fio_thread_mutex_init(&grp.mutex);
  fio_thread_cond_init(&grp.cond);
  for (size_t i = 0; i < grp.workers; ++i) {
    fio_thread_create(threads + i, fio___queue_worker_task, (void *)&grp);
  }
  fio_atomic_and(&((fio___thread_group_s *)g_)->stop, 0);
  /* from this point on, g_ is invalid! */
  for (size_t i = 0; i < grp.workers; ++i) {
    fio_thread_join(threads + i);
  }
  if (threads != threads_buf)
    FIO_MEM_FREE_(threads, sizeof(*threads) * grp.workers);
  FIO___LOCK_LOCK(grp.queue->lock);
  FIO_LIST_REMOVE(&grp.node);
  FIO___LOCK_UNLOCK(grp.queue->lock);
  fio_queue_perform_all(grp.queue);
  return NULL;
}

SFUNC int fio_queue_workers_add(fio_queue_s *q, size_t workers) {
  FIO___LOCK_LOCK(q->lock);
  if (!q->consumers.next || !q->consumers.prev) {
    q->consumers = FIO_LIST_INIT(q->consumers);
  }
  fio___thread_group_s grp = {.queue = q, .workers = workers, .stop = 1};
  if (fio_thread_create(&grp.thread, fio___queue_worker_manager, &grp)) {
    FIO___LOCK_UNLOCK(q->lock);
    return -1;
  }
  while (grp.stop)
    FIO_THREAD_RESCHEDULE();
  FIO___LOCK_UNLOCK(q->lock);
  return 0;
}

SFUNC void fio_queue_workers_stop(fio_queue_s *q) {
  if (FIO_LIST_IS_EMPTY(&q->consumers))
    return;
  FIO___LOCK_LOCK(q->lock);
  FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
    fio_atomic_or(&pos->stop, 1);
    for (size_t i = 0; i < pos->workers * 2; ++i)
      fio_thread_cond_signal(&pos->cond);
  }
  FIO___LOCK_UNLOCK(q->lock);
}

/** Signals all worker threads to go back to work (new tasks were). */
SFUNC void fio_queue_workers_wake(fio_queue_s *q) {
  if (FIO_LIST_IS_EMPTY(&q->consumers))
    return;
  FIO___LOCK_LOCK(q->lock);
  FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
    fio_thread_cond_signal(&pos->cond);
  }
  FIO___LOCK_UNLOCK(q->lock);
}

/** Signals all worker threads to stop, waiting for them to complete. */
SFUNC void fio_queue_workers_join(fio_queue_s *q) {
  fio_queue_workers_stop(q);
  FIO___LOCK_LOCK(q->lock);
  FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
    FIO___LOCK_UNLOCK(q->lock);
    fio_thread_join(&pos->thread);
    FIO___LOCK_LOCK(q->lock);
  }
  FIO___LOCK_UNLOCK(q->lock);
}

/* *****************************************************************************
Timer Queue Implementation
***************************************************************************** */
FIO_LEAK_COUNTER_DEF(fio___timer_event_s)

FIO_IFUNC void fio___timer_insert(fio___timer_event_s **pos,
                                  fio___timer_event_s *e) {
  while (*pos && e->due >= (*pos)->due)
    pos = &((*pos)->next);
  e->next = *pos;
  *pos = e;
}

FIO_IFUNC fio___timer_event_s *fio___timer_pop(fio___timer_event_s **pos,
                                               int64_t due) {
  if (!*pos || (*pos)->due > due)
    return NULL;
  fio___timer_event_s *t = *pos;
  *pos = t->next;
  return t;
}

FIO_IFUNC fio___timer_event_s *fio___timer_event_new(
    fio_timer_schedule_args_s args) {
  fio___timer_event_s *t = NULL;
  t = (fio___timer_event_s *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*t), 0);
  if (!t)
    goto init_error;
  FIO_LEAK_COUNTER_ON_ALLOC(fio___timer_event_s);
  if (!args.repetitions)
    args.repetitions = 1;
  *t = (fio___timer_event_s){
      .fn = args.fn,
      .udata1 = args.udata1,
      .udata2 = args.udata2,
      .on_finish = args.on_finish,
      .due = args.start_at + args.every,
      .every = args.every,
      .repetitions = args.repetitions,
  };
  return t;
init_error:
  if (args.on_finish)
    args.on_finish(args.udata1, args.udata2);
  return NULL;
}

FIO_IFUNC void fio___timer_event_free(fio_timer_queue_s *tq,
                                      fio___timer_event_s *t) {
  if (!t)
    return;
  if (tq && (t->repetitions < 0 || fio_atomic_sub_fetch(&t->repetitions, 1))) {
    FIO___LOCK_LOCK(tq->lock);
    fio___timer_insert(&tq->next, t);
    FIO___LOCK_UNLOCK(tq->lock);
    return;
  }
  if (t->on_finish)
    t->on_finish(t->udata1, t->udata2);
  FIO_LEAK_COUNTER_ON_FREE(fio___timer_event_s);
  FIO_MEM_FREE_(t, sizeof(*t));
}

FIO_SFUNC void fio___timer_perform(void *timer_, void *t_) {
  fio_timer_queue_s *tq = (fio_timer_queue_s *)timer_;
  fio___timer_event_s *t = (fio___timer_event_s *)t_;
  if (t->fn(t->udata1, t->udata2))
    tq = NULL;
  t->due += t->every;
  fio___timer_event_free(tq, t);
}

/** Pushes due events from the timer queue to an event queue. */
SFUNC size_t fio_timer_push2queue(fio_queue_s *queue,
                                  fio_timer_queue_s *timer,
                                  int64_t start_at) {
  size_t r = 0;
  if (!start_at)
    start_at = fio_time_milli();
  if (FIO___LOCK_TRYLOCK(timer->lock))
    return 0;
  fio___timer_event_s *t;
  while ((t = fio___timer_pop(&timer->next, start_at))) {
    fio_queue_push(queue,
                   .fn = fio___timer_perform,
                   .udata1 = timer,
                   .udata2 = t);
    ++r;
  }
  FIO___LOCK_UNLOCK(timer->lock);
  return r;
}

void fio_timer_schedule___(void); /* IDE marker */
/** Adds a time-bound event to the timer queue. */
SFUNC void fio_timer_schedule FIO_NOOP(fio_timer_queue_s *timer,
                                       fio_timer_schedule_args_s args) {
  fio___timer_event_s *t = NULL;
  if (!timer || !args.fn || !args.every)
    goto no_timer_queue;
  if (!args.start_at)
    args.start_at = fio_time_milli();
  t = fio___timer_event_new(args);
  if (!t)
    return;
  FIO___LOCK_LOCK(timer->lock);
  fio___timer_insert(&timer->next, t);
  FIO___LOCK_UNLOCK(timer->lock);
  return;
no_timer_queue:
  if (args.on_finish)
    args.on_finish(args.udata1, args.udata2);
  FIO_LOG_ERROR("fio_timer_schedule called with illegal arguments.");
}

/**
 * Clears any waiting timer bound tasks.
 *
 * NOTE:
 *
 * The timer queue must NEVER be freed when there's a chance that timer tasks
 * are waiting to be performed in a `fio_queue_s`.
 *
 * This is due to the fact that the tasks may try to reschedule themselves (if
 * they repeat).
 */
SFUNC void fio_timer_destroy(fio_timer_queue_s *tq) {
  if (!tq)
    return;
  fio___timer_event_s *next = NULL;
  FIO___LOCK_LOCK(tq->lock);
  next = tq->next;
  tq->next = NULL;
  FIO___LOCK_UNLOCK(tq->lock);
  FIO___LOCK_DESTROY(tq->lock);
  while (next) {
    fio___timer_event_s *tmp = next;
    next = next->next;
    fio___timer_event_free(NULL, tmp);
  }
}
/* *****************************************************************************
Queue/Timer Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_QUEUE
#endif /* FIO_QUEUE */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_STREAM             /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




      A packet based data stream for storing / buffering endless data.



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_STREAM) && !defined(H___FIO_STREAM___H)
#define H___FIO_STREAM___H
#include <sys/stat.h>

#ifndef FIO_STREAM_COPY_PER_PACKET
/** Break apart large memory blocks into smaller pieces. by default 96Kb */
#define FIO_STREAM_COPY_PER_PACKET 98304
#endif

#ifndef FIO_STREAM_ALWAYS_COPY_IF_LESS_THAN
/** If the data added is less than said bytes, copy is preferred (locality). */
#define FIO_STREAM_ALWAYS_COPY_IF_LESS_THAN 116
#ifdef DEBUG
#undef FIO_STREAM_ALWAYS_COPY_IF_LESS_THAN
#define FIO_STREAM_ALWAYS_COPY_IF_LESS_THAN 8
#endif
#endif

/* *****************************************************************************
Stream API - types, constructor / destructor
***************************************************************************** */

typedef struct fio_stream_packet_s fio_stream_packet_s;

typedef struct {
  /* do not directly access! */
  fio_stream_packet_s *next;
  fio_stream_packet_s **pos;
  size_t consumed;
  size_t length;
} fio_stream_s;

/* at this point publish (declare only) the public API */

#ifndef FIO_STREAM_INIT
/* Initialization macro. */
#define FIO_STREAM_INIT(s)                                                     \
  { .next = NULL, .pos = &(s).next }
#endif

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY

/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC fio_stream_s *fio_stream_new(void);

/* Frees any internal data AND the object's container! */
FIO_IFUNC int fio_stream_free(fio_stream_s *stream);

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/** Destroys the object, re-initializing its container. */
SFUNC void fio_stream_destroy(fio_stream_s *stream);

/* *****************************************************************************
Stream API - packing data into packets and adding it to the stream
***************************************************************************** */

/** Packs data into a fio_stream_packet_s container. */
SFUNC fio_stream_packet_s *fio_stream_pack_data(void *buf,
                                                size_t len,
                                                size_t offset,
                                                uint8_t copy_buffer,
                                                void (*dealloc_func)(void *));

/** Packs a file descriptor into a fio_stream_packet_s container. */
SFUNC fio_stream_packet_s *fio_stream_pack_fd(int fd,
                                              size_t len,
                                              size_t offset,
                                              uint8_t keep_open);

/** Adds a packet to the stream. This isn't thread safe.*/
SFUNC void fio_stream_add(fio_stream_s *stream, fio_stream_packet_s *packet);

/** Destroys the fio_stream_packet_s - call this ONLY if unused. */
SFUNC void fio_stream_pack_free(fio_stream_packet_s *packet);

/* *****************************************************************************
Stream API - Consuming the stream
***************************************************************************** */

/**
 * Reads data from the stream (if any), leaving it in the stream.
 *
 * `buf` MUST point to a buffer with - at least - `len` bytes. This is required
 * in case the packed data is fragmented or references a file and needs to be
 * copied to an available buffer.
 *
 * On error, or if the stream is empty, `buf` will be set to NULL and `len` will
 * be set to zero.
 *
 * Otherwise, `buf` may retain the same value or it may point directly to a
 * memory address within the stream's buffer (the original value may be lost)
 * and `len` will be updated to the largest possible value for valid data that
 * can be read from `buf`.
 *
 * Note: this isn't thread safe.
 */
SFUNC void fio_stream_read(fio_stream_s *stream, char **buf, size_t *len);

/**
 * Advances the Stream, so the first `len` bytes are marked as consumed.
 *
 * Note: this isn't thread safe.
 */
SFUNC void fio_stream_advance(fio_stream_s *stream, size_t len);

/**
 * Returns true if there's any data in the stream.
 *
 * Note: this isn't truly thread safe.
 */
FIO_IFUNC uint8_t fio_stream_any(fio_stream_s *stream);

/**
 * Returns the number of bytes waiting in the stream.
 *
 * Note: this isn't truly thread safe.
 */
FIO_IFUNC size_t fio_stream_length(fio_stream_s *stream);

/* *****************************************************************************








                          Stream Implementation








***************************************************************************** */

/* *****************************************************************************
Stream Implementation - inlined static functions
***************************************************************************** */

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY
FIO_LEAK_COUNTER_DEF(fio_stream)
/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC fio_stream_s *fio_stream_new(void) {
  fio_stream_s *s = (fio_stream_s *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*s), 0);
  if (s) {
    *s = (fio_stream_s)FIO_STREAM_INIT(s[0]);
  }
  FIO_LEAK_COUNTER_ON_ALLOC(fio_stream);
  return s;
}
/* Frees any internal data AND the object's container! */
FIO_IFUNC int fio_stream_free(fio_stream_s *s) {
  fio_stream_destroy(s);
  FIO_MEM_FREE_(s, sizeof(*s));
  FIO_LEAK_COUNTER_ON_FREE(fio_stream);
  return 0;
}
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/* Returns true if there's any data in the stream */
FIO_IFUNC uint8_t fio_stream_any(fio_stream_s *s) { return s && s->next; }

/* Returns the number of bytes waiting in the stream */
FIO_IFUNC size_t fio_stream_length(fio_stream_s *s) { return s->length; }

/* *****************************************************************************
Stream Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_IFUNC void fio_stream_packet_free_all(fio_stream_packet_s *p);
/* Frees any internal data AND the object's container! */
SFUNC void fio_stream_destroy(fio_stream_s *s) {
  if (!s)
    return;
  fio_stream_packet_free_all(s->next);
  *s = (fio_stream_s)FIO_STREAM_INIT(s[0]);
  return;
}

FIO_LEAK_COUNTER_DEF(fio_stream_packet_s)

/* *****************************************************************************
Stream API - packing data into packets and adding it to the stream
***************************************************************************** */

struct fio_stream_packet_s {
  fio_stream_packet_s *next;
};

typedef enum {
  FIO_PACKET_TYPE_EMBEDDED = 0,
  FIO_PACKET_TYPE_EXTERNAL = 1,
  FIO_PACKET_TYPE_FILE = 2,
  FIO_PACKET_TYPE_FILE_NO_CLOSE = 3,
} fio_stream_packet_type_e;
#define FIO_STREAM___TYPE_BITS 2

typedef struct fio_stream_packet_embd_s {
  fio_stream_packet_type_e type;
  uint32_t length;
  char buf[];
} fio_stream_packet_embd_s;

typedef struct fio_stream_packet_extrn_s {
  fio_stream_packet_type_e type;
  size_t length;
  char *buf;
  uintptr_t offset;
  void (*dealloc)(void *buf);
} fio_stream_packet_extrn_s;

/** User-space socket buffer data */
typedef struct {
  fio_stream_packet_type_e type;
  size_t length;
  size_t offset;
  int fd;
} fio_stream_packet_fd_s;

FIO_SFUNC void fio_stream_packet_free(fio_stream_packet_s *p) {
  if (!p)
    return;
  FIO_LEAK_COUNTER_ON_FREE(fio_stream_packet_s);
  union {
    fio_stream_packet_embd_s *em;
    fio_stream_packet_extrn_s *ext;
    fio_stream_packet_fd_s *f;
  } const u = {.em = (fio_stream_packet_embd_s *)(p + 1)};
  switch (u.em->type) {
  case FIO_PACKET_TYPE_EMBEDDED:
    FIO_MEM_FREE_(p, sizeof(*p) + sizeof(*u.em) + u.em->length);
    break;
  case FIO_PACKET_TYPE_EXTERNAL:
    if (u.ext->dealloc)
      u.ext->dealloc(u.ext->buf);
    FIO_MEM_FREE_(p, sizeof(*p) + sizeof(*u.ext));
    break;
  case FIO_PACKET_TYPE_FILE: close(u.f->fd);
#ifdef DEBUG
    FIO_LOG_DEBUG2("fio_stream_packet_free closed file fd %d", u.f->fd);
#endif
    /* fall through */
  case FIO_PACKET_TYPE_FILE_NO_CLOSE:
    FIO_MEM_FREE_(p, sizeof(*p) + sizeof(*u.f));
    break;
  }
}

FIO_IFUNC void fio_stream_packet_free_all(fio_stream_packet_s *p) {
  while (p) {
    register fio_stream_packet_s *t = p;
    p = p->next;
    fio_stream_packet_free(t);
  }
}

FIO_IFUNC size_t fio___stream_p2len(fio_stream_packet_s *p) {
  size_t len = 0;
  if (!p)
    return len;
  union {
    fio_stream_packet_embd_s *em;
    fio_stream_packet_extrn_s *ext;
    fio_stream_packet_fd_s *f;
  } const u = {.em = (fio_stream_packet_embd_s *)(p + 1)};

  switch ((fio_stream_packet_type_e)(u.em->type &
                                     ((1UL << FIO_STREAM___TYPE_BITS) - 1))) {
  case FIO_PACKET_TYPE_EMBEDDED: return len = u.em->length; return len;
  case FIO_PACKET_TYPE_EXTERNAL: len = u.ext->length; return len;
  case FIO_PACKET_TYPE_FILE: /* fall through */
  case FIO_PACKET_TYPE_FILE_NO_CLOSE: len = u.f->length; return len;
  }
  return len;
}

/** Packs data into a fio_stream_packet_s container. */
SFUNC fio_stream_packet_s *fio_stream_pack_data(void *buf,
                                                size_t len,
                                                size_t offset,
                                                uint8_t copy_buffer,
                                                void (*dealloc_func)(void *)) {
  fio_stream_packet_s *p = NULL;
  if (!len || !buf || (len & ((~(0UL)) << (32 - FIO_STREAM___TYPE_BITS))))
    goto error;
  if (copy_buffer || len < FIO_STREAM_ALWAYS_COPY_IF_LESS_THAN) {
    while (len) {
      /* break apart large memory blocks into smaller pieces */
      const size_t slice =
          (len > FIO_STREAM_COPY_PER_PACKET) ? FIO_STREAM_COPY_PER_PACKET : len;
      fio_stream_packet_embd_s *em;
      fio_stream_packet_s *tmp = (fio_stream_packet_s *)FIO_MEM_REALLOC_(
          NULL,
          0,
          sizeof(*p) + sizeof(*em) + (sizeof(char) * slice),
          0);
      if (!tmp)
        goto error;
      FIO_LEAK_COUNTER_ON_ALLOC(fio_stream_packet_s);
      tmp->next = p;
      em = (fio_stream_packet_embd_s *)(tmp + 1);
      em->type = FIO_PACKET_TYPE_EMBEDDED;
      em->length = (uint32_t)slice;
      FIO_MEMCPY(em->buf, (char *)buf + offset + (len - slice), slice);
      p = tmp;
      len -= slice;
    }
    if (dealloc_func)
      dealloc_func(buf);
  } else {
    fio_stream_packet_extrn_s *ext;
    p = (fio_stream_packet_s *)
        FIO_MEM_REALLOC_(NULL, 0, sizeof(*p) + sizeof(*ext), 0);
    if (!p)
      goto error;
    FIO_LEAK_COUNTER_ON_ALLOC(fio_stream_packet_s);
    p->next = NULL;
    ext = (fio_stream_packet_extrn_s *)(p + 1);
    *ext = (fio_stream_packet_extrn_s){
        .type = FIO_PACKET_TYPE_EXTERNAL,
        .length = (uint32_t)len,
        .buf = (char *)buf,
        .offset = offset,
        .dealloc = dealloc_func,
    };
  }
  return p;

error:
  if (dealloc_func)
    dealloc_func(buf);
  fio_stream_packet_free_all(p);
  return p;
}

/** Packs a file descriptor into a fio_stream_packet_s container. */
SFUNC fio_stream_packet_s *fio_stream_pack_fd(int fd,
                                              size_t len,
                                              size_t offset,
                                              uint8_t keep_open) {
  fio_stream_packet_s *p = NULL;
  fio_stream_packet_fd_s *f;
  if ((unsigned)(fd + 1) < 2)
    goto no_file;

  if (!len) {
    /* review file total length and auto-calculate */
    len = fio_fd_size(fd);
    if (!len || offset >= len || len >= 0x7FFFFFFF)
      goto error;
    len -= offset;
  }

  p = (fio_stream_packet_s *)
      FIO_MEM_REALLOC_(NULL, 0, sizeof(*p) + sizeof(*f), 0);
  if (!p)
    goto error;
  FIO_LEAK_COUNTER_ON_ALLOC(fio_stream_packet_s);
  p->next = NULL;
  f = (fio_stream_packet_fd_s *)(p + 1);
  *f = (fio_stream_packet_fd_s){
      .type =
          (keep_open ? FIO_PACKET_TYPE_FILE_NO_CLOSE : FIO_PACKET_TYPE_FILE),
      .length = len,
      .offset = offset,
      .fd = fd,
  };
#ifdef DEBUG
  FIO_LOG_DEBUG2("fio_stream_pack_fd wrapping file fd %d", fd);
#endif
  return p;
error:
  if (!keep_open)
    close(fd);
no_file:
  return p;
}

/** Adds a packet to the stream. This isn't thread safe.*/
SFUNC void fio_stream_add(fio_stream_s *s, fio_stream_packet_s *p) {
  fio_stream_packet_s *last = p;
  size_t len = 0;

  if (!s || !p)
    goto error;
  len = fio___stream_p2len(p);

  while (last->next) {
    last = last->next;
    len += fio___stream_p2len(last);
  }
  if (!s->pos)
    s->pos = &s->next;
  *s->pos = p;
  s->pos = &last->next;
  s->length += len;
  return;
error:
  fio_stream_pack_free(p);
}

/** Destroys the fio_stream_packet_s - call this ONLY if unused. */
SFUNC void fio_stream_pack_free(fio_stream_packet_s *p) {
  fio_stream_packet_free_all(p);
}

/* *****************************************************************************
Stream API - Consuming the stream
***************************************************************************** */

FIO_SFUNC void fio___stream_read_internal(fio_stream_packet_s *p,
                                          char **buf,
                                          size_t *len,
                                          size_t buf_offset,
                                          size_t offset,
                                          size_t must_copy) {
  if (!p || !len[0]) {
    len[0] = 0;
    return;
  }
  union {
    fio_stream_packet_embd_s *em;
    fio_stream_packet_extrn_s *ext;
    fio_stream_packet_fd_s *f;
  } const u = {.em = (fio_stream_packet_embd_s *)(p + 1)};
  size_t written = 0;

  switch (u.em->type) {
  case FIO_PACKET_TYPE_EMBEDDED:
    if (!buf[0] || !len[0] ||
        (!must_copy && (!p->next || u.em->length >= len[0] + offset))) {
      buf[0] = u.em->buf + offset;
      len[0] = (size_t)u.em->length - offset;
      return;
    }
    written = u.em->length - offset;
    if (written > len[0])
      written = len[0];
    if (written) {
      FIO_MEMCPY(buf[0] + buf_offset, u.em->buf + offset, written);
      len[0] -= written;
    }
    if (len[0]) {
      fio___stream_read_internal(p->next, buf, len, written + buf_offset, 0, 1);
    }
    len[0] += written;
    return;
  case FIO_PACKET_TYPE_EXTERNAL:
    if (!buf[0] || !len[0] ||
        (!must_copy && (!p->next || u.ext->length >= len[0] + offset))) {
      buf[0] = u.ext->buf + u.ext->offset + offset;
      len[0] = (size_t)(u.ext->length) - offset;
      return;
    }
    written = u.ext->length - offset;
    if (written > len[0])
      written = len[0];
    if (written) {
      FIO_MEMCPY(buf[0] + buf_offset,
                 u.ext->buf + u.ext->offset + offset,
                 written);
      len[0] -= written;
    }
    if (len[0]) {
      fio___stream_read_internal(p->next, buf, len, written + buf_offset, 0, 1);
    }
    len[0] += written;
    return;
    break;
  case FIO_PACKET_TYPE_FILE: /* fall through */
  case FIO_PACKET_TYPE_FILE_NO_CLOSE:
    if (!buf[0] || !len[0]) {
      len[0] = 0;
      return;
    }
    {
      uint8_t possible_eof_surprise = 0;
      written = u.f->length - offset; /* written here == to be read & written */
      if (written > len[0])
        written = len[0];
      if (written) {
        ssize_t act;
      retry_on_signal:
        act = fio_fd_read(u.f->fd,
                          buf[0] + buf_offset,
                          written,
                          u.f->offset + offset);
        if (act <= 0) {
          /* no more data in the file? */
          FIO_LOG_DEBUG("file read error for %d: %s", u.f->fd, strerror(errno));
          if (errno == EINTR)
            goto retry_on_signal;
          // u.f->length = offset; /* mark EOF */
        } else if ((size_t)act != written) {
          /* a surprising EOF? */
          written = act;
          possible_eof_surprise = 1;
          // u.f->length = offset + act; /* mark EOF? */
        }
        len[0] -= written;
      }
      if (!possible_eof_surprise && len[0]) {
        fio___stream_read_internal(p->next,
                                   buf,
                                   len,
                                   written + buf_offset,
                                   0,
                                   1);
      }
      len[0] += written;
    }
    return;
  }
}

/**
 * Reads data from the stream (if any), leaving it in the stream.
 *
 * `buf` MUST point to a buffer with - at least - `len` bytes. This is required
 * in case the packed data is fragmented or references a file and needs to be
 * copied to an available buffer.
 *
 * On error, or if the stream is empty, `buf` will be set to NULL and `len` will
 * be set to zero.
 *
 * Otherwise, `buf` may retain the same value or it may point directly to a
 * memory address wiithin the stream's buffer (the original value may be lost)
 * and `len` will be updated to the largest possible value for valid data that
 * can be read from `buf`.
 *
 * Note: this isn't thread safe.
 */
SFUNC void fio_stream_read(fio_stream_s *s, char **buf, size_t *len) {
  if (!s || !s->next)
    goto none;
  fio___stream_read_internal(s->next, buf, len, 0, s->consumed, 0);
  return;
none:
  *buf = NULL;
  *len = 0;
}

/**
 * Advances the Stream, so the first `len` bytes are marked as consumed.
 *
 * Note: this isn't thread safe.
 */
SFUNC void fio_stream_advance(fio_stream_s *s, size_t len) {
  if (!s || !s->next)
    return;
  s->length -= len;
  len += s->consumed;
  while (len) {
    size_t p_len = fio___stream_p2len(s->next);
    if (len >= p_len) {
      fio_stream_packet_s *p = s->next;
      s->next = p->next;
      fio_stream_packet_free(p);
      len -= p_len;
      if (!s->next) {
        s->pos = &s->next;
        s->consumed = 0;
        s->length = 0;
        return;
      }
    } else {
      s->consumed = len;
      return;
    }
  }
  s->consumed = len;
}

/* *****************************************************************************
Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_STREAM___TYPE_BITS
#endif /* FIO_STREAM */
#undef FIO_STREAM
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_STR                /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                      Binary Safe String Core Helpers



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_STR) && !defined(H___FIO_STR___H)
#define H___FIO_STR___H
/* *****************************************************************************
String Authorship Helpers (`fio_string_write` functions)
***************************************************************************** */

/**
 * A reallocation callback type for buffers in a `fio_str_info_s`.
 *
 * The callback MUST allocate at least `len + 1` bytes, setting the new capacity
 * in `dest->capa`.
 * */
typedef int (*fio_string_realloc_fn)(fio_str_info_s *dest, size_t len);
/**
 * Writes data to the end of the string in the `fio_string_s` struct,
 * returning an updated `fio_string_s` struct.
 *
 * The returned string is NUL terminated if edited.
 *
 * * `dest` an `fio_string_s` struct containing the destination string.
 *
 * * `reallocate` is a callback that attempts to reallocate more memory (i.e.,
 * using `realloc`) and returns an updated `fio_string_s` struct containing the
 *   updated capacity and buffer pointer (as well as the original length).
 *
 *   On failure the original `fio_string_s` should be returned. if
 * `reallocate` is NULL or fails, the data copied will be truncated.
 *
 * * `src` is the data to be written to the end of `dest`.
 *
 * * `len` is the length of the data to be written to the end of `dest`.
 *
 * Note: this function performs only minimal checks and assumes that `dest` is
 *       fully valid - i.e., that `dest.capa >= dest.len`, that `dest.buf` is
 *       valid, etc'.
 *
 * An example for a `reallocate` callback using the system's `realloc` function:
 *
 *      int fio_string_realloc_system(fio_str_info_s *dest, size_t len_no_nul) {
 *       const size_t new_capa = fio_string_capa4len(len_pre_nul);
 *       void *tmp = realloc(dest.buf, new_capa);
 *       if (!tmp)
 *         return -1;
 *       dest.capa = new_capa;
 *       dest.buf = (char *)tmp;
 *       return 0;
 *     }
 *
 * An example for using the function:
 *
 *     void example(void) {
 *       char buf[32];
 *       fio_str_info_s str = FIO_STR_INFO3(buf, 0, 32);
 *       fio_string_write(&str, NULL, "The answer is: 0x", 17);
 *       str.len += fio_ltoa(str.buf + str.len, 42, 16);
 *       fio_string_write(&str, NULL, "!\n", 2);
 *       printf("%s", str.buf);
 *     }
 */
FIO_SFUNC int fio_string_write(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               const void *restrict src,
                               size_t len);

/**
 * Similar to `fio_string_write`, only replacing/inserting a sub-string in a
 * specific location.
 *
 * Negative `start_pos` values are calculated backwards, `-1` == end of String.
 *
 * When `overwrite_len` is zero, the function will insert the data at
 * `start_pos`, pushing existing data until after the inserted data.
 *
 * If `overwrite_len` is non-zero, than `overwrite_len` bytes will be
 * overwritten (or deleted).
 *
 * If `len == 0` than `src` will be ignored and the data marked for replacement
 * will be erased.
 */
SFUNC int fio_string_replace(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             intptr_t start_pos,
                             size_t overwrite_len,
                             const void *src,
                             size_t len);

/** Argument type used by fio_string_write2. */
typedef struct {
  size_t klass;
  union {
    struct {
      size_t len;
      const char *buf;
    } str;
    double f;
    int64_t i;
    uint64_t u;
  } info;
} fio_string_write_s;

/**
 * Writes a group of objects (strings, numbers, etc') to `dest`.
 *
 * `dest` and `reallocate` are similar to `fio_string_write`.
 *
 * `src` is an array of `fio_string_write_s` structs, ending with a struct
 * that's all set to 0.
 *
 * Use the `fio_string_write2` macro for ease, i.e.:
 *
 *    fio_str_info_s str = {0};
 *    fio_string_write2(&str, my_reallocate,
 *                        FIO_STRING_WRITE_STR1("The answer is: "),
 *                        FIO_STRING_WRITE_NUM(42),
 *                        FIO_STRING_WRITE_STR2("(0x", 3),
 *                        FIO_STRING_WRITE_HEX(42),
 *                        FIO_STRING_WRITE_STR2(")", 1));
 *
 * Note: this function might end up allocating more memory than absolutely
 * required as it favors fast performance over memory savings. It performs only
 * a single allocation (if any) and computes numeral string length only when
 * writing the numbers to the string.
 */
SFUNC int fio_string_write2(fio_str_info_s *restrict dest,
                            fio_string_realloc_fn reallocate,
                            const fio_string_write_s srcs[]);

/* Helper macro for fio_string_write2 */
#define fio_string_write2(dest, reallocate, ...)                               \
  fio_string_write2((dest),                                                    \
                    (reallocate),                                              \
                    (fio_string_write_s[]){__VA_ARGS__, {0}})

/** A macro to add a String to `fio_string_write2`. */
#define FIO_STRING_WRITE_STR1(str_)                                            \
  ((fio_string_write_s){                                                       \
      .klass = 1,                                                              \
      .info.str = {.len = (size_t)FIO_STRLEN((str_)), .buf = (str_)}})

/** A macro to add a String with known length to `fio_string_write2`. */
#define FIO_STRING_WRITE_STR2(str_, len_)                                      \
  ((fio_string_write_s){.klass = 1, .info.str = {.len = (len_), .buf = (str_)}})

/** A macro to add a String with known length to `fio_string_write2`. */
#define FIO_STRING_WRITE_STR_INFO(str_)                                        \
  ((fio_string_write_s){.klass = 1,                                            \
                        .info.str = {.len = (str_).len, .buf = (str_).buf}})

/** A macro to add a signed number to `fio_string_write2`. */
#define FIO_STRING_WRITE_NUM(num)                                              \
  ((fio_string_write_s){.klass = 2, .info.i = (int64_t)(num)})

/** A macro to add an unsigned number to `fio_string_write2`. */
#define FIO_STRING_WRITE_UNUM(num)                                             \
  ((fio_string_write_s){.klass = 3, .info.u = (uint64_t)(num)})

/** A macro to add a hex representation to `fio_string_write2`. */
#define FIO_STRING_WRITE_HEX(num)                                              \
  ((fio_string_write_s){.klass = 4, .info.u = (uint64_t)(num)})

/** A macro to add a binary representation to `fio_string_write2`. */
#define FIO_STRING_WRITE_BIN(num)                                              \
  ((fio_string_write_s){.klass = 5, .info.u = (uint64_t)(num)})

/** A macro to add a float (double) to `fio_string_write2`. */
#define FIO_STRING_WRITE_FLOAT(num)                                            \
  ((fio_string_write_s){.klass = 6, .info.f = (double)(num)})

/* *****************************************************************************
String Numerals support
***************************************************************************** */

/* Writes a signed number `i` to the String */
SFUNC int fio_string_write_i(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             int64_t i);
/* Writes an unsigned number `i` to the String */
SFUNC int fio_string_write_u(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             uint64_t i);
/* Writes a hex representation of `i` to the String */
SFUNC int fio_string_write_hex(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               uint64_t i);
/* Writes a binary representation of `i` to the String */
SFUNC int fio_string_write_bin(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               uint64_t i);

/* *****************************************************************************
String printf style support
***************************************************************************** */

/** Similar to fio_string_write, only using printf semantics. */
SFUNC FIO___PRINTF_STYLE(3, 0) int fio_string_printf(
    fio_str_info_s *dest,
    fio_string_realloc_fn reallocate,
    const char *format,
    ...);

/** Similar to fio_string_write, only using vprintf semantics. */
SFUNC FIO___PRINTF_STYLE(3, 0) int fio_string_vprintf(
    fio_str_info_s *dest,
    fio_string_realloc_fn reallocate,
    const char *format,
    va_list argv);

/* *****************************************************************************
String C / JSON escaping
***************************************************************************** */

/**
 * Writes data at the end of the String, escaping the data using JSON semantics.
 *
 * The JSON semantic are common to many programming languages, promising a UTF-8
 * String while making it easy to read and copy the string during debugging.
 */
SFUNC int fio_string_write_escape(fio_str_info_s *restrict dest,
                                  fio_string_realloc_fn reallocate,
                                  const void *raw,
                                  size_t raw_len);

/** Writes an escaped data into the string after un-escaping the data. */
SFUNC int fio_string_write_unescape(fio_str_info_s *dest,
                                    fio_string_realloc_fn reallocate,
                                    const void *enscaped,
                                    size_t enscaped_len);

/* *****************************************************************************
String Base32 support
***************************************************************************** */

/** Writes data to String using base64 encoding. */
SFUNC int fio_string_write_base32enc(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *raw,
                                     size_t raw_len);

/** Writes decoded base64 data to String. */
SFUNC int fio_string_write_base32dec(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *encoded,
                                     size_t encoded_len);

/* *****************************************************************************
String Base64 support
***************************************************************************** */

/** Writes data to String using base64 encoding. */
SFUNC int fio_string_write_base64enc(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *raw,
                                     size_t raw_len,
                                     uint8_t url_encoded);

/** Writes decoded base64 data to String. */
SFUNC int fio_string_write_base64dec(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *encoded,
                                     size_t encoded_len);

/* *****************************************************************************
String URL Encoding support
***************************************************************************** */

/** Writes data to String using URL encoding (a.k.a., percent encoding). */
SFUNC int fio_string_write_url_enc(fio_str_info_s *dest,
                                   fio_string_realloc_fn reallocate,
                                   const void *raw,
                                   size_t raw_len);

/** Writes decoded URL data to String, decoding + to spaces. */
SFUNC int fio_string_write_url_dec(fio_str_info_s *dest,
                                   fio_string_realloc_fn reallocate,
                                   const void *encoded,
                                   size_t encoded_len);

/** Writes decoded URL data to String, without decoding + to spaces. */
SFUNC int fio_string_write_path_dec(fio_str_info_s *dest,
                                    fio_string_realloc_fn reallocate,
                                    const void *encoded,
                                    size_t encoded_len);

/* *****************************************************************************
String HTML escaping support
***************************************************************************** */

/** Writes HTML escaped data to a String. */
SFUNC int fio_string_write_html_escape(fio_str_info_s *dest,
                                       fio_string_realloc_fn reallocate,
                                       const void *raw,
                                       size_t raw_len);

/** Writes HTML un-escaped data to a String - incomplete and minimal. */
SFUNC int fio_string_write_html_unescape(fio_str_info_s *dest,
                                         fio_string_realloc_fn reallocate,
                                         const void *enscaped,
                                         size_t enscaped_len);

/* *****************************************************************************
String File Reading support
***************************************************************************** */

/**
 * Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at`.
 *
 * If `limit` is 0 (or less than 0) data will be written until EOF.
 *
 * If `start_at` is negative, position will be calculated from the end of the
 * file where `-1 == EOF`.
 *
 * Note: this will fail unless used on actual files (not sockets, not pipes).
 * */
SFUNC int fio_string_readfd(fio_str_info_s *dest,
                            fio_string_realloc_fn reallocate,
                            int fd,
                            intptr_t start_at,
                            size_t limit);

/**
 * Opens the file `filename` and pastes it's contents (or a slice ot it) at
 * the end of the String. If `limit == 0`, than the data will be read until
 * EOF.
 *
 * If the file can't be located, opened or read, or if `start_at` is beyond
 * the EOF position, NULL is returned in the state's `data` field.
 */
SFUNC int fio_string_readfile(fio_str_info_s *dest,
                              fio_string_realloc_fn reallocate,
                              const char *filename,
                              intptr_t start_at,
                              size_t limit);

/**
 * Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at` and
 * ending either at the first occurrence of `delim` or at EOF.
 *
 * If `limit` is 0 (or less than 0) as much data as may be required will be
 * written.
 *
 * If `start_at` is negative, position will be calculated from the end of the
 * file where `-1 == EOF`.
 *
 * Note: this will fail unless used on actual seekable files (not sockets, not
 * pipes).
 * */
SFUNC int fio_string_getdelim_fd(fio_str_info_s *dest,
                                 fio_string_realloc_fn reallocate,
                                 int fd,
                                 intptr_t start_at,
                                 char delim,
                                 size_t limit);

/**
 * Opens the file `filename`, calls `fio_string_getdelim_fd` and closes the
 * file.
 */
SFUNC int fio_string_getdelim_file(fio_str_info_s *dest,
                                   fio_string_realloc_fn reallocate,
                                   const char *filename,
                                   intptr_t start_at,
                                   char delim,
                                   size_t limit);

/* *****************************************************************************
Memory Helpers (for Authorship)
***************************************************************************** */

/* calculates a 16 bytes boundary aligned capacity for `new_len`. */
FIO_IFUNC size_t fio_string_capa4len(size_t new_len);

/** Default reallocation callback implementation using libc `realloc`. */
#define FIO_STRING_SYS_REALLOC fio_string_sys_reallocate
/** Default reallocation callback implementation using the default allocator */
#define FIO_STRING_REALLOC fio_string_default_reallocate
/** Default reallocation callback for memory that mustn't be freed. */
#define FIO_STRING_ALLOC_COPY fio_string_default_allocate_copy
/** default allocator for the fio_keystr_s string data.. */
#define FIO_STRING_ALLOC_KEY fio_string_default_key_alloc
/** Frees memory that was allocated with the default callbacks. */
#define FIO_STRING_FREE fio_string_default_free
/** Frees memory that was allocated with the default callbacks. */
#define FIO_STRING_FREE2 fio_string_default_free2
/** Frees memory that was allocated for a key string. */
#define FIO_STRING_FREE_KEY fio_string_default_free_key
/** Does nothing. */
#define FIO_STRING_FREE_NOOP fio_string_default_free_noop
/** Does nothing. */
#define FIO_STRING_FREE_NOOP2 fio_string_default_free_noop2

/** default reallocation callback implementation. */
SFUNC int fio_string_default_reallocate(fio_str_info_s *dst, size_t len);
/** default reallocation callback for memory that mustn't be freed. */
SFUNC int fio_string_default_allocate_copy(fio_str_info_s *dest,
                                           size_t new_capa);
/** frees memory that was allocated with the default callbacks. */
SFUNC void fio_string_default_free(void *);
/** frees memory that was allocated with the default callbacks. */
SFUNC void fio_string_default_free2(fio_str_info_s str);
/** does nothing. */
SFUNC void fio_string_default_free_noop(void *);
/** does nothing. */
SFUNC void fio_string_default_free_noop2(fio_str_info_s str);

/** default allocator for the fio_keystr_s string data.. */
SFUNC void *fio_string_default_key_alloc(size_t len);
/** frees a fio_keystr_s memory that was allocated with the default callback. */
SFUNC void fio_string_default_free_key(void *, size_t);

/* *****************************************************************************
UTF-8 Support
***************************************************************************** */

/** Returns 1 if the String is UTF-8 valid and 0 if not. */
SFUNC bool fio_string_utf8_valid(fio_str_info_s str);

/** Returns the String's length in UTF-8 characters or 0 if invalid. */
SFUNC size_t fio_string_utf8_len(fio_str_info_s str);

/** Returns 0 if non-UTF-8 or returns 1-4 (UTF-8 if a valid char). */
SFUNC size_t fio_string_utf8_valid_code_point(const void *u8c, size_t buf_len);

/**
 * Takes a UTF-8 character selection information (UTF-8 position and length)
 * and updates the same variables so they reference the raw byte slice
 * information.
 *
 * If the String isn't UTF-8 valid up to the requested selection, than `pos`
 * will be updated to `-1` otherwise values are always positive.
 *
 * The returned `len` value may be shorter than the original if there wasn't
 * enough data left to accommodate the requested length. When a `len` value of
 * `0` is returned, this means that `pos` marks the end of the String.
 *
 * Returns -1 on error and 0 on success.
 */
SFUNC int fio_string_utf8_select(fio_str_info_s str,
                                 intptr_t *pos,
                                 size_t *len);

/* *****************************************************************************
Sorting / Comparison Helpers
***************************************************************************** */

/**
 * Compares two `fio_buf_info_s`, returning 1 if data in a is bigger than b.
 *
 * Note: returns 0 if data in b is bigger than or equal(!).
 */
SFUNC int fio_string_is_greater_buf(fio_buf_info_s a, fio_buf_info_s b);

/**
 * Compares two strings, returning 1 if string a is bigger than string b.
 *
 * Note: returns 0 if string b is bigger than string a or if strings are equal.
 */
FIO_IFUNC int fio_string_is_greater(fio_str_info_s a, fio_str_info_s b);

/* *****************************************************************************
Binary String Type - Embedded Strings optimized for mutability and locality
***************************************************************************** */

/* for internal use only */
typedef struct {
  uint32_t len;
  uint32_t capa;
  uint32_t ref;
} fio___bstr_meta_s;

/* for internal use only */
typedef struct {
  fio___bstr_meta_s meta;
  char *ptr;
} fio___bstr_const_s;

/** Reserves `len` for future `write` operations (used to minimize realloc). */
FIO_IFUNC char *fio_bstr_reserve(char *bstr, size_t len);

/** Copies a `fio_bstr` using "copy on write". */
FIO_IFUNC char *fio_bstr_copy(char *bstr);
/** Frees a binary string allocated by a `fio_bstr` function. Returns NULL.*/
FIO_IFUNC void fio_bstr_free(char *bstr);

/** Returns information about the fio_bstr. */
FIO_IFUNC fio_str_info_s fio_bstr_info(const char *bstr);
/** Returns information about the fio_bstr. */
FIO_IFUNC fio_buf_info_s fio_bstr_buf(const char *bstr);
/** Gets the length of the fio_bstr. `bstr` MUST NOT be NULL. */
FIO_IFUNC size_t fio_bstr_len(const char *bstr);
/** Sets the length of the fio_bstr. `bstr` MUST NOT be NULL. */
FIO_IFUNC char *fio_bstr_len_set(char *bstr, size_t len);

/** Compares to see if fio_bstr a is greater than fio_bstr b (for FIO_SORT). */
FIO_SFUNC int fio_bstr_is_greater(const char *a, const char *b);
/** Compares to see if fio_bstr a is equal to another String. */
FIO_SFUNC int fio_bstr_is_eq2info(const char *a_, fio_str_info_s b);
/** Compares to see if fio_bstr a is equal to another String. */
FIO_SFUNC int fio_bstr_is_eq2buf(const char *a_, fio_buf_info_s b);

/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write(char *bstr,
                               const void *restrict src,
                               size_t len);
/** Replaces data in a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_replace(char *bstr,
                                 intptr_t start_pos,
                                 size_t overwrite_len,
                                 const void *src,
                                 size_t len);
/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write2(char *bstr, const fio_string_write_s srcs[]);
/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
#define fio_bstr_write2(bstr, ...)                                             \
  fio_bstr_write2(bstr, (fio_string_write_s[]){__VA_ARGS__, {0}})

/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_i(char *bstr, int64_t num);
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_u(char *bstr, uint64_t num);
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_hex(char *bstr, uint64_t num);
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_bin(char *bstr, uint64_t num);

/** Writes escaped data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_escape(char *bstr, const void *src, size_t len);
/** Un-escapes and writes data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_unescape(char *bstr,
                                        const void *src,
                                        size_t len);

/** Writes base64 encoded data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_base64enc(char *bstr,
                                         const void *src,
                                         size_t len,
                                         uint8_t url_encoded);
/** Decodes base64 data and writes to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_base64dec(char *bstr,
                                         const void *src,
                                         size_t len);

/** Writes data to String using URL encoding (a.k.a., percent encoding). */
FIO_IFUNC char *fio_bstr_write_url_enc(char *bstr,
                                       const void *data,
                                       size_t len);
/** Writes decoded URL data to String. */
FIO_IFUNC char *fio_bstr_write_url_dec(char *bstr,
                                       const void *encoded,
                                       size_t len);

/** Writes HTML escaped data to a String. */
FIO_IFUNC char *fio_bstr_write_html_escape(char *bstr,
                                           const void *raw,
                                           size_t len);
/** Writes HTML un-escaped data to a String - incomplete and minimal. */
FIO_IFUNC char *fio_bstr_write_html_unescape(char *bstr,
                                             const void *escaped,
                                             size_t len);

/** Writes to the String from a regular file `fd`. */
FIO_IFUNC char *fio_bstr_readfd(char *bstr,
                                int fd,
                                intptr_t start_at,
                                intptr_t limit);
/** Writes to the String from a regular file named `filename`. */
FIO_IFUNC char *fio_bstr_readfile(char *bstr,
                                  const char *filename,
                                  intptr_t start_at,
                                  intptr_t limit);
/** Writes to the String from a regular file named `filename`. */
FIO_IFUNC char *fio_bstr_getdelim_file(char *bstr,
                                       const char *filename,
                                       intptr_t start_at,
                                       char delim,
                                       size_t limit);
/** Writes to the String from a regular file `fd`. */
FIO_IFUNC char *fio_bstr_getdelim_fd(char *bstr,
                                     int fd,
                                     intptr_t start_at,
                                     char delim,
                                     size_t limit);

/** Writes a `fio_bstr` in `printf` style. */
FIO_IFUNC FIO___PRINTF_STYLE(2, 0) char *fio_bstr_printf(char *bstr,
                                                         const char *format,
                                                         ...);

/** default reallocation callback implementation - mostly for internal use. */
SFUNC int fio_bstr_reallocate(fio_str_info_s *dest, size_t len);

/* *****************************************************************************
Key String Type - binary String container for Hash Maps and Arrays
***************************************************************************** */

/** a semi-opaque type used for the `fio_keystr` functions */
typedef struct fio_keystr_s fio_keystr_s;

/** returns the Key String. NOTE: Key Strings are NOT NUL TERMINATED! */
FIO_IFUNC fio_buf_info_s fio_keystr_buf(fio_keystr_s *str);
/** returns the Key String. NOTE: Key Strings are NOT NUL TERMINATED! */
FIO_IFUNC fio_str_info_s fio_keystr_info(fio_keystr_s *str);

/** Returns a TEMPORARY `fio_keystr_s`. */
FIO_IFUNC fio_keystr_s fio_keystr_tmp(const char *buf, uint32_t len);
/** Returns an initialized `fio_keystr_s` containing a copy of `str`. */
FIO_SFUNC fio_keystr_s fio_keystr_init(fio_str_info_s str,
                                       void *(*alloc_func)(size_t len));
/** Destroys an initialized `fio_keystr_s`. */
FIO_SFUNC void fio_keystr_destroy(fio_keystr_s *key,
                                  void (*free_func)(void *, size_t));
/** Compares two Key Strings. */
FIO_IFUNC int fio_keystr_is_eq(fio_keystr_s a, fio_keystr_s b);
/** Compares a Key String to any String - used internally by the hash map. */
FIO_IFUNC int fio_keystr_is_eq2(fio_keystr_s a_, fio_str_info_s b);
/** Compares a Key String to any String - used internally by the hash map. */
FIO_IFUNC int fio_keystr_is_eq3(fio_keystr_s a_, fio_buf_info_s b);
/** Returns a good-enough `fio_keystr_s` risky hash. */
FIO_IFUNC uint64_t fio_keystr_hash(fio_keystr_s a);

#define FIO_KEYSTR_CONST ((size_t)-1LL)

/* *****************************************************************************


                             String Implementation

                           IMPLEMENTATION - INLINED


***************************************************************************** */

/* *****************************************************************************
String Authorship Helpers - (inlined) implementation
***************************************************************************** */

/* calculates a 16 bytes boundary aligned capacity for `new_len`. */
FIO_IFUNC size_t fio_string_capa4len(size_t new_len) {
  return sizeof(char) *
         ((new_len + 15LL + (!(new_len & 15ULL))) & (~((size_t)15ULL)));
}

/*
 * performs `reallocate` if necessary, `capa` rounded up to 16 byte units.
 * updates `len` if reallocation fails (or is unavailable).
 */
FIO_IFUNC int fio_string___write_validate_len(fio_str_info_s *restrict dest,
                                              fio_string_realloc_fn reallocate,
                                              size_t *restrict len) {
  size_t l = len[0];
  if ((dest->capa > dest->len + l))
    return 0;
  if (reallocate && l < (dest->capa >> 2) &&
      ((dest->capa >> 2) + (dest->capa) < 0x7FFFFFFFULL))
    l = (dest->capa >> 2);
  l += dest->len;
  if (l < 0x7FFFFFFFULL && reallocate && !reallocate(dest, l))
    return 0;
  if (dest->capa > dest->len + 1)
    len[0] = dest->capa - (dest->len + 1);
  else
    len[0] = 0;
  return -1;
}

/* fio_string_write */
FIO_SFUNC int fio_string_write(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               const void *restrict src,
                               size_t len) {
  int r = 0;
  if (!len)
    return r;
  r = fio_string___write_validate_len(dest, reallocate, &len);
  if (FIO_LIKELY(len && src))
    FIO_MEMCPY(dest->buf + dest->len, src, len);
  dest->len += len;
  dest->buf[dest->len] = 0;
  return r;
}

/**
 * Compares two strings, returning 1 if string a is bigger than string b.
 *
 * Note: returns 0 if string b is bigger than string a or if strings are equal.
 */
FIO_IFUNC int fio_string_is_greater(fio_str_info_s a, fio_str_info_s b) {
  return fio_string_is_greater_buf(FIO_STR2BUF_INFO(a), FIO_STR2BUF_INFO(b));
}

/* *****************************************************************************
Binary String Type - Embedded Strings
***************************************************************************** */
FIO_LEAK_COUNTER_DEF(fio_bstr_s)

#ifndef FIO___BSTR_META
#define FIO___BSTR_META(bstr)                                                  \
  FIO_PTR_MATH_SUB(fio___bstr_meta_s, bstr, sizeof(fio___bstr_meta_s))
#endif

/** Duplicates a `fio_bstr` using copy on write. */
FIO_IFUNC char *fio_bstr_copy(char *bstr) {
  if (!bstr)
    return bstr;
  fio___bstr_meta_s *meta = FIO___BSTR_META(bstr);
  if (fio_atomic_add(&meta->ref, 1) > ((uint32_t)1UL << 31))
    goto copy_anyway;
  return bstr;
copy_anyway:
  bstr = fio_bstr_write(NULL, bstr, meta->len);
  fio_bstr_free((char *)(meta + 1));
  return bstr;
}

/** Frees a binary string allocated by a `fio_bstr` function. */
FIO_IFUNC void fio_bstr_free(char *bstr) {
  if (!bstr)
    return;
  fio___bstr_meta_s *meta = FIO___BSTR_META(bstr);
  if (fio_atomic_sub(&meta->ref, 1))
    return;
  FIO_LEAK_COUNTER_ON_FREE(fio_bstr_s);
  FIO_MEM_FREE_(meta, (meta->capa + sizeof(*meta)));
}

/** internal helper - sets the length of the fio_bstr. */
FIO_IFUNC char *fio_bstr___len_set(char *bstr, size_t len) {
  if (FIO_UNLIKELY(!bstr))
    return bstr;
  // if (FIO_UNLIKELY(len >= 0xFFFFFFFFULL))
  //   return bstr;
  bstr[(FIO___BSTR_META(bstr)->len = (uint32_t)len)] = 0;
  return bstr;
}

/** Reserves `len` for future `write` operations (used to minimize realloc). */
FIO_IFUNC char *fio_bstr_reserve(char *bstr, size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  if (i.len + len < i.capa)
    return bstr;
  fio_bstr_reallocate(&i, (i.len + len));
  return fio_bstr___len_set(i.buf, i.len);
}

/** Returns information about the fio_bstr. */
FIO_IFUNC fio_str_info_s fio_bstr_info(const char *bstr) {
  fio_str_info_s r = {0};
  r.buf = (char *)bstr;
  /* please emit conditional mov and not if branches */
  if (bstr)
    r.len = FIO___BSTR_META(bstr)->len;
  if (bstr)
    r.capa = FIO___BSTR_META(bstr)->capa;
  if (bstr && FIO___BSTR_META(bstr)->ref)
    r.capa = 1;
  return r;
}

/** Returns information about the fio_bstr. */
FIO_IFUNC fio_buf_info_s fio_bstr_buf(const char *bstr) {
  fio___bstr_meta_s mem[1] = {{0}};
  fio___bstr_meta_s *meta_map[2] = {FIO___BSTR_META(bstr), mem};
  fio___bstr_meta_s *meta = meta_map[!bstr];
  return FIO_BUF_INFO2((char *)bstr, meta->len);
}

/** Gets the length of the fio_bstr. `bstr` MUST NOT be NULL. */
FIO_IFUNC size_t fio_bstr_len(const char *bstr) {
  if (!bstr)
    return 0;
  fio___bstr_meta_s *meta = FIO___BSTR_META(bstr);
  return meta->len;
}

/** Sets the length of the fio_bstr. `bstr` MUST NOT be NULL. */
FIO_IFUNC char *fio_bstr_len_set(char *bstr, size_t len) {
  fio___bstr_meta_s m[2] = {0};
  fio___bstr_meta_s *meta = FIO___BSTR_META(bstr);
  if (!bstr)
    meta = m;
  if (FIO_UNLIKELY(len >= 0xFFFFFFFFULL))
    return bstr;
  if (FIO_UNLIKELY(meta->ref || meta->capa <= len)) {
    fio_str_info_s i = fio_bstr_info(bstr);
    fio_bstr_reallocate(&i, len);
    bstr = i.buf;
  }
  return fio_bstr___len_set(bstr, len);
}

/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write(char *bstr,
                               const void *restrict src,
                               size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Replaces data in a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_replace(char *bstr,
                                 intptr_t start_pos,
                                 size_t overwrite_len,
                                 const void *src,
                                 size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_replace(&i,
                     fio_bstr_reallocate,
                     start_pos,
                     overwrite_len,
                     src,
                     len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write2 FIO_NOOP(char *bstr,
                                         const fio_string_write_s srcs[]) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write2 FIO_NOOP(&i, fio_bstr_reallocate, srcs);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_i(char *bstr, int64_t num) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_i(&i, fio_bstr_reallocate, num);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_u(char *bstr, uint64_t num) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_u(&i, fio_bstr_reallocate, num);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_hex(char *bstr, uint64_t num) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_hex(&i, fio_bstr_reallocate, num);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_bin(char *bstr, uint64_t num) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_bin(&i, fio_bstr_reallocate, num);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes escaped data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_escape(char *bstr, const void *src, size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_escape(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Un-escapes and writes data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_unescape(char *bstr,
                                        const void *src,
                                        size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_unescape(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes base64 encoded data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_base64enc(char *bstr,
                                         const void *src,
                                         size_t len,
                                         uint8_t url_encoded) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_base64enc(&i, fio_bstr_reallocate, src, len, url_encoded);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Decodes base64 data and writes to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_base64dec(char *bstr,
                                         const void *src,
                                         size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_base64dec(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes data to String using URL encoding (a.k.a., percent encoding). */
FIO_IFUNC char *fio_bstr_write_url_enc(char *bstr,
                                       const void *src,
                                       size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_url_enc(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes decoded URL data to String. */
FIO_IFUNC char *fio_bstr_write_url_dec(char *bstr,
                                       const void *src,
                                       size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_url_dec(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes HTML escaped data to a String. */
FIO_IFUNC char *fio_bstr_write_html_escape(char *bstr,
                                           const void *src,
                                           size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_html_escape(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes HTML un-escaped data to a String - incomplete and minimal. */
FIO_IFUNC char *fio_bstr_write_html_unescape(char *bstr,
                                             const void *src,
                                             size_t len) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_html_unescape(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

FIO_IFUNC FIO___PRINTF_STYLE(2, 0) char *fio_bstr_printf(char *bstr,
                                                         const char *format,
                                                         ...) {
  va_list argv;
  va_start(argv, format);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_vprintf(&i, fio_bstr_reallocate, format, argv);
  va_end(argv);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes to the String from a regular file `fd`. */
FIO_IFUNC char *fio_bstr_readfd(char *bstr,
                                int fd,
                                intptr_t start_at,
                                intptr_t limit) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_readfd(&i, fio_bstr_reallocate, fd, start_at, limit);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes to the String from a regular file named `filename`. */
FIO_IFUNC char *fio_bstr_readfile(char *bstr,
                                  const char *filename,
                                  intptr_t start_at,
                                  intptr_t limit) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_readfile(&i, fio_bstr_reallocate, filename, start_at, limit);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes to the String from a regular file named `filename`. */
FIO_IFUNC char *fio_bstr_getdelim_file(char *bstr,
                                       const char *filename,
                                       intptr_t start_at,
                                       char delim,
                                       size_t limit) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_getdelim_file(&i,
                           fio_bstr_reallocate,
                           filename,
                           start_at,
                           delim,
                           limit);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes to the String from a regular file `fd`. */
FIO_IFUNC char *fio_bstr_getdelim_fd(char *bstr,
                                     int fd,
                                     intptr_t start_at,
                                     char delim,
                                     size_t limit) {
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_getdelim_fd(&i, fio_bstr_reallocate, fd, start_at, delim, limit);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Compares to see if fio_bstr a is greater than fio_bstr b (for FIO_SORT). */
FIO_SFUNC int fio_bstr_is_greater(const char *a, const char *b) {
  return fio_string_is_greater_buf(fio_bstr_buf(a), fio_bstr_buf(b));
}

/** Compares to see if fio_bstr a is equal to another String. */
FIO_SFUNC int fio_bstr_is_eq2info(const char *a_, fio_str_info_s b) {
  fio_str_info_s a = fio_bstr_info(a_);
  return FIO_STR_INFO_IS_EQ(a, b);
}
/** Compares to see if fio_bstr a is equal to another String. */
FIO_SFUNC int fio_bstr_is_eq2buf(const char *a_, fio_buf_info_s b) {
  fio_buf_info_s a = fio_bstr_buf(a_);
  return FIO_BUF_INFO_IS_EQ(a, b);
}

/* *****************************************************************************
Key String Type - binary String container for Hash Maps and Arrays
***************************************************************************** */
FIO_LEAK_COUNTER_DEF(fio_keystr_s)

/* key string type implementation */
struct fio_keystr_s {
  uint8_t info;
  uint8_t embd[3];
  uint32_t len;
  const char *buf;
};

/** returns the Key String. */
FIO_IFUNC fio_buf_info_s fio_keystr_buf(fio_keystr_s *str) {
  fio_buf_info_s r;
  if ((str->info + 1) > 1) {
    r = (fio_buf_info_s){.len = str->info, .buf = (char *)str->embd};
    return r;
  }
  r = (fio_buf_info_s){.len = str->len, .buf = (char *)str->buf};
  return r;
}
/** returns the Key String. */
FIO_IFUNC fio_str_info_s fio_keystr_info(fio_keystr_s *str) {
  fio_str_info_s r;
  if ((str->info + 1) > 1) {
    r = (fio_str_info_s){.len = str->info, .buf = (char *)str->embd};
    return r;
  }
  r = (fio_str_info_s){.len = str->len, .buf = (char *)str->buf};
  return r;
}

/** Returns a TEMPORARY `fio_keystr_s` to be used as a key for a hash map. */
FIO_IFUNC fio_keystr_s fio_keystr_tmp(const char *buf, uint32_t len) {
  fio_keystr_s r = {0};
  if (len + 1 &&             /* test for overflow */
      len + 1 < sizeof(r)) { /* always embed small strings in container! */
    r.info = (uint8_t)len;
    FIO_MEMCPY((char *)r.embd, buf, len);
    return r;
  }
  r.info = 0xFF;
  r.len = len;
  r.buf = buf;
  return r;
}

/** Returns a copy of `fio_keystr_s`. */
FIO_SFUNC fio_keystr_s fio_keystr_init(fio_str_info_s str,
                                       void *(*alloc_func)(size_t len)) {
  fio_keystr_s r = {0};
  if (!str.buf || !str.len || (str.len & (~(size_t)0xFFFFFFFF)))
    return r;
  if (str.len + 1 && str.len + 1 < sizeof(r)) {
    r.info = (uint8_t)str.len;
    FIO_MEMCPY((char *)r.embd, str.buf, str.len);
    return r;
  }
  if (str.capa == FIO_KEYSTR_CONST) {
    r.info = 0xFF;
    r.len = (uint32_t)str.len;
    r.buf = str.buf;
    return r;
  }
  char *buf;
  r.len = (uint32_t)str.len;
  r.buf = buf = (char *)alloc_func(str.len + 1);
  if (!buf)
    goto no_mem;
  FIO_LEAK_COUNTER_ON_ALLOC(fio_keystr_s);
  FIO_MEMCPY(buf, str.buf, str.len);
  buf[str.len] = 0;
  return r;
no_mem:
  FIO_LOG_FATAL("fio_keystr_init allocation failed - results undefined!!!");
  r = fio_keystr_tmp(str.buf, (uint32_t)str.len);
  return r;
}
/** Destroys a copy of `fio_keystr_s` - used internally by the hash map. */
FIO_SFUNC void fio_keystr_destroy(fio_keystr_s *key,
                                  void (*free_func)(void *, size_t)) {
  if (key->info || !key->buf)
    return;
  FIO_LEAK_COUNTER_ON_FREE(fio_keystr_s);
  free_func((void *)key->buf, key->len);
}

/** Compares two Key Strings. */
FIO_IFUNC int fio_keystr_is_eq(fio_keystr_s a_, fio_keystr_s b_) {
  fio_buf_info_s a = fio_keystr_buf(&a_);
  fio_buf_info_s b = fio_keystr_buf(&b_);
  return FIO_BUF_INFO_IS_EQ(a, b);
}

/** Compares a Key String to any String - used internally by the hash map. */
FIO_IFUNC int fio_keystr_is_eq2(fio_keystr_s a_, fio_str_info_s b) {
  fio_str_info_s a = fio_keystr_info(&a_);
  return FIO_STR_INFO_IS_EQ(a, b);
}
/** Compares a Key String to any String - used internally by the hash map. */
FIO_IFUNC int fio_keystr_is_eq3(fio_keystr_s a_, fio_buf_info_s b) {
  fio_buf_info_s a = fio_keystr_buf(&a_);
  return FIO_BUF_INFO_IS_EQ(a, b);
}

/** Returns a good-enough `fio_keystr_s` risky hash. */
FIO_IFUNC uint64_t fio_keystr_hash(fio_keystr_s a_) {
  fio_buf_info_s a = fio_keystr_buf(&a_);
  return fio_risky_hash(a.buf, a.len, (uint64_t)(uintptr_t)fio_string_write2);
}

/* *****************************************************************************
Extern-ed functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_LEAK_COUNTER_DEF(fio_string_default_allocations)
FIO_LEAK_COUNTER_DEF(fio_string_default_key_allocations)
/* *****************************************************************************
Allocation Helpers
***************************************************************************** */

SFUNC int fio_string_sys_reallocate(fio_str_info_s *dest, size_t len) {
  len = fio_string_capa4len(len);
  void *tmp = realloc(dest->buf, dest->capa);
  if (!tmp)
    return -1;
  dest->capa = len;
  dest->buf = (char *)tmp;
  return 0;
}

SFUNC int fio_string_default_reallocate(fio_str_info_s *dest, size_t len) {
  len = fio_string_capa4len(len);
  void *tmp = FIO_MEM_REALLOC_(dest->buf, dest->capa, len, dest->len);
  if (!tmp)
    return -1;
  if (!dest->buf)
    FIO_LEAK_COUNTER_ON_ALLOC(fio_string_default_allocations);
  dest->capa = len;
  dest->buf = (char *)tmp;
  return 0;
}

SFUNC int fio_string_default_allocate_copy(fio_str_info_s *dest, size_t len) {
  len = fio_string_capa4len(len);
  void *tmp = FIO_MEM_REALLOC_(NULL, 0, len, 0);
  if (!tmp)
    return -1;
  FIO_LEAK_COUNTER_ON_ALLOC(fio_string_default_allocations);
  dest->capa = len;
  dest->buf = (char *)tmp;
  if (dest->len)
    FIO_MEMCPY(tmp, dest->buf, dest->len);
  return 0;
}

SFUNC void *fio_string_default_key_alloc(size_t len) {
  return FIO_MEM_REALLOC_(NULL, 0, len, 0);
}

SFUNC void fio_string_default_free(void *ptr) {
  if (ptr) {
    FIO_LEAK_COUNTER_ON_FREE(fio_string_default_allocations);
    FIO_MEM_FREE_(ptr, 0);
  }
}
SFUNC void fio_string_default_free2(fio_str_info_s str) {
  if (str.buf) {
    FIO_LEAK_COUNTER_ON_FREE(fio_string_default_allocations);
    FIO_MEM_FREE_(str.buf, str.capa);
  }
}

/** frees a fio_keystr_s memory that was allocated with the default callback. */
SFUNC void fio_string_default_free_key(void *buf, size_t capa) {
  FIO_MEM_FREE_(buf, capa);
  (void)capa; /* if unused */
}

SFUNC void fio_string_default_free_noop(void *str) { (void)str; }
SFUNC void fio_string_default_free_noop2(fio_str_info_s str) { (void)str; }

/* *****************************************************************************
Numeral Support
***************************************************************************** */

/* fio_string_write_i */
SFUNC int fio_string_write_i(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             int64_t i) {
  int r = -1;
  size_t len = 0;
  len = fio_digits10(i);
  if (fio_string___write_validate_len(dest, reallocate, &len))
    return r; /* no writing of partial numbers. */
  r = 0;
  fio_ltoa10(dest->buf + dest->len, i, len);
  dest->len += len;
  return r;
}

/* fio_string_write_u */
SFUNC int fio_string_write_u(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             uint64_t i) {
  int r = -1;
  size_t len = fio_digits10u(i);
  if (fio_string___write_validate_len(dest, reallocate, &len))
    return r; /* no writing of partial numbers. */
  r = 0;
  fio_ltoa10u(dest->buf + dest->len, i, len);
  dest->len += len;
  return r;
}

/* fio_string_write_hex */
SFUNC int fio_string_write_hex(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               uint64_t i) {
  int r = 0;
  size_t len = fio_digits16u(i);
  if (fio_string___write_validate_len(dest, reallocate, &len))
    return (r = -1); /* no writing of partial numbers. */
  fio_ltoa16u(dest->buf + dest->len, i, len);
  dest->len += len;
  return r;
}

/* fio_string_write_bin */
SFUNC int fio_string_write_bin(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               uint64_t i) {
  int r = 0;
  size_t len = fio_digits_bin(i);
  if (fio_string___write_validate_len(dest, reallocate, &len))
    return (r = -1); /* no writing of partial numbers. */
  fio_ltoa_bin(dest->buf + dest->len, i, len);
  dest->len += len;
  return r;
}

/* *****************************************************************************
`printf` Style Support
***************************************************************************** */

/* Similar to fio_string_write, only using vprintf semantics. */
SFUNC int FIO___PRINTF_STYLE(3, 0)
    fio_string_vprintf(fio_str_info_s *dest,
                       fio_string_realloc_fn reallocate,
                       const char *format,
                       va_list argv) {
  int r = 0;
  va_list argv_cpy;
  va_copy(argv_cpy, argv);
  int len_i = vsnprintf(NULL, 0, format, argv_cpy);
  va_end(argv_cpy);
  if (len_i <= 0)
    return -1;
  size_t len = (size_t)len_i;
  r = fio_string___write_validate_len(dest, reallocate, &len);
  if (FIO_UNLIKELY(dest->capa < dest->len + 2))
    return -1;
  if (len)
    vsnprintf(dest->buf + dest->len, len + 1, format, argv);
  dest->len += len;
  dest->buf[dest->len] = 0;
  return r;
}

/** Similar to fio_string_write, only using printf semantics. */
SFUNC int FIO___PRINTF_STYLE(3, 4)
    fio_string_printf(fio_str_info_s *dest,
                      fio_string_realloc_fn reallocate,
                      const char *format,
                      ...) {
  int r = 0;
  va_list argv;
  va_start(argv, format);
  r = fio_string_vprintf(dest, reallocate, format, argv);
  va_end(argv);
  return r;
}

/* *****************************************************************************
UTF-8 Support
***************************************************************************** */

/** Returns 0 if non-UTF-8 or returns 1-4 (UTF-8 if a valid char). */
SFUNC size_t fio_string_utf8_valid_code_point(const void *c, size_t buf_len) {
  size_t l = fio_utf8_char_len((uint8_t *)c);
  l &= 0U - (buf_len >= l);
  return l;
}

/** Returns 1 if the String is UTF-8 valid and 0 if not. */
SFUNC bool fio_string_utf8_valid(fio_str_info_s str) {
  if (!str.len)
    return 1;
  char *const end = str.buf + str.len;
  size_t tmp;
  while ((tmp = fio_utf8_char_len(str.buf)) && ((str.buf += tmp) < end))
    ;
  return str.buf == end;
}

/** Returns the String's length in UTF-8 characters. */
SFUNC size_t fio_string_utf8_len(fio_str_info_s str) {
  if (!str.len)
    return 0;
  char *end = str.buf + str.len;
  size_t utf8len = 0, tmp;
  do {
    tmp = fio_utf8_char_len(str.buf);
    str.buf += tmp;
    ++utf8len;
  } while (tmp && str.buf < end);
  utf8len &= 0U - (str.buf == end);
  return utf8len;
}

/**
 * Takes a UTF-8 character selection information (UTF-8 position and length)
 * and updates the same variables so they reference the raw byte slice
 * information.
 *
 * If the String isn't UTF-8 valid up to the requested selection, than `pos`
 * will be updated to `-1` otherwise values are always positive.
 *
 * The returned `len` value may be shorter than the original if there wasn't
 * enough data left to accommodate the requested length. When a `len` value of
 * `0` is returned, this means that `pos` marks the end of the String.
 *
 * Returns -1 on error and 0 on success.
 */
SFUNC int fio_string_utf8_select(fio_str_info_s str,
                                 intptr_t *pos,
                                 size_t *len) {
  if (!pos || !len)
    return -1;
  const uint8_t *p = (uint8_t *)str.buf;
  const uint8_t *const end = p + str.len;
  size_t start, clen;
  if (!str.len)
    goto at_end;
  if ((*pos) > 0) {
    start = *pos;
    do {
      clen = fio_utf8_char_len(p);
      p += clen;
      --start;
    } while (clen && start && p < end);
    if (!clen || p > end)
      goto error;
    if (p == end)
      goto at_end;
  } else if (*pos < 0) { /* walk backwards */
    p += str.len;
    start = 0 - *pos;
    do {
      const uint8_t *was = p;
      --p;
      while ((*p & 0xC0U) == 0x80U && p > (uint8_t *)str.buf)
        --p;
      if ((size_t)fio_utf8_char_len_unsafe(*p) != (size_t)(was - p))
        goto error;
    } while (--start && p > (uint8_t *)str.buf);
  }
  *pos = p - (uint8_t *)str.buf;

  /* find end */
  start = *len;
  clen = 1;
  while (start && p < end && (clen = fio_utf8_char_len(p))) {
    p += clen;
    --start;
  }
  if (!clen || p > end)
    goto error;
  *len = p - ((uint8_t *)str.buf + (*pos));
  return 0;

at_end:
  *pos = str.len;
  *len = 0;
  return 0;
error:
  *pos = -1;
  *len = 0;
  return -1;
}

/* *****************************************************************************
fio_string_is_greater
***************************************************************************** */

/**
 * Compares two `fio_buf_info_s`, returning 1 if data in a is bigger than b.
 *
 * Note: returns 0 if data in b is bigger than or equal(!).
 */
SFUNC int fio_string_is_greater_buf(fio_buf_info_s a, fio_buf_info_s b) {
  const int a_len_is_bigger = a.len > b.len;
  size_t len = a_len_is_bigger ? b.len : a.len; /* shared length */
  if (a.buf == b.buf)
    return a_len_is_bigger;
  uint64_t ua[4] FIO_ALIGN(16) = {0};
  uint64_t ub[4] FIO_ALIGN(16) = {0};
  uint64_t flag = 0;
  if (len < 32)
    goto mini_cmp;

  len -= 32;
  for (;;) {
    for (size_t i = 0; i < 4; ++i) {
      fio_memcpy8(ua + i, a.buf);
      fio_memcpy8(ub + i, b.buf);
      flag |= (ua[i] ^ ub[i]);
      a.buf += 8;
      b.buf += 8;
    }
    if (flag)
      goto review_diff;
    if (len > 31) {
      len -= 32;
      continue;
    }
    if (!len)
      return a_len_is_bigger;
    a.buf -= 32;
    b.buf -= 32;
    a.buf += len & 31;
    b.buf += len & 31;
    len = 0;
  }

review_diff:
  if (ua[2] != ub[2]) {
    ua[3] = ua[2];
    ub[3] = ub[2];
  }
  if (ua[1] != ub[1]) {
    ua[3] = ua[1];
    ub[3] = ub[1];
  }
  if (ua[0] != ub[0]) {
    ua[3] = ua[0];
    ub[3] = ub[0];
  }
review_diff8:
  ua[3] = fio_lton64(ua[3]); /* comparison requires network byte order */
  ub[3] = fio_lton64(ub[3]);
  return ua[3] > ub[3];

mini_cmp:
  if (len > 7) {
    len -= 8;
    for (;;) {
      fio_memcpy8(ua + 3, a.buf);
      fio_memcpy8(ub + 3, b.buf);
      if (ua[3] != ub[3])
        goto review_diff8;
      if (len > 7) {
        a.buf += 8;
        b.buf += 8;
        len -= 8;
        continue;
      }
      if (!len)
        return a_len_is_bigger;
      a.buf += len & 7;
      b.buf += len & 7;
      len = 0;
    }
  }
  while (len--) {
    if (a.buf[0] != b.buf[0])
      return a.buf[0] > b.buf[0];
    ++a.buf;
    ++b.buf;
  }
  return a_len_is_bigger;
}

/* *****************************************************************************
Insert / Write2
***************************************************************************** */

/* fio_string_replace */
SFUNC int fio_string_replace(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             intptr_t start_pos,
                             size_t overwrite_len,
                             const void *src,
                             size_t len) {
  int r = 0;
  if (start_pos < 0) {
    start_pos = dest->len + start_pos + 1;
    if (start_pos < 0)
      start_pos = 0;
  }
  if (dest->len < (size_t)start_pos + overwrite_len + 1) {
    if ((size_t)start_pos < dest->len)
      dest->len = start_pos;
    return fio_string_write(dest, reallocate, src, len);
  }

  size_t move_start = start_pos + overwrite_len;
  size_t move_len = dest->len - (start_pos + overwrite_len);
  if (overwrite_len < len) {
    /* adjust for possible memory expansion */
    const size_t extra = len - overwrite_len;
    if (dest->capa < dest->len + extra + 1) {
      r = -1; /* in case reallocate is NULL */
      if (!reallocate ||
          FIO_UNLIKELY(
              (r = reallocate(dest, fio_string_capa4len(dest->len + extra))))) {
        move_len -= (dest->len + extra + 1) - dest->capa;
        if (dest->capa < start_pos + len + 1) {
          move_len = 0;
          len = dest->capa - start_pos - 1;
        }
      }
    }
  }
  if (move_len)
    FIO_MEMMOVE(dest->buf + start_pos + len, dest->buf + move_start, move_len);
  if (len)
    FIO_MEMCPY(dest->buf + start_pos, src, len);
  dest->len = start_pos + len + move_len;
  dest->buf[dest->len] = 0;
  return r;
}

/* IDE marker */
void fio_string_write2____(void);
/* the fio_string_write2 is a printf alternative. */
SFUNC int fio_string_write2 FIO_NOOP(fio_str_info_s *restrict dest,
                                     fio_string_realloc_fn reallocate,
                                     const fio_string_write_s srcs[]) {
  int r = 0;
  const fio_string_write_s *pos = srcs;
  size_t len = 0;

  while (pos->klass) {
    switch (pos->klass) { /* use more memory rather then calculate twice. */
    case 2: /* number */ len += fio_digits10(pos->info.i); break;
    case 3: /* unsigned */ len += fio_digits10u(pos->info.u); break;
    case 4: /* hex */ len += fio_digits16u(pos->info.u); break;
    case 5: /* binary */ len += fio_digits_bin(pos->info.u); break;
    case 6: /* float */ len += 18; break;
    default: len += pos->info.str.len;
    }
    ++pos;
  }
  if (!len)
    return r;
  pos = srcs;
  if (fio_string___write_validate_len(dest, reallocate, &len))
    goto truncate;
  while (pos->klass) {
    switch (pos->klass) {
    case 2: fio_string_write_i(dest, NULL, pos->info.i); break;   /* number */
    case 3: fio_string_write_u(dest, NULL, pos->info.u); break;   /* unsigned */
    case 4: fio_string_write_hex(dest, NULL, pos->info.u); break; /* hex */
    case 5: fio_string_write_bin(dest, NULL, pos->info.u); break; /* binary */
    case 6:                                                       /* float */
      dest->len += snprintf(dest->buf + dest->len, 19, "%.15g", pos->info.f);
      break;
    default:
      FIO_MEMCPY(&dest->buf[dest->len], pos->info.str.buf, pos->info.str.len);
      dest->len += pos->info.str.len;
    }
    ++pos;
  }
finish:
  dest->buf[dest->len] = 0;
  return r;
truncate:
  r = -1;
  while (pos->klass) {
    switch (pos->klass) {
    case 2:
      if (fio_string_write_i(dest, NULL, pos->info.i))
        goto finish;
      break; /* number */
    case 3:
      if (fio_string_write_u(dest, NULL, pos->info.u))
        goto finish;
      break; /* unsigned */
    case 4:
      if (fio_string_write_hex(dest, NULL, pos->info.u))
        goto finish;
      break; /* hex */
    case 5:
      if (fio_string_write_bin(dest, NULL, pos->info.u))
        goto finish;
      break; /* binary */
    case 6:  /* float */
      len = snprintf(dest->buf + dest->len, 19, "%.15g", pos->info.f);
      if (dest->capa < dest->len + len + 2)
        goto finish;
      dest->len += len;
      break;
    default:
      if (fio_string_write(dest, NULL, pos->info.str.buf, pos->info.str.len))
        goto finish;
    }
    ++pos;
  }
  goto finish;
}

/* *****************************************************************************
Escaping / Un-Escaping Primitives (not for encoding)
***************************************************************************** */

typedef struct {
  fio_str_info_s *restrict dest;
  fio_string_realloc_fn reallocate;
  const void *restrict src;
  const size_t len;
  /* moves to the next character (or character sequence) to alter. */
  const uint8_t *(*next)(const uint8_t *restrict s, const uint8_t *restrict e);
  /*
   * `dest` will be NULL when calculating length to be written.
   *
   * `*s` is the source data.
   *
   * `e` is the end-of-bounds position (src + len).
   *
   * Returns the number of characters that would have been written.
   *
   * Note: must update `s` to point to the next character after the altered
   * sequence.
   */
  size_t (*diff)(uint8_t *restrict dest,
                 const uint8_t *restrict *restrict s,
                 const uint8_t *restrict e);
  /*
   * Writes (un)escaped data to `dest`.
   *
   * Behaves the same as `diff` only writes data to `dest`.
   *
   * `dest` is the same number of bytes as reported by `diff` (or more).
   */
  size_t (*write)(uint8_t *restrict dest,
                  const uint8_t *restrict *restrict s,
                  const uint8_t *restrict e);
  /* If `len` of `src` is less then `skip_diff_len`, skips the test. */
  uint32_t skip_diff_len;
  /* If set, will not allow a partial write when memory allocation fails. */
  uint32_t refuse_partial;
} fio___string_altering_args_s;

/**
 * Writes an escaped data into the string after un-escaping the data.
 */
FIO_IFUNC int fio___string_altering_cycle(
    const fio___string_altering_args_s args) {
  int r = 0;
  if (((long long)args.len < 1) | !args.src | !args.dest)
    return r;
  const uint8_t *s = (const uint8_t *)args.src;
  const uint8_t *e = s + args.len;
  const uint8_t *p = s;
  fio_str_info_s d = *args.dest;
  size_t first_stop = 0;
  size_t updater = 0;
  /* we need to allocate memory - limit to result's length */
  if (d.len + args.len >= d.capa) {
    updater = (args.len > args.skip_diff_len);
    size_t written_length = args.len;
    if (updater) { /* skip memory reduction for small strings */
      written_length = 0;
      p = s;
      for (;;) {
        const uint8_t *p2 = args.next(p, e);
        if (!p2)
          break;
        written_length += p2 - p;
        p = p2;
        first_stop |= (0ULL - updater) & ((p - s) + 1);
        updater = 0;
        written_length += args.diff(NULL, &p, e);
        if (p + 1 > e)
          break;
      }
    }
    written_length += e - p;
    /* allocate extra required space. */
    FIO_ASSERT_DEBUG(written_length > 0, "string (un)escape reduced too much");
    if (d.len + written_length >= d.capa &&
        fio_string___write_validate_len(&d, args.reallocate, &written_length)) {
      r = -1;
      if (args.refuse_partial)
        goto finish;
      e = (const uint8_t *)d.capa - (d.len + 1);
    }
  }

  /* copy unescaped head of string (if it's worth our time), saves one memchr */
  if (((!first_stop) & updater) | (first_stop > 16)) {
    if (!first_stop)
      first_stop = (e - s) + 1;
    --first_stop;
    FIO_MEMMOVE(d.buf + d.len, s, first_stop);
    d.len += first_stop;
    s += first_stop;
  }
  p = s;

  /* start copying and un-escaping as needed */
  while (p < e) {
    const uint8_t *p2 = args.next(p, e);
    if (!p2)
      break;
    if (p2 - p) {
      updater = p2 - p;
      FIO_MEMMOVE(d.buf + d.len, p, updater);
      d.len += updater;
    }
    p = p2;
    d.len += args.write((uint8_t *)d.buf + d.len, &p, e);
  }
  if (p < e) {
    updater = e - p;
    FIO_MEMCPY(d.buf + d.len, p, updater);
    d.len += updater;
  }

finish:
  d.buf[d.len] = 0;
  *args.dest = d;
  return r;
}

/* *****************************************************************************
String C / JSON escaping
***************************************************************************** */

/**
 * Writes data at the end of the String, escaping the data using JSON semantics.
 *
 * The JSON semantic are common to many programming languages, promising a UTF-8
 * String while making it easy to read and copy the string during debugging.
 */
SFUNC int fio_string_write_escape(fio_str_info_s *restrict dest,
                                  fio_string_realloc_fn reallocate,
                                  const void *restrict src,
                                  size_t len) {
  /* Escaping map, test if bit 64 is set or not. Created using Ruby Script:
  map = []; 256.times { |i| map << ((i > 126 || i < 35) ? 48.chr : 64.chr)  };
  map[' '.ord] = 64.chr; map['!'.ord] = 64.chr;
  ["\b","\f","\n","\r","\t",'\\','"'].each {|c| map[c.ord] = 49.chr };
  str = map.join(''); puts "static const uint8_t escape_map[256]= " +
          "\"#{str.slice(0,64)}\"" +
          "\"#{str.slice(64,64)}\"" +
          "\"#{str.slice(128,64)}\"" +
          "\"#{str.slice(192,64)}\";"
   */
  static const uint8_t escape_map[256] =
      "00000000111011000000000000000000@@1@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
      "@@@@@@@@@@@@@@@@@@@@@@@@@@@@1@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0"
      "0000000000000000000000000000000000000000000000000000000000000000"
      "0000000000000000000000000000000000000000000000000000000000000000";
  int r = 0;
  if ((!len | !src | !dest))
    return r;
  size_t extra_space = 0;
  size_t first_stop = 0;
  size_t updater = 1;
  const uint8_t *s = (const uint8_t *)src;
  const uint8_t *e = s + len;
  const uint8_t *p = s;

  /* test memory length requirements  unlikely to be avoided (len * 5) */
  for (; (p < e); ++p) {
    if ((escape_map[*p] & 64)) /* hope for compiler magic */
      continue;
    size_t valid_utf8_len = fio_utf8_char_len(p);
    if (valid_utf8_len > 1) {
      p += valid_utf8_len - 1;
      continue;
    }
    first_stop |= (0ULL - updater) & (p - s);
    updater = 0;
    /* count extra bytes */
    ++extra_space; /* the '\' character followed by escape sequence */
    /* constant-time "if" (bit mask)  known escape or \xFF / \uFFFF escaping */
    extra_space += (escape_map[*p] - 1) & (3 + ((*p < 127) << 1));
  }

  /* reserve space and copy any valid first_stop */
  /* the + 3 adds room for the likely use case of JSON: "\",\"" */
  if ((dest->capa < dest->len + extra_space + len + 1) &&
      (!reallocate ||
       reallocate(dest,
                  fio_string_capa4len(dest->len + extra_space + len + 3)))) {
    r = -1;
    len = dest->capa - (dest->len + 6);
    if (dest->capa < len + 6)
      return r;
  }

  /* copy unescaped head of string (if it's worth our time) */
  if (((!first_stop) & updater & (escape_map[*s] == 64)) || first_stop > 16) {
    if (!first_stop)
      first_stop = len;
    FIO_MEMMOVE(dest->buf + dest->len, s, first_stop);
    dest->len += first_stop;
    s += first_stop;
  }
  p = s;

  /* start copying and escaping as needed */
  for (;;) {
    if ((escape_map[*p] & 64)) {
      for (s = p; (s < e) && (escape_map[*s] & 64); ++s)
        ; /* hope for compiler magic */
      updater = s - p;
      FIO_MEMMOVE(dest->buf + dest->len, p, updater);
      dest->len += updater;
      p = s;
    }
    if (p >= e)
      break;
    size_t valid_utf8_len = fio_utf8_char_len(p);
    size_t limit = e - p;
    if (valid_utf8_len > limit)
      valid_utf8_len = limit;
    switch (valid_utf8_len) {
    case 4: dest->buf[dest->len++] = *p++; /* fall through */
    case 3: dest->buf[dest->len++] = *p++; /* fall through */
    case 2:
      dest->buf[dest->len++] = *p++; /* fall through */
      dest->buf[dest->len++] = *p++; /* fall through */
      continue;
    default: break;
    }
    // FIO_ASSERT(valid_utf8_len < 2, "valid_utf8_len error!");
    dest->buf[dest->len++] = '\\';
    uint8_t ec = *p++;
    switch (ec) {
    case '\b': dest->buf[dest->len++] = 'b'; continue;
    case '\f': dest->buf[dest->len++] = 'f'; continue;
    case '\n': dest->buf[dest->len++] = 'n'; continue;
    case '\r': dest->buf[dest->len++] = 'r'; continue;
    case '\t': dest->buf[dest->len++] = 't'; continue;
    case '\\': dest->buf[dest->len++] = '\\'; continue;
    case ' ': dest->buf[dest->len++] = ' '; continue;
    case '"': dest->buf[dest->len++] = '"'; continue;
    default:
      /* pass through character */
      first_stop = (ec > 34);
      dest->buf[dest->len - first_stop] = ec;
      /* escaping all control characters and non-UTF-8 characters */
      first_stop = (ec < 127);
      const char in_hex[2] = {(char)fio_i2c(ec >> 4), (char)fio_i2c(ec & 15)};
      dest->buf[dest->len] = 'u'; /* UTF-8 encoding (remains valid) */
      dest->buf[dest->len += first_stop] = '0';
      dest->buf[dest->len += first_stop] = '0';
      dest->buf[dest->len += first_stop] = in_hex[0];
      dest->buf[dest->len += first_stop] = in_hex[1];
      dest->len += first_stop;
    }
  }
  dest->buf[dest->len] = 0;
  return r;
}

FIO_SFUNC const uint8_t *fio___string_write_unescape_next(
    const uint8_t *restrict s,
    const uint8_t *restrict e) {
  if (*s == '\\')
    return s;
  return (const uint8_t *)FIO_MEMCHR(s, '\\', e - s);
}

FIO_SFUNC size_t
fio___string_write_unescape_diff(uint8_t *restrict dest,
                                 const uint8_t *restrict *restrict ps,
                                 const uint8_t *restrict e) {
  size_t r = 1;
  unsigned step = 1;
  const uint8_t *s = *ps;
  ++s;
  unsigned peek = ((*s == 'x') & (e - s > 2));
  peek &= (unsigned)(fio_c2i(s[peek]) < 16) & (fio_c2i(s[peek + peek]) < 16);
  step |= (peek << 1);
  // peek &= (fio_c2i(s[peek]) > 7);
  r += peek; /* assumes \xFF is unescaped as UTF-8, up to 2 bytes */

  peek = ((*s == 'u') & (e - s > 4));
  peek &= (unsigned)(fio_c2i(s[peek]) < 16) & (fio_c2i(s[peek + peek]) < 16) &
          (fio_c2i(s[peek + peek + peek]) < 16) &
          (fio_c2i(s[peek + peek + peek + peek]) < 16);
  r |= (peek << 1); /* assumes \uFFFF in maximum length, ignores UTF-16 pairs */
  step |= (peek << 2);

  s += step;
  *ps = s;
  return r;
  (void)dest;
}
FIO_IFUNC size_t
fio___string_write_unescape_write(uint8_t *restrict dest,
                                  const uint8_t *restrict *restrict ps,
                                  const uint8_t *restrict e) {
  unsigned r = 1;
  const uint8_t *restrict s = *ps;
  s += ((s + 1) < e); /* skip '\\' byte */
  switch (*s) {
  case 'b':
    *dest = '\b';
    ++s;
    break; /* from switch */
  case 'f':
    *dest = '\f';
    ++s;
    break; /* from switch */
  case 'n':
    *dest = '\n';
    ++s;
    break; /* from switch */
  case 'r':
    *dest = '\r';
    ++s;
    break; /* from switch */
  case 't':
    *dest = '\t';
    ++s;
    break; /* from switch */
  case 'u': {
    /* test UTF-8 notation */
    if ((s + 4 < e) && ((unsigned)(fio_c2i(s[1]) < 16) & (fio_c2i(s[2]) < 16) &
                        (fio_c2i(s[3]) < 16) & (fio_c2i(s[4]) < 16))) {
      uint32_t u = (((fio_c2i(s[1]) << 4) | fio_c2i(s[2])) << 8) |
                   ((fio_c2i(s[3]) << 4) | fio_c2i(s[4]));
      if ((s + 10 < e) &&
          (((fio_c2i(s[1]) << 4) | fio_c2i(s[2])) == 0xD8U && s[5] == '\\' &&
           s[6] == 'u' &&
           ((unsigned)(fio_c2i(s[7]) < 16) & (fio_c2i(s[8]) < 16) &
            (fio_c2i(s[9]) < 16) & (fio_c2i(s[10]) < 16)))) {
        /* surrogate-pair (high/low code points) */
        u = (u & 0x03FF) << 10;
        u |= (((((fio_c2i(s[7]) << 4) | fio_c2i(s[8])) << 8) |
               ((fio_c2i(s[9]) << 4) | fio_c2i(s[10]))) &
              0x03FF);
        u += 0x10000;
        s += 6;
      }
      r = fio_utf8_write(dest, u);
      s += 5;
      break; /* from switch */
    } else
      goto invalid_escape;
  }
  case 'x': { /* test for hex notation */
    if (fio_c2i(s[1]) < 16 && fio_c2i(s[2]) < 16) {
      *dest = (fio_c2i(s[1]) << 4) | fio_c2i(s[2]);
      s += 3;
      break; /* from switch */
    } else
      goto invalid_escape;
  }
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7': { /* test for octal notation */
    if (s[0] >= '0' && s[0] <= '7' && s[1] >= '0' && s[1] <= '7') {
      *dest = ((s[0] - '0') << 3) | (s[1] - '0');
      s += 2;
      break; /* from switch */
    } else
      goto invalid_escape;
  }
  case '"':
  case '\\':
  case '/':
  /* fall through */
  default:
  invalid_escape:
    *dest = *s++;
  }
  *ps = s;
  return r;
}
SFUNC int fio_string_write_unescape(fio_str_info_s *restrict dest,
                                    fio_string_realloc_fn alloc,
                                    const void *src,
                                    size_t len) {
  return fio___string_altering_cycle((fio___string_altering_args_s){
      .dest = dest,
      .reallocate = alloc,
      .src = src,
      .len = len,
      .next = fio___string_write_unescape_next,
      .diff = fio___string_write_unescape_diff,
      .write = fio___string_write_unescape_write,
      .skip_diff_len = 127,
      .refuse_partial = 1,
  });
}

/* *****************************************************************************
String Base32 support
***************************************************************************** */

/** Writes data to String using base64 encoding. */
SFUNC int fio_string_write_base32enc(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *raw,
                                     size_t raw_len) {
  static const uint8_t base32ecncode[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  int r = 0;
  size_t expected = ((raw_len * 8) / 5) + 1;
  if (fio_string___write_validate_len(dest, reallocate, &expected)) {
    return (r = -1); /* no partial encoding. */
  }
  expected = dest->len;
  size_t bits = 0, store = 0;
  for (size_t i = 0; i < raw_len; ++i) {
    store = (store << 8) | (size_t)((uint8_t *)raw)[i];
    bits += 8;
    if (bits < 25)
      continue;
    while (bits > 4) {
      uint8_t val = base32ecncode[(31U & (store >> (bits - 5)))];
      dest->buf[dest->len++] = val;
      bits -= 5;
    }
  }
  while (bits > 4) {
    uint8_t val = base32ecncode[(31U & (store >> (bits - 5)))];
    dest->buf[dest->len++] = val;
    bits -= 5;
  }
  if (bits) {
    // dest->buf[dest->len++] = base32ecncode[store & ((1U << bits) - 1)];
    dest->buf[dest->len++] = base32ecncode[31U & (store << (5 - bits))];
    dest->buf[dest->len] = '=';
    dest->len += !!((dest->len - expected) % 5);
  }
  dest->buf[dest->len] = 0;
  return r;
}

/** Writes decoded base64 data to String. */
SFUNC int fio_string_write_base32dec(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *encoded,
                                     size_t encoded_len) {
  /* ABCDEF6HIJK3MN6PQRSTUV6XYZ234567
 a = [];
 256.times { a << 255 }
 b = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".bytes
 b.length.times {|i| a[b[i]] = i }
 b = "abcdefghijklmnopqrstuvwxyz234567".bytes
 b.length.times {|i| a[b[i]] = i }
 b = " \r\n\t\b".bytes
 b.length.times {|i| a[b[i]] = 32 }
 a.map! {|n| n.to_s 10 }
 puts "const static uint8_t base32decode[256] = { #{a.join(", ") } }; "
*/
  static const uint8_t base32decode[256] = {
      255, 255, 255, 255, 255, 255, 255, 255, 32,  32,  32,  255, 255, 32,  255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 32,  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 26,  27,  28,  29,  30,  31,  255, 255, 255, 255,
      255, 255, 255, 255, 255, 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
      10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,
      25,  255, 255, 255, 255, 255, 255, 0,   1,   2,   3,   4,   5,   6,   7,
      8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,
      23,  24,  25,  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255};
  int r = 0;
  size_t expected = ((encoded_len * 5) / 8) + 1;
  if (fio_string___write_validate_len(dest, reallocate, &expected)) {
    return (r = -1); /* no partial encoding. */
  }
  uint64_t val = 0;
  uint64_t bits = 0;
  uint8_t *s = (uint8_t *)dest->buf + dest->len;
  for (size_t i = 0; i < encoded_len; ++i) {
    uint64_t dec = (size_t)base32decode[((uint8_t *)encoded)[i]];
    if (dec == 32)
      continue;
    if (dec > 31)
      break;
    bits += 5;
    val = (val << 5) | dec;
    if (bits < 40)
      continue;
    do {
      *(s++) = (0xFF & (val >> (bits - 8)));
      bits -= 8;
    } while (bits > 7);
  }
  while (bits > 7) {
    *(s++) = (0xFF & (val >> (bits - 8)));
    bits -= 8;
  }
  if (bits) { /* letfover bits considered padding? */
    val = 0xFF & (val << (8 - bits));
    if (val || (encoded_len && ((uint8_t *)encoded)[encoded_len - 1] != '='))
      *(s++) = val;
  }
  dest->len = (size_t)(s - (uint8_t *)dest->buf);
  dest->buf[dest->len] = 0;
  return r;
}

/* *****************************************************************************
String Base64 support
***************************************************************************** */

/** Writes data to String using Base64 encoding. */
SFUNC int fio_string_write_base64enc(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *data,
                                     size_t len,
                                     uint8_t url_encoded) {
  int r = 0;
  if (!dest || !data || !len)
    return r;
  static const char *encmap[2] = {
      /* Regular, URL encoding*/
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  };

  /* the base64 encoding array */
  const char *encoding = encmap[!!url_encoded];

  /* base64 length and padding information */
  size_t groups = len / 3;
  const size_t mod = len - (groups * 3);
  size_t target_size = (groups + (mod != 0)) * 4;

  if (fio_string___write_validate_len(dest, reallocate, &target_size)) {
    return (r = -1); /* no partial encoding. */
  }
  char *writer = dest->buf + dest->len;
  const unsigned char *reader = (const unsigned char *)data;
  dest->len += target_size;
  /* write encoded data */
  while (groups) {
    --groups;
    const unsigned char tmp1 = *(reader++);
    const unsigned char tmp2 = *(reader++);
    const unsigned char tmp3 = *(reader++);

    *(writer++) = encoding[(tmp1 >> 2) & 63];
    *(writer++) = encoding[(((tmp1 & 3) << 4) | ((tmp2 >> 4) & 15))];
    *(writer++) = encoding[((tmp2 & 15) << 2) | ((tmp3 >> 6) & 3)];
    *(writer++) = encoding[tmp3 & 63];
  }

  /* write padding / ending */
  switch (mod) {
  case 2: {
    const unsigned char tmp1 = *(reader++);
    const unsigned char tmp2 = *(reader++);

    *(writer++) = encoding[(tmp1 >> 2) & 63];
    *(writer++) = encoding[((tmp1 & 3) << 4) | ((tmp2 >> 4) & 15)];
    *(writer++) = encoding[((tmp2 & 15) << 2)];
    *(writer++) = '=';
  } break;
  case 1: {
    const unsigned char tmp1 = *(reader++);

    *(writer++) = encoding[(tmp1 >> 2) & 63];
    *(writer++) = encoding[(tmp1 & 3) << 4];
    *(writer++) = '=';
    *(writer++) = '=';
  } break;
  }
  dest->buf[dest->len] = 0;
  return r;
}

/** Writes decoded base64 data to String. */
SFUNC int fio_string_write_base64dec(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *encoded_,
                                     size_t len) {
  /* Base64 decoding array. Generation script (Ruby):
s = ["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
valid = []; (0..255).each {|i| valid[i] = 0 };
decoder = []; (0..127).each {|i| decoder[i] = 0 };
s.each {|d| d.bytes.each_with_index { |b, i| decoder[b] = i; valid[b] = 1 } };
p valid; p decoder; nil
  */
  static const uint8_t base64_valid[256] = {
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  };
  static const uint8_t base64_decodes[128] = {
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  62, 0,  62, 0,  63,
      52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0,  0,  0,  64, 0,  0,
      0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14,
      15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0,  0,  0,  0,  63,
      0,  26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
      41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 0,  0,  0,  0,  0,
  };
  int r = 0;
  if (!dest || !encoded_ || !len)
    return r;
  const uint8_t *encoded = (const uint8_t *)encoded_;
  /* skip unknown data at end */
  while (len && !base64_valid[encoded[len - 1]]) {
    len--;
  }
  if (!len)
    return (r = -1);

  /* reserve memory space */
  {
    size_t required_len = (((len >> 2) * 3) + 3);
    if (fio_string___write_validate_len(dest, reallocate, &required_len)) {
      return (r = -1); /* no partial decoding. */
    };
  }

  /* decoded and count actual length */
  size_t pos = 0;
  uint8_t b64wrd[4];
  const uint8_t *stop = encoded + len;
  uint8_t *writer = (uint8_t *)dest->buf + dest->len;
  for (;;) {
    if (base64_valid[encoded[0]])
      b64wrd[pos++] = base64_decodes[encoded[0]];
    else if (!isspace(encoded[0]))
      break;
    ++encoded;
    if (pos == 4) {
      writer[0] = (b64wrd[0] << 2) | (b64wrd[1] >> 4);
      writer[1] = (b64wrd[1] << 4) | (b64wrd[2] >> 2);
      writer[2] = (b64wrd[2] << 6) | b64wrd[3];
      pos = 0;
      writer += 3;
    }
    if (encoded == stop)
      break;
  }
  switch (pos) {
  case 1: b64wrd[1] = 0; /* fall through */
  case 2: b64wrd[2] = 0; /* fall through */
  case 3: b64wrd[3] = 0; /* fall through */
  case 4:
    writer[0] = (b64wrd[0] << 2) | (b64wrd[1] >> 4);
    writer[1] = (b64wrd[1] << 4) | (b64wrd[2] >> 2);
    writer[2] = (b64wrd[2] << 6) | b64wrd[3];
    writer += 3;
  }
  writer -= (encoded[-1] == '=') + (encoded[-2] == '=');
  if (writer < ((uint8_t *)dest->buf + dest->len))
    writer = ((uint8_t *)dest->buf + dest->len);
  dest->len = (size_t)(writer - (uint8_t *)dest->buf);
  dest->buf[dest->len] = 0;
  return r;
}

/* *****************************************************************************
String URL Encoding support
***************************************************************************** */

/** Writes data to String using URL encoding (a.k.a., percent encoding). */
SFUNC int fio_string_write_url_enc(fio_str_info_s *dest,
                                   fio_string_realloc_fn reallocate,
                                   const void *data,
                                   size_t data_len) {
  static const uint8_t url_enc_map[256] = {
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0,
      2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2};
  int r = 0;
  /* reserve memory space */
  {
    size_t required_len = data_len;
    for (size_t i = 0; i < data_len; ++i) {
      required_len += url_enc_map[((uint8_t *)data)[i]];
    }
    if (fio_string___write_validate_len(dest, reallocate, &required_len)) {
      return (r = -1); /* no partial encoding. */
    };
  }
  for (size_t i = 0; i < data_len; ++i) {
    if (!url_enc_map[((uint8_t *)data)[i]]) {
      dest->buf[dest->len++] = ((uint8_t *)data)[i];
      continue;
    }
    dest->buf[dest->len++] = '%';
    dest->buf[dest->len++] = fio_i2c(((uint8_t *)data)[i] >> 4);
    dest->buf[dest->len++] = fio_i2c(((uint8_t *)data)[i] & 15);
  }
  dest->buf[dest->len] = 0;
  return r;
}

/** Writes decoded URL data to String. */
FIO_IFUNC int fio_string_write_url_dec_internal(
    fio_str_info_s *dest,
    fio_string_realloc_fn reallocate,
    const void *encoded,
    size_t encoded_len,
    _Bool plus_is_included) {
  int r = 0;
  if (!dest || !encoded || !encoded_len)
    return r;
  uint8_t *pr = (uint8_t *)encoded;
  uint8_t *last = pr;
  uint8_t *end = pr + encoded_len;
  if (dest->len + encoded_len >= dest->capa) { /* reserve only what we need */
    size_t act_len = 0;
    while (end > pr && (pr = (uint8_t *)FIO_MEMCHR(pr, '%', end - pr))) {
      act_len += pr - last;
      last = pr + 1;
      if (end - last > 1 && fio_c2i(last[0]) < 16 && fio_c2i(last[1]) < 16)
        last += 2;
      else if (end - last > 4 && (last[0] | 32) == 'u' &&
               fio_c2i(last[1]) < 16 && fio_c2i(last[2]) < 16 &&
               fio_c2i(last[3]) < 16 && fio_c2i(last[4]) < 16) {
        last += 5;
        act_len += 3; /* uXXXX length maxes out at 4 ... I think */
      }
      pr = last;
    }
    act_len += end - last;
    if (fio_string___write_validate_len(dest, reallocate, &act_len)) {
      return (r = -1); /* no partial decoding. */
    };
  }
  /* copy and un-encode data */
  pr = (uint8_t *)encoded;
  last = pr;
  end = pr + encoded_len;
  while (end > pr && (pr = (uint8_t *)FIO_MEMCHR(pr, '%', end - pr))) {
    const size_t slice_len = pr - last;
    if (slice_len) {
      FIO_MEMCPY(dest->buf + dest->len, last, slice_len);
      /* test for '+' in the slice that has no % characters */
      if (plus_is_included) {
        uint8_t *start_plus = (uint8_t *)dest->buf + dest->len;
        uint8_t *end_plus = start_plus + slice_len;
        while (
            start_plus && start_plus < end_plus &&
            (start_plus =
                 (uint8_t *)FIO_MEMCHR(start_plus, '+', end_plus - start_plus)))
          *(start_plus++) = ' ';
      }
    }
    dest->len += slice_len;
    last = pr + 1;
    if (end - last > 1 && fio_c2i(last[0]) < 16 && fio_c2i(last[1]) < 16) {
      dest->buf[dest->len++] = (fio_c2i(last[0]) << 4) | fio_c2i(last[1]);
      last += 2;
    } else if (end - last > 4 && (last[0] | 32) == 'u' &&
               fio_c2i(last[1]) < 16 && fio_c2i(last[2]) < 16 &&
               fio_c2i(last[3]) < 16 && fio_c2i(last[4]) < 16) {
      uint32_t u = (((fio_c2i(last[1]) << 4) | fio_c2i(last[2])) << 8) |
                   ((fio_c2i(last[3]) << 4) | fio_c2i(last[4]));
      if (end - last > 9 &&
          ((fio_c2i(last[1]) << 4) | fio_c2i(last[2])) == 0xD8U &&
          last[5] == '%' && last[6] == 'u' && fio_c2i(last[7]) < 16 &&
          fio_c2i(last[8]) < 16 && fio_c2i(last[9]) < 16 &&
          fio_c2i(last[10]) < 16) {
        /* surrogate-pair (high/low code points) */
        u = (u & 0x03FF) << 10;
        u |= (((((fio_c2i(last[7]) << 4) | fio_c2i(last[8])) << 8) |
               ((fio_c2i(last[9]) << 4) | fio_c2i(last[10]))) &
              0x03FF);
        u += 0x10000;
        last += 6;
      }
      dest->len += fio_utf8_write((uint8_t *)dest->buf + dest->len, u);
      last += 5;
    } else {
      dest->buf[dest->len++] = '%';
    }
    pr = last;
  }
  if (end > last) {
    const size_t slice_len = end - last;
    FIO_MEMCPY(dest->buf + dest->len, last, slice_len);
    /* test for '+' in the slice that has no % characters */
    if (plus_is_included) {
      uint8_t *start_plus = (uint8_t *)dest->buf + dest->len;
      uint8_t *end_plus = start_plus + slice_len;
      while (
          start_plus && start_plus < end_plus &&
          (start_plus =
               (uint8_t *)FIO_MEMCHR(start_plus, '+', end_plus - start_plus)))
        *(start_plus++) = ' ';
    }
    dest->len += slice_len;
  }
  dest->buf[dest->len] = 0;
  return r;
}

/** Writes decoded URL data to String. */
SFUNC int fio_string_write_url_dec(fio_str_info_s *dest,
                                   fio_string_realloc_fn reallocate,
                                   const void *encoded,
                                   size_t encoded_len) {
  return fio_string_write_url_dec_internal(dest,
                                           reallocate,
                                           encoded,
                                           encoded_len,
                                           1);
}

/** Writes decoded URL data to String. */
SFUNC int fio_string_write_path_dec(fio_str_info_s *dest,
                                    fio_string_realloc_fn reallocate,
                                    const void *encoded,
                                    size_t encoded_len) {
  return fio_string_write_url_dec_internal(dest,
                                           reallocate,
                                           encoded,
                                           encoded_len,
                                           0);
}

/* *****************************************************************************
String HTML escaping support
***************************************************************************** */

/** Writes HTML escaped data to a String. */
SFUNC int fio_string_write_html_escape(fio_str_info_s *dest,
                                       fio_string_realloc_fn reallocate,
                                       const void *data,
                                       size_t data_len) {
  /* produced using the following Ruby script:
    a = (0..255).to_a.map {|i| "&#x#{i.to_s(16)};" }
    must_escape = ['&', '<', '>', '"', "'", '`', '!', '@', '$', '%',
                   '(', ')', '=', '+', '{', '}', '[', ']'] # space?
    ["\b","\f","\n","\r","\t",'\\'].each {|i| a[i.ord] = i }
    (32..123).each {|i| a[i] = i.chr unless must_escape.include?(i.chr) }
    {'<': "&lt;", '>': "&gt;", '"': "&qout;", '&': "&amp;"}.each {|k,v|
       a[k.to_s.ord] = v
    }
    b = a.map {|s| s.length }
    puts "static const uint8_t html_escape_len[] = {", b.to_s.slice(1..-2), "};"
  */
  static const uint8_t html_escape_len[] = {
      5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 5, 1, 1, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 1, 6, 6, 1, 6, 6, 5, 6, 6, 6, 1, 6, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 6, 4, 1, 6, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 6, 1, 1,
      6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
  int r = 0;
  size_t start = 0;
  size_t pos = 0;
  if (!data_len || !data || !dest)
    return r;
  { /* reserve memory space */
    size_t required_len = data_len;
    for (size_t i = 0; i < data_len; ++i) {
      required_len += html_escape_len[((uint8_t *)data)[i]];
    }
    if (fio_string___write_validate_len(dest, reallocate, &required_len)) {
      return (r = -1); /* no partial encoding. */
    };
  }
  for (;;) { /* copy and encode data */
    while (pos < data_len && html_escape_len[((uint8_t *)data)[pos]] == 1)
      ++pos;
    /* don't escape valid UTF-8 */
    if (pos < data_len)
      switch (
          fio_string_utf8_valid_code_point((void *)(((uint8_t *)data) + pos),
                                           data_len - pos)) {
      case 4: ++pos; /* fall through */
      case 3: ++pos; /* fall through */
      case 2: pos += 2; continue;
      }
    /* copy valid segment before escaping */
    if (pos != start) {
      const size_t len = pos - start;
      FIO_MEMCPY(dest->buf + dest->len, (uint8_t *)data + start, len);
      dest->len += len;
      start = pos;
    }
    if (pos == data_len)
      break;
    /* escape data */
    dest->buf[dest->len++] = '&';
    switch (((uint8_t *)data)[pos]) {
    case '<':
      dest->buf[dest->len++] = 'l';
      dest->buf[dest->len++] = 't';
      break;
    case '>':
      dest->buf[dest->len++] = 'g';
      dest->buf[dest->len++] = 't';
      break;
    case '"':
      dest->buf[dest->len++] = 'q';
      dest->buf[dest->len++] = 'u';
      dest->buf[dest->len++] = 'o';
      dest->buf[dest->len++] = 't';
      break;
    case '&':
      dest->buf[dest->len++] = 'a';
      dest->buf[dest->len++] = 'm';
      dest->buf[dest->len++] = 'p';
      break;
    default:
      dest->buf[dest->len++] = '#';
      dest->buf[dest->len++] = 'x';
      dest->len += ((dest->buf[dest->len] =
                         fio_i2c(((uint8_t *)data)[pos] >> 4)) != '0');
      dest->buf[dest->len++] = fio_i2c(((uint8_t *)data)[pos] & 15);
    }
    dest->buf[dest->len++] = ';';
    ++pos;
    start = pos;
  }
  dest->buf[dest->len] = 0;
  return r;
}

/** Writes HTML un-escaped data to a String - incomplete and minimal. */
SFUNC int fio_string_write_html_unescape(fio_str_info_s *dest,
                                         fio_string_realloc_fn reallocate,
                                         const void *data,
                                         size_t data_len) {
  int r = 0;
  struct {
    uint64_t code;
    uint32_t clen;
    uint8_t r[4];
  } html_named_codes[] = {
#define FIO___STRING_HTML_CODE_POINT(named_code, result)                       \
  {.code = *(uint64_t *)(named_code "\0\0\0\0\0\0\0\0"),                       \
   .clen = (uint32_t)(sizeof(named_code) - 1),                                 \
   .r = result}
      FIO___STRING_HTML_CODE_POINT("lt", "<"),
      FIO___STRING_HTML_CODE_POINT("gt", ">"),
      FIO___STRING_HTML_CODE_POINT("amp", "&"),
      FIO___STRING_HTML_CODE_POINT("apos", "'"),
      FIO___STRING_HTML_CODE_POINT("quot", "\""),
      FIO___STRING_HTML_CODE_POINT("nbsp", "\xC2\xA0"),
      FIO___STRING_HTML_CODE_POINT("tab", "\t"),
      FIO___STRING_HTML_CODE_POINT("ge", ""),
      FIO___STRING_HTML_CODE_POINT("le", ""),
      FIO___STRING_HTML_CODE_POINT("ne", ""),
      FIO___STRING_HTML_CODE_POINT("copy", ""),
      FIO___STRING_HTML_CODE_POINT("raquo", ""),
      FIO___STRING_HTML_CODE_POINT("laquo", ""),
      FIO___STRING_HTML_CODE_POINT("rdquo", ""),
      FIO___STRING_HTML_CODE_POINT("ldquo", ""),
      FIO___STRING_HTML_CODE_POINT("reg", ""),
      FIO___STRING_HTML_CODE_POINT("asymp", ""),
      FIO___STRING_HTML_CODE_POINT("bdquo", ""),
      FIO___STRING_HTML_CODE_POINT("bull", ""),
      FIO___STRING_HTML_CODE_POINT("cent", ""),
      FIO___STRING_HTML_CODE_POINT("euro", ""),
      FIO___STRING_HTML_CODE_POINT("dagger", ""),
      FIO___STRING_HTML_CODE_POINT("deg", ""),
      FIO___STRING_HTML_CODE_POINT("frac14", ""),
      FIO___STRING_HTML_CODE_POINT("frac12", ""),
      FIO___STRING_HTML_CODE_POINT("frac34", ""),
      FIO___STRING_HTML_CODE_POINT("hellip", ""),
      FIO___STRING_HTML_CODE_POINT("lsquo", ""),
      FIO___STRING_HTML_CODE_POINT("mdash", ""),
      FIO___STRING_HTML_CODE_POINT("middot", ""),
      FIO___STRING_HTML_CODE_POINT("ndash", ""),
      FIO___STRING_HTML_CODE_POINT("para", ""),
      FIO___STRING_HTML_CODE_POINT("plusmn", ""),
      FIO___STRING_HTML_CODE_POINT("pound", ""),
      FIO___STRING_HTML_CODE_POINT("prime", ""),
      FIO___STRING_HTML_CODE_POINT("rsquo", ""),
      FIO___STRING_HTML_CODE_POINT("sbquo", ""),
      FIO___STRING_HTML_CODE_POINT("sect", ""),
      FIO___STRING_HTML_CODE_POINT("trade", ""),
      FIO___STRING_HTML_CODE_POINT("yen", ""),
  };
  if (!dest || !data || !data_len)
    return r;
  size_t reduced = data_len + dest->len;
  uint8_t *start = (uint8_t *)data;
  uint8_t *const end = start + data_len;
  if (dest->len + data_len >= dest->capa) { /* reserve only what we need */
    reduced = data_len;
    uint8_t *del = start;
    while (end > del && (del = (uint8_t *)FIO_MEMCHR(del, '&', end - del))) {
      uint8_t *tmp = del++;
      /* note that in some cases the `;` might be dropped (history) */
      if (del[0] == '#') {
        ++del;
        del += (del[0] == 'x');
        uint64_t num =
            (del[-1] == 'x' ? fio_atol16u : fio_atol10u)((char **)&del);
        if (del >= end || num > 65535) /* untrusted result */
          continue;
        del += (*del == ';');
        reduced -= (del - tmp);
        reduced += fio_utf8_code_len((uint32_t)num);
        continue;
      }
      union {
        uint64_t u64;
        uint8_t u8[8];
      } u;
      for (size_t i = 0;
           i < sizeof(html_named_codes) / sizeof(html_named_codes[0]);
           ++i) {
        u.u64 = 0;
        for (size_t p = 0; p < html_named_codes[i].clen; ++p)
          u.u8[p] = del[p] | 32;
        if (u.u64 != html_named_codes[i].code)
          continue;
        del += html_named_codes[i].clen;
        if (del > end)
          break;
        del += (del < end && del[0] == ';');
        reduced -= (del - tmp);
        for (size_t j = 0; html_named_codes[i].r[j]; ++j)
          ++reduced;
        break;
      }
    }
    if (fio_string___write_validate_len(dest, reallocate, &reduced)) {
      return (r = -1); /* no partial decoding. */
    }
    reduced += dest->len;
  }
  { /* copy and unescape data */
    uint8_t *del = start = (uint8_t *)data;
    while (end > (start = del) &&
           (del = (uint8_t *)FIO_MEMCHR(del, '&', end - del))) {
      if (start != del) {
        const size_t len = del - start;
        FIO_MEMCPY(dest->buf + dest->len, start, len);
        dest->len += len;
        start = del;
      }
      ++del;
      if (del == end)
        break;
      if (del[0] == '#') {
        ++del;
        if (del + 2 > end)
          break;
        del += (del[0] == 'x');
        uint64_t num =
            (del[-1] == 'x' ? fio_atol16u : fio_atol10u)((char **)&del);
        if (*del != ';' || num > 65535)
          goto untrusted_no_encode;
        dest->len +=
            fio_utf8_write((uint8_t *)dest->buf + dest->len, (uint32_t)num);
        del += (del < end && del[0] == ';');
        continue;
      }
      /* note that in some cases the `;` might be dropped (history) */
      for (size_t i = 0;
           i < sizeof(html_named_codes) / sizeof(html_named_codes[0]);
           ++i) {
        union {
          uint64_t u64;
          uint8_t u8[8];
        } u = {0};
        for (size_t p = 0; p < html_named_codes[i].clen; ++p)
          u.u8[p] = del[p] | 32;
        if (u.u64 != html_named_codes[i].code)
          continue;
        del += html_named_codes[i].clen;
        del += (del < end && del[0] == ';');
        start = del;
        for (size_t j = 0; html_named_codes[i].r[j]; ++j) {
          dest->buf[dest->len++] = html_named_codes[i].r[j];
        }
        break;
      }
      if (start == del)
        continue;
    untrusted_no_encode: /* untrusted, don't decode */
      del += (del < end && del[0] == ';');
      FIO_MEMCPY(dest->buf + dest->len, start, del - start);
      dest->len += del - start;
    }
  }
  if (start < end) {
    const size_t len = end - start;
    FIO_MEMCPY(dest->buf + dest->len, start, len);
    dest->len += len;
  }
  dest->buf[dest->len] = 0;
  FIO_ASSERT_DEBUG(dest->len < reduced + 1,
                   "string HTML unescape reduced calculation error");
  return r;
}

/* *****************************************************************************
String File Reading support
***************************************************************************** */

FIO_IFUNC intptr_t fio___string_fd_normalise_offset(intptr_t i,
                                                    size_t file_len) {
  if (i < 0) {
    i += (intptr_t)file_len + 1;
    if (i < 0)
      i = 0;
  }
  return i;
}

/**
 * Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at`.
 *
 * If `limit` is 0 (or less than 0) data will be written until EOF.
 *
 * If `start_at` is negative, position will be calculated from the end of the
 * file where `-1 == EOF`.
 *
 * Note: this will fail unless used on actual files (not sockets, not pipes).
 * */
SFUNC int fio_string_readfd(fio_str_info_s *dest,
                            fio_string_realloc_fn reallocate,
                            int fd,
                            intptr_t start_at,
                            size_t limit) {
  int r = 0;
  if (!dest) {
    return r;
  }
  size_t file_len = fio_fd_size(fd);
  start_at = fio___string_fd_normalise_offset(start_at, file_len);
  if (!limit || file_len < (size_t)(limit + start_at)) {
    limit = (intptr_t)file_len - start_at;
  }
  if (!file_len || !limit || (size_t)start_at >= file_len) {
    return (r = -1);
  }
  r = fio_string___write_validate_len(dest, reallocate, &limit);
  size_t added = fio_fd_read(fd, dest->buf + dest->len, limit, (off_t)start_at);
  dest->len += added;
  dest->buf[dest->len] = 0;
  return r;
}

/**
 * Opens the file `filename` and pastes it's contents (or a slice ot it) at
 * the end of the String. If `limit == 0`, than the data will be read until
 * EOF.
 *
 * If the file can't be located, opened or read, or if `start_at` is beyond
 * the EOF position, NULL is returned in the state's `data` field.
 */
SFUNC int fio_string_readfile(fio_str_info_s *dest,
                              fio_string_realloc_fn reallocate,
                              const char *filename,
                              intptr_t start_at,
                              size_t limit) {
  int r = -1;
  int fd = fio_filename_open(filename, O_RDONLY);
  if (fd == -1)
    return r;
  r = fio_string_readfd(dest, reallocate, fd, start_at, limit);
  close(fd);
  return r;
}

/**
 * Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at`
 * and ending at the first occurrence of `token`.
 *
 * If `limit` is 0 (or less than 0) as much data as may be required will be
 * written.
 *
 * If `start_at` is negative, position will be calculated from the end of the
 * file where `-1 == EOF`.
 *
 * Note: this will fail unless used on actual seekable files (not sockets, not
 * pipes).
 * */
SFUNC int fio_string_getdelim_fd(fio_str_info_s *dest,
                                 fio_string_realloc_fn reallocate,
                                 int fd,
                                 intptr_t start_at,
                                 char delim,
                                 size_t limit) {
  int r = -1;
  if (!dest || fd == -1)
    return (r = 0);
  size_t file_len = fio_fd_size(fd);
  if (!file_len)
    return r;
  start_at = fio___string_fd_normalise_offset(start_at, file_len);
  if ((size_t)start_at >= file_len)
    return r;
  size_t index = fio_fd_find_next(fd, delim, (size_t)start_at);
  if (index == FIO_FD_FIND_EOF)
    index = file_len;
  if (limit < 1 || limit > (index - start_at) + 1) {
    limit = (index - start_at) + 1;
  }

  r = fio_string___write_validate_len(dest, reallocate, &limit);
  size_t added = fio_fd_read(fd, dest->buf + dest->len, limit, (off_t)start_at);
  dest->len += added;
  dest->buf[dest->len] = 0;
  return r;
}

/**
 * Opens the file `filename`, calls `fio_string_getdelim_fd` and closes the
 * file.
 */
SFUNC int fio_string_getdelim_file(fio_str_info_s *dest,
                                   fio_string_realloc_fn reallocate,
                                   const char *filename,
                                   intptr_t start_at,
                                   char delim,
                                   size_t limit) {
  int r = -1;
  int fd = fio_filename_open(filename, O_RDONLY);
  if (fd == -1)
    return r;
  r = fio_string_getdelim_fd(dest, reallocate, fd, start_at, delim, limit);
  close(fd);
  return r;
}

/* *****************************************************************************
Binary String Type - Embedded Strings
***************************************************************************** */
/** default reallocation callback implementation */
SFUNC int fio_bstr_reallocate(fio_str_info_s *dest, size_t len) {
  fio___bstr_meta_s *bstr_m = NULL;
  size_t new_capa = fio_string_capa4len(len + sizeof(bstr_m[0]));
  if (FIO_UNLIKELY(new_capa > (size_t)0xFFFFFFFFULL))
    new_capa = (size_t)0x0FFFFFFFFULL + sizeof(bstr_m[0]);
  if (dest->capa < fio_string_capa4len(sizeof(bstr_m[0])))
    goto copy_the_string;
  bstr_m = (fio___bstr_meta_s *)FIO_MEM_REALLOC_(
      ((fio___bstr_meta_s *)dest->buf - 1),
      sizeof(bstr_m[0]) + dest->capa,
      new_capa,
      FIO___BSTR_META(dest->buf)->len + sizeof(bstr_m[0]));
  if (!bstr_m)
    return -1;
update_metadata:
  dest->buf = (char *)(bstr_m + 1);
  dest->capa = new_capa - sizeof(bstr_m[0]);
  bstr_m->capa = (uint32_t)dest->capa;
  return 0;

copy_the_string:
  bstr_m = (fio___bstr_meta_s *)FIO_MEM_REALLOC_(NULL, 0, new_capa, 0);
  if (!bstr_m)
    return -1;
  if (!FIO_MEM_REALLOC_IS_SAFE_)
    *bstr_m = (fio___bstr_meta_s){0};
  FIO_LEAK_COUNTER_ON_ALLOC(fio_bstr_s);
  if (dest->len) {
    FIO_MEMCPY((bstr_m + 1), dest->buf, dest->len + 1);
    bstr_m->len = (uint32_t)dest->len;
  }
  if (dest->capa)
    fio_bstr_free(dest->buf);
  goto update_metadata;
}

/* *****************************************************************************
String Core Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_STR
#endif /* H__FIO_STR__H */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_MUSTACHE module    /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                        Mustache-ish Template Engine




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_MUSTACHE) && !defined(FIO___RECURSIVE_INCLUDE) &&              \
    !defined(H___FIO_MUSTACHE___H)
#define H___FIO_MUSTACHE___H

/* *****************************************************************************
Settings
***************************************************************************** */

#ifndef FIO_MUSTACHE_MAX_DEPTH
/** The maximum depth of a template's context */
#define FIO_MUSTACHE_MAX_DEPTH 128
#endif

#ifndef FIO_MUSTACHE_PRESERVE_PADDING
/** Preserves padding for stand-alone variables and partial templates */
#define FIO_MUSTACHE_PRESERVE_PADDING 0
#endif
#ifndef FIO_MUSTACHE_LAMBDA_SUPPORT
/** Supports raw text for lambda style languages. */
#define FIO_MUSTACHE_LAMBDA_SUPPORT 0
#endif
#ifndef FIO_MUSTACHE_ISOLATE_PARTIALS
/** Limits the scope of partial templates to the context of their section. */
#define FIO_MUSTACHE_ISOLATE_PARTIALS 1
#endif

/* *****************************************************************************
Mustache Parser / Builder API
***************************************************************************** */

typedef struct fio_mustache_s fio_mustache_s;
typedef struct fio_mustache_bargs_s fio_mustache_bargs_s;

typedef struct {
  /** The file's content (if pre-loaded) */
  fio_buf_info_s data;
  /** The file's name (even if preloaded, used for partials load paths) */
  fio_buf_info_s filename;
  /** Loads the file's content, returning a `fio_buf_info_s` structure. */
  fio_buf_info_s (*load_file_data)(fio_buf_info_s filename, void *udata);
  /** Frees the file's content from its `fio_buf_info_s` structure. */
  void (*free_file_data)(fio_buf_info_s file_data, void *udata);
  /** Called when YAML front matter data was found. */
  void (*on_yaml_front_matter)(fio_buf_info_s yaml_front_matter, void *udata);
  /** Opaque user data. */
  void *udata;
} fio_mustache_load_args_s;

/* Allocates a new object on the heap and initializes it's memory. */
SFUNC fio_mustache_s *fio_mustache_load(fio_mustache_load_args_s settings);
/* Allocates a new object on the heap and initializes it's memory. */
#define fio_mustache_load(...)                                                 \
  fio_mustache_load((fio_mustache_load_args_s){__VA_ARGS__})

/* Frees the mustache template object (or reduces it's reference count). */
SFUNC void fio_mustache_free(fio_mustache_s *m);

/** Increases the mustache template's reference count. */
SFUNC fio_mustache_s *fio_mustache_dup(fio_mustache_s *m);

struct fio_mustache_bargs_s {
  /* callback should write `txt` to output and return updated `udata.` */
  void *(*write_text)(void *udata, fio_buf_info_s txt);
  /* same as `write_text`, but should also  HTML escape (sanitize) data. */
  void *(*write_text_escaped)(void *udata, fio_buf_info_s raw);
  /* callback should return a new context pointer with the value of `name`. */
  void *(*get_var)(void *ctx, fio_buf_info_s name);
  /* if context is an Array, should return its length. */
  size_t (*array_length)(void *ctx);
  /* if context is an Array, should return a context pointer @ index. */
  void *(*get_var_index)(void *ctx, size_t index);
  /* should return the String value of context `var` as a `fio_buf_info_s`. */
  fio_buf_info_s (*var2str)(void *var);
  /* should return non-zero if the context pointer refers to a valid value. */
  int (*var_is_truthful)(void *ctx);
  /* callback signals that the `ctx` context pointer is no longer in use. */
  void (*release_var)(void *ctx);
  /* returns non-zero if `ctx` is a lambda and handles section manually. */
  int (*is_lambda)(void **udata,
                   void *ctx,
                   fio_buf_info_s raw_template_section);
  /* the root context for finding named values. */
  void *ctx;
  /* opaque user data (settable as well as readable), the final return value. */
  void *udata;
};

/** Builds the template, returning the final value of `udata` (or NULL). */
SFUNC void *fio_mustache_build(fio_mustache_s *m, fio_mustache_bargs_s);
#define fio_mustache_build(m, ...)                                             \
  fio_mustache_build((m), ((fio_mustache_bargs_s){__VA_ARGS__}))

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
FIO_LEAK_COUNTER_DEF(fio_mustache_s)

/* *****************************************************************************
Instructions (relative state)

All instructions are 1 byte long with optional extra data.

Instruction refer to offsets rather than absolute values.
***************************************************************************** */
/* for ease of use, instructions are always a 1 byte numeral, */
typedef enum {
  FIO___MUSTACHE_I_STACK_POP,    /* 0 extra data (marks end of array / list)? */
  FIO___MUSTACHE_I_STACK_PUSH,   /* 32 bit extra data (goes to position) */
  FIO___MUSTACHE_I_GOTO_PUSH,    /* 32 bit extra data (goes to position) */
  FIO___MUSTACHE_I_TXT,          /* 16 bits length + data */
  FIO___MUSTACHE_I_VAR,          /* 16 bits length + data */
  FIO___MUSTACHE_I_VAR_RAW,      /* 16 bits length + data */
  FIO___MUSTACHE_I_ARY,          /* 16 bits length + 32 bit skip-pos + data */
  FIO___MUSTACHE_I_MISSING,      /* 16 bits length + 32 bit skip-pos + data */
  FIO___MUSTACHE_I_PADDING_PUSH, /* 16 bits length + data */
  FIO___MUSTACHE_I_PADDING_POP,  /* 0 extra data */
#if FIO_MUSTACHE_PRESERVE_PADDING
  FIO___MUSTACHE_I_VAR_PADDED,
  FIO___MUSTACHE_I_VAR_RAW_PADDED,
#endif
#if FIO_MUSTACHE_LAMBDA_SUPPORT
  FIO___MUSTACHE_I_METADATA, /* raw text data, written for lambda support */
#endif
} fio___mustache_inst_e;
/* *****************************************************************************
Instructions - Main processor
***************************************************************************** */

typedef struct fio___mustache_bldr_s {
  char *root;
  struct fio___mustache_bldr_s *prev;
  void *ctx;
  fio_buf_info_s padding;
  fio_mustache_bargs_s *args;
#if FIO_MUSTACHE_ISOLATE_PARTIALS
  uint32_t stop;
#endif
} fio___mustache_bldr_s;

FIO_SFUNC char *fio___mustache_i_stack_pop(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_stack_push(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_goto_push(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_txt(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_var(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_var_raw(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_ary(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_missing(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_padding_push(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_padding_pop(char *p, fio___mustache_bldr_s *);
#if FIO_MUSTACHE_PRESERVE_PADDING
FIO_SFUNC char *fio___mustache_i_var_padded(char *p, fio___mustache_bldr_s *);
FIO_SFUNC char *fio___mustache_i_var_raw_padded(char *,
                                                fio___mustache_bldr_s *);
#endif
#if FIO_MUSTACHE_LAMBDA_SUPPORT
FIO_SFUNC char *fio___mustache_i_metadata(char *p, fio___mustache_bldr_s *);
#endif

FIO_SFUNC void *fio___mustache_build_section(char *p, fio___mustache_bldr_s a) {
  static char *(*map[])(char *, fio___mustache_bldr_s *) = {
    [FIO___MUSTACHE_I_STACK_POP] = fio___mustache_i_stack_pop,
    [FIO___MUSTACHE_I_STACK_PUSH] = fio___mustache_i_stack_push,
    [FIO___MUSTACHE_I_GOTO_PUSH] = fio___mustache_i_goto_push,
    [FIO___MUSTACHE_I_TXT] = fio___mustache_i_txt,
    [FIO___MUSTACHE_I_VAR] = fio___mustache_i_var,
    [FIO___MUSTACHE_I_VAR_RAW] = fio___mustache_i_var_raw,
    [FIO___MUSTACHE_I_ARY] = fio___mustache_i_ary,
    [FIO___MUSTACHE_I_MISSING] = fio___mustache_i_missing,
    [FIO___MUSTACHE_I_PADDING_PUSH] = fio___mustache_i_padding_push,
    [FIO___MUSTACHE_I_PADDING_POP] = fio___mustache_i_padding_pop,
#if FIO_MUSTACHE_PRESERVE_PADDING
    [FIO___MUSTACHE_I_VAR_PADDED] = fio___mustache_i_var_padded,
    [FIO___MUSTACHE_I_VAR_RAW_PADDED] = fio___mustache_i_var_raw_padded,
#endif
#if FIO_MUSTACHE_LAMBDA_SUPPORT
    [FIO___MUSTACHE_I_METADATA] = fio___mustache_i_metadata,
#endif

  };
  while (p)
    p = map[(uint8_t)(p[0])](p, &a);
  return a.args->udata;
}

/* *****************************************************************************
Instructions - Helpers
***************************************************************************** */

/* consumes `val_name`, in whole or in part, returning the variable found.
 * sets `val_name` to the unconsumed partial remaining.
 */
FIO_IFUNC void *fio___mustache_get_var_in_context(fio_mustache_bargs_s *a,
                                                  void *ctx,
                                                  fio_buf_info_s *val_name) {
  void *v = ctx;
  v = a->get_var(ctx, *val_name);
  if (v) {
    val_name->len = 0;
    return v;
  }
  char *s = val_name->buf;
  char *end = val_name->buf + val_name->len;
  for (;;) {
    if (s == end)
      return v;
    s = (char *)FIO_MEMCHR(s, '.', (size_t)(end - s));
    if (!s)
      return v;
    v = a->get_var(ctx,
                   FIO_BUF_INFO2(val_name->buf, (size_t)(s - val_name->buf)));
    ++s;
    if (!v)
      continue;
    val_name->buf = s;
    val_name->len = (size_t)(end - s);
    return v;
  }
}

FIO_IFUNC void *fio___mustache_get_var(fio___mustache_bldr_s *b,
                                       fio_buf_info_s val_name) {
  void *v = b->ctx;
  if (val_name.len == 1 && val_name.buf[0] == '.')
    return v;
  for (;;) {
    if (b->ctx)
      v = fio___mustache_get_var_in_context(b->args, b->ctx, &val_name);
    if (v)
      break;
#if FIO_MUSTACHE_ISOLATE_PARTIALS
    if (b->stop)
      return v;
#endif
    b = b->prev;
    if (!b)
      return v;
  }
  while (val_name.len && v)
    v = fio___mustache_get_var_in_context(b->args, v, &val_name);
  return v;
}

FIO_SFUNC void fio___mustache_write_padding(fio___mustache_bldr_s *b) {
  while (b && b->padding.len) {
    if (b->padding.buf) {
      b->args->udata = b->args->write_text(b->args->udata, b->padding);
    }
    b = b->prev;
  }
}

FIO_SFUNC void fio___mustache_write_text_simple(
    fio___mustache_bldr_s *b,
    fio_buf_info_s txt,
    void *(*writer)(void *, fio_buf_info_s txt)) {
  b->args->udata = writer(b->args->udata, txt);
}

FIO_SFUNC void fio___mustache_write_text_complex(
    fio___mustache_bldr_s *b,
    fio_buf_info_s txt,
    void *(*writer)(void *, fio_buf_info_s txt)) {
  const char *end = txt.buf + txt.len;
  for (;;) {
    char *pos = (char *)FIO_MEMCHR(txt.buf, '\n', (size_t)(end - txt.buf));
    if (!pos)
      break;
    ++pos;
    if (txt.buf[0] != '\n' || (size_t)(pos - txt.buf) > 1)
      fio___mustache_write_padding(b);
    b->args->udata =
        writer(b->args->udata, FIO_BUF_INFO2(txt.buf, (size_t)(pos - txt.buf)));
    txt.buf = pos;
    if (pos < end)
      continue;
    return;
  }
  if (txt.buf < end) {
    fio___mustache_write_padding(b);
    b->args->udata =
        writer(b->args->udata, FIO_BUF_INFO2(txt.buf, (size_t)(end - txt.buf)));
  }
}

FIO_IFUNC void fio___mustache_writer_route(
    fio___mustache_bldr_s *b,
    fio_buf_info_s txt,
    void *(*writer)(void *, fio_buf_info_s txt)) {
  void (*router[2])(fio___mustache_bldr_s *,
                    fio_buf_info_s txt,
                    void *(*writer)(void *, fio_buf_info_s txt)) = {
      fio___mustache_write_text_complex,
      fio___mustache_write_text_simple};
  router[!(b->padding.len)](b, txt, writer);
}

/* *****************************************************************************
Instruction Implementations
***************************************************************************** */

FIO_SFUNC char *fio___mustache_i_stack_pop(char *p, fio___mustache_bldr_s *b) {
  return NULL;
  (void)p, (void)b;
}
FIO_SFUNC char *fio___mustache_i_stack_push(char *p, fio___mustache_bldr_s *b) {
  char *npos = p + 5;
  p = b->root + fio_buf2u32u(p + 1);
  fio___mustache_bldr_s builder = {
    .root = b->root,
    .prev = b,
#if FIO_MUSTACHE_ISOLATE_PARTIALS
    .ctx = b->ctx,
#endif
    .padding = FIO_BUF_INFO2(NULL, b->padding.len),
    .args = b->args,
#if FIO_MUSTACHE_ISOLATE_PARTIALS
    .stop = 1,
#endif
  };
  fio___mustache_build_section(npos, builder);
  return p;
}
FIO_SFUNC char *fio___mustache_i_goto_push(char *p, fio___mustache_bldr_s *b) {
  char *npos = b->root + fio_buf2u32u(p + 1);
  fio___mustache_bldr_s builder = {
    .root = b->root,
    .prev = b,
#if FIO_MUSTACHE_ISOLATE_PARTIALS
    .ctx = b->ctx,
#endif
    .padding = FIO_BUF_INFO2(NULL, b->padding.len),
    .args = b->args,
#if FIO_MUSTACHE_ISOLATE_PARTIALS
    .stop = 1,
#endif
  };
  fio___mustache_build_section(npos, builder);
  p += 5;
  return p;
}
FIO_SFUNC char *fio___mustache_i_txt(char *p, fio___mustache_bldr_s *b) {
  fio_buf_info_s txt = FIO_BUF_INFO2(p + 3, fio_buf2u16u(p + 1));
  p = txt.buf + txt.len;
  fio___mustache_writer_route(b, txt, b->args->write_text);
  return p;
}

FIO_IFUNC char *fio___mustache_i_var_internal(
    char *p,
    fio___mustache_bldr_s *b,
    void *(*writer)(void *, fio_buf_info_s txt)) {
  fio_buf_info_s var = FIO_BUF_INFO2(p + 3, fio_buf2u16u(p + 1));
  p = var.buf + var.len;
  void *v = fio___mustache_get_var(b, var);
  if (!v)
    return p;
  var = b->args->var2str(v);
  b->args->release_var(v);
#if FIO_MUSTACHE_PRESERVE_PADDING
  fio___mustache_writer_route(b, var, writer);
#else
  fio___mustache_write_padding(b);
  b->args->udata = writer(b->args->udata, var);
#endif
  return p;
}
FIO_SFUNC char *fio___mustache_i_var(char *p, fio___mustache_bldr_s *b) {
  return fio___mustache_i_var_internal(p, b, b->args->write_text_escaped);
}
FIO_SFUNC char *fio___mustache_i_var_raw(char *p, fio___mustache_bldr_s *b) {
  return fio___mustache_i_var_internal(p, b, b->args->write_text);
}

FIO_SFUNC char *fio___mustache_i_ary(char *p, fio___mustache_bldr_s *b) {
  fio_buf_info_s var = FIO_BUF_INFO2(p + 7, fio_buf2u16u(p + 1));
  uint32_t skip_pos = fio_buf2u32u(p + 3);
  p = b->root + skip_pos;
#if FIO_MUSTACHE_LAMBDA_SUPPORT
  fio_buf_info_s section_raw_txt = FIO_BUF_INFO2(NULL, 0);
  if (p[0] == FIO___MUSTACHE_I_METADATA) {
    section_raw_txt = FIO_BUF_INFO2(p + 3, fio_buf2u16u(p + 1));
    p = section_raw_txt.buf + section_raw_txt.len;
  }
#else
  const fio_buf_info_s section_raw_txt = FIO_BUF_INFO2(NULL, 0);
#endif

  void *v = fio___mustache_get_var(b, var);
  if (!(b->args->var_is_truthful(v)))
    return p;
  size_t index = 0;
  const size_t ary_len = b->args->array_length(v);
  void *nctx = v;
  if (ary_len)
    nctx = b->args->get_var_index(v, index);
  for (;;) {
    ++index;
    fio___mustache_bldr_s builder = {
        .root = b->root,
        .prev = b,
        .ctx = nctx,
        .padding = FIO_BUF_INFO2(NULL, b->padding.len),
        .args = b->args,
    };
    if (!b->args->is_lambda(&(b->args->udata), nctx, section_raw_txt)) {
      fio___mustache_build_section(var.buf + var.len, builder);
    }
    b->args->release_var(nctx);
    if (index >= ary_len) {
      if (nctx != v)
        b->args->release_var(v);
      return p;
    }
    nctx = b->args->get_var_index(v, index);
  }
}
FIO_SFUNC char *fio___mustache_i_missing(char *p, fio___mustache_bldr_s *b) {
  fio_buf_info_s var = FIO_BUF_INFO2(p + 7, fio_buf2u16u(p + 1));
  uint32_t skip_pos = fio_buf2u32u(p + 3);
  p = b->root + skip_pos;

  void *v = fio___mustache_get_var(b, var);
  if (b->args->var_is_truthful(v)) {
    b->args->release_var(v);
    return p;
  }

  fio___mustache_bldr_s builder = {
      .root = b->root,
      .prev = b,
      .padding = FIO_BUF_INFO2(NULL, b->padding.len),
      .args = b->args,
  };
  fio___mustache_build_section(var.buf + var.len, builder);
  return p;
}

FIO_SFUNC char *fio___mustache_i_padding_push(char *p,
                                              fio___mustache_bldr_s *b) {
  b->padding = FIO_BUF_INFO2(p + 3, fio_buf2u16u(p + 1));
  return p + 3 + b->padding.len;
}
FIO_SFUNC char *fio___mustache_i_padding_pop(char *p,
                                             fio___mustache_bldr_s *b) {
  b->padding = FIO_BUF_INFO2(NULL, 0);
  if (b->prev)
    b->padding.len = b->prev->padding.len;
  return p + 1;
}

#if FIO_MUSTACHE_PRESERVE_PADDING

FIO_SFUNC char *fio___mustache_i_var_padded(char *p, fio___mustache_bldr_s *b) {
  fio_buf_info_s var = FIO_BUF_INFO2(p + 5, fio_buf2u16u(p + 1));
  fio_buf_info_s padding = FIO_BUF_INFO2(p + 5 + var.len, fio_buf2u16u(p + 3));
  p = padding.buf + padding.len;
  void *v = fio___mustache_get_var(b, var);
  if (!v)
    return p;
  var = b->args->var2str(v);
  if (!var.len)
    goto done;
  fio___mustache_bldr_s b2 = *b;
  b2.padding = padding;
  fio___mustache_writer_route(&b2, var, b->args->write_text_escaped);
done:
  b->args->release_var(v);
  return p;
}
FIO_SFUNC char *fio___mustache_i_var_raw_padded(char *p,
                                                fio___mustache_bldr_s *b) {
  fio_buf_info_s var = FIO_BUF_INFO2(p + 5, fio_buf2u16u(p + 1));
  fio_buf_info_s padding = FIO_BUF_INFO2(p + 5 + var.len, fio_buf2u16u(p + 3));
  p = padding.buf + padding.len;
  void *v = fio___mustache_get_var(b, var);
  if (!v)
    return p;
  var = b->args->var2str(v);
  if (!var.len)
    goto done;
  fio___mustache_bldr_s b2 = *b;
  b2.padding = padding;
  fio___mustache_writer_route(&b2, var, b->args->write_text);
  b->args->release_var(v);
  return p;
}

#endif

#if FIO_MUSTACHE_LAMBDA_SUPPORT
FIO_SFUNC char *fio___mustache_i_metadata(char *p, fio___mustache_bldr_s *b) {
  uint32_t len = fio_buf2u16u(p + 1);
  return p + 3 + len;
  (void)b;
}
#endif

/* *****************************************************************************
Mustache delimiter testing
***************************************************************************** */
FIO_SFUNC _Bool fio___mustache_delcmp1(const char *restrict a,
                                       const char *restrict b) {
  return 1;
  (void)a, (void)b;
}
FIO_SFUNC _Bool fio___mustache_delcmp2(const char *restrict a,
                                       const char *restrict b) {
  return a[1] == b[1];
}
FIO_SFUNC _Bool fio___mustache_delcmp3(const char *restrict a,
                                       const char *restrict b) {
  return a[1] == b[1] && a[2] == b[2];
}
FIO_SFUNC _Bool fio___mustache_delcmp4(const char *restrict a,
                                       const char *restrict b) {
  return a[1] == b[1] && a[2] == b[2] && a[3] == b[3];
}

typedef struct fio___mustache_delimiter_s {
  struct {
    _Bool (*cmp)(const char *restrict, const char *restrict);
    uint32_t len;
    char buf[4];
  } in, out;
} fio___mustache_delimiter_s;

FIO_IFUNC fio___mustache_delimiter_s fio___mustache_delimiter_init(void) {
  fio___mustache_delimiter_s r = {
      .in = {.cmp = fio___mustache_delcmp2, .len = 2, .buf = {'{', '{'}},
      .out = {.cmp = fio___mustache_delcmp2, .len = 2, .buf = {'}', '}'}},
  };
  return r;
}

/* *****************************************************************************
Parser type & helpers
***************************************************************************** */

typedef struct fio___mustache_parser_s {
  char *root;
  struct fio___mustache_parser_s *prev;
  fio_mustache_load_args_s *args;
  fio___mustache_delimiter_s delim;
  fio_buf_info_s fname;
  fio_buf_info_s path;
  fio_buf_info_s backwards;
  fio_buf_info_s forwards;
  uint32_t starts_at;
  uint32_t depth;
  uint32_t dirty;
} fio___mustache_parser_s;

/* *****************************************************************************
Template file loading
***************************************************************************** */
FIO_SFUNC fio_buf_info_s
fio___mustache_load_template(fio___mustache_parser_s *p, fio_buf_info_s fname) {
  /* Attempt to load templates in the following order:
   * 1. Calling template folder
   * 2. Parent calling folder (recursively)?
   * 3. Working folder.
   */
  fio_buf_info_s r = {0};
  fio_buf_info_s const extensions[] = {FIO_BUF_INFO1((char *)".mustache"),
                                       FIO_BUF_INFO1((char *)".html"),
                                       FIO_BUF_INFO2((char *)"", 0),
                                       {0}};
  FIO_STR_INFO_TMP_VAR(fn, (PATH_MAX | 2094));
  if (FIO_UNLIKELY(!fname.len || fname.len > (PATH_MAX - 1)))
    return r;
  fio___mustache_parser_s *tp = p;
  /* TODO: iterate file names to test for a match... */
  if (fname.buf[0] != FIO_FOLDER_SEPARATOR && fname.buf[0] != '/') {
    for (;;) { /* test and load file with a possible relative base path... */
      /* test if file was previously loaded (with this base-path) */
      for (;;) {
        if (FIO_BUF_INFO_IS_EQ(tp->fname, fname))
          goto already_exists;
        if (tp->path.buf)
          break; /* we arrived at current relative path root */
        tp = tp->prev;
        if (!tp)
          goto absolute_path_or_cwd;
      }
      /* test current relative path with each filename & extension combo */
      if (tp->path.len + fname.len + 32 < ((PATH_MAX | 2094) - 1)) {
        for (size_t i = 0; extensions[i].buf; ++i) {
          fn.len = 0;
          fio_string_write2(
              &fn,
              NULL,
              FIO_STRING_WRITE_STR2(tp->path.buf, tp->path.len),
              FIO_STRING_WRITE_STR2(fname.buf, fname.len),
              FIO_STRING_WRITE_STR2(extensions[i].buf, extensions[i].len));
          r = p->args->load_file_data(FIO_STR2BUF_INFO(fn), p->args->udata);
          if (r.len)
            goto file_loaded_successfully;
        }
      }
      tp = tp->prev;
      if (!tp)
        goto absolute_path_or_cwd;
    }
  }

absolute_path_or_cwd:
  /* possibly full-path specified + fallback to working folder */
  for (size_t i = 0; extensions[i].buf; ++i) {
    fn.len = 0;
    fio_string_write2(
        &fn,
        NULL,
        FIO_STRING_WRITE_STR2(fname.buf, fname.len),
        FIO_STRING_WRITE_STR2(extensions[i].buf, extensions[i].len));
    r = p->args->load_file_data(FIO_STR2BUF_INFO(fn), p->args->udata);
    if (r.len)
      goto file_loaded_successfully;
  }

file_loaded_successfully:
  return r;

already_exists:
  fn.len = 5; /* TODO: fixme? */
  fn.buf[0] = FIO___MUSTACHE_I_GOTO_PUSH;
  fio_u2buf32u(fn.buf + 1, tp->starts_at);
  p->root = fio_bstr_write(p->root, fn.buf, fn.len);
  return r;
}

FIO_SFUNC void fio___mustache_free_template(fio___mustache_parser_s *p,
                                            fio_buf_info_s d) {
  p->args->free_file_data(d, p->args->udata);
}

/* *****************************************************************************
Tag Helpers
***************************************************************************** */

/* forward declaration, implemented later */
FIO_SFUNC int fio___mustache_parse_block(fio___mustache_parser_s *p);
FIO_SFUNC int fio___mustache_parse_template_file(fio___mustache_parser_s *p);

FIO_IFUNC void fio___mustache_stand_alone_skip_eol(fio___mustache_parser_s *p) {
  size_t offset =
      !p->dirty && p->forwards.buf[0] == '\r' && p->forwards.buf[1] == '\n';
  p->forwards.buf += offset;
  p->forwards.len -= offset;
  offset = !p->dirty && p->forwards.buf[0] == '\n';
  p->forwards.buf += offset;
  p->forwards.len -= offset;
}

FIO_IFUNC int fio___mustache_parse_add_text(fio___mustache_parser_s *p,
                                            fio_buf_info_s txt) {
  union {
    uint64_t u64[1];
    char u8[8];
  } buf;
  buf.u8[0] = FIO___MUSTACHE_I_TXT;
  FIO_ASSERT_DEBUG(txt.len < (1 << 16),
                   "(mustache) text instruction overflow!");
  fio_u2buf16u(buf.u8 + 1, txt.len);
  p->root = fio_bstr_write2(p->root,
                            FIO_STRING_WRITE_STR2(buf.u8, 3),
                            FIO_STRING_WRITE_STR2(txt.buf, txt.len));
  return 0;
}

FIO_IFUNC int fio___mustache_parse_comment(fio___mustache_parser_s *p,
                                           fio_buf_info_s comment) {
  fio___mustache_stand_alone_skip_eol(p);
  return 0;
  (void)comment;
}

FIO_IFUNC int fio___mustache_parse_section_end(fio___mustache_parser_s *p,
                                               fio_buf_info_s var) {
  union {
    uint64_t u64[1];
    char u8[8];
  } buf;
  char *prev = NULL;
  fio_buf_info_s old_var_name;
  buf.u8[0] = FIO___MUSTACHE_I_STACK_POP;
  if (!p->prev)
    goto section_not_open;
  prev = p->root + p->starts_at;
  if (*prev != FIO___MUSTACHE_I_ARY && *prev != FIO___MUSTACHE_I_MISSING)
    goto section_not_open;
  old_var_name = FIO_BUF_INFO2(prev + 7, (size_t)fio_buf2u16u(prev + 1));
  if (!FIO_BUF_INFO_IS_EQ(old_var_name, var))
    goto value_name_mismatch;

  fio_u2buf32u(prev + 3, (uint32_t)(fio_bstr_len(p->root) + 1));
  fio___mustache_stand_alone_skip_eol(p);

#if FIO_MUSTACHE_LAMBDA_SUPPORT
  old_var_name =
      FIO_BUF_INFO2(p->prev->forwards.buf,
                    (size_t)(p->backwards.buf - p->prev->forwards.buf));
  old_var_name.len -= (old_var_name.len && old_var_name.buf[-1] == '\n');
  old_var_name.len -= (old_var_name.len && old_var_name.buf[-1] == '\r');
  if (old_var_name.len && old_var_name.len < (1U << 16)) {
    buf.u8[1] = FIO___MUSTACHE_I_METADATA;
    fio_u2buf16u(buf.u8 + 2, old_var_name.len);
    p->root = fio_bstr_write2(
        p->root,
        FIO_STRING_WRITE_STR2(buf.u8, 4),
        FIO_STRING_WRITE_STR2(old_var_name.buf, old_var_name.len));
  } else
#endif
    p->root = fio_bstr_write(p->root, buf.u8, 1);
  return -2;

value_name_mismatch:
  FIO_LOG_ERROR(
      "(mustache) template section end tag doesn't match section start:"
      "\n\t\t%.*s != %.*s",
      (int)var.len,
      var.buf,
      (int)old_var_name.len,
      old_var_name.buf);
  return -1;

section_not_open:
  FIO_LOG_ERROR("(mustache) section end tag with no section opening tag?"
                "\n\t\t%.*s",
                (int)var.len,
                var.buf);
  return -1;
}

FIO_IFUNC int fio___mustache_parse_section_start(fio___mustache_parser_s *p,
                                                 fio_buf_info_s var,
                                                 size_t inverted) {
  if (p->depth == FIO_MUSTACHE_MAX_DEPTH)
    return -1;
  fio___mustache_stand_alone_skip_eol(p);

  fio___mustache_parser_s new_section = {
      .root = p->root,
      .prev = p,
      .args = p->args,
      .delim = p->delim,
      .forwards = p->forwards,
      .starts_at = (uint32_t)fio_bstr_len(p->root),
      .depth = p->depth + 1,
      .dirty = p->dirty,
  };
  union {
    uint64_t u64[1];
    char u8[8];
  } buf;
  buf.u8[0] = FIO___MUSTACHE_I_ARY + inverted;
  fio_u2buf16u(buf.u8 + 1, var.len);
  /* + 32 bit value to be filled by closure. */
  new_section.root = fio_bstr_write2(new_section.root,
                                     FIO_STRING_WRITE_STR2(buf.u8, 7),
                                     FIO_STRING_WRITE_STR2(var.buf, var.len));
#if FIO_MUSTACHE_PRESERVE_PADDING
  if (!p->dirty && p->backwards.len) {
    buf.u8[0] = FIO___MUSTACHE_I_PADDING_PUSH;
    fio_u2buf16u(buf.u8 + 1, p->backwards.len);
    new_section.root = fio_bstr_write2(
        new_section.root,
        FIO_STRING_WRITE_STR2(buf.u8, 3),
        FIO_STRING_WRITE_STR2(p->backwards.buf, p->backwards.len));
  }
#endif
  int r = fio___mustache_parse_block(&new_section);
  p->root = new_section.root;
  p->forwards = new_section.forwards;
  return r;
}

FIO_IFUNC int fio___mustache_parse_partial(fio___mustache_parser_s *p,
                                           fio_buf_info_s filename) {
  if (p->depth == FIO_MUSTACHE_MAX_DEPTH)
    return -1;

  fio___mustache_stand_alone_skip_eol(p);

  fio_buf_info_s file_content = fio___mustache_load_template(p, filename);
  if (!file_content.len)
    return 0;

  union {
    uint64_t u64[1];
    char u8[8];
  } buf;

  buf.u8[0] = FIO___MUSTACHE_I_STACK_PUSH;
  size_t ipos = fio_bstr_len(p->root) + 1;
  p->root = fio_bstr_write(p->root, buf.u8, 5);

  if (!p->dirty && p->backwards.len) {
    buf.u8[0] = FIO___MUSTACHE_I_PADDING_PUSH;
    fio_u2buf16u(buf.u8 + 1, p->backwards.len);
    p->root = fio_bstr_write2(
        p->root,
        FIO_STRING_WRITE_STR2(buf.u8, 3),
        FIO_STRING_WRITE_STR2(p->backwards.buf, p->backwards.len));
  }

  fio___mustache_parser_s new_section = {
      .root = p->root,
      .prev = p,
      .args = p->args,
      .delim = fio___mustache_delimiter_init(),
      .fname = filename,
      .path = fio_filename_parse2(filename.buf, filename.len).folder,
      .forwards = file_content,
      .starts_at = (uint32_t)fio_bstr_len(p->root),
      .depth = p->depth + 1,
      .dirty = 0,
  };

  int r = fio___mustache_parse_template_file(&new_section);
  buf.u8[0] = FIO___MUSTACHE_I_STACK_POP;
  p->root = fio_bstr_write(new_section.root, buf.u8, 1);
  fio_u2buf32u(p->root + ipos, (uint32_t)fio_bstr_len(p->root));
  fio___mustache_free_template(p, file_content);
  return r;
}

FIO_IFUNC int fio___mustache_parse_set_delim(fio___mustache_parser_s *p,
                                             fio_buf_info_s buf) {
  struct {
    uint32_t len;
    void *(*cpy)(void *a, const void *b);
    _Bool (*cmp)(const char *restrict, const char *restrict);
  } const len_map[] = {
      {0},
      {1, fio_memcpy1, fio___mustache_delcmp1},
      {2, fio_memcpy2, fio___mustache_delcmp2},
      {3, fio_memcpy3, fio___mustache_delcmp3},
      {4, fio_memcpy4, fio___mustache_delcmp4},
  };

  fio___mustache_stand_alone_skip_eol(p);

  char *end = buf.buf + buf.len;
  char *pos = buf.buf;
  while (pos < end && *pos != ' ' && *pos != '\t')
    ++pos;
  if (pos == end)
    goto delim_tag_error;
  buf.len = (size_t)(pos - buf.buf);
  while (*pos == ' ' || *pos == '\t')
    ++pos;
  if (pos >= end)
    goto delim_tag_error;

  if ((size_t)(end - pos) > 4UL || !(size_t)(end - pos) || !buf.len ||
      buf.len > 4UL)
    goto delim_tag_error;
  len_map[buf.len].cpy(p->delim.in.buf, buf.buf);
  len_map[(size_t)(end - pos)].cpy(p->delim.out.buf, pos);
  p->delim.in.cmp = len_map[buf.len].cmp;
  p->delim.out.cmp = len_map[(size_t)(end - pos)].cmp;
  p->delim.in.len = len_map[buf.len].len;
  p->delim.out.len = len_map[(size_t)(end - pos)].len;
  return 0;

delim_tag_error:
  FIO_LOG_ERROR("(mustache) delimiter tag error: %.*s",
                (int)(end - buf.buf),
                buf.buf);
  return -1;
}

FIO_IFUNC int fio___mustache_parse_var_name(fio___mustache_parser_s *p,
                                            fio_buf_info_s var,
                                            size_t raw) {
  union {
    uint64_t u64[1];
    char u8[8];
  } buf;
  if (p->backwards.len > ((1 << 16) - 1))
    p->backwards.len = 0;

#if FIO_MUSTACHE_PRESERVE_PADDING
  if (p->backwards.len)
    goto padded;
#else
  fio___mustache_parse_add_text(p, p->backwards);
#endif
  buf.u8[0] = (char)(FIO___MUSTACHE_I_VAR + raw);
  fio_u2buf16u(buf.u8 + 1, var.len);
  p->root = fio_bstr_write2(p->root,
                            FIO_STRING_WRITE_STR2(buf.u8, 3),
                            FIO_STRING_WRITE_STR2(var.buf, var.len));
  return 0;
#if FIO_MUSTACHE_PRESERVE_PADDING
padded:
  /* TODO: fixme (what if padding value is already used?) */
  buf.u8[0] = (char)(FIO___MUSTACHE_I_VAR_PADDED + raw);
  fio_u2buf16u(buf.u8 + 1, var.len);
  fio_u2buf16u(buf.u8 + 3, p->backwards.len);
  p->root = fio_bstr_write2(
      p->root,
      FIO_STRING_WRITE_STR2(buf.u8, 5),
      FIO_STRING_WRITE_STR2(var.buf, var.len),
      FIO_STRING_WRITE_STR2(p->backwards.buf, p->backwards.len));
  return 0;
#endif
}

/* *****************************************************************************
Tag Consumer
***************************************************************************** */

FIO_SFUNC int fio___mustache_parse_consume_tag(fio___mustache_parser_s *p,
                                               fio_buf_info_s buf) {
  /* remove white-space from name */
  for (; buf.len &&
         (buf.buf[buf.len - 1] == ' ' || buf.buf[buf.len - 1] == '\t');)
    --buf.len;
  if (!buf.len) {
    FIO_LOG_ERROR("(mustache) template tags must contain a value!");
    return -1;
  }

  while (buf.buf[0] == ' ' || buf.buf[0] == '\t') {
    ++buf.buf;
    --buf.len;
  }
  char id = buf.buf[0];
  if (!(id == '/' || id == '#' || id == '^' || id == '>' || id == '!' ||
        id == '&' || (id == '=' && buf.buf[buf.len - 1] == '=') ||
        (id == '{' && buf.buf[buf.len - 1] == '}')))
    return fio___mustache_parse_var_name(p, buf, 0); /* escaped var */

  /* tag starts with a marker, seek new tag starting point */
  do {
    ++buf.buf;
    --buf.len;
    if (buf.len)
      continue;
    FIO_LOG_ERROR("(mustache) template tags must contain a value!");
    return -1;
  } while (buf.buf[0] == ' ' || buf.buf[0] == '\t');
  /* test for tag type and route to handler */
  switch (id) {
  case '/': return fio___mustache_parse_section_end(p, buf);
  case '#': return fio___mustache_parse_section_start(p, buf, 0);
  case '^': return fio___mustache_parse_section_start(p, buf, 1);
  case '>': return fio___mustache_parse_partial(p, buf);
  case '!': return fio___mustache_parse_comment(p, buf);
  case '=': /* fall through */
  case '{':
    do /* it is known that (buf.buf ends as '=' or '}')*/
      --buf.len;
    while (buf.buf[buf.len - 1] == ' ' || buf.buf[buf.len - 1] == '\t');

    if (id == '=')
      return fio___mustache_parse_set_delim(p, buf); /* fall through */
  default: /* raw var */ return fio___mustache_parse_var_name(p, buf, 1);
  }
}

/* *****************************************************************************
File Consumer parser
***************************************************************************** */

FIO_SFUNC int fio___mustache_parse_block(fio___mustache_parser_s *p) {
  int r = 0;
  const char *end = p->forwards.buf + p->forwards.len;
  fio_buf_info_s tag;
  p->backwards = FIO_BUF_INFO2(p->forwards.buf, 0);
  p->root = fio_bstr_reserve(p->root, p->forwards.len);
  /* consume each line (in case it's a stand alone line) */
  for (;;) {
    p->backwards.len = (size_t)(p->forwards.buf - p->backwards.buf);
    if (p->forwards.buf >= end)
      break;
    if (FIO_UNLIKELY(*p->forwards.buf == p->delim.in.buf[0] &&
                     p->delim.in.cmp(p->forwards.buf, p->delim.in.buf))) {
      /* tag started */
      p->forwards.buf += p->delim.in.len;
      tag = FIO_BUF_INFO2(p->forwards.buf, 0);
      for (;;) {
        if (p->forwards.buf + p->delim.out.len > end)
          goto incomplete_tag_error;
        if (p->forwards.buf[0] == p->delim.out.buf[0] &&
            p->delim.out.cmp(p->forwards.buf, p->delim.out.buf))
          break;
        ++(p->forwards.buf);
      }
      /* advance tag ending when triple mustache is detected. */
      p->forwards.buf +=
          ((p->forwards.buf + p->delim.out.len) < end &&
           p->forwards.buf[0] == '}' &&
           p->delim.out.cmp(p->forwards.buf + 1, p->delim.out.buf));
      /* finalize tag */
      tag.len = p->forwards.buf - tag.buf;
      if (!tag.len)
        goto empty_tag_error;
      p->forwards.buf += p->delim.out.len;
      p->forwards.len = (size_t)(end - p->forwards.buf);
      p->dirty |= (unsigned)(p->forwards.buf[0] && p->forwards.buf[0] != '\r' &&
                             p->forwards.buf[0] != '\n');
      if (p->dirty && p->backwards.len) { /* not stand-alone, add txt */
        fio___mustache_parse_add_text(p, p->backwards);
        p->backwards = FIO_BUF_INFO2((p->backwards.buf + p->backwards.len), 0);
      }
      if ((r = fio___mustache_parse_consume_tag(p, tag)))
        goto done;
      p->backwards = FIO_BUF_INFO2(p->forwards.buf, 0);
      continue;
    }
    p->dirty = (unsigned)(p->forwards.buf[0] != '\n') &
               (p->dirty | (unsigned)(p->forwards.buf[0] != ' ' &&
                                      p->forwards.buf[0] != '\t'));
    ++p->forwards.buf;
    if (p->backwards.len == ((1 << 16) - 2) || p->forwards.buf[-1] == '\n') {
      p->backwards.len = p->forwards.buf - p->backwards.buf;
      fio___mustache_parse_add_text(p, p->backwards);
      p->backwards.buf = p->forwards.buf;
    }
  }
  /* print leftover text? */
  if (p->backwards.len)
    fio___mustache_parse_add_text(p, p->backwards);

done:
  r += ((r == -2) << 1); /* end-tag stop shouldn't propagate onward. */
  return r;
incomplete_tag_error:
  FIO_LOG_ERROR("(mustache) template error, un-terminated {{tag}}:\n\t%.*s",
                (int)(end - (p->backwards.buf + p->backwards.len) > 32
                          ? (int)32
                          : (int)(end - (p->backwards.buf + p->backwards.len))),
                (p->backwards.buf + p->backwards.len));
  return (r = -1);
empty_tag_error:
  FIO_LOG_ERROR("(mustache) template error, empty {{tag}}:\n\t%.*s",
                (int)(end - (p->backwards.buf + p->backwards.len) > 32
                          ? (int)32
                          : (int)(end - (p->backwards.buf + p->backwards.len))),
                (p->backwards.buf + p->backwards.len));
  return (r = -1);
}

FIO_SFUNC int fio___mustache_parse_template_file(fio___mustache_parser_s *p) {
  /* remove (possible) filename comment line */
  if (p->forwards.buf[0] == '@' && p->forwards.buf[1] == ':') {
    char *pos = (char *)FIO_MEMCHR(p->forwards.buf, '\n', p->forwards.len);
    if (!pos)
      return 0; /* done with file... though nothing happened. */
  }
  /* consume (possible) YAML front matter */
  if (p->forwards.buf[0] == '-' && p->forwards.buf[1] == '-' &&
      p->forwards.buf[2] == '-' &&
      (p->forwards.buf[3] == '\n' || p->forwards.buf[3] == '\r')) {
    const char *end = p->forwards.buf + p->forwards.len;
    const char *pos = p->forwards.buf;
    for (;;) {
      pos = (const char *)FIO_MEMCHR(pos, '\n', end - pos);
      if (!pos)
        return 0; /* done with file... though nothing happened. */
      ++pos;
      if (pos[0] == '-' && pos[1] == '-' && pos[2] == '-' &&
          (pos[3] == '\n' || pos[3] == '\r' || !pos[3])) {
        pos += 4;
        pos += pos[0] == '\n';
        break;
      }
    }
    p->args->on_yaml_front_matter(
        FIO_BUF_INFO2(p->forwards.buf, (size_t)(pos - p->forwards.buf)),
        p->args->udata);
    p->forwards.len = (size_t)(pos - p->forwards.buf);
    p->forwards.buf = (char *)pos;
  }
  return fio___mustache_parse_block(p);
}

/* *****************************************************************************
Default functions
***************************************************************************** */
FIO_SFUNC fio_buf_info_s fio___mustache_dflt_load_file_data(fio_buf_info_s fn,
                                                            void *udata) {
  char *data = fio_bstr_readfile(NULL, fn.buf, 0, 0);
  return fio_bstr_buf(data);
  (void)udata;
}

FIO_SFUNC void fio___mustache_dflt_free_file_data(fio_buf_info_s d,
                                                  void *udata) {
  fio_bstr_free(d.buf);
  (void)udata;
}

FIO_SFUNC void fio___mustache_dflt_on_yaml_front_matter(fio_buf_info_s y,
                                                        void *udata) {
  (void)y, (void)udata;
}

FIO_SFUNC void *fio___mustache_dflt_write_text(void *u, fio_buf_info_s txt) {
  return (void *)fio_bstr_write((char *)u, txt.buf, txt.len);
}

FIO_SFUNC void *fio___mustache_dflt_write_text_escaped(void *u,
                                                       fio_buf_info_s raw) {
  return (void *)fio_bstr_write_html_escape((char *)u, raw.buf, raw.len);
}

/* callback should return a new context pointer with the value of `name`. */
FIO_SFUNC void *fio___mustache_dflt_get_var(void *ctx, fio_buf_info_s name) {
  return NULL;
  (void)ctx, (void)name;
}

/* if context is an Array, should return its length. */
FIO_SFUNC size_t fio___mustache_dflt_array_length(void *ctx) {
  return 0;
  (void)ctx;
}

/* if context is an Array, should return a context pointer @ index. */
FIO_SFUNC void *fio___mustache_dflt_get_var_index(void *ctx, size_t index) {
  return NULL;
  (void)ctx, (void)index;
}
/* should return the String value of context `var` as a `fio_buf_info_s`. */
FIO_SFUNC fio_buf_info_s fio___mustache_dflt_var2str(void *var) {
  return FIO_BUF_INFO2(NULL, 0);
  (void)var;
}

FIO_SFUNC int fio___mustache_dflt_var_is_truthful(void *v) { return !!v; }

FIO_IFUNC void fio___mustache_dflt_release_var(void *ctx) { (void)ctx; }

/* returns non-zero if `ctx` is a lambda and handles section manually. */
FIO_SFUNC int fio___mustache_dflt_is_lambda(
    void **udata,
    void *ctx,
    fio_buf_info_s raw_template_section) {
  return 0;
  (void)raw_template_section, (void)ctx, (void)udata;
}

/* *****************************************************************************
Public API
***************************************************************************** */

void fio_mustache_load___(void); /* IDE Marker */
/* Allocates a new object on the heap and initializes it's memory. */
SFUNC fio_mustache_s *fio_mustache_load FIO_NOOP(fio_mustache_load_args_s a) {
  uint8_t should_free_data = 0;
  fio_buf_info_s base_path = {0};
  fio___mustache_parser_s parser = {0};
  if (!a.load_file_data && !a.free_file_data) {
    a.load_file_data = fio___mustache_dflt_load_file_data;
    a.free_file_data = fio___mustache_dflt_free_file_data;
  }
  if (!a.filename.buf && !a.data.buf)
    return NULL;
  if (!a.on_yaml_front_matter)
    a.on_yaml_front_matter = fio___mustache_dflt_on_yaml_front_matter;
  if (a.filename.buf) {
    fio_filename_s pathname;
    FIO_STR_INFO_TMP_VAR(fn, (PATH_MAX | 2096));
    if (!a.filename.len)
      a.filename.len = FIO_STRLEN(a.filename.buf);
    if (a.filename.buf[a.filename.len])
      fio_string_write(&fn, NULL, a.filename.buf, a.filename.len);
    else
      fn = FIO_BUF2STR_INFO(a.filename);
    if (!a.data.buf && fn.buf) {
      a.data = a.load_file_data(FIO_STR2BUF_INFO(fn), a.udata);
      if (!a.data.buf)
        return NULL;
      should_free_data = 1;
    }
    pathname = fio_filename_parse2(a.filename.buf, a.filename.len);
    base_path = pathname.folder;
  }
  parser.args = &a;
  parser.root = NULL;
  parser.delim = fio___mustache_delimiter_init();
  parser.depth = 0;
  parser.fname = a.filename;
  parser.forwards = a.data;
  parser.path = base_path;
  if (fio___mustache_parse_template_file(&parser)) { /* parser failed(!) */
    fio_bstr_free(parser.root);
    parser.root = NULL;
  }
  /* No need to write FIO___MUSTACHE_I_STACK_POP, as the string ends with NUL */
  if (should_free_data)
    a.free_file_data(a.data, a.udata);
  if (parser.root)
    FIO_LEAK_COUNTER_ON_ALLOC(fio_mustache_s);
  return (fio_mustache_s *)parser.root;
}

/* Frees the mustache template object (or reduces it's reference count). */
SFUNC void fio_mustache_free(fio_mustache_s *m) {
  if (!m)
    return;
  FIO_LEAK_COUNTER_ON_FREE(fio_mustache_s);
  fio_bstr_free((char *)m);
}

/** Increases the mustache template's reference count. */
SFUNC fio_mustache_s *fio_mustache_dup(fio_mustache_s *m) {
  if (!m)
    return m;
  FIO_LEAK_COUNTER_ON_ALLOC(fio_mustache_s);
  return (fio_mustache_s *)fio_bstr_copy((char *)m);
}

void fio_mustache_build___(void); /* IDE marker */
/** Builds the template, returning the final value of `udata` (or NULL). */
SFUNC void *fio_mustache_build FIO_NOOP(fio_mustache_s *m,
                                        fio_mustache_bargs_s args) {
  if (!m)
    return args.udata;
  if (!args.write_text && !args.write_text_escaped) {
    args.write_text = fio___mustache_dflt_write_text;
    args.write_text_escaped = fio___mustache_dflt_write_text_escaped;
  }
  FIO_ASSERT(args.write_text_escaped && args.write_text,
             "(mustache) fio_mustache_build requires both writer "
             "callbacks!\n\t\t(or none, for a fio_bstr_s return)");
  if (!args.get_var)
    args.get_var = fio___mustache_dflt_get_var;
  if (!args.array_length)
    args.array_length = fio___mustache_dflt_array_length;
  if (!args.get_var_index)
    args.get_var_index = fio___mustache_dflt_get_var_index;
  if (!args.var2str)
    args.var2str = fio___mustache_dflt_var2str;
  if (!args.var_is_truthful)
    args.var_is_truthful = fio___mustache_dflt_var_is_truthful;
  if (!args.release_var)
    args.release_var = fio___mustache_dflt_release_var;
  if (!args.is_lambda)
    args.is_lambda = fio___mustache_dflt_is_lambda;

  fio___mustache_bldr_s builder = {
      .root = (char *)m,
      .ctx = args.ctx,
      .args = &args,
  };
  return fio___mustache_build_section((char *)m, builder);
}

/* *****************************************************************************
Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_MODULE_PTR
#undef FIO_MUSTACHE
#undef FIO___UNTAG_T
#endif /* FIO_MUSTACHE */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_CRYPTO_CORE        /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                          Cryptographic Core Module




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_CRYPTO_CORE) && !defined(H___FIO_CRYPTO_CORE___H)
/* *****************************************************************************
**Note**: do NOT use these cryptographic unless you have no other choice. Always
*prefer tested cryptographic libraries such as OpenSSL.
***************************************************************************** */
#define H___FIO_CRYPTO_CORE___H

typedef void(fio_crypto_enc_fn)(void *restrict mac,
                                void *restrict data,
                                size_t len,
                                const void *ad, /* additional data */
                                size_t adlen,
                                const void *key,
                                const void *nonce);
typedef int(fio_crypto_dec_fn)(void *restrict mac,
                               void *restrict data,
                               size_t len,
                               const void *ad, /* additional data */
                               size_t adlen,
                               const void *key,
                               const void *nonce);

/* *****************************************************************************
Module Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_CRYPTO_CORE
#endif /* FIO_CRYPTO_CORE */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_BLAKE2             /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                  BLAKE2
                        BLAKE2b (64-bit) and BLAKE2s (32-bit)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_BLAKE2) && !defined(H___FIO_BLAKE2___H)
#define H___FIO_BLAKE2___H
/* *****************************************************************************
BLAKE2 API
***************************************************************************** */

/** Streaming BLAKE2b type (64-bit, up to 64-byte digest). */
typedef struct {
  uint64_t h[8];    /* state */
  uint64_t t[2];    /* total bytes processed (128-bit counter) */
  uint64_t f[2];    /* finalization flags */
  uint8_t buf[128]; /* input buffer */
  size_t buflen;    /* bytes in buffer */
  size_t outlen;    /* digest length */
} fio_blake2b_s;

/** Streaming BLAKE2s type (32-bit, up to 32-byte digest). */
typedef struct {
  uint32_t h[8];   /* state */
  uint32_t t[2];   /* total bytes processed (64-bit counter) */
  uint32_t f[2];   /* finalization flags */
  uint8_t buf[64]; /* input buffer */
  size_t buflen;   /* bytes in buffer */
  size_t outlen;   /* digest length */
} fio_blake2s_s;

/* *****************************************************************************
BLAKE2b API (64-bit optimized, up to 64-byte digest)
***************************************************************************** */

/**
 * A simple, non-streaming implementation of BLAKE2b.
 *
 * `out` must point to a buffer of at least `outlen` bytes.
 * `outlen` must be between 1 and 64 (default 64 if 0).
 * `key` and `keylen` are optional (set to NULL/0 for unkeyed hashing).
 */
SFUNC void fio_blake2b(void *restrict out,
                       size_t outlen,
                       const void *restrict data,
                       size_t len,
                       const void *restrict key,
                       size_t keylen);

/** Initialize a BLAKE2b streaming context. outlen: 1-64 (default 64). */
SFUNC fio_blake2b_s fio_blake2b_init(size_t outlen,
                                     const void *key,
                                     size_t keylen);

/** Feed data into BLAKE2b hash. */
SFUNC void fio_blake2b_consume(fio_blake2b_s *restrict h,
                               const void *restrict data,
                               size_t len);

/** Finalize BLAKE2b hash. Writes `h->outlen` bytes to `out`. */
SFUNC void fio_blake2b_finalize(fio_blake2b_s *restrict h, void *restrict out);

/* *****************************************************************************
BLAKE2s API (32-bit optimized, up to 32-byte digest)
***************************************************************************** */

/**
 * A simple, non-streaming implementation of BLAKE2s.
 *
 * `out` must point to a buffer of at least `outlen` bytes.
 * `outlen` must be between 1 and 32 (default 32 if 0).
 * `key` and `keylen` are optional (set to NULL/0 for unkeyed hashing).
 */
SFUNC void fio_blake2s(void *restrict out,
                       size_t outlen,
                       const void *restrict data,
                       size_t len,
                       const void *restrict key,
                       size_t keylen);

/** Initialize a BLAKE2s streaming context. outlen: 1-32 (default 32). */
SFUNC fio_blake2s_s fio_blake2s_init(size_t outlen,
                                     const void *key,
                                     size_t keylen);

/** Feed data into BLAKE2s hash. */
SFUNC void fio_blake2s_consume(fio_blake2s_s *restrict h,
                               const void *restrict data,
                               size_t len);

/** Finalize BLAKE2s hash. Writes `h->outlen` bytes to `out`. */
SFUNC void fio_blake2s_finalize(fio_blake2s_s *restrict h, void *restrict out);

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
BLAKE2b Implementation (64-bit)
***************************************************************************** */

/* BLAKE2b initialization vector */
static const uint64_t fio___blake2b_iv[8] = {0x6A09E667F3BCC908ULL,
                                             0xBB67AE8584CAA73BULL,
                                             0x3C6EF372FE94F82BULL,
                                             0xA54FF53A5F1D36F1ULL,
                                             0x510E527FADE682D1ULL,
                                             0x9B05688C2B3E6C1FULL,
                                             0x1F83D9ABFB41BD6BULL,
                                             0x5BE0CD19137E2179ULL};

/* BLAKE2b sigma permutation table */
static const uint8_t fio___blake2b_sigma[12][16] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
    {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
    {7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
    {9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
    {2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
    {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
    {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
    {6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
    {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0},
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3}};

/* BLAKE2b G mixing function */
#define FIO___BLAKE2B_G(r, i, a, b, c, d, m)                                   \
  do {                                                                         \
    (a) += (b) + m[fio___blake2b_sigma[r][2 * (i)]];                           \
    (d) = fio_rrot64((d) ^ (a), 32);                                           \
    (c) += (d);                                                                \
    (b) = fio_rrot64((b) ^ (c), 24);                                           \
    (a) += (b) + m[fio___blake2b_sigma[r][2 * (i) + 1]];                       \
    (d) = fio_rrot64((d) ^ (a), 16);                                           \
    (c) += (d);                                                                \
    (b) = fio_rrot64((b) ^ (c), 63);                                           \
  } while (0)

/* BLAKE2b round function */
#define FIO___BLAKE2B_ROUND(r, v, m)                                           \
  do {                                                                         \
    FIO___BLAKE2B_G(r, 0, v[0], v[4], v[8], v[12], m);                         \
    FIO___BLAKE2B_G(r, 1, v[1], v[5], v[9], v[13], m);                         \
    FIO___BLAKE2B_G(r, 2, v[2], v[6], v[10], v[14], m);                        \
    FIO___BLAKE2B_G(r, 3, v[3], v[7], v[11], v[15], m);                        \
    FIO___BLAKE2B_G(r, 4, v[0], v[5], v[10], v[15], m);                        \
    FIO___BLAKE2B_G(r, 5, v[1], v[6], v[11], v[12], m);                        \
    FIO___BLAKE2B_G(r, 6, v[2], v[7], v[8], v[13], m);                         \
    FIO___BLAKE2B_G(r, 7, v[3], v[4], v[9], v[14], m);                         \
  } while (0)

/* BLAKE2b compression function */
FIO_IFUNC void fio___blake2b_compress(fio_blake2b_s *restrict h,
                                      const uint8_t *restrict block,
                                      int is_last) {
  uint64_t v[16] FIO_ALIGN(64);
  uint64_t m[16] FIO_ALIGN(64);

  /* Initialize working vector */
  for (size_t i = 0; i < 8; ++i) {
    v[i] = h->h[i];
    v[i + 8] = fio___blake2b_iv[i];
  }
  v[12] ^= h->t[0];
  v[13] ^= h->t[1];
  if (is_last)
    v[14] = ~v[14]; /* Invert finalization flag */

  /* Load message block (little-endian) */
  for (size_t i = 0; i < 16; ++i)
    m[i] = fio_buf2u64_le(block + i * 8);

  /* 12 rounds of mixing */
  FIO___BLAKE2B_ROUND(0, v, m);
  FIO___BLAKE2B_ROUND(1, v, m);
  FIO___BLAKE2B_ROUND(2, v, m);
  FIO___BLAKE2B_ROUND(3, v, m);
  FIO___BLAKE2B_ROUND(4, v, m);
  FIO___BLAKE2B_ROUND(5, v, m);
  FIO___BLAKE2B_ROUND(6, v, m);
  FIO___BLAKE2B_ROUND(7, v, m);
  FIO___BLAKE2B_ROUND(8, v, m);
  FIO___BLAKE2B_ROUND(9, v, m);
  FIO___BLAKE2B_ROUND(10, v, m);
  FIO___BLAKE2B_ROUND(11, v, m);

  /* Finalize state */
  for (size_t i = 0; i < 8; ++i)
    h->h[i] ^= v[i] ^ v[i + 8];
}

#undef FIO___BLAKE2B_G
#undef FIO___BLAKE2B_ROUND

/** Initialize a BLAKE2b streaming context. */
SFUNC fio_blake2b_s fio_blake2b_init(size_t outlen,
                                     const void *key,
                                     size_t keylen) {
  fio_blake2b_s h = {0};

  /* Validate parameters */
  if (outlen == 0)
    outlen = 64;
  if (outlen > 64)
    outlen = 64;
  if (keylen > 64)
    keylen = 64;

  h.outlen = outlen;

  /* Initialize state with IV */
  for (size_t i = 0; i < 8; ++i)
    h.h[i] = fio___blake2b_iv[i];

  /* XOR parameter block into state[0] */
  /* Parameter block: fanout=1, depth=1, leaf_len=0, node_offset=0,
   * node_depth=0, inner_len=0, reserved=0, salt=0, personal=0 */
  h.h[0] ^= 0x01010000ULL ^ ((uint64_t)keylen << 8) ^ (uint64_t)outlen;

  /* If keyed, pad key to 128 bytes and process as first block */
  if (keylen > 0 && key) {
    FIO_MEMSET(h.buf, 0, 128);
    FIO_MEMCPY(h.buf, key, keylen);
    h.buflen = 128;
  }

  return h;
}

/** Feed data into BLAKE2b hash. */
SFUNC void fio_blake2b_consume(fio_blake2b_s *restrict h,
                               const void *restrict data,
                               size_t len) {
  const uint8_t *p = (const uint8_t *)data;

  /* If we have buffered data, try to complete a block */
  if (h->buflen > 0) {
    size_t fill = 128 - h->buflen;
    if (len < fill) {
      FIO_MEMCPY(h->buf + h->buflen, p, len);
      h->buflen += len;
      return;
    }
    FIO_MEMCPY(h->buf + h->buflen, p, fill);
    h->t[0] += 128;
    if (h->t[0] < 128)
      h->t[1]++; /* Overflow */
    fio___blake2b_compress(h, h->buf, 0);
    h->buflen = 0;
    p += fill;
    len -= fill;
  }

  /* Process full blocks */
  while (len > 128) {
    h->t[0] += 128;
    if (h->t[0] < 128)
      h->t[1]++;
    fio___blake2b_compress(h, p, 0);
    p += 128;
    len -= 128;
  }

  /* Buffer remaining data */
  if (len > 0) {
    FIO_MEMCPY(h->buf, p, len);
    h->buflen = len;
  }
}

/** Finalize BLAKE2b hash. */
SFUNC void fio_blake2b_finalize(fio_blake2b_s *restrict h, void *restrict out) {
  /* Update counter with remaining bytes */
  h->t[0] += h->buflen;
  if (h->t[0] < h->buflen)
    h->t[1]++;

  /* Pad remaining buffer with zeros */
  if (h->buflen < 128)
    FIO_MEMSET(h->buf + h->buflen, 0, 128 - h->buflen);

  /* Final compression */
  fio___blake2b_compress(h, h->buf, 1);

  /* Output hash (little-endian) */
  uint8_t *o = (uint8_t *)out;
  for (size_t i = 0; i < h->outlen; ++i)
    o[i] = (uint8_t)(h->h[i / 8] >> (8 * (i % 8)));
}

/** Simple non-streaming BLAKE2b. */
SFUNC void fio_blake2b(void *restrict out,
                       size_t outlen,
                       const void *restrict data,
                       size_t len,
                       const void *restrict key,
                       size_t keylen) {
  fio_blake2b_s h = fio_blake2b_init(outlen, key, keylen);
  fio_blake2b_consume(&h, data, len);
  fio_blake2b_finalize(&h, out);
}

/* *****************************************************************************
BLAKE2s Implementation (32-bit)
***************************************************************************** */

/* BLAKE2s initialization vector */
static const uint32_t fio___blake2s_iv[8] = {0x6A09E667UL,
                                             0xBB67AE85UL,
                                             0x3C6EF372UL,
                                             0xA54FF53AUL,
                                             0x510E527FUL,
                                             0x9B05688CUL,
                                             0x1F83D9ABUL,
                                             0x5BE0CD19UL};

/* BLAKE2s sigma permutation table (same as BLAKE2b) */
static const uint8_t fio___blake2s_sigma[10][16] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
    {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
    {7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
    {9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
    {2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
    {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
    {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
    {6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
    {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0}};

/* BLAKE2s G mixing function */
#define FIO___BLAKE2S_G(r, i, a, b, c, d, m)                                   \
  do {                                                                         \
    (a) += (b) + m[fio___blake2s_sigma[r][2 * (i)]];                           \
    (d) = fio_rrot32((d) ^ (a), 16);                                           \
    (c) += (d);                                                                \
    (b) = fio_rrot32((b) ^ (c), 12);                                           \
    (a) += (b) + m[fio___blake2s_sigma[r][2 * (i) + 1]];                       \
    (d) = fio_rrot32((d) ^ (a), 8);                                            \
    (c) += (d);                                                                \
    (b) = fio_rrot32((b) ^ (c), 7);                                            \
  } while (0)

/* BLAKE2s round function */
#define FIO___BLAKE2S_ROUND(r, v, m)                                           \
  do {                                                                         \
    FIO___BLAKE2S_G(r, 0, v[0], v[4], v[8], v[12], m);                         \
    FIO___BLAKE2S_G(r, 1, v[1], v[5], v[9], v[13], m);                         \
    FIO___BLAKE2S_G(r, 2, v[2], v[6], v[10], v[14], m);                        \
    FIO___BLAKE2S_G(r, 3, v[3], v[7], v[11], v[15], m);                        \
    FIO___BLAKE2S_G(r, 4, v[0], v[5], v[10], v[15], m);                        \
    FIO___BLAKE2S_G(r, 5, v[1], v[6], v[11], v[12], m);                        \
    FIO___BLAKE2S_G(r, 6, v[2], v[7], v[8], v[13], m);                         \
    FIO___BLAKE2S_G(r, 7, v[3], v[4], v[9], v[14], m);                         \
  } while (0)

/* BLAKE2s compression function */
FIO_IFUNC void fio___blake2s_compress(fio_blake2s_s *restrict h,
                                      const uint8_t *restrict block,
                                      int is_last) {
  uint32_t v[16] FIO_ALIGN(64);
  uint32_t m[16] FIO_ALIGN(64);

  /* Initialize working vector */
  for (size_t i = 0; i < 8; ++i) {
    v[i] = h->h[i];
    v[i + 8] = fio___blake2s_iv[i];
  }
  v[12] ^= h->t[0];
  v[13] ^= h->t[1];
  if (is_last)
    v[14] = ~v[14];

  /* Load message block (little-endian) */
  for (size_t i = 0; i < 16; ++i)
    m[i] = fio_buf2u32_le(block + i * 4);

  /* 10 rounds of mixing */
  FIO___BLAKE2S_ROUND(0, v, m);
  FIO___BLAKE2S_ROUND(1, v, m);
  FIO___BLAKE2S_ROUND(2, v, m);
  FIO___BLAKE2S_ROUND(3, v, m);
  FIO___BLAKE2S_ROUND(4, v, m);
  FIO___BLAKE2S_ROUND(5, v, m);
  FIO___BLAKE2S_ROUND(6, v, m);
  FIO___BLAKE2S_ROUND(7, v, m);
  FIO___BLAKE2S_ROUND(8, v, m);
  FIO___BLAKE2S_ROUND(9, v, m);

  /* Finalize state */
  for (size_t i = 0; i < 8; ++i)
    h->h[i] ^= v[i] ^ v[i + 8];
}

#undef FIO___BLAKE2S_G
#undef FIO___BLAKE2S_ROUND

/** Initialize a BLAKE2s streaming context. */
SFUNC fio_blake2s_s fio_blake2s_init(size_t outlen,
                                     const void *key,
                                     size_t keylen) {
  fio_blake2s_s h = {0};

  /* Validate parameters */
  if (outlen == 0)
    outlen = 32;
  if (outlen > 32)
    outlen = 32;
  if (keylen > 32)
    keylen = 32;

  h.outlen = outlen;

  /* Initialize state with IV */
  for (size_t i = 0; i < 8; ++i)
    h.h[i] = fio___blake2s_iv[i];

  /* XOR parameter block into state[0] */
  h.h[0] ^= 0x01010000UL ^ ((uint32_t)keylen << 8) ^ (uint32_t)outlen;

  /* If keyed, pad key to 64 bytes and process as first block */
  if (keylen > 0 && key) {
    FIO_MEMSET(h.buf, 0, 64);
    FIO_MEMCPY(h.buf, key, keylen);
    h.buflen = 64;
  }

  return h;
}

/** Feed data into BLAKE2s hash. */
SFUNC void fio_blake2s_consume(fio_blake2s_s *restrict h,
                               const void *restrict data,
                               size_t len) {
  const uint8_t *p = (const uint8_t *)data;

  /* If we have buffered data, try to complete a block */
  if (h->buflen > 0) {
    size_t fill = 64 - h->buflen;
    if (len < fill) {
      FIO_MEMCPY(h->buf + h->buflen, p, len);
      h->buflen += len;
      return;
    }
    FIO_MEMCPY(h->buf + h->buflen, p, fill);
    h->t[0] += 64;
    if (h->t[0] < 64)
      h->t[1]++;
    fio___blake2s_compress(h, h->buf, 0);
    h->buflen = 0;
    p += fill;
    len -= fill;
  }

  /* Process full blocks */
  while (len > 64) {
    h->t[0] += 64;
    if (h->t[0] < 64)
      h->t[1]++;
    fio___blake2s_compress(h, p, 0);
    p += 64;
    len -= 64;
  }

  /* Buffer remaining data */
  if (len > 0) {
    FIO_MEMCPY(h->buf, p, len);
    h->buflen = len;
  }
}

/** Finalize BLAKE2s hash. */
SFUNC void fio_blake2s_finalize(fio_blake2s_s *restrict h, void *restrict out) {
  /* Update counter with remaining bytes */
  h->t[0] += (uint32_t)h->buflen;
  if (h->t[0] < h->buflen)
    h->t[1]++;

  /* Pad remaining buffer with zeros */
  if (h->buflen < 64)
    FIO_MEMSET(h->buf + h->buflen, 0, 64 - h->buflen);

  /* Final compression */
  fio___blake2s_compress(h, h->buf, 1);

  /* Output hash (little-endian) */
  uint8_t *o = (uint8_t *)out;
  for (size_t i = 0; i < h->outlen; ++i)
    o[i] = (uint8_t)(h->h[i / 4] >> (8 * (i % 4)));
}

/** Simple non-streaming BLAKE2s. */
SFUNC void fio_blake2s(void *restrict out,
                       size_t outlen,
                       const void *restrict data,
                       size_t len,
                       const void *restrict key,
                       size_t keylen) {
  fio_blake2s_s h = fio_blake2s_init(outlen, key, keylen);
  fio_blake2s_consume(&h, data, len);
  fio_blake2s_finalize(&h, out);
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_BLAKE2 */
#undef FIO_BLAKE2
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_CHACHA             /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                              ChaCha20 & Poly1305



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_CHACHA) && !defined(H___FIO_CHACHA___H)
#define H___FIO_CHACHA___H 1

/* *****************************************************************************
ChaCha20Poly1305 API
***************************************************************************** */

/**
 * Performs an in-place encryption of `data` using ChaCha20 with additional
 * data, producing a 16 byte message authentication code (MAC) using Poly1305.
 *
 * * `key`    MUST point to a 256 bit long memory address (32 Bytes).
 * * `nonce` MUST point to a  96 bit long memory address (12 Bytes).
 * * `ad`     MAY be omitted, will NOT be encrypted.
 * * `data`   MAY be omitted, WILL be encrypted.
 * * `mac`    MUST point to a buffer with (at least) 16 available bytes.
 */
SFUNC void fio_chacha20_poly1305_enc(void *restrict mac,
                                     void *restrict data,
                                     size_t len,
                                     const void *ad, /* additional data */
                                     size_t adlen,
                                     const void *key,
                                     const void *nonce);

/**
 * Performs an in-place decryption of `data` using ChaCha20 after authenticating
 * the message authentication code (MAC) using Poly1305.
 *
 * * `key`    MUST point to a 256 bit long memory address (32 Bytes).
 * * `nonce` MUST point to a  96 bit long memory address (12 Bytes).
 * * `ad`     MAY be omitted ONLY IF originally omitted.
 * * `data`   MAY be omitted, WILL be decrypted.
 * * `mac`    MUST point to a buffer where the 16 byte MAC is placed.
 *
 * Returns `-1` on error (authentication failed).
 */
SFUNC int fio_chacha20_poly1305_dec(void *restrict mac,
                                    void *restrict data,
                                    size_t len,
                                    const void *ad, /* additional data */
                                    size_t adlen,
                                    const void *key,
                                    const void *nonce);

/* *****************************************************************************
Using ChaCha20 and Poly1305 separately
***************************************************************************** */

/**
 * Performs an in-place encryption/decryption of `data` using ChaCha20.
 *
 * * `key`    MUST point to a 256 bit long memory address (32 Bytes).
 * * `nonce` MUST point to a  96 bit long memory address (12 Bytes).
 * * `counter` is the block counter, usually 1 unless `data` is mid-cyphertext.
 */
SFUNC void fio_chacha20(void *restrict data,
                        size_t len,
                        const void *key,
                        const void *nonce,
                        uint32_t counter);

/**
 * Given a Poly1305 256bit (32 byte) key, writes the authentication code for the
 * poly message and additional data into `mac_dest`.
 *
 * * `mac_dest` MUST point to a buffer with (at least) 16 available bytes.
 * * `message`  MAY be omitted.
 * * `ad`       MAY be omitted (additional data).
 * * `key`      MUST point to a 256 bit long memory address (32 Bytes).
 */
SFUNC void fio_poly1305_auth(void *restrict mac_dest,
                             void *restrict message,
                             size_t len,
                             const void *ad,
                             size_t ad_len,
                             const void *key256bits);

/* *****************************************************************************
ChaCha20Poly1305 Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Poly1305 (authentication)
Prime 2^130-5   = 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB
The math is mostly copied from: https://github.com/floodyberry/poly1305-donna
***************************************************************************** */
/*
 * Math copied from https://github.com/floodyberry/poly1305-donna
 *
 * With thanks to Andrew Moon.
 */
typedef struct {
  /* r (cycle key addition) is 128 bits */
  uint64_t r[3];
  /* s (final key addition) is 128 bits */
  uint64_t s[2];
  /* Accumulator should not exceed 131 bits at the end of every cycle. */
  uint64_t a[3];
} FIO_ALIGN(16) fio___poly_s;

FIO_IFUNC fio___poly_s fio___poly_init(const void *key256b) {
  static const uint64_t defkey[4] = {0};
  if (!key256b)
    key256b = (const void *)defkey;
  uint64_t t0, t1;
  /* r &= 0xffffffc0ffffffc0ffffffc0fffffff */
  t0 = fio_buf2u64_le((uint8_t *)key256b + 0);
  t1 = fio_buf2u64_le((uint8_t *)key256b + 8);
  fio___poly_s pl = {
      .r =
          {
              ((t0)&0xffc0fffffff),
              (((t0 >> 44) | (t1 << 20)) & 0xfffffc0ffff),
              (((t1 >> 24)) & 0x00ffffffc0f),
          },
      .s =
          {
              fio_buf2u64_le(((uint8_t *)key256b + 16)),
              fio_buf2u64_le(((uint8_t *)key256b + 24)),
          },
  };
  return pl;
}
FIO_IFUNC void fio___poly_consume128bit(fio___poly_s *pl,
                                        const void *msg,
                                        uint64_t is_full) {
  uint64_t r0, r1, r2;
  uint64_t s1, s2;
  uint64_t a0, a1, a2;
  uint64_t c;
  uint64_t d0[2], d1[2], d2[2], d[2];

  r0 = pl->r[0];
  r1 = pl->r[1];
  r2 = pl->r[2];

  a0 = pl->a[0];
  a1 = pl->a[1];
  a2 = pl->a[2];

  s1 = r1 * (5 << 2);
  s2 = r2 * (5 << 2);

  {
    uint64_t t0, t1;
    t0 = fio_buf2u64_le(msg);
    t1 = fio_buf2u64_le(((uint8_t *)msg + 8));
    /* a += msg */
    a0 += ((t0)&0xFFFFFFFFFFF);
    a1 += (((t0 >> 44) | (t1 << 20)) & 0xFFFFFFFFFFF);
    a2 += (((t1 >> 24)) & 0x3FFFFFFFFFF) | (is_full << 40);
  }

  /* a *= r */
  d0[0] = fio_math_mulc64(a0, r0, d0 + 1);
  d[0] = fio_math_mulc64(a1, s2, d + 1);
  d0[0] = fio_math_addc64(d0[0], d[0], 0, &c);
  d0[1] += d[1] + c;

  d[0] = fio_math_mulc64(a2, s1, d + 1);
  d0[0] = fio_math_addc64(d0[0], d[0], 0, &c);
  d0[1] += d[1] + c;

  d1[0] = fio_math_mulc64(a0, r1, d1 + 1);
  d[0] = fio_math_mulc64(a1, r0, d + 1);
  d1[0] = fio_math_addc64(d1[0], d[0], 0, &c);
  d1[1] += d[1] + c;

  d[0] = fio_math_mulc64(a2, s2, d + 1);
  d1[0] = fio_math_addc64(d1[0], d[0], 0, &c);
  d1[1] += d[1] + c;

  d2[0] = fio_math_mulc64(a0, r2, d2 + 1);
  d[0] = fio_math_mulc64(a1, r1, d + 1);
  d2[0] = fio_math_addc64(d2[0], d[0], 0, &c);
  d2[1] += d[1] + c;

  d[0] = fio_math_mulc64(a2, r0, d + 1);
  d2[0] = fio_math_addc64(d2[0], d[0], 0, &c);
  d2[1] += d[1] + c;

  /* (partial) a %= p */
  c = (d0[0] >> 44) | (d0[1] << 20);
  a0 = d0[0] & 0xfffffffffff;
  d1[0] = fio_math_addc64(d1[0], c, 0, &c);
  d1[1] += c;

  c = (d1[0] >> 44) | (d1[1] << 20);
  a1 = d1[0] & 0xfffffffffff;
  d2[0] = fio_math_addc64(d2[0], c, 0, &c);
  d2[1] += c;

  c = (d2[0] >> 42) | (d2[1] << 22);
  a2 = d2[0] & 0x3ffffffffff;
  a0 += c * 5;
  c = a0 >> 44;
  a0 = a0 & 0xfffffffffff;
  a1 += c;

  pl->a[0] = a0;
  pl->a[1] = a1;
  pl->a[2] = a2;
}

FIO_IFUNC void fio___poly_finilize(fio___poly_s *pl) {
  uint64_t a0, a1, a2, c;
  uint64_t g0, g1, g2;
  uint64_t t0, t1;

  /* fully carry a */
  a0 = pl->a[0];
  a1 = pl->a[1];
  a2 = pl->a[2];

  c = (a1 >> 44);
  a1 &= 0xFFFFFFFFFFF;
  a2 += c;
  c = (a2 >> 42);
  a2 &= 0x3FFFFFFFFFF;
  a0 += c * 5;
  c = (a0 >> 44);
  a0 &= 0xFFFFFFFFFFF;
  a1 += c;
  c = (a1 >> 44);
  a1 &= 0xFFFFFFFFFFF;
  a2 += c;
  c = (a2 >> 42);
  a2 &= 0x3FFFFFFFFFF;
  a0 += c * 5;
  c = (a0 >> 44);
  a0 &= 0xFFFFFFFFFFF;
  a1 += c;

  /* compute a + -p */
  g0 = a0 + 5;
  c = (g0 >> 44);
  g0 &= 0xFFFFFFFFFFF;
  g1 = a1 + c;
  c = (g1 >> 44);
  g1 &= 0xFFFFFFFFFFF;
  g2 = a2 + c - ((uint64_t)1 << 42);

  /* select h if h < p, or h + -p if h >= p */
  c = (g2 >> ((sizeof(uint64_t) * 8) - 1)) - 1;
  g0 &= c;
  g1 &= c;
  g2 &= c;
  c = ~c;
  a0 = (a0 & c) | g0;
  a1 = (a1 & c) | g1;
  a2 = (a2 & c) | g2;

  /* a = (a + Poly S key) */
  t0 = pl->s[0];
  t1 = pl->s[1];

  a0 += ((t0)&0xFFFFFFFFFFF);
  c = (a0 >> 44);
  a0 &= 0xFFFFFFFFFFF;
  a1 += (((t0 >> 44) | (t1 << 20)) & 0xFFFFFFFFFFF) + c;
  c = (a1 >> 44);
  a1 &= 0xFFFFFFFFFFF;
  a2 += (((t1 >> 24)) & 0x3FFFFFFFFFF) + c;
  a2 &= 0x3FFFFFFFFFF;

  /* mac = a % (2^128) */
  a0 = ((a0) | (a1 << 44));
  a1 = ((a1 >> 20) | (a2 << 24));
  pl->a[0] = a0;
  pl->a[1] = a1;
}

FIO_IFUNC void fio___poly_consume_msg(fio___poly_s *pl,
                                      uint8_t *msg,
                                      size_t len) {
  /* read 16 byte blocks */
  uint64_t n[2];
  for (size_t i = 31; i < len; i += 32) {
    fio___poly_consume128bit(pl, msg, 1);
    fio___poly_consume128bit(pl, msg + 16, 1);
    msg += 32;
  }
  if ((len & 16)) {
    fio___poly_consume128bit(pl, msg, 1);
    msg += 16;
  }
  if ((len & 15)) {
    n[0] = 0;
    n[1] = 0;
    fio_memcpy15x(n, msg, len);
    n[0] = fio_ltole64(n[0]);
    n[1] = fio_ltole64(n[1]);
    ((uint8_t *)n)[len & 15] = 0x01;
    fio___poly_consume128bit(pl, (void *)n, 0);
  }
}

/* Given a Poly1305 key, writes a MAC into `mac_dest`. */
SFUNC void fio_poly1305_auth(void *restrict mac,
                             void *restrict msg,
                             size_t len,
                             const void *ad,
                             size_t ad_len,
                             const void *key) {
  fio___poly_s pl = fio___poly_init(key);
  fio___poly_consume_msg(&pl, (uint8_t *)ad, ad_len);
  fio___poly_consume_msg(&pl, (uint8_t *)msg, len);
  fio___poly_finilize(&pl);
  fio_u2buf64_le(mac, pl.a[0]);
  fio_u2buf64_le(&((char *)mac)[8], pl.a[1]);
  fio_secure_zero(&pl, sizeof(pl));
}

/* *****************************************************************************
ChaCha20 (encryption)
***************************************************************************** */

#define FIO___CHACHA_VROUND(count, a, b, c, d)                                 \
  for (size_t i = 0; i < count; ++i) {                                         \
    a[i] += b[i];                                                              \
    d[i] ^= a[i];                                                              \
    d[i] = fio_lrot32(d[i], 16);                                               \
    c[i] += d[i];                                                              \
    b[i] ^= c[i];                                                              \
    b[i] = fio_lrot32(b[i], 12);                                               \
    a[i] += b[i];                                                              \
    d[i] ^= a[i];                                                              \
    d[i] = fio_lrot32(d[i], 8);                                                \
    c[i] += d[i];                                                              \
    b[i] ^= c[i];                                                              \
    b[i] = fio_lrot32(b[i], 7);                                                \
  }

FIO_IFUNC fio_u512 fio___chacha_init(const void *key,
                                     const void *nonce,
                                     uint32_t counter) {
  fio_u512 o = {
      .u32 =
          {
              // clang-format off
              0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,
              fio_buf2u32_le(key),
              fio_buf2u32_le((uint8_t *)key + 4),
              fio_buf2u32_le((uint8_t *)key + 8),
              fio_buf2u32_le((uint8_t *)key + 12),
              fio_buf2u32_le((uint8_t *)key + 16),
              fio_buf2u32_le((uint8_t *)key + 20),
              fio_buf2u32_le((uint8_t *)key + 24),
              fio_buf2u32_le((uint8_t *)key + 28),
              counter,
              fio_buf2u32_le(nonce),
              fio_buf2u32_le((uint8_t *)nonce + 4),
              fio_buf2u32_le((uint8_t *)nonce + 8),
          }, // clang-format on
  };
  return o;
}

FIO_SFUNC void fio___chacha_vround20(const fio_u512 c, uint8_t *restrict data) {
  uint32_t v[16];
  for (size_t i = 0; i < 16; ++i) {
    v[i] = c.u32[i];
  }
  for (size_t round__ = 0; round__ < 10; ++round__) { /* 2 rounds per loop */
    FIO___CHACHA_VROUND(4, v, (v + 4), (v + 8), (v + 12));
    fio_u32x4_reshuffle((v + 4), 1, 2, 3, 0);
    fio_u32x4_reshuffle((v + 8), 2, 3, 0, 1);
    fio_u32x4_reshuffle((v + 12), 3, 0, 1, 2);
    FIO___CHACHA_VROUND(4, v, (v + 4), (v + 8), (v + 12));
    fio_u32x4_reshuffle((v + 4), 3, 0, 1, 2);
    fio_u32x4_reshuffle((v + 8), 2, 3, 0, 1);
    fio_u32x4_reshuffle((v + 12), 1, 2, 3, 0);
  }
  for (size_t i = 0; i < 16; ++i) {
    v[i] += c.u32[i];
  }

#if __BIG_ENDIAN__
  for (size_t i = 0; i < 16; ++i) {
    v[i] = fio_bswap32(v[i]);
  }
#endif
  {
    uint32_t d[16];
    fio_memcpy64(d, data);
    for (size_t i = 0; i < 16; ++i) {
      d[i] ^= v[i];
    }
    fio_memcpy64(data, d);
  }
}

FIO_SFUNC void fio___chacha_vround20x2(fio_u512 c, uint8_t *restrict data) {
  uint32_t v[32];
  for (size_t i = 0; i < 16; ++i) {
    v[i + (i & (4 | 8))] = c.u32[i];
    v[i + 4 + (i & (4 | 8))] = c.u32[i];
  }
  ++v[28];
  for (size_t round__ = 0; round__ < 10; ++round__) { /* 2 rounds per loop */
    FIO___CHACHA_VROUND(8, v, (v + 8), (v + 16), (v + 24));
    fio_u32x8_reshuffle((v + 8), 1, 2, 3, 0, 5, 6, 7, 4);
    fio_u32x8_reshuffle((v + 16), 2, 3, 0, 1, 6, 7, 4, 5);
    fio_u32x8_reshuffle((v + 24), 3, 0, 1, 2, 7, 4, 5, 6);
    FIO___CHACHA_VROUND(8, v, (v + 8), (v + 16), (v + 24));
    fio_u32x8_reshuffle((v + 8), 3, 0, 1, 2, 7, 4, 5, 6);
    fio_u32x8_reshuffle((v + 16), 2, 3, 0, 1, 6, 7, 4, 5);
    fio_u32x8_reshuffle((v + 24), 1, 2, 3, 0, 5, 6, 7, 4);
  }
  for (size_t i = 0; i < 16; ++i) {
    v[i + (i & (4 | 8))] += c.u32[i];
    v[i + 4 + (i & (4 | 8))] += c.u32[i];
  }
  ++v[28];

#if __BIG_ENDIAN__
  for (size_t i = 0; i < 32; ++i) {
    v[i] = fio_bswap32(v[i]);
  }
#endif
  {
    fio_u32x8_reshuffle((v + 4), 4, 5, 6, 7, 0, 1, 2, 3);
    fio_u32x8_reshuffle((v + 20), 4, 5, 6, 7, 0, 1, 2, 3);
    uint32_t d[8];
    fio_memcpy32(d, data);
    for (size_t i = 0; i < 8; ++i) {
      d[i] ^= v[i];
    }
    fio_memcpy32(data, d);

    fio_memcpy32(d, data + 32);
    for (size_t i = 0; i < 8; ++i) {
      d[i] ^= v[16 + i];
    }
    fio_memcpy32(data + 32, d);

    fio_memcpy32(d, data + 64);
    for (size_t i = 0; i < 8; ++i) {
      d[i] ^= v[8 + i];
    }
    fio_memcpy32(data + 64, d);

    fio_memcpy32(d, data + 96);
    for (size_t i = 0; i < 8; ++i) {
      d[i] ^= v[24 + i];
    }
    fio_memcpy32(data + 96, d);
  }
}

SFUNC void fio_chacha20(void *restrict data,
                        size_t len,
                        const void *key,
                        const void *nonce,
                        uint32_t counter) {
  fio_u512 c = fio___chacha_init(key, nonce, counter);
  for (size_t pos = 127; pos < len; pos += 128) {
    fio___chacha_vround20x2(c, (uint8_t *)data);
    c.u32[12] += 2; /* block counter */
    data = (void *)((uint8_t *)data + 128);
  }
  if ((len & 64)) {
    fio___chacha_vround20(c, (uint8_t *)data);
    data = (void *)((uint8_t *)data + 64);
    ++c.u32[12];
  }
  if ((len & 63)) {
    fio_u512 dest; /* no need to initialize, junk data disregarded. */
    fio_memcpy63x(dest.u64, data, len);
    fio___chacha_vround20(c, dest.u8);
    fio_memcpy63x(data, dest.u64, len);
  }
}

/* *****************************************************************************
ChaCha20Poly1305 Encryption with Authentication
***************************************************************************** */

FIO_IFUNC fio_u512 fio___chacha20_mixround(fio_u512 c) {
  fio_u512 k = {.u64 = {0}};
  fio___chacha_vround20(c, k.u8);
  return k;
}
SFUNC void fio_chacha20_poly1305_enc(void *restrict mac,
                                     void *restrict data,
                                     size_t len,
                                     const void *ad, /* additional data */
                                     size_t adlen,
                                     const void *key,
                                     const void *nonce) {
  fio_u512 c = fio___chacha_init(key, nonce, 0);
  fio___poly_s pl;
  {
    fio_u512 c2 = fio___chacha20_mixround(c);
    pl = fio___poly_init(&c2);
  }
  ++c.u32[12]; /* block counter */
  for (size_t i = 31; i < adlen; i += 32) {
    fio___poly_consume128bit(&pl, (uint8_t *)ad, 1);
    fio___poly_consume128bit(&pl, (uint8_t *)ad + 16, 1);
    ad = (void *)((uint8_t *)ad + 32);
  }
  if (adlen & 16) {
    fio___poly_consume128bit(&pl, (uint8_t *)ad, 1);
    ad = (void *)((uint8_t *)ad + 16);
  }
  if (adlen & 15) {
    uint64_t tmp[2] = {0}; /* 16 byte pad */
    fio_memcpy15x(tmp, ad, adlen);
    fio___poly_consume128bit(&pl, (uint8_t *)tmp, 1);
  }
  for (size_t i = 127; i < len; i += 128) {
    fio___chacha_vround20x2(c, (uint8_t *)data);
    fio___poly_consume128bit(&pl, data, 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 16), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 32), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 48), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 64), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 80), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 96), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 112), 1);
    c.u32[12] += 2; /* block counter */
    data = (void *)((uint8_t *)data + 128);
  }
  if ((len & 64)) {
    fio___chacha_vround20(c, (uint8_t *)data);
    fio___poly_consume128bit(&pl, data, 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 16), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 32), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 48), 1);
    ++c.u32[12]; /* block counter */
    data = (void *)((uint8_t *)data + 64);
  }
  if ((len & 63)) {
    fio_u512 dest;
    fio_memcpy63x(dest.u8, data, len);
    fio___chacha_vround20(c, dest.u8);
    fio_memcpy63x(data, dest.u8, len);
    uint8_t *p = dest.u8;
    if ((len & 32)) {
      fio___poly_consume128bit(&pl, p, 1);
      fio___poly_consume128bit(&pl, (p + 16), 1);
      p += 32;
    }
    if ((len & 16)) {
      fio___poly_consume128bit(&pl, p, 1);
      p += 16;
    }
    if ((len & 15)) {
      /* zero out poly padding */
      for (size_t i = (len & 15UL); i < 16; i++)
        p[i] = 0;
      fio___poly_consume128bit(&pl, p, 1);
    }
  }
  {
    uint64_t mac_data[2] = {fio_ltole64(adlen), fio_ltole64(len)};
    fio___poly_consume128bit(&pl, (uint8_t *)mac_data, 1);
  }
  fio___poly_finilize(&pl);
  fio_u2buf64_le(mac, pl.a[0]);
  fio_u2buf64_le(&((char *)mac)[8], pl.a[1]);
  fio_secure_zero(&pl, sizeof(pl));
}

SFUNC void fio_chacha20_poly1305_auth(void *restrict mac,
                                      void *restrict data,
                                      size_t len,
                                      const void *ad, /* additional data */
                                      size_t adlen,
                                      const void *key,
                                      const void *nonce) {
  fio___poly_s pl;
  {
    fio_u512 c = fio___chacha_init(key, nonce, 0);
    c = fio___chacha20_mixround(c); /* computes poly1305 key */
    pl = fio___poly_init(&c);
  }
  for (size_t i = 31; i < adlen; i += 32) {
    fio___poly_consume128bit(&pl, (uint8_t *)ad, 1);
    fio___poly_consume128bit(&pl, (uint8_t *)ad + 16, 1);
    ad = (void *)((uint8_t *)ad + 32);
  }
  if (adlen & 16) {
    fio___poly_consume128bit(&pl, (uint8_t *)ad, 1);
    ad = (void *)((uint8_t *)ad + 16);
  }
  if (adlen & 15) {
    uint64_t tmp[2] = {0}; /* 16 byte pad */
    fio_memcpy15x(tmp, ad, adlen);
    fio___poly_consume128bit(&pl, (uint8_t *)tmp, 1);
  }
  fio___poly_consume_msg(&pl, (uint8_t *)data, (len & (~15ULL)));
  if ((len & 15)) {
    fio_u128 dest = {0}; /* 16 byte pad */
    fio_memcpy15x(dest.u64, (uint8_t *)data + (len & (~15ULL)), len);
    fio___poly_consume128bit(&pl, (uint8_t *)(dest.u64), 1);
  }
  {
    uint64_t mac_data[2] = {fio_ltole64(adlen), fio_ltole64(len)};
    fio___poly_consume128bit(&pl, (uint8_t *)mac_data, 1);
  }
  fio___poly_finilize(&pl);
  fio_u2buf64_le(mac, pl.a[0]);
  fio_u2buf64_le(&((char *)mac)[8], pl.a[1]);
  fio_secure_zero(&pl, sizeof(pl));
}

SFUNC int fio_chacha20_poly1305_dec(void *restrict mac,
                                    void *restrict data,
                                    size_t len,
                                    const void *ad, /* additional data */
                                    size_t adlen,
                                    const void *key,
                                    const void *nonce) {
  uint64_t auth[2];
  fio_chacha20_poly1305_auth(&auth, data, len, ad, adlen, key, nonce);
  /* Use constant-time comparison to prevent timing side-channel attacks.
   * Even though early return stops communication with attacker, timing
   * differences could leak information about the correct MAC value. */
  if (!fio_ct_is_eq(auth, mac, 16)) {
    fio_secure_zero(auth, sizeof(auth));
    return -1;
  }
  fio_secure_zero(auth, sizeof(auth));
  fio_chacha20(data, len, key, nonce, 1);
  return 0;
}
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_CHACHA
#endif /* FIO_CHACHA */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_SHA1               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                    SHA 1



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_SHA1) && !defined(H___FIO_SHA1___H)
#define H___FIO_SHA1___H
/* *****************************************************************************
SHA 1
***************************************************************************** */

/** The data type containing the SHA1 digest (result). */
typedef union {
#ifdef __SIZEOF_INT128__
  __uint128_t align__;
#else
  uint64_t align__;
#endif
  uint32_t v[5];
  uint8_t digest[20];
} fio_sha1_s;

/**
 * A simple, non streaming, implementation of the SHA1 hashing algorithm.
 *
 * Do NOT use - SHA1 is broken... but for some reason some protocols still
 * require it's use (i.e., WebSockets), so it's here for your convenience.
 */
SFUNC fio_sha1_s fio_sha1(const void *data, uint64_t len);

/** Returns the digest length of SHA1 in bytes (20 bytes) */
FIO_IFUNC size_t fio_sha1_len(void);

/** Returns the 20 Byte long digest of a SHA1 object. */
FIO_IFUNC uint8_t *fio_sha1_digest(fio_sha1_s *s);

/* *****************************************************************************
SHA 1 Implementation - inlined static functions
***************************************************************************** */

/** returns the digest length of SHA1 in bytes */
FIO_IFUNC size_t fio_sha1_len(void) { return 20; }

/** returns the digest of a SHA1 object. */
FIO_IFUNC uint8_t *fio_sha1_digest(fio_sha1_s *s) { return s->digest; }

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_IFUNC void fio___sha1_round512(uint32_t *old, /* state */
                                   uint32_t *w /* 16 words */) {
#if defined(FIO___HAS_X86_SHA_INTRIN) && FIO___HAS_X86_SHA_INTRIN
  /* Code adjusted from:
   * https://github.com/noloader/SHA-Intrinsics/blob/master/sha1-x86.c
   * Credit to Jeffrey Walton.
   */
  __m128i abcd, e0, e1;
  __m128i abcd_save, e_save;
  __m128i msg0, msg1, msg2, msg3;

  /* Load initial values */
  abcd = _mm_loadu_si128((const __m128i *)old);
  e0 = _mm_set_epi32(old[4], 0, 0, 0);
  abcd = _mm_shuffle_epi32(abcd, 0x1B); /* big endian */
  /* Save current state */
  abcd_save = abcd;
  e_save = e0;

  /* Load and convert message to big endian */
  msg0 = _mm_loadu_si128((const __m128i *)(w + 0));
  msg1 = _mm_loadu_si128((const __m128i *)(w + 4));
  msg2 = _mm_loadu_si128((const __m128i *)(w + 8));
  msg3 = _mm_loadu_si128((const __m128i *)(w + 12));
  msg0 = _mm_shuffle_epi8(
      msg0,
      _mm_set_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15));
  msg1 = _mm_shuffle_epi8(
      msg1,
      _mm_set_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15));
  msg2 = _mm_shuffle_epi8(
      msg2,
      _mm_set_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15));
  msg3 = _mm_shuffle_epi8(
      msg3,
      _mm_set_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15));

  /* Rounds 0-3 */
  e0 = _mm_add_epi32(e0, msg0);
  e1 = abcd;
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 0);

  /* Rounds 4-7 */
  e1 = _mm_sha1nexte_epu32(e1, msg1);
  e0 = abcd;
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 0);
  msg0 = _mm_sha1msg1_epu32(msg0, msg1);

  /* Rounds 8-11 */
  e0 = _mm_sha1nexte_epu32(e0, msg2);
  e1 = abcd;
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 0);
  msg1 = _mm_sha1msg1_epu32(msg1, msg2);
  msg0 = _mm_xor_si128(msg0, msg2);

  /* Rounds 12-15 */
  e1 = _mm_sha1nexte_epu32(e1, msg3);
  e0 = abcd;
  msg0 = _mm_sha1msg2_epu32(msg0, msg3);
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 0);
  msg2 = _mm_sha1msg1_epu32(msg2, msg3);
  msg1 = _mm_xor_si128(msg1, msg3);

  /* Rounds 16-19 */
  e0 = _mm_sha1nexte_epu32(e0, msg0);
  e1 = abcd;
  msg1 = _mm_sha1msg2_epu32(msg1, msg0);
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 0);
  msg3 = _mm_sha1msg1_epu32(msg3, msg0);
  msg2 = _mm_xor_si128(msg2, msg0);

  /* Rounds 20-23 */
  e1 = _mm_sha1nexte_epu32(e1, msg1);
  e0 = abcd;
  msg2 = _mm_sha1msg2_epu32(msg2, msg1);
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 1);
  msg0 = _mm_sha1msg1_epu32(msg0, msg1);
  msg3 = _mm_xor_si128(msg3, msg1);

  /* Rounds 24-27 */
  e0 = _mm_sha1nexte_epu32(e0, msg2);
  e1 = abcd;
  msg3 = _mm_sha1msg2_epu32(msg3, msg2);
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 1);
  msg1 = _mm_sha1msg1_epu32(msg1, msg2);
  msg0 = _mm_xor_si128(msg0, msg2);

  /* Rounds 28-31 */
  e1 = _mm_sha1nexte_epu32(e1, msg3);
  e0 = abcd;
  msg0 = _mm_sha1msg2_epu32(msg0, msg3);
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 1);
  msg2 = _mm_sha1msg1_epu32(msg2, msg3);
  msg1 = _mm_xor_si128(msg1, msg3);

  /* Rounds 32-35 */
  e0 = _mm_sha1nexte_epu32(e0, msg0);
  e1 = abcd;
  msg1 = _mm_sha1msg2_epu32(msg1, msg0);
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 1);
  msg3 = _mm_sha1msg1_epu32(msg3, msg0);
  msg2 = _mm_xor_si128(msg2, msg0);

  /* Rounds 36-39 */
  e1 = _mm_sha1nexte_epu32(e1, msg1);
  e0 = abcd;
  msg2 = _mm_sha1msg2_epu32(msg2, msg1);
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 1);
  msg0 = _mm_sha1msg1_epu32(msg0, msg1);
  msg3 = _mm_xor_si128(msg3, msg1);

  /* Rounds 40-43 */
  e0 = _mm_sha1nexte_epu32(e0, msg2);
  e1 = abcd;
  msg3 = _mm_sha1msg2_epu32(msg3, msg2);
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 2);
  msg1 = _mm_sha1msg1_epu32(msg1, msg2);
  msg0 = _mm_xor_si128(msg0, msg2);

  /* Rounds 44-47 */
  e1 = _mm_sha1nexte_epu32(e1, msg3);
  e0 = abcd;
  msg0 = _mm_sha1msg2_epu32(msg0, msg3);
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 2);
  msg2 = _mm_sha1msg1_epu32(msg2, msg3);
  msg1 = _mm_xor_si128(msg1, msg3);

  /* Rounds 48-51 */
  e0 = _mm_sha1nexte_epu32(e0, msg0);
  e1 = abcd;
  msg1 = _mm_sha1msg2_epu32(msg1, msg0);
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 2);
  msg3 = _mm_sha1msg1_epu32(msg3, msg0);
  msg2 = _mm_xor_si128(msg2, msg0);

  /* Rounds 52-55 */
  e1 = _mm_sha1nexte_epu32(e1, msg1);
  e0 = abcd;
  msg2 = _mm_sha1msg2_epu32(msg2, msg1);
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 2);
  msg0 = _mm_sha1msg1_epu32(msg0, msg1);
  msg3 = _mm_xor_si128(msg3, msg1);

  /* Rounds 56-59 */
  e0 = _mm_sha1nexte_epu32(e0, msg2);
  e1 = abcd;
  msg3 = _mm_sha1msg2_epu32(msg3, msg2);
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 2);
  msg1 = _mm_sha1msg1_epu32(msg1, msg2);
  msg0 = _mm_xor_si128(msg0, msg2);

  /* Rounds 60-63 */
  e1 = _mm_sha1nexte_epu32(e1, msg3);
  e0 = abcd;
  msg0 = _mm_sha1msg2_epu32(msg0, msg3);
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 3);
  msg2 = _mm_sha1msg1_epu32(msg2, msg3);
  msg1 = _mm_xor_si128(msg1, msg3);

  /* Rounds 64-67 */
  e0 = _mm_sha1nexte_epu32(e0, msg0);
  e1 = abcd;
  msg1 = _mm_sha1msg2_epu32(msg1, msg0);
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 3);
  msg3 = _mm_sha1msg1_epu32(msg3, msg0);
  msg2 = _mm_xor_si128(msg2, msg0);

  /* Rounds 68-71 */
  e1 = _mm_sha1nexte_epu32(e1, msg1);
  e0 = abcd;
  msg2 = _mm_sha1msg2_epu32(msg2, msg1);
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 3);
  msg3 = _mm_xor_si128(msg3, msg1);

  /* Rounds 72-75 */
  e0 = _mm_sha1nexte_epu32(e0, msg2);
  e1 = abcd;
  msg3 = _mm_sha1msg2_epu32(msg3, msg2);
  abcd = _mm_sha1rnds4_epu32(abcd, e0, 3);

  /* Rounds 76-79 */
  e1 = _mm_sha1nexte_epu32(e1, msg3);
  e0 = abcd;
  abcd = _mm_sha1rnds4_epu32(abcd, e1, 3);

  /* Combine state */
  e0 = _mm_sha1nexte_epu32(e0, e_save);
  abcd = _mm_add_epi32(abcd, abcd_save);

  /* Save state (convert back from big endian) */
  abcd = _mm_shuffle_epi32(abcd, 0x1B);
  _mm_storeu_si128((__m128i *)old, abcd);
  old[4] = _mm_extract_epi32(e0, 3);

#elif FIO___HAS_ARM_INTRIN
  /* Code adjusted from:
   * https://github.com/noloader/SHA-Intrinsics/blob/master/sha1-arm.c
   * Credit to Jeffrey Walton.
   */
  uint32x4_t w0, w1, w2, w3;
  uint32x4_t t0, t1, v0, v_old;
  uint32_t e0, e1, e_old;
  e0 = e_old = old[4];
  v_old = vld1q_u32(old);
  v0 = v_old;

  /* load to vectors */
  w0 = vld1q_u32(w);
  w1 = vld1q_u32(w + 4);
  w2 = vld1q_u32(w + 8);
  w3 = vld1q_u32(w + 12);
  /* make little endian */
  w0 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(w0)));
  w1 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(w1)));
  w2 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(w2)));
  w3 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(w3)));

  t0 = vaddq_u32(w0, vdupq_n_u32(0x5A827999));
  t1 = vaddq_u32(w1, vdupq_n_u32(0x5A827999));

  /* round: 0-3 */
  e1 = vsha1h_u32(vgetq_lane_u32(v0, 0));
  v0 = vsha1cq_u32(v0, e0, t0);
  t0 = vaddq_u32(w2, vdupq_n_u32(0x5A827999));
  w0 = vsha1su0q_u32(w0, w1, w2);

  /* round: 4-7 */
  e0 = vsha1h_u32(vgetq_lane_u32(v0, 0));
  v0 = vsha1cq_u32(v0, e1, t1);
  t1 = vaddq_u32(w3, vdupq_n_u32(0x5A827999));
  w0 = vsha1su1q_u32(w0, w3);
  w1 = vsha1su0q_u32(w1, w2, w3);

  /* round: 8-11 */
  e1 = vsha1h_u32(vgetq_lane_u32(v0, 0));
  v0 = vsha1cq_u32(v0, e0, t0);
  t0 = vaddq_u32(w0, vdupq_n_u32(0x5A827999));
  w1 = vsha1su1q_u32(w1, w0);
  w2 = vsha1su0q_u32(w2, w3, w0);

#define FIO_SHA1_ROUND_(K, rn_fn, n, ni, n0, n1, n2, n3)                       \
  e##n = vsha1h_u32(vgetq_lane_u32(v0, 0));                                    \
  v0 = rn_fn(v0, e##ni, t##ni);                                                \
  t##ni = vaddq_u32(w##n1, vdupq_n_u32(K));                                    \
  w##n2 = vsha1su1q_u32(w##n2, w##n1);                                         \
  w##n3 = vsha1su0q_u32(w##n3, w##n0, w##n1);
  FIO_SHA1_ROUND_(0x6ED9EBA1, vsha1cq_u32, 0, 1, 0, 1, 2, 3)
  FIO_SHA1_ROUND_(0x6ED9EBA1, vsha1cq_u32, 1, 0, 1, 2, 3, 0)
  FIO_SHA1_ROUND_(0x6ED9EBA1, vsha1pq_u32, 0, 1, 2, 3, 0, 1)
  FIO_SHA1_ROUND_(0x6ED9EBA1, vsha1pq_u32, 1, 0, 3, 0, 1, 2)
  FIO_SHA1_ROUND_(0x6ED9EBA1, vsha1pq_u32, 0, 1, 0, 1, 2, 3)

  FIO_SHA1_ROUND_(0x8F1BBCDC, vsha1pq_u32, 1, 0, 1, 2, 3, 0)
  FIO_SHA1_ROUND_(0x8F1BBCDC, vsha1pq_u32, 0, 1, 2, 3, 0, 1)
  FIO_SHA1_ROUND_(0x8F1BBCDC, vsha1mq_u32, 1, 0, 3, 0, 1, 2)
  FIO_SHA1_ROUND_(0x8F1BBCDC, vsha1mq_u32, 0, 1, 0, 1, 2, 3)
  FIO_SHA1_ROUND_(0x8F1BBCDC, vsha1mq_u32, 1, 0, 1, 2, 3, 0)

  FIO_SHA1_ROUND_(0xCA62C1D6, vsha1mq_u32, 0, 1, 2, 3, 0, 1)
  FIO_SHA1_ROUND_(0xCA62C1D6, vsha1mq_u32, 1, 0, 3, 0, 1, 2)
  FIO_SHA1_ROUND_(0xCA62C1D6, vsha1pq_u32, 0, 1, 0, 1, 2, 3)
  FIO_SHA1_ROUND_(0xCA62C1D6, vsha1pq_u32, 1, 0, 1, 2, 3, 0)
#undef FIO_SHA1_ROUND_
  /* round: 68-71 */
  e0 = vsha1h_u32(vgetq_lane_u32(v0, 0));
  v0 = vsha1pq_u32(v0, e1, t1);
  t1 = vaddq_u32(w3, vdupq_n_u32(0xCA62C1D6));
  w0 = vsha1su1q_u32(w0, w3);

  /* round: 72-75 */
  e1 = vsha1h_u32(vgetq_lane_u32(v0, 0));
  v0 = vsha1pq_u32(v0, e0, t0);

  /* round: 76-79 */
  e0 = vsha1h_u32(vgetq_lane_u32(v0, 0));
  v0 = vsha1pq_u32(v0, e1, t1);

  /* combine and store */
  e0 += e_old;
  v0 = vaddq_u32(v_old, v0);
  vst1q_u32(old, v0);
  old[4] = e0;

#else /* Portable implementation */

  uint32_t v[5]; /* working variables a, b, c, d, e */
  for (size_t i = 0; i < 5; ++i)
    v[i] = old[i];

  /* convert read buffer to Big Endian */
  for (size_t i = 0; i < 16; ++i)
    w[i] = fio_ntol32(w[i]);

    /* SHA-1 round function */
#define FIO___SHA1_ROUND(i, k, f)                                              \
  do {                                                                         \
    const uint32_t t = fio_lrot32(v[0], 5) + (f) + v[4] + (k) + w[(i)&15];     \
    v[4] = v[3];                                                               \
    v[3] = v[2];                                                               \
    v[2] = fio_lrot32(v[1], 30);                                               \
    v[1] = v[0];                                                               \
    v[0] = t;                                                                  \
  } while (0)

    /* Message schedule expansion */
#define FIO___SHA1_EXPAND(i)                                                   \
  (w[(i)&15] = fio_lrot32(w[((i) + 13) & 15] ^ w[((i) + 8) & 15] ^             \
                              w[((i) + 2) & 15] ^ w[(i)&15],                   \
                          1))

  /* Rounds 0-15: use message words directly */
  for (size_t i = 0; i < 16; ++i)
    FIO___SHA1_ROUND(i, 0x5A827999UL, fio_ct_mux32(v[1], v[2], v[3]));

  /* Rounds 16-19: Ch function */
  for (size_t i = 16; i < 20; ++i) {
    FIO___SHA1_EXPAND(i);
    FIO___SHA1_ROUND(i, 0x5A827999UL, fio_ct_mux32(v[1], v[2], v[3]));
  }

  /* Rounds 20-39: Parity function */
  for (size_t i = 20; i < 40; ++i) {
    FIO___SHA1_EXPAND(i);
    FIO___SHA1_ROUND(i, 0x6ED9EBA1UL, fio_ct_xor3_32(v[1], v[2], v[3]));
  }

  /* Rounds 40-59: Maj function */
  for (size_t i = 40; i < 60; ++i) {
    FIO___SHA1_EXPAND(i);
    FIO___SHA1_ROUND(i, 0x8F1BBCDCUL, fio_ct_maj32(v[1], v[2], v[3]));
  }

  /* Rounds 60-79: Parity function */
  for (size_t i = 60; i < 80; ++i) {
    FIO___SHA1_EXPAND(i);
    FIO___SHA1_ROUND(i, 0xCA62C1D6UL, fio_ct_xor3_32(v[1], v[2], v[3]));
  }

#undef FIO___SHA1_ROUND
#undef FIO___SHA1_EXPAND

  /* Add compressed chunk to current hash value */
  for (size_t i = 0; i < 5; ++i)
    old[i] += v[i];

#endif /* FIO___HAS_X86_SHA_INTRIN / FIO___HAS_ARM_INTRIN */
}
/**
 * A simple, non streaming, implementation of the SHA1 hashing algorithm.
 *
 * Do NOT use - SHA1 is broken... but for some reason some protocols still
 * require it's use (i.e., WebSockets), so it's here for your convinience.
 */
SFUNC fio_sha1_s fio_sha1(const void *data, uint64_t len) {
  fio_sha1_s s FIO_ALIGN(16) = {.v = {
                                    0x67452301,
                                    0xEFCDAB89,
                                    0x98BADCFE,
                                    0x10325476,
                                    0xC3D2E1F0,
                                }};
  uint32_t vec[16] FIO_ALIGN(16);

  const uint8_t *buf = (const uint8_t *)data;

  for (size_t i = 63; i < len; i += 64) {
    fio_memcpy64(vec, buf);
    fio___sha1_round512(s.v, vec);
    buf += 64;
  }
  for (size_t i = 0; i < 16; ++i) {
    vec[i] = 0;
  }
  if ((len & 63)) {
    uint32_t tbuf[16] = {0};
    fio_memcpy63x(tbuf, buf, len);
    fio_memcpy64(vec, tbuf);
  }
  ((uint8_t *)vec)[(len & 63)] = 0x80;

  if ((len & 63) > 55) {
    fio___sha1_round512(s.v, vec);
    for (size_t i = 0; i < 16; ++i) {
      vec[i] = 0;
    }
  }
  len <<= 3;
  len = fio_lton64(len);
  vec[14] = (uint32_t)(len & 0xFFFFFFFF);
  vec[15] = (uint32_t)(len >> 32);
  fio___sha1_round512(s.v, vec);
  for (size_t i = 0; i < 5; ++i) {
    s.v[i] = fio_ntol32(s.v[i]);
  }
  return s;
}

/** HMAC-SHA1, resulting in a 20 byte authentication code. */
SFUNC fio_sha1_s fio_sha1_hmac(const void *key,
                               uint64_t key_len,
                               const void *msg,
                               uint64_t msg_len) {
  fio_sha1_s inner FIO_ALIGN(16) = {.v =
                                        {
                                            0x67452301,
                                            0xEFCDAB89,
                                            0x98BADCFE,
                                            0x10325476,
                                            0xC3D2E1F0,
                                        }},
                   outer FIO_ALIGN(16) = {.v = {
                                              0x67452301,
                                              0xEFCDAB89,
                                              0x98BADCFE,
                                              0x10325476,
                                              0xC3D2E1F0,
                                          }};
  fio_u512 v = fio_u512_init64(0), k = fio_u512_init64(0);
  uint32_t tmp[16] FIO_ALIGN(16); /* temp buffer for sha1 rounds */
  const uint8_t *buf = (const uint8_t *)msg;

  /* copy key */
  if (key_len > 64)
    goto key_too_long;
  if (key_len == 64)
    fio_memcpy64(k.u8, key);
  else
    fio_memcpy63x(k.u8, key, key_len);
  /* prepare inner key */
  for (size_t i = 0; i < 8; ++i)
    k.u64[i] ^= (uint64_t)0x3636363636363636ULL;

  /* hash inner key block */
  fio_memcpy64(tmp, k.u32);
  fio___sha1_round512(inner.v, tmp);
  /* consume data */
  for (size_t i = 63; i < msg_len; i += 64) {
    fio_memcpy64(tmp, buf);
    fio___sha1_round512(inner.v, tmp);
    buf += 64;
  }
  /* finalize temporary hash */
  if ((msg_len & 63)) {
    v = fio_u512_init64(0);
    fio_memcpy63x(v.u8, buf, msg_len);
  }
  v.u8[(msg_len & 63)] = 0x80;
  if ((msg_len & 63) > 55) {
    fio_memcpy64(tmp, v.u32);
    fio___sha1_round512(inner.v, tmp);
    v = fio_u512_init64(0);
  }
  msg_len += 64; /* add the 64 byte inner key to the length count */
  msg_len <<= 3;
  msg_len = fio_lton64(msg_len);
  v.u32[14] = (uint32_t)(msg_len & 0xFFFFFFFFUL);
  v.u32[15] = (uint32_t)(msg_len >> 32);
  fio_memcpy64(tmp, v.u32);
  fio___sha1_round512(inner.v, tmp);
  for (size_t i = 0; i < 5; ++i)
    inner.v[i] = fio_ntol32(inner.v[i]);

  /* switch key to outer key */
  for (size_t i = 0; i < 8; ++i)
    k.u64[i] ^=
        ((uint64_t)0x3636363636363636ULL ^ (uint64_t)0x5C5C5C5C5C5C5C5CULL);

  /* hash outer key block */
  fio_memcpy64(tmp, k.u32);
  fio___sha1_round512(outer.v, tmp);
  /* hash inner (temporary) hash result and finalize */
  v = fio_u512_init64(0);
  for (size_t i = 0; i < 5; ++i)
    v.u32[i] = inner.v[i];
  v.u8[20] = 0x80;
  msg_len = ((64U + 20U) << 3);
  msg_len = fio_lton64(msg_len);
  v.u32[14] = (uint32_t)(msg_len & 0xFFFFFFFF);
  v.u32[15] = (uint32_t)(msg_len >> 32);
  fio_memcpy64(tmp, v.u32);
  fio___sha1_round512(outer.v, tmp);
  for (size_t i = 0; i < 5; ++i)
    outer.v[i] = fio_ntol32(outer.v[i]);

  return outer;

key_too_long:
  inner = fio_sha1(key, key_len);
  return fio_sha1_hmac(inner.digest, 20, msg, msg_len);
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_SHA1 */
#undef FIO_SHA1
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_SHA2               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                    SHA 2
                        SHA-256 / SHA-512 and variations



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_SHA2) && !defined(H___FIO_SHA2___H)
#define H___FIO_SHA2___H
/* *****************************************************************************
SHA 2 API
***************************************************************************** */

/** Streaming SHA-256 type. */
typedef struct {
  fio_u256 hash;
  fio_u512 cache;
  uint64_t total_len;
} fio_sha256_s;

/** A simple, non streaming, implementation of the SHA-256 hashing algorithm. */
FIO_IFUNC fio_u256 fio_sha256(const void *data, uint64_t len);

/** initializes a fio_u256 so the hash can consume streaming data. */
FIO_IFUNC fio_sha256_s fio_sha256_init(void);
/** Feed data into the hash */
SFUNC void fio_sha256_consume(fio_sha256_s *h, const void *data, uint64_t len);
/** finalizes a fio_u256 with the SHA 256 hash. */
SFUNC fio_u256 fio_sha256_finalize(fio_sha256_s *h);

/** Streaming SHA-512 type. */
typedef struct {
  fio_u512 hash;
  fio_u1024 cache;
  uint64_t total_len;
} fio_sha512_s;

/** A simple, non streaming, implementation of the SHA-512 hashing algorithm. */
FIO_IFUNC fio_u512 fio_sha512(const void *data, uint64_t len);

/** initializes a fio_u512 so the hash can consume streaming data. */
FIO_IFUNC fio_sha512_s fio_sha512_init(void);
/** Feed data into the hash */
SFUNC void fio_sha512_consume(fio_sha512_s *h, const void *data, uint64_t len);
/** finalizes a fio_u512 with the SHA 512 hash. */
SFUNC fio_u512 fio_sha512_finalize(fio_sha512_s *h);

/* *****************************************************************************
Implementation - static / inline functions.
***************************************************************************** */

/** initializes a fio_u256 so the hash can be consumed. */
FIO_IFUNC fio_sha256_s fio_sha256_init(void) {
  fio_sha256_s h = {.hash.u32 = {0x6A09E667ULL,
                                 0xBB67AE85ULL,
                                 0x3C6EF372ULL,
                                 0xA54FF53AULL,
                                 0x510E527FULL,
                                 0x9B05688CULL,
                                 0x1F83D9ABULL,
                                 0x5BE0CD19ULL}};
  return h;
}

/** A simple, non streaming, implementation of the SHA-256 hashing algorithm. */
FIO_IFUNC fio_u256 fio_sha256(const void *data, uint64_t len) {
  fio_sha256_s h = fio_sha256_init();
  fio_sha256_consume(&h, data, len);
  return fio_sha256_finalize(&h);
}

/** initializes a fio_u256 so the hash can be consumed. */
FIO_IFUNC fio_sha512_s fio_sha512_init(void) {
  fio_sha512_s h = {.hash.u64 = {0x6A09E667F3BCC908ULL,
                                 0xBB67AE8584CAA73BULL,
                                 0x3C6EF372FE94F82BULL,
                                 0xA54FF53A5F1D36F1ULL,
                                 0x510E527FADE682D1ULL,
                                 0x9B05688C2B3E6C1FULL,
                                 0x1F83D9ABFB41BD6BULL,
                                 0x5BE0CD19137E2179ULL}};
  return h;
}

/** A simple, non streaming, implementation of the SHA-256 hashing algorithm. */
FIO_IFUNC fio_u512 fio_sha512(const void *data, uint64_t len) {
  fio_sha512_s h = fio_sha512_init();
  fio_sha512_consume(&h, data, len);
  return fio_sha512_finalize(&h);
}

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Implementation - SHA-256
***************************************************************************** */

FIO_IFUNC void fio___sha256_round(fio_u256 *h, const uint8_t *block) {
#if defined(FIO___HAS_X86_SHA_INTRIN) && FIO___HAS_X86_SHA_INTRIN
  /* Code adjusted from:
   * https://github.com/noloader/SHA-Intrinsics/blob/master/sha256-x86.c
   * Credit to Jeffrey Walton.
   */
  __m128i state0, state1;
  __m128i msg, tmp;
  __m128i msg0, msg1, msg2, msg3;
  __m128i abef_save, cdgh_save;
  const __m128i shuf_mask =
      _mm_set_epi8(12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3);

  /* Load initial values */
  tmp = _mm_loadu_si128((const __m128i *)&h->u32[0]);
  state1 = _mm_loadu_si128((const __m128i *)&h->u32[4]);

  tmp = _mm_shuffle_epi32(tmp, 0xB1);          /* CDAB */
  state1 = _mm_shuffle_epi32(state1, 0x1B);    /* EFGH */
  state0 = _mm_alignr_epi8(tmp, state1, 8);    /* ABEF */
  state1 = _mm_blend_epi16(state1, tmp, 0xF0); /* CDGH */

  /* Save current state */
  abef_save = state0;
  cdgh_save = state1;

  /* Rounds 0-3 */
  msg = _mm_loadu_si128((const __m128i *)(block + 0));
  msg0 = _mm_shuffle_epi8(msg, shuf_mask);
  msg = _mm_add_epi32(
      msg0,
      _mm_set_epi64x(0xE9B5DBA5B5C0FBCFULL, 0x71374491428A2F98ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);

  /* Rounds 4-7 */
  msg1 = _mm_loadu_si128((const __m128i *)(block + 16));
  msg1 = _mm_shuffle_epi8(msg1, shuf_mask);
  msg = _mm_add_epi32(
      msg1,
      _mm_set_epi64x(0xAB1C5ED5923F82A4ULL, 0x59F111F13956C25BULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg0 = _mm_sha256msg1_epu32(msg0, msg1);

  /* Rounds 8-11 */
  msg2 = _mm_loadu_si128((const __m128i *)(block + 32));
  msg2 = _mm_shuffle_epi8(msg2, shuf_mask);
  msg = _mm_add_epi32(
      msg2,
      _mm_set_epi64x(0x550C7DC3243185BEULL, 0x12835B01D807AA98ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg1 = _mm_sha256msg1_epu32(msg1, msg2);

  /* Rounds 12-15 */
  msg3 = _mm_loadu_si128((const __m128i *)(block + 48));
  msg3 = _mm_shuffle_epi8(msg3, shuf_mask);
  msg = _mm_add_epi32(
      msg3,
      _mm_set_epi64x(0xC19BF1749BDC06A7ULL, 0x80DEB1FE72BE5D74ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg3, msg2, 4);
  msg0 = _mm_add_epi32(msg0, tmp);
  msg0 = _mm_sha256msg2_epu32(msg0, msg3);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg2 = _mm_sha256msg1_epu32(msg2, msg3);

  /* Rounds 16-19 */
  msg = _mm_add_epi32(
      msg0,
      _mm_set_epi64x(0x240CA1CC0FC19DC6ULL, 0xEFBE4786E49B69C1ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg0, msg3, 4);
  msg1 = _mm_add_epi32(msg1, tmp);
  msg1 = _mm_sha256msg2_epu32(msg1, msg0);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg3 = _mm_sha256msg1_epu32(msg3, msg0);

  /* Rounds 20-23 */
  msg = _mm_add_epi32(
      msg1,
      _mm_set_epi64x(0x76F988DA5CB0A9DCULL, 0x4A7484AA2DE92C6FULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg1, msg0, 4);
  msg2 = _mm_add_epi32(msg2, tmp);
  msg2 = _mm_sha256msg2_epu32(msg2, msg1);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg0 = _mm_sha256msg1_epu32(msg0, msg1);

  /* Rounds 24-27 */
  msg = _mm_add_epi32(
      msg2,
      _mm_set_epi64x(0xBF597FC7B00327C8ULL, 0xA831C66D983E5152ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg2, msg1, 4);
  msg3 = _mm_add_epi32(msg3, tmp);
  msg3 = _mm_sha256msg2_epu32(msg3, msg2);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg1 = _mm_sha256msg1_epu32(msg1, msg2);

  /* Rounds 28-31 */
  msg = _mm_add_epi32(
      msg3,
      _mm_set_epi64x(0x1429296706CA6351ULL, 0xD5A79147C6E00BF3ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg3, msg2, 4);
  msg0 = _mm_add_epi32(msg0, tmp);
  msg0 = _mm_sha256msg2_epu32(msg0, msg3);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg2 = _mm_sha256msg1_epu32(msg2, msg3);

  /* Rounds 32-35 */
  msg = _mm_add_epi32(
      msg0,
      _mm_set_epi64x(0x53380D134D2C6DFCULL, 0x2E1B213827B70A85ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg0, msg3, 4);
  msg1 = _mm_add_epi32(msg1, tmp);
  msg1 = _mm_sha256msg2_epu32(msg1, msg0);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg3 = _mm_sha256msg1_epu32(msg3, msg0);

  /* Rounds 36-39 */
  msg = _mm_add_epi32(
      msg1,
      _mm_set_epi64x(0x92722C8581C2C92EULL, 0x766A0ABB650A7354ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg1, msg0, 4);
  msg2 = _mm_add_epi32(msg2, tmp);
  msg2 = _mm_sha256msg2_epu32(msg2, msg1);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg0 = _mm_sha256msg1_epu32(msg0, msg1);

  /* Rounds 40-43 */
  msg = _mm_add_epi32(
      msg2,
      _mm_set_epi64x(0xC76C51A3C24B8B70ULL, 0xA81A664BA2BFE8A1ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg2, msg1, 4);
  msg3 = _mm_add_epi32(msg3, tmp);
  msg3 = _mm_sha256msg2_epu32(msg3, msg2);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg1 = _mm_sha256msg1_epu32(msg1, msg2);

  /* Rounds 44-47 */
  msg = _mm_add_epi32(
      msg3,
      _mm_set_epi64x(0x106AA070F40E3585ULL, 0xD6990624D192E819ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg3, msg2, 4);
  msg0 = _mm_add_epi32(msg0, tmp);
  msg0 = _mm_sha256msg2_epu32(msg0, msg3);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg2 = _mm_sha256msg1_epu32(msg2, msg3);

  /* Rounds 48-51 */
  msg = _mm_add_epi32(
      msg0,
      _mm_set_epi64x(0x34B0BCB52748774CULL, 0x1E376C0819A4C116ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg0, msg3, 4);
  msg1 = _mm_add_epi32(msg1, tmp);
  msg1 = _mm_sha256msg2_epu32(msg1, msg0);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);
  msg3 = _mm_sha256msg1_epu32(msg3, msg0);

  /* Rounds 52-55 */
  msg = _mm_add_epi32(
      msg1,
      _mm_set_epi64x(0x5B9CCA4F4ED8AA4AULL, 0x391C0CB3391C0CB3ULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg1, msg0, 4);
  msg2 = _mm_add_epi32(msg2, tmp);
  msg2 = _mm_sha256msg2_epu32(msg2, msg1);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);

  /* Rounds 56-59 */
  msg = _mm_add_epi32(
      msg2,
      _mm_set_epi64x(0x8CC7020884C87814ULL, 0x78A5636F748F82EEULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  tmp = _mm_alignr_epi8(msg2, msg1, 4);
  msg3 = _mm_add_epi32(msg3, tmp);
  msg3 = _mm_sha256msg2_epu32(msg3, msg2);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);

  /* Rounds 60-63 */
  msg = _mm_add_epi32(
      msg3,
      _mm_set_epi64x(0xC67178F2BEF9A3F7ULL, 0xA4506CEB90BEFFFAULL));
  state1 = _mm_sha256rnds2_epu32(state1, state0, msg);
  msg = _mm_shuffle_epi32(msg, 0x0E);
  state0 = _mm_sha256rnds2_epu32(state0, state1, msg);

  /* Combine state */
  state0 = _mm_add_epi32(state0, abef_save);
  state1 = _mm_add_epi32(state1, cdgh_save);

  tmp = _mm_shuffle_epi32(state0, 0x1B);       /* FEBA */
  state1 = _mm_shuffle_epi32(state1, 0xB1);    /* DCHG */
  state0 = _mm_blend_epi16(tmp, state1, 0xF0); /* DCBA */
  state1 = _mm_alignr_epi8(state1, tmp, 8);    /* ABEF */

  /* Save state */
  _mm_storeu_si128((__m128i *)&h->u32[0], state0);
  _mm_storeu_si128((__m128i *)&h->u32[4], state1);

#elif FIO___HAS_ARM_INTRIN
  /* Code adjusted from:
   * https://github.com/noloader/SHA-Intrinsics/blob/master/sha256-arm.c
   * Credit to Jeffrey Walton.
   */
  static const uint32_t sha256_consts[64] FIO_ALIGN(16) = {
      0x428A2F98UL, 0x71374491UL, 0xB5C0FBCFUL, 0xE9B5DBA5UL, 0x3956C25BUL,
      0x59F111F1UL, 0x923F82A4UL, 0xAB1C5ED5UL, 0xD807AA98UL, 0x12835B01UL,
      0x243185BEUL, 0x550C7DC3UL, 0x72BE5D74UL, 0x80DEB1FEUL, 0x9BDC06A7UL,
      0xC19BF174UL, 0xE49B69C1UL, 0xEFBE4786UL, 0x0FC19DC6UL, 0x240CA1CCUL,
      0x2DE92C6FUL, 0x4A7484AAUL, 0x5CB0A9DCUL, 0x76F988DAUL, 0x983E5152UL,
      0xA831C66DUL, 0xB00327C8UL, 0xBF597FC7UL, 0xC6E00BF3UL, 0xD5A79147UL,
      0x06CA6351UL, 0x14292967UL, 0x27B70A85UL, 0x2E1B2138UL, 0x4D2C6DFCUL,
      0x53380D13UL, 0x650A7354UL, 0x766A0ABBUL, 0x81C2C92EUL, 0x92722C85UL,
      0xA2BFE8A1UL, 0xA81A664BUL, 0xC24B8B70UL, 0xC76C51A3UL, 0xD192E819UL,
      0xD6990624UL, 0xF40E3585UL, 0x106AA070UL, 0x19A4C116UL, 0x1E376C08UL,
      0x2748774CUL, 0x34B0BCB5UL, 0x391C0CB3UL, 0x4ED8AA4AUL, 0x5B9CCA4FUL,
      0x682E6FF3UL, 0x748F82EEUL, 0x78A5636FUL, 0x84C87814UL, 0x8CC70208UL,
      0x90BEFFFAUL, 0xA4506CEBUL, 0xBEF9A3F7UL, 0xC67178F2UL};

  uint32x4_t state0, state1, state0_save, state1_save;
  uint32x4_t msg0, msg1, msg2, msg3;
  uint32x4_t tmp0, tmp1, tmp2;

  /* Load state */
  state0 = vld1q_u32(&h->u32[0]);
  state1 = vld1q_u32(&h->u32[4]);

  /* Save state */
  state0_save = state0;
  state1_save = state1;

  /* Load and byte-swap message */
  msg0 = vld1q_u32((const uint32_t *)(block + 0));
  msg1 = vld1q_u32((const uint32_t *)(block + 16));
  msg2 = vld1q_u32((const uint32_t *)(block + 32));
  msg3 = vld1q_u32((const uint32_t *)(block + 48));
  msg0 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(msg0)));
  msg1 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(msg1)));
  msg2 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(msg2)));
  msg3 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(msg3)));

  /* Rounds 0-3 */
  tmp0 = vaddq_u32(msg0, vld1q_u32(&sha256_consts[0]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp0);
  state1 = vsha256h2q_u32(state1, tmp2, tmp0);
  msg0 = vsha256su0q_u32(msg0, msg1);

  /* Rounds 4-7 */
  tmp1 = vaddq_u32(msg1, vld1q_u32(&sha256_consts[4]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp1);
  state1 = vsha256h2q_u32(state1, tmp2, tmp1);
  msg0 = vsha256su1q_u32(msg0, msg2, msg3);
  msg1 = vsha256su0q_u32(msg1, msg2);

  /* Rounds 8-11 */
  tmp0 = vaddq_u32(msg2, vld1q_u32(&sha256_consts[8]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp0);
  state1 = vsha256h2q_u32(state1, tmp2, tmp0);
  msg1 = vsha256su1q_u32(msg1, msg3, msg0);
  msg2 = vsha256su0q_u32(msg2, msg3);

  /* Rounds 12-15 */
  tmp1 = vaddq_u32(msg3, vld1q_u32(&sha256_consts[12]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp1);
  state1 = vsha256h2q_u32(state1, tmp2, tmp1);
  msg2 = vsha256su1q_u32(msg2, msg0, msg1);
  msg3 = vsha256su0q_u32(msg3, msg0);

  /* Rounds 16-19 */
  tmp0 = vaddq_u32(msg0, vld1q_u32(&sha256_consts[16]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp0);
  state1 = vsha256h2q_u32(state1, tmp2, tmp0);
  msg3 = vsha256su1q_u32(msg3, msg1, msg2);
  msg0 = vsha256su0q_u32(msg0, msg1);

  /* Rounds 20-23 */
  tmp1 = vaddq_u32(msg1, vld1q_u32(&sha256_consts[20]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp1);
  state1 = vsha256h2q_u32(state1, tmp2, tmp1);
  msg0 = vsha256su1q_u32(msg0, msg2, msg3);
  msg1 = vsha256su0q_u32(msg1, msg2);

  /* Rounds 24-27 */
  tmp0 = vaddq_u32(msg2, vld1q_u32(&sha256_consts[24]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp0);
  state1 = vsha256h2q_u32(state1, tmp2, tmp0);
  msg1 = vsha256su1q_u32(msg1, msg3, msg0);
  msg2 = vsha256su0q_u32(msg2, msg3);

  /* Rounds 28-31 */
  tmp1 = vaddq_u32(msg3, vld1q_u32(&sha256_consts[28]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp1);
  state1 = vsha256h2q_u32(state1, tmp2, tmp1);
  msg2 = vsha256su1q_u32(msg2, msg0, msg1);
  msg3 = vsha256su0q_u32(msg3, msg0);

  /* Rounds 32-35 */
  tmp0 = vaddq_u32(msg0, vld1q_u32(&sha256_consts[32]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp0);
  state1 = vsha256h2q_u32(state1, tmp2, tmp0);
  msg3 = vsha256su1q_u32(msg3, msg1, msg2);
  msg0 = vsha256su0q_u32(msg0, msg1);

  /* Rounds 36-39 */
  tmp1 = vaddq_u32(msg1, vld1q_u32(&sha256_consts[36]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp1);
  state1 = vsha256h2q_u32(state1, tmp2, tmp1);
  msg0 = vsha256su1q_u32(msg0, msg2, msg3);
  msg1 = vsha256su0q_u32(msg1, msg2);

  /* Rounds 40-43 */
  tmp0 = vaddq_u32(msg2, vld1q_u32(&sha256_consts[40]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp0);
  state1 = vsha256h2q_u32(state1, tmp2, tmp0);
  msg1 = vsha256su1q_u32(msg1, msg3, msg0);
  msg2 = vsha256su0q_u32(msg2, msg3);

  /* Rounds 44-47 */
  tmp1 = vaddq_u32(msg3, vld1q_u32(&sha256_consts[44]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp1);
  state1 = vsha256h2q_u32(state1, tmp2, tmp1);
  msg2 = vsha256su1q_u32(msg2, msg0, msg1);
  msg3 = vsha256su0q_u32(msg3, msg0);

  /* Rounds 48-51 */
  tmp0 = vaddq_u32(msg0, vld1q_u32(&sha256_consts[48]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp0);
  state1 = vsha256h2q_u32(state1, tmp2, tmp0);
  msg3 = vsha256su1q_u32(msg3, msg1, msg2);

  /* Rounds 52-55 */
  tmp1 = vaddq_u32(msg1, vld1q_u32(&sha256_consts[52]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp1);
  state1 = vsha256h2q_u32(state1, tmp2, tmp1);

  /* Rounds 56-59 */
  tmp0 = vaddq_u32(msg2, vld1q_u32(&sha256_consts[56]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp0);
  state1 = vsha256h2q_u32(state1, tmp2, tmp0);

  /* Rounds 60-63 */
  tmp1 = vaddq_u32(msg3, vld1q_u32(&sha256_consts[60]));
  tmp2 = state0;
  state0 = vsha256hq_u32(state0, state1, tmp1);
  state1 = vsha256h2q_u32(state1, tmp2, tmp1);

  /* Combine state */
  state0 = vaddq_u32(state0, state0_save);
  state1 = vaddq_u32(state1, state1_save);

  /* Save state */
  vst1q_u32(&h->u32[0], state0);
  vst1q_u32(&h->u32[4], state1);

#else /* Portable implementation */
  static const uint32_t sha256_consts[64] = {
      0x428A2F98UL, 0x71374491UL, 0xB5C0FBCFUL, 0xE9B5DBA5UL, 0x3956C25BUL,
      0x59F111F1UL, 0x923F82A4UL, 0xAB1C5ED5UL, 0xD807AA98UL, 0x12835B01UL,
      0x243185BEUL, 0x550C7DC3UL, 0x72BE5D74UL, 0x80DEB1FEUL, 0x9BDC06A7UL,
      0xC19BF174UL, 0xE49B69C1UL, 0xEFBE4786UL, 0x0FC19DC6UL, 0x240CA1CCUL,
      0x2DE92C6FUL, 0x4A7484AAUL, 0x5CB0A9DCUL, 0x76F988DAUL, 0x983E5152UL,
      0xA831C66DUL, 0xB00327C8UL, 0xBF597FC7UL, 0xC6E00BF3UL, 0xD5A79147UL,
      0x06CA6351UL, 0x14292967UL, 0x27B70A85UL, 0x2E1B2138UL, 0x4D2C6DFCUL,
      0x53380D13UL, 0x650A7354UL, 0x766A0ABBUL, 0x81C2C92EUL, 0x92722C85UL,
      0xA2BFE8A1UL, 0xA81A664BUL, 0xC24B8B70UL, 0xC76C51A3UL, 0xD192E819UL,
      0xD6990624UL, 0xF40E3585UL, 0x106AA070UL, 0x19A4C116UL, 0x1E376C08UL,
      0x2748774CUL, 0x34B0BCB5UL, 0x391C0CB3UL, 0x4ED8AA4AUL, 0x5B9CCA4FUL,
      0x682E6FF3UL, 0x748F82EEUL, 0x78A5636FUL, 0x84C87814UL, 0x8CC70208UL,
      0x90BEFFFAUL, 0xA4506CEBUL, 0xBEF9A3F7UL, 0xC67178F2UL};

  uint32_t v[8];
  for (size_t i = 0; i < 8; ++i)
    v[i] = h->u32[i];

  /* read data as an array of 16 big endian 32 bit integers. */
  uint32_t w[16] FIO_ALIGN(16);
  fio_memcpy64(w, block);
  for (size_t i = 0; i < 16; ++i)
    w[i] = fio_lton32(w[i]); /* no-op on big endian systems */

    /* SHA-256 round - processes one word */
#define FIO___SHA256_ROUND(i, k)                                               \
  do {                                                                         \
    const uint32_t t1 = v[7] + (k) + w[(i)&15] +                               \
                        fio_ct_mux32(v[4], v[5], v[6]) +                       \
                        fio_xor_rrot3_32(v[4], 6, 11, 25);                     \
    const uint32_t t2 =                                                        \
        fio_ct_maj32(v[0], v[1], v[2]) + fio_xor_rrot3_32(v[0], 2, 13, 22);    \
    v[7] = v[6];                                                               \
    v[6] = v[5];                                                               \
    v[5] = v[4];                                                               \
    v[4] = v[3] + t1;                                                          \
    v[3] = v[2];                                                               \
    v[2] = v[1];                                                               \
    v[1] = v[0];                                                               \
    v[0] = t1 + t2;                                                            \
  } while (0)

  /* First 16 rounds - use message words directly */
  for (size_t i = 0; i < 16; ++i)
    FIO___SHA256_ROUND(i, sha256_consts[i]);

  /* Remaining 48 rounds - expand message schedule inline */
  for (size_t i = 16; i < 64; ++i) {
    w[i & 15] = fio_xor_rrot2_shr_32(w[(i + 14) & 15], 17, 19, 10) +
                w[(i + 9) & 15] +
                fio_xor_rrot2_shr_32(w[(i + 1) & 15], 7, 18, 3) + w[i & 15];
    FIO___SHA256_ROUND(i, sha256_consts[i]);
  }
#undef FIO___SHA256_ROUND

  /* Add compressed chunk to current hash value */
  for (size_t i = 0; i < 8; ++i)
    h->u32[i] += v[i];

#endif /* FIO___HAS_X86_SHA_INTRIN / FIO___HAS_ARM_INTRIN */
}

/** consume data and feed it to hash. */
SFUNC void fio_sha256_consume(fio_sha256_s *h, const void *data, uint64_t len) {
  const uint8_t *r = (const uint8_t *)data;
  const size_t old_total = h->total_len;
  const size_t new_total = len + h->total_len;
  h->total_len = new_total;
  /* manage cache */
  if (old_total & 63) {
    const size_t offset = (old_total & 63);
    if (len + offset < 64) { /* not enough - copy to cache */
      fio_memcpy63x((h->cache.u8 + offset), r, len);
      return;
    }
    /* consume cache */
    const size_t byte2copy = 64UL - offset;
    fio_memcpy63x(h->cache.u8 + offset, r, byte2copy);
    fio___sha256_round(&h->hash, h->cache.u8);
    FIO_MEMSET(h->cache.u8, 0, 64);
    r += byte2copy;
    len -= byte2copy;
  }
  const uint8_t *end = r + (len & (~(uint64_t)63ULL));
  while ((uintptr_t)r < (uintptr_t)end) {
    fio___sha256_round(&h->hash, r);
    r += 64;
  }
  fio_memcpy63x(h->cache.u64, r, len);
}

SFUNC fio_u256 fio_sha256_finalize(fio_sha256_s *h) {
  if (h->total_len == ((uint64_t)0ULL - 1ULL))
    return h->hash;
  const size_t total = h->total_len;
  size_t remainder = total & 63;
  h->cache.u8[remainder] = 0x80U; /* set the 1 bit at the left most position */
  if ((remainder) > 55) { /* make sure there's room to attach `total_len` */
    fio___sha256_round(&h->hash, h->cache.u8);
    FIO_MEMSET(h->cache.u8, 0, 64);
  }
  h->cache.u64[7] = fio_lton64((total << 3));
  fio___sha256_round(&h->hash, h->cache.u8);
  for (size_t i = 0; i < 8; ++i)
    h->hash.u32[i] = fio_ntol32(h->hash.u32[i]); /* back to big endien */
  h->total_len = ((uint64_t)0ULL - 1ULL);
  return h->hash;
}

/* *****************************************************************************
Implementation - SHA-512
***************************************************************************** */

FIO_IFUNC void fio___sha512_round(fio_u512 *restrict h,
                                  const uint8_t *restrict block) {
  /* SHA-512 round constants */
  static const uint64_t K[80] = {
      0x428A2F98D728AE22ULL, 0x7137449123EF65CDULL, 0xB5C0FBCFEC4D3B2FULL,
      0xE9B5DBA58189DBBCULL, 0x3956C25BF348B538ULL, 0x59F111F1B605D019ULL,
      0x923F82A4AF194F9BULL, 0xAB1C5ED5DA6D8118ULL, 0xD807AA98A3030242ULL,
      0x12835B0145706FBEULL, 0x243185BE4EE4B28CULL, 0x550C7DC3D5FFB4E2ULL,
      0x72BE5D74F27B896FULL, 0x80DEB1FE3B1696B1ULL, 0x9BDC06A725C71235ULL,
      0xC19BF174CF692694ULL, 0xE49B69C19EF14AD2ULL, 0xEFBE4786384F25E3ULL,
      0x0FC19DC68B8CD5B5ULL, 0x240CA1CC77AC9C65ULL, 0x2DE92C6F592B0275ULL,
      0x4A7484AA6EA6E483ULL, 0x5CB0A9DCBD41FBD4ULL, 0x76F988DA831153B5ULL,
      0x983E5152EE66DFABULL, 0xA831C66D2DB43210ULL, 0xB00327C898FB213FULL,
      0xBF597FC7BEEF0EE4ULL, 0xC6E00BF33DA88FC2ULL, 0xD5A79147930AA725ULL,
      0x06CA6351E003826FULL, 0x142929670A0E6E70ULL, 0x27B70A8546D22FFCULL,
      0x2E1B21385C26C926ULL, 0x4D2C6DFC5AC42AEDULL, 0x53380D139D95B3DFULL,
      0x650A73548BAF63DEULL, 0x766A0ABB3C77B2A8ULL, 0x81C2C92E47EDAEE6ULL,
      0x92722C851482353BULL, 0xA2BFE8A14CF10364ULL, 0xA81A664BBC423001ULL,
      0xC24B8B70D0F89791ULL, 0xC76C51A30654BE30ULL, 0xD192E819D6EF5218ULL,
      0xD69906245565A910ULL, 0xF40E35855771202AULL, 0x106AA07032BBD1B8ULL,
      0x19A4C116B8D2D0C8ULL, 0x1E376C085141AB53ULL, 0x2748774CDF8EEB99ULL,
      0x34B0BCB5E19B48A8ULL, 0x391C0CB3C5C95A63ULL, 0x4ED8AA4AE3418ACBULL,
      0x5B9CCA4F7763E373ULL, 0x682E6FF3D6B2B8A3ULL, 0x748F82EE5DEFB2FCULL,
      0x78A5636F43172F60ULL, 0x84C87814A1F0AB72ULL, 0x8CC702081A6439ECULL,
      0x90BEFFFA23631E28ULL, 0xA4506CEBDE82BDE9ULL, 0xBEF9A3F7B2C67915ULL,
      0xC67178F2E372532BULL, 0xCA273ECEEA26619CULL, 0xD186B8C721C0C207ULL,
      0xEADA7DD6CDE0EB1EULL, 0xF57D4F7FEE6ED178ULL, 0x06F067AA72176FBAULL,
      0x0A637DC5A2C898A6ULL, 0x113F9804BEF90DAEULL, 0x1B710B35131C471BULL,
      0x28DB77F523047D84ULL, 0x32CAAB7B40C72493ULL, 0x3C9EBE0A15C9BEBCULL,
      0x431D67C49C100D4CULL, 0x4CC5D4BECB3E42B6ULL, 0x597F299CFC657E2AULL,
      0x5FCB6FAB3AD6FAECULL, 0x6C44198C4A475817ULL};

  /* Load state into registers */
  uint64_t a = h->u64[0], b = h->u64[1], c = h->u64[2], d = h->u64[3];
  uint64_t e = h->u64[4], f = h->u64[5], g = h->u64[6], hv = h->u64[7];

  /* Message schedule array */
  uint64_t w[16];

  /* Load and byte-swap message block - unrolled for better performance */
  w[0] = fio_buf2u64_be(block);
  w[1] = fio_buf2u64_be(block + 8);
  w[2] = fio_buf2u64_be(block + 16);
  w[3] = fio_buf2u64_be(block + 24);
  w[4] = fio_buf2u64_be(block + 32);
  w[5] = fio_buf2u64_be(block + 40);
  w[6] = fio_buf2u64_be(block + 48);
  w[7] = fio_buf2u64_be(block + 56);
  w[8] = fio_buf2u64_be(block + 64);
  w[9] = fio_buf2u64_be(block + 72);
  w[10] = fio_buf2u64_be(block + 80);
  w[11] = fio_buf2u64_be(block + 88);
  w[12] = fio_buf2u64_be(block + 96);
  w[13] = fio_buf2u64_be(block + 104);
  w[14] = fio_buf2u64_be(block + 112);
  w[15] = fio_buf2u64_be(block + 120);

/* SHA-512 Sigma functions - using optimized helpers */
#define FIO___S512_S0(x) fio_xor_rrot3_64(x, 28, 34, 39)
#define FIO___S512_S1(x) fio_xor_rrot3_64(x, 14, 18, 41)
#define FIO___S512_s0(x) fio_xor_rrot2_shr_64(x, 1, 8, 7)
#define FIO___S512_s1(x) fio_xor_rrot2_shr_64(x, 19, 61, 6)

/* Optimized Ch and Maj - fewer operations */
#define FIO___S512_CH(e, f, g)  ((g) ^ ((e) & ((f) ^ (g))))
#define FIO___S512_MAJ(a, b, c) (((a) & (b)) | ((c) & ((a) | (b))))

/* SHA-512 round - rotates variables instead of copying */
#define FIO___SHA512_RND(a, b, c, d, e, f, g, h, k, w)                         \
  do {                                                                         \
    uint64_t t1 = (h) + FIO___S512_S1(e) + FIO___S512_CH(e, f, g) + (k) + (w); \
    uint64_t t2 = FIO___S512_S0(a) + FIO___S512_MAJ(a, b, c);                  \
    (d) += t1;                                                                 \
    (h) = t1 + t2;                                                             \
  } while (0)

/* Message schedule expansion */
#define FIO___SHA512_SCHED(i)                                                  \
  (w[(i)&15] += FIO___S512_s0(w[((i) + 1) & 15]) + w[((i) + 9) & 15] +         \
                FIO___S512_s1(w[((i) + 14) & 15]))

  /* Rounds 0-15 - use message words directly */
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[0], w[0]);
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[1], w[1]);
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[2], w[2]);
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[3], w[3]);
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[4], w[4]);
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[5], w[5]);
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[6], w[6]);
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[7], w[7]);
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[8], w[8]);
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[9], w[9]);
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[10], w[10]);
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[11], w[11]);
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[12], w[12]);
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[13], w[13]);
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[14], w[14]);
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[15], w[15]);

  /* Rounds 16-31 */
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[16], FIO___SHA512_SCHED(0));
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[17], FIO___SHA512_SCHED(1));
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[18], FIO___SHA512_SCHED(2));
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[19], FIO___SHA512_SCHED(3));
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[20], FIO___SHA512_SCHED(4));
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[21], FIO___SHA512_SCHED(5));
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[22], FIO___SHA512_SCHED(6));
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[23], FIO___SHA512_SCHED(7));
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[24], FIO___SHA512_SCHED(8));
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[25], FIO___SHA512_SCHED(9));
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[26], FIO___SHA512_SCHED(10));
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[27], FIO___SHA512_SCHED(11));
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[28], FIO___SHA512_SCHED(12));
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[29], FIO___SHA512_SCHED(13));
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[30], FIO___SHA512_SCHED(14));
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[31], FIO___SHA512_SCHED(15));

  /* Rounds 32-47 */
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[32], FIO___SHA512_SCHED(0));
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[33], FIO___SHA512_SCHED(1));
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[34], FIO___SHA512_SCHED(2));
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[35], FIO___SHA512_SCHED(3));
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[36], FIO___SHA512_SCHED(4));
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[37], FIO___SHA512_SCHED(5));
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[38], FIO___SHA512_SCHED(6));
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[39], FIO___SHA512_SCHED(7));
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[40], FIO___SHA512_SCHED(8));
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[41], FIO___SHA512_SCHED(9));
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[42], FIO___SHA512_SCHED(10));
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[43], FIO___SHA512_SCHED(11));
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[44], FIO___SHA512_SCHED(12));
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[45], FIO___SHA512_SCHED(13));
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[46], FIO___SHA512_SCHED(14));
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[47], FIO___SHA512_SCHED(15));

  /* Rounds 48-63 */
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[48], FIO___SHA512_SCHED(0));
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[49], FIO___SHA512_SCHED(1));
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[50], FIO___SHA512_SCHED(2));
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[51], FIO___SHA512_SCHED(3));
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[52], FIO___SHA512_SCHED(4));
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[53], FIO___SHA512_SCHED(5));
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[54], FIO___SHA512_SCHED(6));
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[55], FIO___SHA512_SCHED(7));
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[56], FIO___SHA512_SCHED(8));
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[57], FIO___SHA512_SCHED(9));
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[58], FIO___SHA512_SCHED(10));
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[59], FIO___SHA512_SCHED(11));
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[60], FIO___SHA512_SCHED(12));
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[61], FIO___SHA512_SCHED(13));
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[62], FIO___SHA512_SCHED(14));
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[63], FIO___SHA512_SCHED(15));

  /* Rounds 64-79 */
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[64], FIO___SHA512_SCHED(0));
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[65], FIO___SHA512_SCHED(1));
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[66], FIO___SHA512_SCHED(2));
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[67], FIO___SHA512_SCHED(3));
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[68], FIO___SHA512_SCHED(4));
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[69], FIO___SHA512_SCHED(5));
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[70], FIO___SHA512_SCHED(6));
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[71], FIO___SHA512_SCHED(7));
  FIO___SHA512_RND(a, b, c, d, e, f, g, hv, K[72], FIO___SHA512_SCHED(8));
  FIO___SHA512_RND(hv, a, b, c, d, e, f, g, K[73], FIO___SHA512_SCHED(9));
  FIO___SHA512_RND(g, hv, a, b, c, d, e, f, K[74], FIO___SHA512_SCHED(10));
  FIO___SHA512_RND(f, g, hv, a, b, c, d, e, K[75], FIO___SHA512_SCHED(11));
  FIO___SHA512_RND(e, f, g, hv, a, b, c, d, K[76], FIO___SHA512_SCHED(12));
  FIO___SHA512_RND(d, e, f, g, hv, a, b, c, K[77], FIO___SHA512_SCHED(13));
  FIO___SHA512_RND(c, d, e, f, g, hv, a, b, K[78], FIO___SHA512_SCHED(14));
  FIO___SHA512_RND(b, c, d, e, f, g, hv, a, K[79], FIO___SHA512_SCHED(15));

#undef FIO___S512_S0
#undef FIO___S512_S1
#undef FIO___S512_s0
#undef FIO___S512_s1
#undef FIO___S512_CH
#undef FIO___S512_MAJ
#undef FIO___SHA512_RND
#undef FIO___SHA512_SCHED

  /* Add to hash state */
  h->u64[0] += a;
  h->u64[1] += b;
  h->u64[2] += c;
  h->u64[3] += d;
  h->u64[4] += e;
  h->u64[5] += f;
  h->u64[6] += g;
  h->u64[7] += hv;
}

/** Feed data into the hash */
SFUNC void fio_sha512_consume(fio_sha512_s *restrict h,
                              const void *restrict data,
                              uint64_t len) {
  const uint8_t *r = (const uint8_t *)data;
  const size_t old_total = h->total_len;
  const size_t new_total = len + h->total_len;
  h->total_len = new_total;
  /* manage cache */
  if (old_total & 127) {
    const size_t offset = (old_total & 127);
    if (len + offset < 128) { /* not enough - copy to cache */
      fio_memcpy127x((h->cache.u8 + offset), r, len);
      return;
    }
    /* consume cache */
    const size_t byte2copy = 128UL - offset;
    fio_memcpy127x(h->cache.u8 + offset, r, byte2copy);
    fio___sha512_round(&h->hash, h->cache.u8);
    h->cache = (fio_u1024){0};
    r += byte2copy;
    len -= byte2copy;
  }
  const uint8_t *end = r + (len & (~(uint64_t)127ULL));
  while ((uintptr_t)r < (uintptr_t)end) {
    fio___sha512_round(&h->hash, r);
    r += 128;
  }
  fio_memcpy127x(h->cache.u64, r, len);
}

/** finalizes a fio_u512 with the SHA 512 hash. */
SFUNC fio_u512 fio_sha512_finalize(fio_sha512_s *h) {
  if (h->total_len == ((uint64_t)0ULL - 1ULL))
    return h->hash;
  const size_t total = h->total_len;
  const size_t remainder = total & 127;
  h->cache.u8[remainder] = 0x80U; /* set the 1 bit at the left most position */
  if ((remainder) > 112) { /* make sure there's room to attach `total_len` */
    fio___sha512_round(&h->hash, h->cache.u8);
    h->cache = (fio_u1024){0};
  }
  h->cache.u64[15] = fio_lton64((total << 3));
  fio___sha512_round(&h->hash, h->cache.u8);
  for (size_t i = 0; i < 8; ++i)
    h->hash.u64[i] = fio_ntol64(h->hash.u64[i]); /* back to/from big endien */
  h->total_len = ((uint64_t)0ULL - 1ULL);
  return h->hash;
}

/* *****************************************************************************
HMAC
***************************************************************************** */

/**
 * HMAC-SHA256, resulting in a 32 byte authentication code.
 *
 * Keys are limited to 64 bytes due to the design of the HMAC algorithm.
 */
SFUNC fio_u256 fio_sha256_hmac(const void *key,
                               uint64_t key_len,
                               const void *msg,
                               uint64_t msg_len) {
  fio_u512 k = {0};
  /* copy key - SHA-256 block size is 64 bytes */
  if (key_len > 64) {
    /* keys longer than block size are hashed first */
    k.u256[0] = fio_sha256(key, key_len);
    key_len = 32;
  } else {
    FIO_MEMCPY(k.u8, key, key_len);
  }
  /* prepare inner key (k XOR ipad) */
  for (size_t i = 0; i < 8; ++i)
    k.u64[i] ^= (uint64_t)0x3636363636363636ULL;
  /* inner hash = H((k XOR ipad) || msg) */
  fio_sha256_s inner = fio_sha256_init();
  fio_sha256_consume(&inner, k.u8, 64);
  fio_sha256_consume(&inner, msg, msg_len);
  fio_u256 inner_hash = fio_sha256_finalize(&inner);
  /* switch to outer key (k XOR opad) */
  for (size_t i = 0; i < 8; ++i)
    k.u64[i] ^=
        ((uint64_t)0x3636363636363636ULL ^ (uint64_t)0x5C5C5C5C5C5C5C5CULL);
  /* outer hash = H((k XOR opad) || inner_hash) */
  fio_sha256_s outer = fio_sha256_init();
  fio_sha256_consume(&outer, k.u8, 64);
  fio_sha256_consume(&outer, inner_hash.u8, 32);
  return fio_sha256_finalize(&outer);
}
/**
 * HMAC-SHA512, resulting in a 64 byte authentication code.
 *
 * Keys are limited to 128 bytes due to the design of the HMAC algorithm.
 */
SFUNC fio_u512 fio_sha512_hmac(const void *key,
                               uint64_t key_len,
                               const void *msg,
                               uint64_t msg_len) {
  fio_sha512_s inner = fio_sha512_init();
  fio_u2048 k;
  /* copy key */
  if (key_len > 128)
    goto key_too_long;
  if (key_len == 128)
    fio_memcpy128(k.u8, key);
  else {
    k.u1024[0] = (fio_u1024){0};
    fio_memcpy127x(k.u8, key, key_len);
  }
  /* prepare inner key */
  for (size_t i = 0; i < 16; ++i)
    k.u64[i] ^= (uint64_t)0x3636363636363636ULL;
  /* hash of inner key + msg
   * It's the same as the following, but easier for compilers to optimize:
   * fio_sha512_consume(&inner, k.u8, 128);
   * fio_sha512_consume(&inner, msg, msg_len); */
  {
    /* consume key block */
    fio___sha512_round(&inner.hash, k.u8);
    /* consume data */
    uint8_t *buf = (uint8_t *)msg;
    for (size_t i = 127; i < msg_len; (i += 128), (buf += 128))
      fio___sha512_round(&inner.hash, buf);
    if ((msg_len & 127)) {
      inner.cache = (fio_u1024){0};
      fio_memcpy127x(inner.cache.u8, buf, msg_len);
    }
    inner.total_len = 128 + msg_len;
  }
  /* finalize SHA512 and append to end of key */
  k.u512[2] = fio_sha512_finalize(&inner);
  /* switch key to outer key */
  for (size_t i = 0; i < 16; ++i)
    k.u64[i] ^=
        ((uint64_t)0x3636363636363636ULL ^ (uint64_t)0x5C5C5C5C5C5C5C5CULL);
  /* hash outer key with inner hash appended and return */
  return fio_sha512(k.u8, 192);

key_too_long:
  k.u512[3] = fio_sha512(key, key_len);
  return fio_sha512_hmac(k.u512[3].u8, sizeof(k.u512[3]), msg, msg_len);
}

/* *****************************************************************************
Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_SHA2 */
#undef FIO_SHA2
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_HKDF               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                    HKDF
                    HMAC-based Key Derivation Function (RFC 5869)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_HKDF) && !defined(H___FIO_HKDF___H)
#define H___FIO_HKDF___H

/* *****************************************************************************
HKDF API

Note: HKDF requires SHA-2 HMAC functions (fio_sha256_hmac, fio_sha512_hmac).
      Either define FIO_SHA2 before FIO_HKDF, or use FIO_CRYPTO to include all
      crypto modules.
***************************************************************************** */

/** SHA-256 hash length (32 bytes). */
#define FIO_HKDF_SHA256_HASH_LEN 32
/** SHA-384 hash length (48 bytes). */
#define FIO_HKDF_SHA384_HASH_LEN 48

/**
 * HKDF-Extract: PRK = HMAC-Hash(salt, IKM)
 *
 * Extracts a pseudorandom key (PRK) from input keying material (IKM).
 *
 * @param prk Output buffer (32 bytes for SHA-256, 48 for SHA-384)
 * @param salt Optional salt (if NULL, uses zeros of hash length)
 * @param salt_len Salt length in bytes
 * @param ikm Input keying material
 * @param ikm_len IKM length in bytes
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_hkdf_extract(void *restrict prk,
                            const void *restrict salt,
                            size_t salt_len,
                            const void *restrict ikm,
                            size_t ikm_len,
                            int use_sha384);

/**
 * HKDF-Expand: OKM = HKDF-Expand(PRK, info, L)
 *
 * Expands a pseudorandom key (PRK) into output keying material (OKM).
 *
 * @param okm Output keying material buffer
 * @param okm_len Desired output length (max 255 * hash_len)
 * @param prk Pseudorandom key from Extract (32 or 48 bytes)
 * @param prk_len PRK length (32 for SHA-256, 48 for SHA-384)
 * @param info Optional context/application info
 * @param info_len Info length in bytes
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_hkdf_expand(void *restrict okm,
                           size_t okm_len,
                           const void *restrict prk,
                           size_t prk_len,
                           const void *restrict info,
                           size_t info_len,
                           int use_sha384);

/**
 * Combined HKDF (Extract + Expand) - RFC 5869 Section 2.
 *
 * Derives keying material from input keying material using HKDF.
 *
 * @param okm Output keying material buffer
 * @param okm_len Desired output length (max 255 * hash_len)
 * @param salt Optional salt (if NULL, uses zeros of hash length)
 * @param salt_len Salt length in bytes
 * @param ikm Input keying material
 * @param ikm_len IKM length in bytes
 * @param info Optional context/application info
 * @param info_len Info length in bytes
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_hkdf(void *restrict okm,
                    size_t okm_len,
                    const void *restrict salt,
                    size_t salt_len,
                    const void *restrict ikm,
                    size_t ikm_len,
                    const void *restrict info,
                    size_t info_len,
                    int use_sha384);

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
HKDF-Extract Implementation
***************************************************************************** */

SFUNC void fio_hkdf_extract(void *restrict prk,
                            const void *restrict salt,
                            size_t salt_len,
                            const void *restrict ikm,
                            size_t ikm_len,
                            int use_sha384) {
  if (!prk || !ikm)
    return;

  if (use_sha384) {
    /* SHA-384: use SHA-512 HMAC, truncate to 48 bytes */
    /* If salt is NULL or empty, use hash_len zeros */
    uint8_t zero_salt[48] = {0};
    const void *actual_salt = salt;
    size_t actual_salt_len = salt_len;
    if (!salt || salt_len == 0) {
      actual_salt = zero_salt;
      actual_salt_len = 48;
    }
    /* PRK = HMAC-SHA384(salt, IKM) - using SHA-512 HMAC truncated */
    fio_u512 hmac_result =
        fio_sha512_hmac(actual_salt, actual_salt_len, ikm, ikm_len);
    /* Copy first 48 bytes (SHA-384 output) */
    FIO_MEMCPY(prk, hmac_result.u8, 48);
  } else {
    /* SHA-256 */
    uint8_t zero_salt[32] = {0};
    const void *actual_salt = salt;
    size_t actual_salt_len = salt_len;
    if (!salt || salt_len == 0) {
      actual_salt = zero_salt;
      actual_salt_len = 32;
    }
    /* PRK = HMAC-SHA256(salt, IKM) */
    fio_u256 hmac_result =
        fio_sha256_hmac(actual_salt, actual_salt_len, ikm, ikm_len);
    FIO_MEMCPY(prk, hmac_result.u8, 32);
  }
}

/* *****************************************************************************
HKDF-Expand Implementation
***************************************************************************** */

SFUNC void fio_hkdf_expand(void *restrict okm,
                           size_t okm_len,
                           const void *restrict prk,
                           size_t prk_len,
                           const void *restrict info,
                           size_t info_len,
                           int use_sha384) {
  if (!okm || !prk || okm_len == 0)
    return;

  const size_t hash_len = use_sha384 ? 48 : 32;
  const size_t max_okm_len = 255 * hash_len;

  /* Clamp output length to maximum allowed */
  if (okm_len > max_okm_len)
    okm_len = max_okm_len;

  uint8_t *out = (uint8_t *)okm;
  uint8_t t_prev[64] = {0}; /* T(i-1), max 64 bytes for SHA-512 */
  size_t t_prev_len = 0;
  uint8_t counter = 1;
  size_t remaining = okm_len;

  /* N = ceil(L/HashLen) iterations */
  while (remaining > 0) {
    /* T(i) = HMAC-Hash(PRK, T(i-1) || info || counter) */
    /* Build input: T(i-1) || info || counter */
    size_t input_len = t_prev_len + info_len + 1;
    uint8_t *input = (uint8_t *)FIO_MEM_REALLOC(NULL, 0, input_len, 0);
    if (!input)
      return;

    size_t offset = 0;
    if (t_prev_len > 0) {
      FIO_MEMCPY(input, t_prev, t_prev_len);
      offset = t_prev_len;
    }
    if (info && info_len > 0) {
      FIO_MEMCPY(input + offset, info, info_len);
      offset += info_len;
    }
    input[offset] = counter;

    if (use_sha384) {
      fio_u512 hmac_result = fio_sha512_hmac(prk, prk_len, input, input_len);
      FIO_MEMCPY(t_prev, hmac_result.u8, 48);
      t_prev_len = 48;
    } else {
      fio_u256 hmac_result = fio_sha256_hmac(prk, prk_len, input, input_len);
      FIO_MEMCPY(t_prev, hmac_result.u8, 32);
      t_prev_len = 32;
    }

    FIO_MEM_FREE(input, input_len);

    /* Copy to output */
    size_t to_copy = (remaining < hash_len) ? remaining : hash_len;
    FIO_MEMCPY(out, t_prev, to_copy);
    out += to_copy;
    remaining -= to_copy;
    ++counter;
  }
}

/* *****************************************************************************
Combined HKDF Implementation
***************************************************************************** */

SFUNC void fio_hkdf(void *restrict okm,
                    size_t okm_len,
                    const void *restrict salt,
                    size_t salt_len,
                    const void *restrict ikm,
                    size_t ikm_len,
                    const void *restrict info,
                    size_t info_len,
                    int use_sha384) {
  if (!okm || !ikm || okm_len == 0)
    return;

  const size_t prk_len = use_sha384 ? 48 : 32;
  uint8_t prk[48]; /* Max size for SHA-384 */

  /* Step 1: Extract */
  fio_hkdf_extract(prk, salt, salt_len, ikm, ikm_len, use_sha384);

  /* Step 2: Expand */
  fio_hkdf_expand(okm, okm_len, prk, prk_len, info, info_len, use_sha384);
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_HKDF */
#undef FIO_HKDF
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_SHA3               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                    SHA-3
                    SHA3-224, SHA3-256, SHA3-384, SHA3-512
                          SHAKE128, SHAKE256




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_SHA3) && !defined(H___FIO_SHA3___H)
#define H___FIO_SHA3___H
/* *****************************************************************************
SHA-3 API
***************************************************************************** */

/** Keccak state (1600 bits = 200 bytes = 25 x 64-bit words) */
typedef struct {
  uint64_t state[25];
  uint8_t buf[200]; /* rate buffer (max rate = 1600 - 2*capacity) */
  size_t buflen;    /* bytes in buffer */
  size_t rate;      /* rate in bytes */
  size_t outlen;    /* output length in bytes (0 for SHAKE) */
  uint8_t delim;    /* domain separation byte */
} fio_sha3_s;

/* *****************************************************************************
SHA3 Fixed-Output Functions API
***************************************************************************** */

/** Initialize SHA3-224 (28-byte output). */
FIO_IFUNC fio_sha3_s fio_sha3_224_init(void);
/** Initialize SHA3-256 (32-byte output). */
FIO_IFUNC fio_sha3_s fio_sha3_256_init(void);
/** Initialize SHA3-384 (48-byte output). */
FIO_IFUNC fio_sha3_s fio_sha3_384_init(void);
/** Initialize SHA3-512 (64-byte output). */
FIO_IFUNC fio_sha3_s fio_sha3_512_init(void);

/** Feed data into SHA3 hash. */
SFUNC void fio_sha3_consume(fio_sha3_s *restrict h,
                            const void *restrict data,
                            size_t len);

/** Finalize SHA3 hash. Writes h->outlen bytes to out. */
SFUNC void fio_sha3_finalize(fio_sha3_s *restrict h, void *restrict out);

/** Simple SHA3-224 (28-byte output). */
SFUNC void fio_sha3_224(void *restrict out,
                        const void *restrict data,
                        size_t len);

/** Simple SHA3-256 (32-byte output). */
SFUNC void fio_sha3_256(void *restrict out,
                        const void *restrict data,
                        size_t len);

/** Simple SHA3-384 (48-byte output). */
SFUNC void fio_sha3_384(void *restrict out,
                        const void *restrict data,
                        size_t len);

/** Simple SHA3-512 (64-byte output). */
SFUNC void fio_sha3_512(void *restrict out,
                        const void *restrict data,
                        size_t len);

/* *****************************************************************************
SHAKE Extendable-Output Functions API
***************************************************************************** */

/** Initialize SHAKE128 (variable output length). */
FIO_IFUNC fio_sha3_s fio_shake128_init(void);
/** Initialize SHAKE256 (variable output length). */
FIO_IFUNC fio_sha3_s fio_shake256_init(void);

/** Feed data into SHAKE. */
#define fio_shake_consume fio_sha3_consume

/** Squeeze output from SHAKE. Can be called multiple times. */
SFUNC void fio_shake_squeeze(fio_sha3_s *restrict h,
                             void *restrict out,
                             size_t outlen);

/** Simple SHAKE128 with specified output length. */
SFUNC void fio_shake128(void *restrict out,
                        size_t outlen,
                        const void *restrict data,
                        size_t len);

/** Simple SHAKE256 with specified output length. */
SFUNC void fio_shake256(void *restrict out,
                        size_t outlen,
                        const void *restrict data,
                        size_t len);

/* *****************************************************************************
Implementation - inline functions
***************************************************************************** */

/** Initialize SHA3-224. */
FIO_IFUNC fio_sha3_s fio_sha3_224_init(void) {
  fio_sha3_s h = {0};
  h.rate = 144; /* (1600 - 2*224) / 8 = 144 */
  h.outlen = 28;
  h.delim = 0x06; /* SHA3 domain separator */
  return h;
}

/** Initialize SHA3-256. */
FIO_IFUNC fio_sha3_s fio_sha3_256_init(void) {
  fio_sha3_s h = {0};
  h.rate = 136; /* (1600 - 2*256) / 8 = 136 */
  h.outlen = 32;
  h.delim = 0x06;
  return h;
}

/** Initialize SHA3-384. */
FIO_IFUNC fio_sha3_s fio_sha3_384_init(void) {
  fio_sha3_s h = {0};
  h.rate = 104; /* (1600 - 2*384) / 8 = 104 */
  h.outlen = 48;
  h.delim = 0x06;
  return h;
}

/** Initialize SHA3-512. */
FIO_IFUNC fio_sha3_s fio_sha3_512_init(void) {
  fio_sha3_s h = {0};
  h.rate = 72; /* (1600 - 2*512) / 8 = 72 */
  h.outlen = 64;
  h.delim = 0x06;
  return h;
}

/** Initialize SHAKE128. */
FIO_IFUNC fio_sha3_s fio_shake128_init(void) {
  fio_sha3_s h = {0};
  h.rate = 168;   /* (1600 - 2*128) / 8 = 168 */
  h.outlen = 0;   /* variable output */
  h.delim = 0x1F; /* SHAKE domain separator */
  return h;
}

/** Initialize SHAKE256. */
FIO_IFUNC fio_sha3_s fio_shake256_init(void) {
  fio_sha3_s h = {0};
  h.rate = 136; /* (1600 - 2*256) / 8 = 136 */
  h.outlen = 0;
  h.delim = 0x1F;
  return h;
}

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Keccak-f[1600] Permutation
***************************************************************************** */

/* Keccak round constants */
static const uint64_t fio___keccak_rc[24] = {
    0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808aULL,
    0x8000000080008000ULL, 0x000000000000808bULL, 0x0000000080000001ULL,
    0x8000000080008081ULL, 0x8000000000008009ULL, 0x000000000000008aULL,
    0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000aULL,
    0x000000008000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL,
    0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL,
    0x000000000000800aULL, 0x800000008000000aULL, 0x8000000080008081ULL,
    0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL};

/* Keccak rotation offsets */
static const uint8_t fio___keccak_rot[25] = {
    0,  1,  62, 28, 27, /* row 0 */
    36, 44, 6,  55, 20, /* row 1 */
    3,  10, 43, 25, 39, /* row 2 */
    41, 45, 15, 21, 8,  /* row 3 */
    18, 2,  61, 56, 14  /* row 4 */
};

/* Keccak-f[1600] permutation */
FIO_IFUNC void fio___keccak_f1600(uint64_t *state) {
  uint64_t C[5], D[5], B[25];

  for (size_t round = 0; round < 24; ++round) {
    /* Theta step */
    C[0] = state[0] ^ state[5] ^ state[10] ^ state[15] ^ state[20];
    C[1] = state[1] ^ state[6] ^ state[11] ^ state[16] ^ state[21];
    C[2] = state[2] ^ state[7] ^ state[12] ^ state[17] ^ state[22];
    C[3] = state[3] ^ state[8] ^ state[13] ^ state[18] ^ state[23];
    C[4] = state[4] ^ state[9] ^ state[14] ^ state[19] ^ state[24];

    D[0] = C[4] ^ fio_lrot64(C[1], 1);
    D[1] = C[0] ^ fio_lrot64(C[2], 1);
    D[2] = C[1] ^ fio_lrot64(C[3], 1);
    D[3] = C[2] ^ fio_lrot64(C[4], 1);
    D[4] = C[3] ^ fio_lrot64(C[0], 1);

    for (size_t i = 0; i < 25; i += 5) {
      state[i + 0] ^= D[0];
      state[i + 1] ^= D[1];
      state[i + 2] ^= D[2];
      state[i + 3] ^= D[3];
      state[i + 4] ^= D[4];
    }

    /* Rho and Pi steps combined */
    B[0] = state[0];
    B[1] = fio_lrot64(state[6], 44);
    B[2] = fio_lrot64(state[12], 43);
    B[3] = fio_lrot64(state[18], 21);
    B[4] = fio_lrot64(state[24], 14);
    B[5] = fio_lrot64(state[3], 28);
    B[6] = fio_lrot64(state[9], 20);
    B[7] = fio_lrot64(state[10], 3);
    B[8] = fio_lrot64(state[16], 45);
    B[9] = fio_lrot64(state[22], 61);
    B[10] = fio_lrot64(state[1], 1);
    B[11] = fio_lrot64(state[7], 6);
    B[12] = fio_lrot64(state[13], 25);
    B[13] = fio_lrot64(state[19], 8);
    B[14] = fio_lrot64(state[20], 18);
    B[15] = fio_lrot64(state[4], 27);
    B[16] = fio_lrot64(state[5], 36);
    B[17] = fio_lrot64(state[11], 10);
    B[18] = fio_lrot64(state[17], 15);
    B[19] = fio_lrot64(state[23], 56);
    B[20] = fio_lrot64(state[2], 62);
    B[21] = fio_lrot64(state[8], 55);
    B[22] = fio_lrot64(state[14], 39);
    B[23] = fio_lrot64(state[15], 41);
    B[24] = fio_lrot64(state[21], 2);

    /* Chi step */
    for (size_t i = 0; i < 25; i += 5) {
      state[i + 0] = B[i + 0] ^ ((~B[i + 1]) & B[i + 2]);
      state[i + 1] = B[i + 1] ^ ((~B[i + 2]) & B[i + 3]);
      state[i + 2] = B[i + 2] ^ ((~B[i + 3]) & B[i + 4]);
      state[i + 3] = B[i + 3] ^ ((~B[i + 4]) & B[i + 0]);
      state[i + 4] = B[i + 4] ^ ((~B[i + 0]) & B[i + 1]);
    }

    /* Iota step */
    state[0] ^= fio___keccak_rc[round];
  }
}

/* Absorb a block into the state */
FIO_IFUNC void fio___sha3_absorb(fio_sha3_s *restrict h) {
  /* XOR rate bytes into state (little-endian) */
  size_t rate_words = h->rate / 8;
  for (size_t i = 0; i < rate_words; ++i)
    h->state[i] ^= fio_buf2u64_le(h->buf + i * 8);
  fio___keccak_f1600(h->state);
}

/** Feed data into SHA3 hash. */
SFUNC void fio_sha3_consume(fio_sha3_s *restrict h,
                            const void *restrict data,
                            size_t len) {
  const uint8_t *p = (const uint8_t *)data;

  /* Fill buffer if partially filled */
  if (h->buflen > 0) {
    size_t fill = h->rate - h->buflen;
    if (len < fill) {
      FIO_MEMCPY(h->buf + h->buflen, p, len);
      h->buflen += len;
      return;
    }
    FIO_MEMCPY(h->buf + h->buflen, p, fill);
    fio___sha3_absorb(h);
    h->buflen = 0;
    p += fill;
    len -= fill;
  }

  /* Process full blocks */
  while (len >= h->rate) {
    FIO_MEMCPY(h->buf, p, h->rate);
    fio___sha3_absorb(h);
    p += h->rate;
    len -= h->rate;
  }

  /* Buffer remaining data */
  if (len > 0) {
    FIO_MEMCPY(h->buf, p, len);
    h->buflen = len;
  }
}

/** Finalize SHA3 hash (fixed output). */
SFUNC void fio_sha3_finalize(fio_sha3_s *restrict h, void *restrict out) {
  /* Pad: append domain separator, then 10*1 padding */
  FIO_MEMSET(h->buf + h->buflen, 0, h->rate - h->buflen);
  h->buf[h->buflen] = h->delim;
  h->buf[h->rate - 1] |= 0x80;

  /* Final absorb */
  fio___sha3_absorb(h);

  /* Squeeze output (little-endian) */
  uint8_t *o = (uint8_t *)out;
  for (size_t i = 0; i < h->outlen; ++i)
    o[i] = (uint8_t)(h->state[i / 8] >> (8 * (i % 8)));
}

/** Squeeze output from SHAKE (can be called multiple times). */
SFUNC void fio_shake_squeeze(fio_sha3_s *restrict h,
                             void *restrict out,
                             size_t outlen) {
  uint8_t *o = (uint8_t *)out;

  /* First call: finalize padding */
  if (h->outlen == 0) {
    FIO_MEMSET(h->buf + h->buflen, 0, h->rate - h->buflen);
    h->buf[h->buflen] = h->delim;
    h->buf[h->rate - 1] |= 0x80;
    fio___sha3_absorb(h);
    h->buflen = 0;
    h->outlen = 1; /* Mark as finalized */
  }

  /* Squeeze output */
  while (outlen > 0) {
    if (h->buflen == 0) {
      /* Output from state */
      size_t to_copy = (outlen < h->rate) ? outlen : h->rate;
      for (size_t i = 0; i < to_copy; ++i)
        o[i] = (uint8_t)(h->state[i / 8] >> (8 * (i % 8)));
      o += to_copy;
      outlen -= to_copy;
      if (outlen > 0) {
        fio___keccak_f1600(h->state);
      }
    } else {
      /* Should not happen in normal use */
      h->buflen = 0;
    }
  }
}

/** Simple SHA3-224. */
SFUNC void fio_sha3_224(void *restrict out,
                        const void *restrict data,
                        size_t len) {
  fio_sha3_s h = fio_sha3_224_init();
  fio_sha3_consume(&h, data, len);
  fio_sha3_finalize(&h, out);
}

/** Simple SHA3-256. */
SFUNC void fio_sha3_256(void *restrict out,
                        const void *restrict data,
                        size_t len) {
  fio_sha3_s h = fio_sha3_256_init();
  fio_sha3_consume(&h, data, len);
  fio_sha3_finalize(&h, out);
}

/** Simple SHA3-384. */
SFUNC void fio_sha3_384(void *restrict out,
                        const void *restrict data,
                        size_t len) {
  fio_sha3_s h = fio_sha3_384_init();
  fio_sha3_consume(&h, data, len);
  fio_sha3_finalize(&h, out);
}

/** Simple SHA3-512. */
SFUNC void fio_sha3_512(void *restrict out,
                        const void *restrict data,
                        size_t len) {
  fio_sha3_s h = fio_sha3_512_init();
  fio_sha3_consume(&h, data, len);
  fio_sha3_finalize(&h, out);
}

/** Simple SHAKE128. */
SFUNC void fio_shake128(void *restrict out,
                        size_t outlen,
                        const void *restrict data,
                        size_t len) {
  fio_sha3_s h = fio_shake128_init();
  fio_sha3_consume(&h, data, len);
  fio_shake_squeeze(&h, out, outlen);
}

/** Simple SHAKE256. */
SFUNC void fio_shake256(void *restrict out,
                        size_t outlen,
                        const void *restrict data,
                        size_t len) {
  fio_sha3_s h = fio_shake256_init();
  fio_sha3_consume(&h, data, len);
  fio_shake_squeeze(&h, out, outlen);
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_SHA3 */
#undef FIO_SHA3
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_AES                /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                              AES & AES-GCM




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_AES) && !defined(H___FIO_AES___H)
#define H___FIO_AES___H 1

/* *****************************************************************************
AES-GCM API

AES-GCM provides authenticated encryption with associated data (AEAD).
This is the most common cipher suite for TLS 1.3.

Supported key sizes:
- AES-128-GCM: 16-byte key (128 bits)
- AES-256-GCM: 32-byte key (256 bits)

The nonce (IV) MUST be 12 bytes (96 bits) for GCM mode.
The authentication tag is 16 bytes (128 bits).

API matches fio_chacha20_poly1305 for easy function pointer substitution.
***************************************************************************** */

/**
 * Performs in-place AES-128-GCM encryption with authentication.
 *
 * * `mac`    MUST point to a buffer with (at least) 16 available bytes.
 * * `key`    MUST point to a 128 bit key (16 Bytes).
 * * `nonce`  MUST point to a 96 bit nonce (12 Bytes).
 * * `ad`     MAY be omitted, will NOT be encrypted.
 * * `data`   MAY be omitted, WILL be encrypted.
 */
SFUNC void fio_aes128_gcm_enc(void *restrict mac,
                              void *restrict data,
                              size_t len,
                              const void *ad,
                              size_t adlen,
                              const void *key,
                              const void *nonce);

/**
 * Performs in-place AES-128-GCM decryption with authentication verification.
 *
 * * `mac`    MUST point to a buffer with the 16 byte MAC to verify.
 * * `key`    MUST point to a 128 bit key (16 Bytes).
 * * `nonce`  MUST point to a 96 bit nonce (12 Bytes).
 * * `ad`     MAY be omitted ONLY IF originally omitted.
 * * `data`   MAY be omitted, WILL be decrypted.
 *
 * Returns `-1` on error (authentication failed).
 */
SFUNC int fio_aes128_gcm_dec(void *restrict mac,
                             void *restrict data,
                             size_t len,
                             const void *ad,
                             size_t adlen,
                             const void *key,
                             const void *nonce);

/**
 * Performs in-place AES-256-GCM encryption with authentication.
 *
 * * `mac`    MUST point to a buffer with (at least) 16 available bytes.
 * * `key`    MUST point to a 256 bit key (32 Bytes).
 * * `nonce`  MUST point to a 96 bit nonce (12 Bytes).
 * * `ad`     MAY be omitted, will NOT be encrypted.
 * * `data`   MAY be omitted, WILL be encrypted.
 */
SFUNC void fio_aes256_gcm_enc(void *restrict mac,
                              void *restrict data,
                              size_t len,
                              const void *ad,
                              size_t adlen,
                              const void *key,
                              const void *nonce);

/**
 * Performs in-place AES-256-GCM decryption with authentication verification.
 *
 * * `mac`    MUST point to a buffer with the 16 byte MAC to verify.
 * * `key`    MUST point to a 256 bit key (32 Bytes).
 * * `nonce`  MUST point to a 96 bit nonce (12 Bytes).
 * * `ad`     MAY be omitted ONLY IF originally omitted.
 * * `data`   MAY be omitted, WILL be decrypted.
 *
 * Returns `-1` on error (authentication failed).
 */
SFUNC int fio_aes256_gcm_dec(void *restrict mac,
                             void *restrict data,
                             size_t len,
                             const void *ad,
                             size_t adlen,
                             const void *key,
                             const void *nonce);

/* *****************************************************************************
AES-GCM Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Hardware Intrinsics Detection
***************************************************************************** */

/* x86/x64 AES-NI + PCLMULQDQ detection */
#if defined(FIO___HAS_X86_INTRIN) && defined(__AES__) && defined(__PCLMUL__)
#define FIO___HAS_X86_AES_INTRIN 1
#endif

/* ARM Crypto Extensions detection */
#if defined(FIO___HAS_ARM_INTRIN)
#define FIO___HAS_ARM_AES_INTRIN 1
#endif

/* *****************************************************************************
x86 AES-NI Implementation
***************************************************************************** */
#if defined(FIO___HAS_X86_AES_INTRIN) && FIO___HAS_X86_AES_INTRIN

/* AES-128 key expansion using AES-NI */
FIO_IFUNC __m128i fio___aesni_key_expand_128(__m128i key, __m128i keygen) {
  keygen = _mm_shuffle_epi32(keygen, 0xFF);
  key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
  key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
  key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
  return _mm_xor_si128(key, keygen);
}

FIO_IFUNC void fio___aesni_gcm128_init(__m128i *rk,
                                       __m128i *h,
                                       const uint8_t key[16]) {
  __m128i k = _mm_loadu_si128((const __m128i *)key);
  rk[0] = k;
  rk[1] =
      fio___aesni_key_expand_128(rk[0], _mm_aeskeygenassist_si128(rk[0], 0x01));
  rk[2] =
      fio___aesni_key_expand_128(rk[1], _mm_aeskeygenassist_si128(rk[1], 0x02));
  rk[3] =
      fio___aesni_key_expand_128(rk[2], _mm_aeskeygenassist_si128(rk[2], 0x04));
  rk[4] =
      fio___aesni_key_expand_128(rk[3], _mm_aeskeygenassist_si128(rk[3], 0x08));
  rk[5] =
      fio___aesni_key_expand_128(rk[4], _mm_aeskeygenassist_si128(rk[4], 0x10));
  rk[6] =
      fio___aesni_key_expand_128(rk[5], _mm_aeskeygenassist_si128(rk[5], 0x20));
  rk[7] =
      fio___aesni_key_expand_128(rk[6], _mm_aeskeygenassist_si128(rk[6], 0x40));
  rk[8] =
      fio___aesni_key_expand_128(rk[7], _mm_aeskeygenassist_si128(rk[7], 0x80));
  rk[9] =
      fio___aesni_key_expand_128(rk[8], _mm_aeskeygenassist_si128(rk[8], 0x1B));
  rk[10] =
      fio___aesni_key_expand_128(rk[9], _mm_aeskeygenassist_si128(rk[9], 0x36));

  /* Compute H = AES(K, 0^128) */
  __m128i zero = _mm_setzero_si128();
  __m128i tmp = _mm_xor_si128(zero, rk[0]);
  tmp = _mm_aesenc_si128(tmp, rk[1]);
  tmp = _mm_aesenc_si128(tmp, rk[2]);
  tmp = _mm_aesenc_si128(tmp, rk[3]);
  tmp = _mm_aesenc_si128(tmp, rk[4]);
  tmp = _mm_aesenc_si128(tmp, rk[5]);
  tmp = _mm_aesenc_si128(tmp, rk[6]);
  tmp = _mm_aesenc_si128(tmp, rk[7]);
  tmp = _mm_aesenc_si128(tmp, rk[8]);
  tmp = _mm_aesenc_si128(tmp, rk[9]);
  *h = _mm_aesenclast_si128(tmp, rk[10]);
}

/* AES-256 key expansion helpers */
FIO_IFUNC __m128i fio___aesni_key_expand_256_1(__m128i key, __m128i keygen) {
  keygen = _mm_shuffle_epi32(keygen, 0xFF);
  key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
  key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
  key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
  return _mm_xor_si128(key, keygen);
}

FIO_IFUNC __m128i fio___aesni_key_expand_256_2(__m128i key, __m128i keygen) {
  keygen = _mm_shuffle_epi32(keygen, 0xAA);
  key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
  key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
  key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
  return _mm_xor_si128(key, keygen);
}

FIO_IFUNC void fio___aesni_gcm256_init(__m128i *rk,
                                       __m128i *h,
                                       const uint8_t key[32]) {
  __m128i k1 = _mm_loadu_si128((const __m128i *)key);
  __m128i k2 = _mm_loadu_si128((const __m128i *)(key + 16));
  rk[0] = k1;
  rk[1] = k2;
  rk[2] = fio___aesni_key_expand_256_1(rk[0],
                                       _mm_aeskeygenassist_si128(rk[1], 0x01));
  rk[3] = fio___aesni_key_expand_256_2(rk[1],
                                       _mm_aeskeygenassist_si128(rk[2], 0x00));
  rk[4] = fio___aesni_key_expand_256_1(rk[2],
                                       _mm_aeskeygenassist_si128(rk[3], 0x02));
  rk[5] = fio___aesni_key_expand_256_2(rk[3],
                                       _mm_aeskeygenassist_si128(rk[4], 0x00));
  rk[6] = fio___aesni_key_expand_256_1(rk[4],
                                       _mm_aeskeygenassist_si128(rk[5], 0x04));
  rk[7] = fio___aesni_key_expand_256_2(rk[5],
                                       _mm_aeskeygenassist_si128(rk[6], 0x00));
  rk[8] = fio___aesni_key_expand_256_1(rk[6],
                                       _mm_aeskeygenassist_si128(rk[7], 0x08));
  rk[9] = fio___aesni_key_expand_256_2(rk[7],
                                       _mm_aeskeygenassist_si128(rk[8], 0x00));
  rk[10] = fio___aesni_key_expand_256_1(rk[8],
                                        _mm_aeskeygenassist_si128(rk[9], 0x10));
  rk[11] =
      fio___aesni_key_expand_256_2(rk[9],
                                   _mm_aeskeygenassist_si128(rk[10], 0x00));
  rk[12] =
      fio___aesni_key_expand_256_1(rk[10],
                                   _mm_aeskeygenassist_si128(rk[11], 0x20));
  rk[13] =
      fio___aesni_key_expand_256_2(rk[11],
                                   _mm_aeskeygenassist_si128(rk[12], 0x00));
  rk[14] =
      fio___aesni_key_expand_256_1(rk[12],
                                   _mm_aeskeygenassist_si128(rk[13], 0x40));

  /* Compute H = AES(K, 0^128) */
  __m128i zero = _mm_setzero_si128();
  __m128i tmp = _mm_xor_si128(zero, rk[0]);
  for (int i = 1; i < 14; ++i)
    tmp = _mm_aesenc_si128(tmp, rk[i]);
  *h = _mm_aesenclast_si128(tmp, rk[14]);
}

/* AES-NI block encryption */
FIO_IFUNC __m128i fio___aesni_encrypt128(__m128i block, const __m128i *rk) {
  block = _mm_xor_si128(block, rk[0]);
  block = _mm_aesenc_si128(block, rk[1]);
  block = _mm_aesenc_si128(block, rk[2]);
  block = _mm_aesenc_si128(block, rk[3]);
  block = _mm_aesenc_si128(block, rk[4]);
  block = _mm_aesenc_si128(block, rk[5]);
  block = _mm_aesenc_si128(block, rk[6]);
  block = _mm_aesenc_si128(block, rk[7]);
  block = _mm_aesenc_si128(block, rk[8]);
  block = _mm_aesenc_si128(block, rk[9]);
  return _mm_aesenclast_si128(block, rk[10]);
}

FIO_IFUNC __m128i fio___aesni_encrypt256(__m128i block, const __m128i *rk) {
  block = _mm_xor_si128(block, rk[0]);
  for (int i = 1; i < 14; ++i)
    block = _mm_aesenc_si128(block, rk[i]);
  return _mm_aesenclast_si128(block, rk[14]);
}

/* GHASH multiplication using PCLMULQDQ (carryless multiply) */
FIO_IFUNC __m128i fio___ghash_mult_pclmul(__m128i a, __m128i b) {
  /* Perform carryless multiplication */
  __m128i tmp2 = _mm_clmulepi64_si128(a, b, 0x00);
  __m128i tmp3 = _mm_clmulepi64_si128(a, b, 0x01);
  __m128i tmp4 = _mm_clmulepi64_si128(a, b, 0x10);
  __m128i tmp5 = _mm_clmulepi64_si128(a, b, 0x11);

  tmp3 = _mm_xor_si128(tmp3, tmp4);
  tmp4 = _mm_slli_si128(tmp3, 8);
  tmp3 = _mm_srli_si128(tmp3, 8);
  tmp2 = _mm_xor_si128(tmp2, tmp4);
  tmp5 = _mm_xor_si128(tmp5, tmp3);

  /* Reduction modulo x^128 + x^7 + x^2 + x + 1 */
  __m128i tmp6 = _mm_srli_epi32(tmp2, 31);
  __m128i tmp7 = _mm_srli_epi32(tmp2, 30);
  __m128i tmp8 = _mm_srli_epi32(tmp2, 25);
  tmp6 = _mm_xor_si128(tmp6, tmp7);
  tmp6 = _mm_xor_si128(tmp6, tmp8);
  tmp7 = _mm_shuffle_epi32(tmp6, 0x93);
  tmp6 = _mm_and_si128(tmp7, _mm_set_epi32(0, ~0, ~0, ~0));
  tmp7 = _mm_and_si128(tmp7, _mm_set_epi32(~0, 0, 0, 0));
  tmp2 = _mm_xor_si128(tmp2, tmp6);
  tmp5 = _mm_xor_si128(tmp5, tmp7);

  __m128i tmp9 = _mm_slli_epi32(tmp2, 1);
  tmp2 = _mm_xor_si128(tmp2, tmp9);
  tmp9 = _mm_slli_epi32(tmp2, 2);
  tmp2 = _mm_xor_si128(tmp2, tmp9);
  tmp9 = _mm_slli_epi32(tmp2, 7);
  tmp2 = _mm_xor_si128(tmp2, tmp9);
  tmp7 = _mm_srli_si128(tmp2, 12);
  tmp2 = _mm_slli_si128(tmp2, 4);
  tmp5 = _mm_xor_si128(tmp5, tmp2);
  tmp5 = _mm_xor_si128(tmp5, tmp7);

  return tmp5;
}

/* Byte-swap for GCM (big-endian) */
FIO_IFUNC __m128i fio___bswap128(__m128i x) {
  return _mm_shuffle_epi8(
      x,
      _mm_set_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15));
}

/* Precompute H powers for parallel GHASH: H, H, H, H */
FIO_IFUNC void fio___x86_ghash_precompute(__m128i h, __m128i *htbl) {
  htbl[0] = h;                                         /* H */
  htbl[1] = fio___ghash_mult_pclmul(h, h);             /* H */
  htbl[2] = fio___ghash_mult_pclmul(htbl[1], h);       /* H */
  htbl[3] = fio___ghash_mult_pclmul(htbl[1], htbl[1]); /* H */
}

/* 4-way parallel GHASH: compute (X0H) ^ (X1H) ^ (X2H) ^ (X3H) */
FIO_IFUNC __m128i fio___x86_ghash_mult4(__m128i x0,
                                        __m128i x1,
                                        __m128i x2,
                                        __m128i x3,
                                        const __m128i *htbl) {
  __m128i r0 = fio___ghash_mult_pclmul(x0, htbl[3]); /* X0  H */
  __m128i r1 = fio___ghash_mult_pclmul(x1, htbl[2]); /* X1  H */
  __m128i r2 = fio___ghash_mult_pclmul(x2, htbl[1]); /* X2  H */
  __m128i r3 = fio___ghash_mult_pclmul(x3, htbl[0]); /* X3  H  */
  return _mm_xor_si128(_mm_xor_si128(r0, r1), _mm_xor_si128(r2, r3));
}

/* Increment counter (last 32 bits, big-endian) */
FIO_IFUNC __m128i fio___gcm_inc_ctr(__m128i ctr) {
  /* Counter is in bytes 12-15 (big-endian) */
  __m128i one = _mm_set_epi32(1, 0, 0, 0);
  ctr = fio___bswap128(ctr);
  ctr = _mm_add_epi32(ctr, one);
  return fio___bswap128(ctr);
}

SFUNC void fio_aes128_gcm_enc(void *restrict mac,
                              void *restrict data,
                              size_t len,
                              const void *ad,
                              size_t adlen,
                              const void *key,
                              const void *nonce) {
  __m128i rk[11];
  __m128i h, htbl[4], tag, ctr, j0;
  uint8_t *p = (uint8_t *)data;
  const uint8_t *aad = (const uint8_t *)ad;
  size_t orig_len = len;
  size_t orig_adlen = adlen;

  fio___aesni_gcm128_init(rk, &h, (const uint8_t *)key);
  h = fio___bswap128(h);

  /* Precompute H powers for parallel GHASH */
  fio___x86_ghash_precompute(h, htbl);

  uint8_t j0_bytes[16] = {0};
  FIO_MEMCPY(j0_bytes, nonce, 12);
  j0_bytes[15] = 1;
  j0 = _mm_loadu_si128((const __m128i *)j0_bytes);
  ctr = j0;
  tag = _mm_setzero_si128();

  /* GHASH over AAD - process 4 blocks at a time */
  while (adlen >= 64) {
    __m128i a0 = fio___bswap128(_mm_loadu_si128((const __m128i *)aad));
    __m128i a1 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 16)));
    __m128i a2 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 32)));
    __m128i a3 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 48)));
    a0 = _mm_xor_si128(tag, a0);
    tag = fio___x86_ghash_mult4(a0, a1, a2, a3, htbl);
    aad += 64;
    adlen -= 64;
  }
  while (adlen >= 16) {
    __m128i aad_block = _mm_loadu_si128((const __m128i *)aad);
    aad_block = fio___bswap128(aad_block);
    tag = _mm_xor_si128(tag, aad_block);
    tag = fio___ghash_mult_pclmul(tag, h);
    aad += 16;
    adlen -= 16;
  }
  if (adlen > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, aad, adlen);
    __m128i aad_block = _mm_loadu_si128((const __m128i *)tmp);
    aad_block = fio___bswap128(aad_block);
    tag = _mm_xor_si128(tag, aad_block);
    tag = fio___ghash_mult_pclmul(tag, h);
  }

  /* Encrypt and GHASH - process 4 blocks at a time */
  while (len >= 64) {
    /* Generate 4 counters */
    __m128i ctr0 = fio___gcm_inc_ctr(ctr);
    __m128i ctr1 = fio___gcm_inc_ctr(ctr0);
    __m128i ctr2 = fio___gcm_inc_ctr(ctr1);
    __m128i ctr3 = fio___gcm_inc_ctr(ctr2);
    ctr = ctr3;

    /* Encrypt 4 blocks */
    __m128i ks0 = fio___aesni_encrypt128(ctr0, rk);
    __m128i ks1 = fio___aesni_encrypt128(ctr1, rk);
    __m128i ks2 = fio___aesni_encrypt128(ctr2, rk);
    __m128i ks3 = fio___aesni_encrypt128(ctr3, rk);

    /* Load plaintext and XOR with keystream */
    __m128i pt0 = _mm_loadu_si128((const __m128i *)p);
    __m128i pt1 = _mm_loadu_si128((const __m128i *)(p + 16));
    __m128i pt2 = _mm_loadu_si128((const __m128i *)(p + 32));
    __m128i pt3 = _mm_loadu_si128((const __m128i *)(p + 48));

    __m128i ct0 = _mm_xor_si128(pt0, ks0);
    __m128i ct1 = _mm_xor_si128(pt1, ks1);
    __m128i ct2 = _mm_xor_si128(pt2, ks2);
    __m128i ct3 = _mm_xor_si128(pt3, ks3);

    /* Store ciphertext */
    _mm_storeu_si128((__m128i *)p, ct0);
    _mm_storeu_si128((__m128i *)(p + 16), ct1);
    _mm_storeu_si128((__m128i *)(p + 32), ct2);
    _mm_storeu_si128((__m128i *)(p + 48), ct3);

    /* GHASH 4 blocks in parallel */
    ct0 = _mm_xor_si128(tag, fio___bswap128(ct0));
    tag = fio___x86_ghash_mult4(ct0,
                                fio___bswap128(ct1),
                                fio___bswap128(ct2),
                                fio___bswap128(ct3),
                                htbl);

    p += 64;
    len -= 64;
  }

  /* Handle remaining full blocks */
  while (len >= 16) {
    ctr = fio___gcm_inc_ctr(ctr);
    __m128i keystream = fio___aesni_encrypt128(ctr, rk);
    __m128i plaintext = _mm_loadu_si128((const __m128i *)p);
    __m128i ciphertext = _mm_xor_si128(plaintext, keystream);
    _mm_storeu_si128((__m128i *)p, ciphertext);
    ciphertext = fio___bswap128(ciphertext);
    tag = _mm_xor_si128(tag, ciphertext);
    tag = fio___ghash_mult_pclmul(tag, h);
    p += 16;
    len -= 16;
  }

  /* Handle partial final block */
  if (len > 0) {
    ctr = fio___gcm_inc_ctr(ctr);
    __m128i keystream = fio___aesni_encrypt128(ctr, rk);
    uint8_t ks_bytes[16];
    _mm_storeu_si128((__m128i *)ks_bytes, keystream);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= ks_bytes[i];
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, p, len);
    __m128i ct_block = _mm_loadu_si128((const __m128i *)tmp);
    ct_block = fio___bswap128(ct_block);
    tag = _mm_xor_si128(tag, ct_block);
    tag = fio___ghash_mult_pclmul(tag, h);
  }

  /* GHASH length block */
  uint8_t len_block[16] = {0};
  fio_u2buf64_be(len_block, (uint64_t)orig_adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  __m128i len_blk = _mm_loadu_si128((const __m128i *)len_block);
  len_blk = fio___bswap128(len_blk);
  tag = _mm_xor_si128(tag, len_blk);
  tag = fio___ghash_mult_pclmul(tag, h);

  /* Final tag */
  __m128i s = fio___aesni_encrypt128(j0, rk);
  tag = fio___bswap128(tag);
  tag = _mm_xor_si128(tag, s);
  _mm_storeu_si128((__m128i *)mac, tag);
  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(htbl, sizeof(htbl));
  fio_secure_zero(j0_bytes, sizeof(j0_bytes));
}

SFUNC void fio_aes256_gcm_enc(void *restrict mac,
                              void *restrict data,
                              size_t len,
                              const void *ad,
                              size_t adlen,
                              const void *key,
                              const void *nonce) {
  __m128i rk[15];
  __m128i h, htbl[4], tag, ctr, j0;
  uint8_t *p = (uint8_t *)data;
  const uint8_t *aad = (const uint8_t *)ad;
  size_t orig_len = len;
  size_t orig_adlen = adlen;

  fio___aesni_gcm256_init(rk, &h, (const uint8_t *)key);
  h = fio___bswap128(h);

  /* Precompute H powers for parallel GHASH */
  fio___x86_ghash_precompute(h, htbl);

  uint8_t j0_bytes[16] = {0};
  FIO_MEMCPY(j0_bytes, nonce, 12);
  j0_bytes[15] = 1;
  j0 = _mm_loadu_si128((const __m128i *)j0_bytes);
  ctr = j0;
  tag = _mm_setzero_si128();

  /* GHASH over AAD - process 4 blocks at a time */
  while (adlen >= 64) {
    __m128i a0 = fio___bswap128(_mm_loadu_si128((const __m128i *)aad));
    __m128i a1 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 16)));
    __m128i a2 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 32)));
    __m128i a3 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 48)));
    a0 = _mm_xor_si128(tag, a0);
    tag = fio___x86_ghash_mult4(a0, a1, a2, a3, htbl);
    aad += 64;
    adlen -= 64;
  }
  while (adlen >= 16) {
    __m128i aad_block = _mm_loadu_si128((const __m128i *)aad);
    aad_block = fio___bswap128(aad_block);
    tag = _mm_xor_si128(tag, aad_block);
    tag = fio___ghash_mult_pclmul(tag, h);
    aad += 16;
    adlen -= 16;
  }
  if (adlen > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, aad, adlen);
    __m128i aad_block = _mm_loadu_si128((const __m128i *)tmp);
    aad_block = fio___bswap128(aad_block);
    tag = _mm_xor_si128(tag, aad_block);
    tag = fio___ghash_mult_pclmul(tag, h);
  }

  /* Encrypt and GHASH - process 4 blocks at a time */
  while (len >= 64) {
    /* Generate 4 counters */
    __m128i ctr0 = fio___gcm_inc_ctr(ctr);
    __m128i ctr1 = fio___gcm_inc_ctr(ctr0);
    __m128i ctr2 = fio___gcm_inc_ctr(ctr1);
    __m128i ctr3 = fio___gcm_inc_ctr(ctr2);
    ctr = ctr3;

    /* Encrypt 4 blocks */
    __m128i ks0 = fio___aesni_encrypt256(ctr0, rk);
    __m128i ks1 = fio___aesni_encrypt256(ctr1, rk);
    __m128i ks2 = fio___aesni_encrypt256(ctr2, rk);
    __m128i ks3 = fio___aesni_encrypt256(ctr3, rk);

    /* Load plaintext and XOR with keystream */
    __m128i pt0 = _mm_loadu_si128((const __m128i *)p);
    __m128i pt1 = _mm_loadu_si128((const __m128i *)(p + 16));
    __m128i pt2 = _mm_loadu_si128((const __m128i *)(p + 32));
    __m128i pt3 = _mm_loadu_si128((const __m128i *)(p + 48));

    __m128i ct0 = _mm_xor_si128(pt0, ks0);
    __m128i ct1 = _mm_xor_si128(pt1, ks1);
    __m128i ct2 = _mm_xor_si128(pt2, ks2);
    __m128i ct3 = _mm_xor_si128(pt3, ks3);

    /* Store ciphertext */
    _mm_storeu_si128((__m128i *)p, ct0);
    _mm_storeu_si128((__m128i *)(p + 16), ct1);
    _mm_storeu_si128((__m128i *)(p + 32), ct2);
    _mm_storeu_si128((__m128i *)(p + 48), ct3);

    /* GHASH 4 blocks in parallel */
    ct0 = _mm_xor_si128(tag, fio___bswap128(ct0));
    tag = fio___x86_ghash_mult4(ct0,
                                fio___bswap128(ct1),
                                fio___bswap128(ct2),
                                fio___bswap128(ct3),
                                htbl);

    p += 64;
    len -= 64;
  }

  /* Handle remaining full blocks */
  while (len >= 16) {
    ctr = fio___gcm_inc_ctr(ctr);
    __m128i keystream = fio___aesni_encrypt256(ctr, rk);
    __m128i plaintext = _mm_loadu_si128((const __m128i *)p);
    __m128i ciphertext = _mm_xor_si128(plaintext, keystream);
    _mm_storeu_si128((__m128i *)p, ciphertext);
    ciphertext = fio___bswap128(ciphertext);
    tag = _mm_xor_si128(tag, ciphertext);
    tag = fio___ghash_mult_pclmul(tag, h);
    p += 16;
    len -= 16;
  }
  if (len > 0) {
    ctr = fio___gcm_inc_ctr(ctr);
    __m128i keystream = fio___aesni_encrypt256(ctr, rk);
    uint8_t ks_bytes[16];
    _mm_storeu_si128((__m128i *)ks_bytes, keystream);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= ks_bytes[i];
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, p, len);
    __m128i ct_block = _mm_loadu_si128((const __m128i *)tmp);
    ct_block = fio___bswap128(ct_block);
    tag = _mm_xor_si128(tag, ct_block);
    tag = fio___ghash_mult_pclmul(tag, h);
  }

  /* GHASH length block */
  uint8_t len_block[16] = {0};
  fio_u2buf64_be(len_block, (uint64_t)orig_adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  __m128i len_blk = _mm_loadu_si128((const __m128i *)len_block);
  len_blk = fio___bswap128(len_blk);
  tag = _mm_xor_si128(tag, len_blk);
  tag = fio___ghash_mult_pclmul(tag, h);

  /* Final tag */
  __m128i s = fio___aesni_encrypt256(j0, rk);
  tag = fio___bswap128(tag);
  tag = _mm_xor_si128(tag, s);
  _mm_storeu_si128((__m128i *)mac, tag);
  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(htbl, sizeof(htbl));
  fio_secure_zero(j0_bytes, sizeof(j0_bytes));
}

SFUNC int fio_aes128_gcm_dec(void *restrict mac,
                             void *restrict data,
                             size_t len,
                             const void *ad,
                             size_t adlen,
                             const void *key,
                             const void *nonce) {
  __m128i rk[11];
  __m128i h, htbl[4], tag, ctr, j0;
  uint8_t *p = (uint8_t *)data;
  const uint8_t *aad = (const uint8_t *)ad;
  size_t orig_len = len;
  size_t orig_adlen = adlen;

  fio___aesni_gcm128_init(rk, &h, (const uint8_t *)key);
  h = fio___bswap128(h);

  /* Precompute H powers for parallel GHASH */
  fio___x86_ghash_precompute(h, htbl);

  uint8_t j0_bytes[16] = {0};
  FIO_MEMCPY(j0_bytes, nonce, 12);
  j0_bytes[15] = 1;
  j0 = _mm_loadu_si128((const __m128i *)j0_bytes);
  ctr = j0;
  tag = _mm_setzero_si128();

  /* GHASH over AAD - process 4 blocks at a time */
  while (adlen >= 64) {
    __m128i a0 = fio___bswap128(_mm_loadu_si128((const __m128i *)aad));
    __m128i a1 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 16)));
    __m128i a2 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 32)));
    __m128i a3 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 48)));
    a0 = _mm_xor_si128(tag, a0);
    tag = fio___x86_ghash_mult4(a0, a1, a2, a3, htbl);
    aad += 64;
    adlen -= 64;
  }
  while (adlen >= 16) {
    __m128i aad_block = _mm_loadu_si128((const __m128i *)aad);
    aad_block = fio___bswap128(aad_block);
    tag = _mm_xor_si128(tag, aad_block);
    tag = fio___ghash_mult_pclmul(tag, h);
    aad += 16;
    adlen -= 16;
  }
  if (adlen > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, aad, adlen);
    __m128i aad_block = _mm_loadu_si128((const __m128i *)tmp);
    aad_block = fio___bswap128(aad_block);
    tag = _mm_xor_si128(tag, aad_block);
    tag = fio___ghash_mult_pclmul(tag, h);
  }

  /* GHASH over ciphertext - process 4 blocks at a time */
  const uint8_t *ct = p;
  size_t ct_len = orig_len;
  while (ct_len >= 64) {
    __m128i c0 = fio___bswap128(_mm_loadu_si128((const __m128i *)ct));
    __m128i c1 = fio___bswap128(_mm_loadu_si128((const __m128i *)(ct + 16)));
    __m128i c2 = fio___bswap128(_mm_loadu_si128((const __m128i *)(ct + 32)));
    __m128i c3 = fio___bswap128(_mm_loadu_si128((const __m128i *)(ct + 48)));
    c0 = _mm_xor_si128(tag, c0);
    tag = fio___x86_ghash_mult4(c0, c1, c2, c3, htbl);
    ct += 64;
    ct_len -= 64;
  }
  while (ct_len >= 16) {
    __m128i ct_block = _mm_loadu_si128((const __m128i *)ct);
    ct_block = fio___bswap128(ct_block);
    tag = _mm_xor_si128(tag, ct_block);
    tag = fio___ghash_mult_pclmul(tag, h);
    ct += 16;
    ct_len -= 16;
  }
  if (ct_len > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, ct, ct_len);
    __m128i ct_block = _mm_loadu_si128((const __m128i *)tmp);
    ct_block = fio___bswap128(ct_block);
    tag = _mm_xor_si128(tag, ct_block);
    tag = fio___ghash_mult_pclmul(tag, h);
  }

  /* GHASH length block */
  uint8_t len_block[16] = {0};
  fio_u2buf64_be(len_block, (uint64_t)orig_adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  __m128i len_blk = _mm_loadu_si128((const __m128i *)len_block);
  len_blk = fio___bswap128(len_blk);
  tag = _mm_xor_si128(tag, len_blk);
  tag = fio___ghash_mult_pclmul(tag, h);

  /* Compute and verify tag */
  __m128i s = fio___aesni_encrypt128(j0, rk);
  tag = fio___bswap128(tag);
  tag = _mm_xor_si128(tag, s);
  uint8_t computed_mac[16];
  _mm_storeu_si128((__m128i *)computed_mac, tag);
  if (!fio_ct_is_eq(computed_mac, mac, 16)) {
    fio_secure_zero(computed_mac, sizeof(computed_mac));
    fio_secure_zero(rk, sizeof(rk));
    fio_secure_zero(htbl, sizeof(htbl));
    fio_secure_zero(j0_bytes, sizeof(j0_bytes));
    return -1;
  }
  fio_secure_zero(computed_mac, sizeof(computed_mac));

  /* Decrypt - process 4 blocks at a time */
  while (len >= 64) {
    __m128i ctr0 = fio___gcm_inc_ctr(ctr);
    __m128i ctr1 = fio___gcm_inc_ctr(ctr0);
    __m128i ctr2 = fio___gcm_inc_ctr(ctr1);
    __m128i ctr3 = fio___gcm_inc_ctr(ctr2);
    ctr = ctr3;

    __m128i ks0 = fio___aesni_encrypt128(ctr0, rk);
    __m128i ks1 = fio___aesni_encrypt128(ctr1, rk);
    __m128i ks2 = fio___aesni_encrypt128(ctr2, rk);
    __m128i ks3 = fio___aesni_encrypt128(ctr3, rk);

    __m128i c0 = _mm_loadu_si128((const __m128i *)p);
    __m128i c1 = _mm_loadu_si128((const __m128i *)(p + 16));
    __m128i c2 = _mm_loadu_si128((const __m128i *)(p + 32));
    __m128i c3 = _mm_loadu_si128((const __m128i *)(p + 48));

    _mm_storeu_si128((__m128i *)p, _mm_xor_si128(c0, ks0));
    _mm_storeu_si128((__m128i *)(p + 16), _mm_xor_si128(c1, ks1));
    _mm_storeu_si128((__m128i *)(p + 32), _mm_xor_si128(c2, ks2));
    _mm_storeu_si128((__m128i *)(p + 48), _mm_xor_si128(c3, ks3));

    p += 64;
    len -= 64;
  }
  while (len >= 16) {
    ctr = fio___gcm_inc_ctr(ctr);
    __m128i keystream = fio___aesni_encrypt128(ctr, rk);
    __m128i ciphertext = _mm_loadu_si128((const __m128i *)p);
    __m128i plaintext = _mm_xor_si128(ciphertext, keystream);
    _mm_storeu_si128((__m128i *)p, plaintext);
    p += 16;
    len -= 16;
  }
  if (len > 0) {
    ctr = fio___gcm_inc_ctr(ctr);
    __m128i keystream = fio___aesni_encrypt128(ctr, rk);
    uint8_t ks_bytes[16];
    _mm_storeu_si128((__m128i *)ks_bytes, keystream);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= ks_bytes[i];
  }
  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(htbl, sizeof(htbl));
  fio_secure_zero(j0_bytes, sizeof(j0_bytes));
  return 0;
}

SFUNC int fio_aes256_gcm_dec(void *restrict mac,
                             void *restrict data,
                             size_t len,
                             const void *ad,
                             size_t adlen,
                             const void *key,
                             const void *nonce) {
  __m128i rk[15];
  __m128i h, htbl[4], tag, ctr, j0;
  uint8_t *p = (uint8_t *)data;
  const uint8_t *aad = (const uint8_t *)ad;
  size_t orig_len = len;
  size_t orig_adlen = adlen;

  fio___aesni_gcm256_init(rk, &h, (const uint8_t *)key);
  h = fio___bswap128(h);

  /* Precompute H powers for parallel GHASH */
  fio___x86_ghash_precompute(h, htbl);

  uint8_t j0_bytes[16] = {0};
  FIO_MEMCPY(j0_bytes, nonce, 12);
  j0_bytes[15] = 1;
  j0 = _mm_loadu_si128((const __m128i *)j0_bytes);
  ctr = j0;
  tag = _mm_setzero_si128();

  /* GHASH over AAD - process 4 blocks at a time */
  while (adlen >= 64) {
    __m128i a0 = fio___bswap128(_mm_loadu_si128((const __m128i *)aad));
    __m128i a1 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 16)));
    __m128i a2 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 32)));
    __m128i a3 = fio___bswap128(_mm_loadu_si128((const __m128i *)(aad + 48)));
    a0 = _mm_xor_si128(tag, a0);
    tag = fio___x86_ghash_mult4(a0, a1, a2, a3, htbl);
    aad += 64;
    adlen -= 64;
  }
  while (adlen >= 16) {
    __m128i aad_block = _mm_loadu_si128((const __m128i *)aad);
    aad_block = fio___bswap128(aad_block);
    tag = _mm_xor_si128(tag, aad_block);
    tag = fio___ghash_mult_pclmul(tag, h);
    aad += 16;
    adlen -= 16;
  }
  if (adlen > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, aad, adlen);
    __m128i aad_block = _mm_loadu_si128((const __m128i *)tmp);
    aad_block = fio___bswap128(aad_block);
    tag = _mm_xor_si128(tag, aad_block);
    tag = fio___ghash_mult_pclmul(tag, h);
  }

  /* GHASH over ciphertext - process 4 blocks at a time */
  const uint8_t *ct = p;
  size_t ct_len = orig_len;
  while (ct_len >= 64) {
    __m128i c0 = fio___bswap128(_mm_loadu_si128((const __m128i *)ct));
    __m128i c1 = fio___bswap128(_mm_loadu_si128((const __m128i *)(ct + 16)));
    __m128i c2 = fio___bswap128(_mm_loadu_si128((const __m128i *)(ct + 32)));
    __m128i c3 = fio___bswap128(_mm_loadu_si128((const __m128i *)(ct + 48)));
    c0 = _mm_xor_si128(tag, c0);
    tag = fio___x86_ghash_mult4(c0, c1, c2, c3, htbl);
    ct += 64;
    ct_len -= 64;
  }
  while (ct_len >= 16) {
    __m128i ct_block = _mm_loadu_si128((const __m128i *)ct);
    ct_block = fio___bswap128(ct_block);
    tag = _mm_xor_si128(tag, ct_block);
    tag = fio___ghash_mult_pclmul(tag, h);
    ct += 16;
    ct_len -= 16;
  }
  if (ct_len > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, ct, ct_len);
    __m128i ct_block = _mm_loadu_si128((const __m128i *)tmp);
    ct_block = fio___bswap128(ct_block);
    tag = _mm_xor_si128(tag, ct_block);
    tag = fio___ghash_mult_pclmul(tag, h);
  }

  /* GHASH length block */
  uint8_t len_block[16] = {0};
  fio_u2buf64_be(len_block, (uint64_t)orig_adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  __m128i len_blk = _mm_loadu_si128((const __m128i *)len_block);
  len_blk = fio___bswap128(len_blk);
  tag = _mm_xor_si128(tag, len_blk);
  tag = fio___ghash_mult_pclmul(tag, h);

  /* Compute and verify tag */
  __m128i s = fio___aesni_encrypt256(j0, rk);
  tag = fio___bswap128(tag);
  tag = _mm_xor_si128(tag, s);
  uint8_t computed_mac[16];
  _mm_storeu_si128((__m128i *)computed_mac, tag);
  if (!fio_ct_is_eq(computed_mac, mac, 16)) {
    fio_secure_zero(computed_mac, sizeof(computed_mac));
    fio_secure_zero(rk, sizeof(rk));
    fio_secure_zero(htbl, sizeof(htbl));
    fio_secure_zero(j0_bytes, sizeof(j0_bytes));
    return -1;
  }
  fio_secure_zero(computed_mac, sizeof(computed_mac));

  /* Decrypt - process 4 blocks at a time */
  while (len >= 64) {
    __m128i ctr0 = fio___gcm_inc_ctr(ctr);
    __m128i ctr1 = fio___gcm_inc_ctr(ctr0);
    __m128i ctr2 = fio___gcm_inc_ctr(ctr1);
    __m128i ctr3 = fio___gcm_inc_ctr(ctr2);
    ctr = ctr3;

    __m128i ks0 = fio___aesni_encrypt256(ctr0, rk);
    __m128i ks1 = fio___aesni_encrypt256(ctr1, rk);
    __m128i ks2 = fio___aesni_encrypt256(ctr2, rk);
    __m128i ks3 = fio___aesni_encrypt256(ctr3, rk);

    __m128i c0 = _mm_loadu_si128((const __m128i *)p);
    __m128i c1 = _mm_loadu_si128((const __m128i *)(p + 16));
    __m128i c2 = _mm_loadu_si128((const __m128i *)(p + 32));
    __m128i c3 = _mm_loadu_si128((const __m128i *)(p + 48));

    _mm_storeu_si128((__m128i *)p, _mm_xor_si128(c0, ks0));
    _mm_storeu_si128((__m128i *)(p + 16), _mm_xor_si128(c1, ks1));
    _mm_storeu_si128((__m128i *)(p + 32), _mm_xor_si128(c2, ks2));
    _mm_storeu_si128((__m128i *)(p + 48), _mm_xor_si128(c3, ks3));

    p += 64;
    len -= 64;
  }
  while (len >= 16) {
    ctr = fio___gcm_inc_ctr(ctr);
    __m128i keystream = fio___aesni_encrypt256(ctr, rk);
    __m128i ciphertext = _mm_loadu_si128((const __m128i *)p);
    __m128i plaintext = _mm_xor_si128(ciphertext, keystream);
    _mm_storeu_si128((__m128i *)p, plaintext);
    p += 16;
    len -= 16;
  }
  if (len > 0) {
    ctr = fio___gcm_inc_ctr(ctr);
    __m128i keystream = fio___aesni_encrypt256(ctr, rk);
    uint8_t ks_bytes[16];
    _mm_storeu_si128((__m128i *)ks_bytes, keystream);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= ks_bytes[i];
  }
  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(htbl, sizeof(htbl));
  fio_secure_zero(j0_bytes, sizeof(j0_bytes));
  return 0;
}

/* *****************************************************************************
ARM Crypto Extensions Implementation
***************************************************************************** */
#elif FIO___HAS_ARM_AES_INTRIN

/* AES S-box for key expansion SubWord */
static const uint8_t FIO___AES_SBOX_ARM[256] = {
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,
    0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,
    0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
    0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,
    0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,
    0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,
    0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,
    0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
    0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,
    0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,
    0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,
    0xb0, 0x54, 0xbb, 0x16};

FIO_IFUNC uint32_t fio___arm_subword(uint32_t w) {
  return ((uint32_t)FIO___AES_SBOX_ARM[(w >> 0) & 0xFF] << 0) |
         ((uint32_t)FIO___AES_SBOX_ARM[(w >> 8) & 0xFF] << 8) |
         ((uint32_t)FIO___AES_SBOX_ARM[(w >> 16) & 0xFF] << 16) |
         ((uint32_t)FIO___AES_SBOX_ARM[(w >> 24) & 0xFF] << 24);
}

FIO_IFUNC uint32_t fio___arm_rotword(uint32_t w) {
  return (w << 8) | (w >> 24);
}

/* ARM AES key expansion - stores keys as uint8x16_t */
FIO_IFUNC void fio___arm_aes128_key_expand(uint8x16_t *rk,
                                           const uint8_t key[16]) {
  static const uint32_t rcon[] = {0x01000000,
                                  0x02000000,
                                  0x04000000,
                                  0x08000000,
                                  0x10000000,
                                  0x20000000,
                                  0x40000000,
                                  0x80000000,
                                  0x1b000000,
                                  0x36000000};
  uint32_t w[44];

  for (int i = 0; i < 4; ++i)
    w[i] = fio_buf2u32_be(key + 4 * i);

  for (int i = 4; i < 44; ++i) {
    uint32_t tmp = w[i - 1];
    if ((i & 3) == 0)
      tmp = fio___arm_subword(fio___arm_rotword(tmp)) ^ rcon[(i / 4) - 1];
    w[i] = w[i - 4] ^ tmp;
  }

  /* Store as 11 round keys - convert to byte array for ARM */
  for (int i = 0; i < 11; ++i) {
    uint8_t tmp[16];
    fio_u2buf32_be(tmp + 0, w[i * 4 + 0]);
    fio_u2buf32_be(tmp + 4, w[i * 4 + 1]);
    fio_u2buf32_be(tmp + 8, w[i * 4 + 2]);
    fio_u2buf32_be(tmp + 12, w[i * 4 + 3]);
    rk[i] = vld1q_u8(tmp);
  }
}

FIO_IFUNC void fio___arm_aes256_key_expand(uint8x16_t *rk,
                                           const uint8_t key[32]) {
  static const uint32_t rcon[] = {0x01000000,
                                  0x02000000,
                                  0x04000000,
                                  0x08000000,
                                  0x10000000,
                                  0x20000000,
                                  0x40000000};
  uint32_t w[60];

  for (int i = 0; i < 8; ++i)
    w[i] = fio_buf2u32_be(key + 4 * i);

  for (int i = 8; i < 60; ++i) {
    uint32_t tmp = w[i - 1];
    if ((i & 7) == 0)
      tmp = fio___arm_subword(fio___arm_rotword(tmp)) ^ rcon[(i / 8) - 1];
    else if ((i & 7) == 4)
      tmp = fio___arm_subword(tmp);
    w[i] = w[i - 8] ^ tmp;
  }

  /* Store as 15 round keys - convert to byte array for ARM */
  for (int i = 0; i < 15; ++i) {
    uint8_t tmp[16];
    fio_u2buf32_be(tmp + 0, w[i * 4 + 0]);
    fio_u2buf32_be(tmp + 4, w[i * 4 + 1]);
    fio_u2buf32_be(tmp + 8, w[i * 4 + 2]);
    fio_u2buf32_be(tmp + 12, w[i * 4 + 3]);
    rk[i] = vld1q_u8(tmp);
  }
}

/* ARM AES block encryption
 * vaeseq_u8(data, key) = ShiftRows(SubBytes(data XOR key))
 * vaesmcq_u8(data) = MixColumns(data)
 *
 * Standard AES round: AddRoundKey -> SubBytes -> ShiftRows -> MixColumns
 * ARM sequence: XOR key, then AESE (which does SubBytes+ShiftRows), then AESMC
 */
FIO_IFUNC uint8x16_t fio___arm_aes128_encrypt(uint8x16_t block,
                                              const uint8x16_t *rk) {
  /* Rounds 1-9: AESE + AESMC */
  block = vaeseq_u8(block, rk[0]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[1]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[2]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[3]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[4]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[5]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[6]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[7]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[8]);
  block = vaesmcq_u8(block);
  /* Round 10: AESE (no MixColumns) + final XOR */
  block = vaeseq_u8(block, rk[9]);
  block = veorq_u8(block, rk[10]);
  return block;
}

FIO_IFUNC uint8x16_t fio___arm_aes256_encrypt(uint8x16_t block,
                                              const uint8x16_t *rk) {
  /* Rounds 1-13: AESE + AESMC */
  block = vaeseq_u8(block, rk[0]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[1]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[2]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[3]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[4]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[5]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[6]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[7]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[8]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[9]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[10]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[11]);
  block = vaesmcq_u8(block);
  block = vaeseq_u8(block, rk[12]);
  block = vaesmcq_u8(block);
  /* Round 14: AESE (no MixColumns) + final XOR */
  block = vaeseq_u8(block, rk[13]);
  block = veorq_u8(block, rk[14]);
  return block;
}

/* GHASH multiplication in GF(2^128) using ARM PMULL
 *
 * GCM bit ordering: byte[0] bit 7 = x^0, byte[15] bit 0 = x^127
 * GCM byte ordering: bytes 0-7 are HIGH (x^0 to x^63), bytes 8-15 are LOW (x^64
 * to x^127)
 *
 * After vrbitq_u8:
 * - byte[0] bit 0 = x^0, byte[7] bit 7 = x^63 (lane 0 = x^0 to x^63)
 * - byte[8] bit 0 = x^64, byte[15] bit 7 = x^127 (lane 1 = x^64 to x^127)
 *
 * So lane 0 contains LOW powers (x^0 to x^63) and lane 1 contains HIGH powers
 * (x^64 to x^127). This is the OPPOSITE of what we want for standard polynomial
 * multiplication!
 */
FIO_IFUNC uint8x16_t fio___arm_ghash_mult_pmull(uint8x16_t x_vec,
                                                uint8x16_t h_vec) {
  /* Reverse bits within each byte */
  uint8x16_t a = vrbitq_u8(x_vec);
  uint8x16_t b = vrbitq_u8(h_vec);

  /* lane 0 = x^0 to x^63 (low), lane 1 = x^64 to x^127 (high)
   * For polynomial (a_hi*x^64 + a_lo), we have:
   * a_lo = lane 0 (coefficients of x^0 to x^63)
   * a_hi = lane 1 (coefficients of x^64 to x^127) */
  poly64_t a_lo = (poly64_t)vgetq_lane_u64(vreinterpretq_u64_u8(a), 0);
  poly64_t a_hi = (poly64_t)vgetq_lane_u64(vreinterpretq_u64_u8(a), 1);
  poly64_t b_lo = (poly64_t)vgetq_lane_u64(vreinterpretq_u64_u8(b), 0);
  poly64_t b_hi = (poly64_t)vgetq_lane_u64(vreinterpretq_u64_u8(b), 1);

  /* Karatsuba: (a_hi*x^64 + a_lo) * (b_hi*x^64 + b_lo) */
  poly128_t p_ll = vmull_p64(a_lo, b_lo); /* x^0 to x^126 */
  poly128_t p_hh = vmull_p64(a_hi, b_hi); /* x^128 to x^254 */
  poly128_t p_mid = vmull_p64((poly64_t)(a_lo ^ a_hi), (poly64_t)(b_lo ^ b_hi));

  uint64x2_t ll = vreinterpretq_u64_p128(p_ll);
  uint64x2_t hh = vreinterpretq_u64_p128(p_hh);
  uint64x2_t mm = vreinterpretq_u64_p128(p_mid);
  mm = veorq_u64(mm, ll);
  mm = veorq_u64(mm, hh);

  /* 256-bit product: r3:r2:r1:r0 where r0 is bits 0-63, r3 is bits 192-255 */
  uint64_t r0 = vgetq_lane_u64(ll, 0);
  uint64_t r1 = vgetq_lane_u64(ll, 1) ^ vgetq_lane_u64(mm, 0);
  uint64_t r2 = vgetq_lane_u64(hh, 0) ^ vgetq_lane_u64(mm, 1);
  uint64_t r3 = vgetq_lane_u64(hh, 1);

  /* Reduce modulo x^128 + x^7 + x^2 + x + 1
   * x^128  x^7 + x^2 + x + 1
   *
   * For a bit at position 128+k (in r2 or r3), we need to XOR into position k
   * plus the polynomial terms at k+7, k+2, k+1.
   *
   * r2 contains bits 128-191 (x^128 to x^191)
   * r3 contains bits 192-255 (x^192 to x^255)
   *
   * Bit k of r2 represents x^(128+k), which reduces to x^k + x^(k+7) + x^(k+2)
   * + x^(k+1) These go into r0 (for k < 64) and r1 (for k+7 >= 64, etc.) */

  /* Fold r3 (bits 192-255) into r2:r1:r0
   * Bit k of r3 = x^(192+k)  x^(64+k) + x^(71+k) + x^(66+k) + x^(65+k)
   * x^(64+k) goes to r1 bit k
   * x^(71+k) goes to r1 bit (k+7) if k+7 < 64, else r2 bit (k+7-64)
   * etc. */
  r1 ^= r3;         /* x^(64+k) */
  r1 ^= (r3 << 7);  /* x^(71+k) for k < 57 */
  r2 ^= (r3 >> 57); /* x^(71+k) for k >= 57, wraps to r2 */
  r1 ^= (r3 << 2);  /* x^(66+k) for k < 62 */
  r2 ^= (r3 >> 62); /* x^(66+k) for k >= 62 */
  r1 ^= (r3 << 1);  /* x^(65+k) for k < 63 */
  r2 ^= (r3 >> 63); /* x^(65+k) for k = 63 */

  /* Fold r2 (bits 128-191) into r1:r0
   * Bit k of r2 = x^(128+k)  x^k + x^(k+7) + x^(k+2) + x^(k+1)
   * x^k goes to r0 bit k
   * x^(k+7) goes to r0 bit (k+7) if k+7 < 64, else r1 bit (k+7-64)
   * etc. */
  r0 ^= r2;         /* x^k */
  r0 ^= (r2 << 7);  /* x^(k+7) for k < 57 */
  r1 ^= (r2 >> 57); /* x^(k+7) for k >= 57 */
  r0 ^= (r2 << 2);  /* x^(k+2) for k < 62 */
  r1 ^= (r2 >> 62); /* x^(k+2) for k >= 62 */
  r0 ^= (r2 << 1);  /* x^(k+1) for k < 63 */
  r1 ^= (r2 >> 63); /* x^(k+1) for k = 63 */

  /* Result is r1:r0 where r0 = x^0 to x^63, r1 = x^64 to x^127
   * This maps to: lane 0 = r0, lane 1 = r1
   * Then vrbitq_u8 converts back to GCM format */
  uint64x2_t result = vcombine_u64(vcreate_u64(r0), vcreate_u64(r1));
  return vrbitq_u8(vreinterpretq_u8_u64(result));
}

/* Wrapper for the PMULL implementation */
FIO_IFUNC uint8x16_t fio___arm_ghash_mult(uint8x16_t x_vec, uint8x16_t h_vec) {
  return fio___arm_ghash_mult_pmull(x_vec, h_vec);
}

/* Precompute H powers for parallel GHASH: H, H, H, H */
FIO_IFUNC void fio___arm_ghash_precompute(uint8x16_t h, uint8x16_t *htbl) {
  htbl[0] = h;                                      /* H */
  htbl[1] = fio___arm_ghash_mult(h, h);             /* H */
  htbl[2] = fio___arm_ghash_mult(htbl[1], h);       /* H */
  htbl[3] = fio___arm_ghash_mult(htbl[1], htbl[1]); /* H */
}

/* 4-way parallel GHASH: compute (X0H) ^ (X1H) ^ (X2H) ^ (X3H)
 * This processes 4 blocks at once using precomputed H powers */
FIO_IFUNC uint8x16_t fio___arm_ghash_mult4(uint8x16_t x0,
                                           uint8x16_t x1,
                                           uint8x16_t x2,
                                           uint8x16_t x3,
                                           const uint8x16_t *htbl) {
  /* Compute all 4 products and XOR them together */
  uint8x16_t r0 = fio___arm_ghash_mult(x0, htbl[3]); /* X0  H */
  uint8x16_t r1 = fio___arm_ghash_mult(x1, htbl[2]); /* X1  H */
  uint8x16_t r2 = fio___arm_ghash_mult(x2, htbl[1]); /* X2  H */
  uint8x16_t r3 = fio___arm_ghash_mult(x3, htbl[0]); /* X3  H  */
  return veorq_u8(veorq_u8(r0, r1), veorq_u8(r2, r3));
}

/* Byte reverse for GCM (convert between big-endian and native) */
FIO_IFUNC uint8x16_t fio___arm_bswap128(uint8x16_t x) {
  static const uint8_t rev_idx[16] =
      {15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
  return vqtbl1q_u8(x, vld1q_u8(rev_idx));
}

/* Increment counter (last 32 bits, big-endian) using NEON */
FIO_IFUNC uint8x16_t fio___arm_gcm_inc_ctr(uint8x16_t ctr) {
  /* The counter is in bytes 12-15, big-endian.
   * We need to: extract, byte-swap, increment, byte-swap, insert */
  uint32x4_t ctr32 = vreinterpretq_u32_u8(ctr);
  uint32_t c = vgetq_lane_u32(ctr32, 3);
  c = fio_bswap32(fio_bswap32(c) + 1);
  return vreinterpretq_u8_u32(vsetq_lane_u32(c, ctr32, 3));
}

SFUNC void fio_aes128_gcm_enc(void *restrict mac,
                              void *restrict data,
                              size_t len,
                              const void *ad,
                              size_t adlen,
                              const void *key,
                              const void *nonce) {
  uint8x16_t rk[11];
  uint8x16_t h, htbl[4], tag, ctr, j0;
  uint8_t *p = (uint8_t *)data;
  const uint8_t *aad = (const uint8_t *)ad;
  size_t orig_len = len;
  size_t orig_adlen = adlen;

  fio___arm_aes128_key_expand(rk, (const uint8_t *)key);
  uint8x16_t zero = vdupq_n_u8(0);
  h = fio___arm_aes128_encrypt(zero, rk);

  /* Precompute H powers for parallel GHASH */
  fio___arm_ghash_precompute(h, htbl);

  uint8_t j0_bytes[16] = {0};
  FIO_MEMCPY(j0_bytes, nonce, 12);
  j0_bytes[15] = 1;
  j0 = vld1q_u8(j0_bytes);
  ctr = j0;
  tag = vdupq_n_u8(0);

  /* GHASH over AAD - process 4 blocks at a time */
  while (adlen >= 64) {
    uint8x16_t a0 = vld1q_u8(aad);
    uint8x16_t a1 = vld1q_u8(aad + 16);
    uint8x16_t a2 = vld1q_u8(aad + 32);
    uint8x16_t a3 = vld1q_u8(aad + 48);
    a0 = veorq_u8(tag, a0);
    tag = fio___arm_ghash_mult4(a0, a1, a2, a3, htbl);
    aad += 64;
    adlen -= 64;
  }
  while (adlen >= 16) {
    uint8x16_t aad_block = vld1q_u8(aad);
    tag = veorq_u8(tag, aad_block);
    tag = fio___arm_ghash_mult(tag, h);
    aad += 16;
    adlen -= 16;
  }
  if (adlen > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, aad, adlen);
    uint8x16_t aad_block = vld1q_u8(tmp);
    tag = veorq_u8(tag, aad_block);
    tag = fio___arm_ghash_mult(tag, h);
  }

  /* Encrypt and GHASH - process 4 blocks at a time with interleaving */
  while (len >= 64) {
    /* Generate 4 counters */
    uint8x16_t ctr0 = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t ctr1 = fio___arm_gcm_inc_ctr(ctr0);
    uint8x16_t ctr2 = fio___arm_gcm_inc_ctr(ctr1);
    uint8x16_t ctr3 = fio___arm_gcm_inc_ctr(ctr2);
    ctr = ctr3;

    /* Encrypt 4 blocks (AES operations can be pipelined by CPU) */
    uint8x16_t ks0 = fio___arm_aes128_encrypt(ctr0, rk);
    uint8x16_t ks1 = fio___arm_aes128_encrypt(ctr1, rk);
    uint8x16_t ks2 = fio___arm_aes128_encrypt(ctr2, rk);
    uint8x16_t ks3 = fio___arm_aes128_encrypt(ctr3, rk);

    /* Load plaintext and XOR with keystream */
    uint8x16_t pt0 = vld1q_u8(p);
    uint8x16_t pt1 = vld1q_u8(p + 16);
    uint8x16_t pt2 = vld1q_u8(p + 32);
    uint8x16_t pt3 = vld1q_u8(p + 48);

    uint8x16_t ct0 = veorq_u8(pt0, ks0);
    uint8x16_t ct1 = veorq_u8(pt1, ks1);
    uint8x16_t ct2 = veorq_u8(pt2, ks2);
    uint8x16_t ct3 = veorq_u8(pt3, ks3);

    /* Store ciphertext */
    vst1q_u8(p, ct0);
    vst1q_u8(p + 16, ct1);
    vst1q_u8(p + 32, ct2);
    vst1q_u8(p + 48, ct3);

    /* GHASH 4 blocks in parallel */
    ct0 = veorq_u8(tag, ct0);
    tag = fio___arm_ghash_mult4(ct0, ct1, ct2, ct3, htbl);

    p += 64;
    len -= 64;
  }

  /* Handle remaining full blocks */
  while (len >= 16) {
    ctr = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t keystream = fio___arm_aes128_encrypt(ctr, rk);
    uint8x16_t plaintext = vld1q_u8(p);
    uint8x16_t ciphertext = veorq_u8(plaintext, keystream);
    vst1q_u8(p, ciphertext);
    tag = veorq_u8(tag, ciphertext);
    tag = fio___arm_ghash_mult(tag, h);
    p += 16;
    len -= 16;
  }

  /* Handle partial final block */
  if (len > 0) {
    ctr = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t keystream = fio___arm_aes128_encrypt(ctr, rk);
    uint8_t ks_bytes[16];
    vst1q_u8(ks_bytes, keystream);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= ks_bytes[i];
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, p, len);
    uint8x16_t ct_block = vld1q_u8(tmp);
    tag = veorq_u8(tag, ct_block);
    tag = fio___arm_ghash_mult(tag, h);
  }

  /* GHASH length block */
  uint8_t len_block[16] = {0};
  fio_u2buf64_be(len_block, (uint64_t)orig_adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  uint8x16_t len_blk = vld1q_u8(len_block);
  tag = veorq_u8(tag, len_blk);
  tag = fio___arm_ghash_mult(tag, h);

  /* Final tag */
  uint8x16_t s = fio___arm_aes128_encrypt(j0, rk);
  tag = veorq_u8(tag, s);
  vst1q_u8((uint8_t *)mac, tag);

  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(htbl, sizeof(htbl));
  fio_secure_zero(j0_bytes, sizeof(j0_bytes));
}

SFUNC void fio_aes256_gcm_enc(void *restrict mac,
                              void *restrict data,
                              size_t len,
                              const void *ad,
                              size_t adlen,
                              const void *key,
                              const void *nonce) {
  uint8x16_t rk[15];
  uint8x16_t h, htbl[4], tag, ctr, j0;
  uint8_t *p = (uint8_t *)data;
  const uint8_t *aad = (const uint8_t *)ad;
  size_t orig_len = len;
  size_t orig_adlen = adlen;

  fio___arm_aes256_key_expand(rk, (const uint8_t *)key);
  uint8x16_t zero = vdupq_n_u8(0);
  h = fio___arm_aes256_encrypt(zero, rk);

  /* Precompute H powers for parallel GHASH */
  fio___arm_ghash_precompute(h, htbl);

  uint8_t j0_bytes[16] = {0};
  FIO_MEMCPY(j0_bytes, nonce, 12);
  j0_bytes[15] = 1;
  j0 = vld1q_u8(j0_bytes);
  ctr = j0;
  tag = vdupq_n_u8(0);

  /* GHASH over AAD - process 4 blocks at a time */
  while (adlen >= 64) {
    uint8x16_t a0 = vld1q_u8(aad);
    uint8x16_t a1 = vld1q_u8(aad + 16);
    uint8x16_t a2 = vld1q_u8(aad + 32);
    uint8x16_t a3 = vld1q_u8(aad + 48);
    a0 = veorq_u8(tag, a0);
    tag = fio___arm_ghash_mult4(a0, a1, a2, a3, htbl);
    aad += 64;
    adlen -= 64;
  }
  while (adlen >= 16) {
    uint8x16_t aad_block = vld1q_u8(aad);
    tag = veorq_u8(tag, aad_block);
    tag = fio___arm_ghash_mult(tag, h);
    aad += 16;
    adlen -= 16;
  }
  if (adlen > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, aad, adlen);
    uint8x16_t aad_block = vld1q_u8(tmp);
    tag = veorq_u8(tag, aad_block);
    tag = fio___arm_ghash_mult(tag, h);
  }

  /* Encrypt and GHASH - process 4 blocks at a time with interleaving */
  while (len >= 64) {
    /* Generate 4 counters */
    uint8x16_t ctr0 = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t ctr1 = fio___arm_gcm_inc_ctr(ctr0);
    uint8x16_t ctr2 = fio___arm_gcm_inc_ctr(ctr1);
    uint8x16_t ctr3 = fio___arm_gcm_inc_ctr(ctr2);
    ctr = ctr3;

    /* Encrypt 4 blocks (AES operations can be pipelined by CPU) */
    uint8x16_t ks0 = fio___arm_aes256_encrypt(ctr0, rk);
    uint8x16_t ks1 = fio___arm_aes256_encrypt(ctr1, rk);
    uint8x16_t ks2 = fio___arm_aes256_encrypt(ctr2, rk);
    uint8x16_t ks3 = fio___arm_aes256_encrypt(ctr3, rk);

    /* Load plaintext and XOR with keystream */
    uint8x16_t pt0 = vld1q_u8(p);
    uint8x16_t pt1 = vld1q_u8(p + 16);
    uint8x16_t pt2 = vld1q_u8(p + 32);
    uint8x16_t pt3 = vld1q_u8(p + 48);

    uint8x16_t ct0 = veorq_u8(pt0, ks0);
    uint8x16_t ct1 = veorq_u8(pt1, ks1);
    uint8x16_t ct2 = veorq_u8(pt2, ks2);
    uint8x16_t ct3 = veorq_u8(pt3, ks3);

    /* Store ciphertext */
    vst1q_u8(p, ct0);
    vst1q_u8(p + 16, ct1);
    vst1q_u8(p + 32, ct2);
    vst1q_u8(p + 48, ct3);

    /* GHASH 4 blocks in parallel */
    ct0 = veorq_u8(tag, ct0);
    tag = fio___arm_ghash_mult4(ct0, ct1, ct2, ct3, htbl);

    p += 64;
    len -= 64;
  }

  /* Handle remaining full blocks */
  while (len >= 16) {
    ctr = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t keystream = fio___arm_aes256_encrypt(ctr, rk);
    uint8x16_t plaintext = vld1q_u8(p);
    uint8x16_t ciphertext = veorq_u8(plaintext, keystream);
    vst1q_u8(p, ciphertext);
    tag = veorq_u8(tag, ciphertext);
    tag = fio___arm_ghash_mult(tag, h);
    p += 16;
    len -= 16;
  }

  /* Handle partial final block */
  if (len > 0) {
    ctr = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t keystream = fio___arm_aes256_encrypt(ctr, rk);
    uint8_t ks_bytes[16];
    vst1q_u8(ks_bytes, keystream);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= ks_bytes[i];
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, p, len);
    uint8x16_t ct_block = vld1q_u8(tmp);
    tag = veorq_u8(tag, ct_block);
    tag = fio___arm_ghash_mult(tag, h);
  }

  /* GHASH length block */
  uint8_t len_block[16] = {0};
  fio_u2buf64_be(len_block, (uint64_t)orig_adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  uint8x16_t len_blk = vld1q_u8(len_block);
  tag = veorq_u8(tag, len_blk);
  tag = fio___arm_ghash_mult(tag, h);

  /* Final tag */
  uint8x16_t s = fio___arm_aes256_encrypt(j0, rk);
  tag = veorq_u8(tag, s);
  vst1q_u8((uint8_t *)mac, tag);

  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(htbl, sizeof(htbl));
  fio_secure_zero(j0_bytes, sizeof(j0_bytes));
}

SFUNC int fio_aes128_gcm_dec(void *restrict mac,
                             void *restrict data,
                             size_t len,
                             const void *ad,
                             size_t adlen,
                             const void *key,
                             const void *nonce) {
  uint8x16_t rk[11];
  uint8x16_t h, htbl[4], tag, ctr, j0;
  uint8_t *p = (uint8_t *)data;
  const uint8_t *aad = (const uint8_t *)ad;
  size_t orig_len = len;
  size_t orig_adlen = adlen;

  fio___arm_aes128_key_expand(rk, (const uint8_t *)key);
  uint8x16_t zero = vdupq_n_u8(0);
  h = fio___arm_aes128_encrypt(zero, rk);

  /* Precompute H powers for parallel GHASH */
  fio___arm_ghash_precompute(h, htbl);

  uint8_t j0_bytes[16] = {0};
  FIO_MEMCPY(j0_bytes, nonce, 12);
  j0_bytes[15] = 1;
  j0 = vld1q_u8(j0_bytes);
  ctr = j0;
  tag = vdupq_n_u8(0);

  /* GHASH over AAD - process 4 blocks at a time */
  while (adlen >= 64) {
    uint8x16_t a0 = vld1q_u8(aad);
    uint8x16_t a1 = vld1q_u8(aad + 16);
    uint8x16_t a2 = vld1q_u8(aad + 32);
    uint8x16_t a3 = vld1q_u8(aad + 48);
    a0 = veorq_u8(tag, a0);
    tag = fio___arm_ghash_mult4(a0, a1, a2, a3, htbl);
    aad += 64;
    adlen -= 64;
  }
  while (adlen >= 16) {
    uint8x16_t aad_block = vld1q_u8(aad);
    tag = veorq_u8(tag, aad_block);
    tag = fio___arm_ghash_mult(tag, h);
    aad += 16;
    adlen -= 16;
  }
  if (adlen > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, aad, adlen);
    uint8x16_t aad_block = vld1q_u8(tmp);
    tag = veorq_u8(tag, aad_block);
    tag = fio___arm_ghash_mult(tag, h);
  }

  /* GHASH over ciphertext - process 4 blocks at a time */
  const uint8_t *ct = p;
  size_t ct_len = orig_len;
  while (ct_len >= 64) {
    uint8x16_t c0 = vld1q_u8(ct);
    uint8x16_t c1 = vld1q_u8(ct + 16);
    uint8x16_t c2 = vld1q_u8(ct + 32);
    uint8x16_t c3 = vld1q_u8(ct + 48);
    c0 = veorq_u8(tag, c0);
    tag = fio___arm_ghash_mult4(c0, c1, c2, c3, htbl);
    ct += 64;
    ct_len -= 64;
  }
  while (ct_len >= 16) {
    uint8x16_t ct_block = vld1q_u8(ct);
    tag = veorq_u8(tag, ct_block);
    tag = fio___arm_ghash_mult(tag, h);
    ct += 16;
    ct_len -= 16;
  }
  if (ct_len > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, ct, ct_len);
    uint8x16_t ct_block = vld1q_u8(tmp);
    tag = veorq_u8(tag, ct_block);
    tag = fio___arm_ghash_mult(tag, h);
  }

  /* GHASH length block */
  uint8_t len_block[16] = {0};
  fio_u2buf64_be(len_block, (uint64_t)orig_adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  uint8x16_t len_blk = vld1q_u8(len_block);
  tag = veorq_u8(tag, len_blk);
  tag = fio___arm_ghash_mult(tag, h);

  /* Compute and verify tag */
  uint8x16_t s = fio___arm_aes128_encrypt(j0, rk);
  tag = veorq_u8(tag, s);
  uint8_t computed_mac[16];
  vst1q_u8(computed_mac, tag);
  if (!fio_ct_is_eq(computed_mac, mac, 16)) {
    fio_secure_zero(computed_mac, sizeof(computed_mac));
    fio_secure_zero(rk, sizeof(rk));
    fio_secure_zero(htbl, sizeof(htbl));
    fio_secure_zero(j0_bytes, sizeof(j0_bytes));
    return -1;
  }
  fio_secure_zero(computed_mac, sizeof(computed_mac));

  /* Decrypt - process 4 blocks at a time */
  while (len >= 64) {
    uint8x16_t ctr0 = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t ctr1 = fio___arm_gcm_inc_ctr(ctr0);
    uint8x16_t ctr2 = fio___arm_gcm_inc_ctr(ctr1);
    uint8x16_t ctr3 = fio___arm_gcm_inc_ctr(ctr2);
    ctr = ctr3;

    uint8x16_t ks0 = fio___arm_aes128_encrypt(ctr0, rk);
    uint8x16_t ks1 = fio___arm_aes128_encrypt(ctr1, rk);
    uint8x16_t ks2 = fio___arm_aes128_encrypt(ctr2, rk);
    uint8x16_t ks3 = fio___arm_aes128_encrypt(ctr3, rk);

    uint8x16_t c0 = vld1q_u8(p);
    uint8x16_t c1 = vld1q_u8(p + 16);
    uint8x16_t c2 = vld1q_u8(p + 32);
    uint8x16_t c3 = vld1q_u8(p + 48);

    vst1q_u8(p, veorq_u8(c0, ks0));
    vst1q_u8(p + 16, veorq_u8(c1, ks1));
    vst1q_u8(p + 32, veorq_u8(c2, ks2));
    vst1q_u8(p + 48, veorq_u8(c3, ks3));

    p += 64;
    len -= 64;
  }
  while (len >= 16) {
    ctr = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t keystream = fio___arm_aes128_encrypt(ctr, rk);
    uint8x16_t ciphertext = vld1q_u8(p);
    uint8x16_t plaintext = veorq_u8(ciphertext, keystream);
    vst1q_u8(p, plaintext);
    p += 16;
    len -= 16;
  }
  if (len > 0) {
    ctr = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t keystream = fio___arm_aes128_encrypt(ctr, rk);
    uint8_t ks_bytes[16];
    vst1q_u8(ks_bytes, keystream);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= ks_bytes[i];
  }

  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(htbl, sizeof(htbl));
  fio_secure_zero(j0_bytes, sizeof(j0_bytes));
  return 0;
}

SFUNC int fio_aes256_gcm_dec(void *restrict mac,
                             void *restrict data,
                             size_t len,
                             const void *ad,
                             size_t adlen,
                             const void *key,
                             const void *nonce) {
  uint8x16_t rk[15];
  uint8x16_t h, htbl[4], tag, ctr, j0;
  uint8_t *p = (uint8_t *)data;
  const uint8_t *aad = (const uint8_t *)ad;
  size_t orig_len = len;
  size_t orig_adlen = adlen;

  fio___arm_aes256_key_expand(rk, (const uint8_t *)key);
  uint8x16_t zero = vdupq_n_u8(0);
  h = fio___arm_aes256_encrypt(zero, rk);

  /* Precompute H powers for parallel GHASH */
  fio___arm_ghash_precompute(h, htbl);

  uint8_t j0_bytes[16] = {0};
  FIO_MEMCPY(j0_bytes, nonce, 12);
  j0_bytes[15] = 1;
  j0 = vld1q_u8(j0_bytes);
  ctr = j0;
  tag = vdupq_n_u8(0);

  /* GHASH over AAD - process 4 blocks at a time */
  while (adlen >= 64) {
    uint8x16_t a0 = vld1q_u8(aad);
    uint8x16_t a1 = vld1q_u8(aad + 16);
    uint8x16_t a2 = vld1q_u8(aad + 32);
    uint8x16_t a3 = vld1q_u8(aad + 48);
    a0 = veorq_u8(tag, a0);
    tag = fio___arm_ghash_mult4(a0, a1, a2, a3, htbl);
    aad += 64;
    adlen -= 64;
  }
  while (adlen >= 16) {
    uint8x16_t aad_block = vld1q_u8(aad);
    tag = veorq_u8(tag, aad_block);
    tag = fio___arm_ghash_mult(tag, h);
    aad += 16;
    adlen -= 16;
  }
  if (adlen > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, aad, adlen);
    uint8x16_t aad_block = vld1q_u8(tmp);
    tag = veorq_u8(tag, aad_block);
    tag = fio___arm_ghash_mult(tag, h);
  }

  /* GHASH over ciphertext - process 4 blocks at a time */
  const uint8_t *ct = p;
  size_t ct_len = orig_len;
  while (ct_len >= 64) {
    uint8x16_t c0 = vld1q_u8(ct);
    uint8x16_t c1 = vld1q_u8(ct + 16);
    uint8x16_t c2 = vld1q_u8(ct + 32);
    uint8x16_t c3 = vld1q_u8(ct + 48);
    c0 = veorq_u8(tag, c0);
    tag = fio___arm_ghash_mult4(c0, c1, c2, c3, htbl);
    ct += 64;
    ct_len -= 64;
  }
  while (ct_len >= 16) {
    uint8x16_t ct_block = vld1q_u8(ct);
    tag = veorq_u8(tag, ct_block);
    tag = fio___arm_ghash_mult(tag, h);
    ct += 16;
    ct_len -= 16;
  }
  if (ct_len > 0) {
    uint8_t tmp[16] = {0};
    FIO_MEMCPY(tmp, ct, ct_len);
    uint8x16_t ct_block = vld1q_u8(tmp);
    tag = veorq_u8(tag, ct_block);
    tag = fio___arm_ghash_mult(tag, h);
  }

  /* GHASH length block */
  uint8_t len_block[16] = {0};
  fio_u2buf64_be(len_block, (uint64_t)orig_adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  uint8x16_t len_blk = vld1q_u8(len_block);
  tag = veorq_u8(tag, len_blk);
  tag = fio___arm_ghash_mult(tag, h);

  /* Compute and verify tag */
  uint8x16_t s = fio___arm_aes256_encrypt(j0, rk);
  tag = veorq_u8(tag, s);
  uint8_t computed_mac[16];
  vst1q_u8(computed_mac, tag);
  if (!fio_ct_is_eq(computed_mac, mac, 16)) {
    fio_secure_zero(computed_mac, sizeof(computed_mac));
    fio_secure_zero(rk, sizeof(rk));
    fio_secure_zero(htbl, sizeof(htbl));
    fio_secure_zero(j0_bytes, sizeof(j0_bytes));
    return -1;
  }
  fio_secure_zero(computed_mac, sizeof(computed_mac));

  /* Decrypt - process 4 blocks at a time */
  while (len >= 64) {
    uint8x16_t ctr0 = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t ctr1 = fio___arm_gcm_inc_ctr(ctr0);
    uint8x16_t ctr2 = fio___arm_gcm_inc_ctr(ctr1);
    uint8x16_t ctr3 = fio___arm_gcm_inc_ctr(ctr2);
    ctr = ctr3;

    uint8x16_t ks0 = fio___arm_aes256_encrypt(ctr0, rk);
    uint8x16_t ks1 = fio___arm_aes256_encrypt(ctr1, rk);
    uint8x16_t ks2 = fio___arm_aes256_encrypt(ctr2, rk);
    uint8x16_t ks3 = fio___arm_aes256_encrypt(ctr3, rk);

    uint8x16_t c0 = vld1q_u8(p);
    uint8x16_t c1 = vld1q_u8(p + 16);
    uint8x16_t c2 = vld1q_u8(p + 32);
    uint8x16_t c3 = vld1q_u8(p + 48);

    vst1q_u8(p, veorq_u8(c0, ks0));
    vst1q_u8(p + 16, veorq_u8(c1, ks1));
    vst1q_u8(p + 32, veorq_u8(c2, ks2));
    vst1q_u8(p + 48, veorq_u8(c3, ks3));

    p += 64;
    len -= 64;
  }
  while (len >= 16) {
    ctr = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t keystream = fio___arm_aes256_encrypt(ctr, rk);
    uint8x16_t ciphertext = vld1q_u8(p);
    uint8x16_t plaintext = veorq_u8(ciphertext, keystream);
    vst1q_u8(p, plaintext);
    p += 16;
    len -= 16;
  }
  if (len > 0) {
    ctr = fio___arm_gcm_inc_ctr(ctr);
    uint8x16_t keystream = fio___arm_aes256_encrypt(ctr, rk);
    uint8_t ks_bytes[16];
    vst1q_u8(ks_bytes, keystream);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= ks_bytes[i];
  }
  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(htbl, sizeof(htbl));
  fio_secure_zero(j0_bytes, sizeof(j0_bytes));
  return 0;
}

/* *****************************************************************************
Portable (Software) Implementation - Fallback
***************************************************************************** */
#else /* No hardware acceleration */

/* clang-format off */
/* AES forward S-box */
static const uint8_t FIO___AES_SBOX[256] = {
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

/* AES round constants */
static const uint8_t FIO___AES_RCON[11] = {
    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
};

/* Pre-computed T-tables for AES encryption */
static const uint32_t FIO___AES_TE0[256] = {
    0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554,
    0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a,
    0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,
    0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b,
    0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f,
    0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,
    0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5,
    0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f,
    0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,
    0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497,
    0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed,
    0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,
    0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594,
    0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3,
    0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,
    0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d,
    0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739,
    0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,
    0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883,
    0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76,
    0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4,
    0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b,
    0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0,
    0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,
    0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651,
    0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85,
    0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12,
    0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9,
    0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7,
    0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,
    0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8,
    0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a
};

static const uint32_t FIO___AES_TE1[256] = {
    0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5,
    0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676,
    0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0,
    0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0,
    0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc,
    0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515,
    0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a,
    0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575,
    0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0,
    0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484,
    0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b,
    0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf,
    0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585,
    0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8,
    0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5,
    0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2,
    0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717,
    0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373,
    0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888,
    0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb,
    0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c,
    0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979,
    0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9,
    0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808,
    0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6,
    0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a,
    0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e,
    0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e,
    0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494,
    0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf,
    0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868,
    0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616
};

static const uint32_t FIO___AES_TE2[256] = {
    0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5,
    0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76,
    0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0,
    0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0,
    0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc,
    0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15,
    0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a,
    0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75,
    0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0,
    0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384,
    0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b,
    0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf,
    0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185,
    0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8,
    0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5,
    0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2,
    0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17,
    0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673,
    0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88,
    0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb,
    0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c,
    0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279,
    0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9,
    0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008,
    0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6,
    0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a,
    0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e,
    0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e,
    0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394,
    0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df,
    0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068,
    0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16
};

static const uint32_t FIO___AES_TE3[256] = {
    0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491,
    0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec,
    0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb,
    0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b,
    0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83,
    0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a,
    0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f,
    0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea,
    0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b,
    0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713,
    0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6,
    0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85,
    0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411,
    0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b,
    0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1,
    0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf,
    0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e,
    0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6,
    0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b,
    0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad,
    0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8,
    0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2,
    0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049,
    0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810,
    0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197,
    0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f,
    0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c,
    0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927,
    0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733,
    0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5,
    0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0,
    0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c
};
/* clang-format on */

/* SubWord: apply S-box to each byte of a 32-bit word */
FIO_IFUNC uint32_t fio___aes_subword(uint32_t w) {
  return ((uint32_t)FIO___AES_SBOX[(w >> 0) & 0xFF] << 0) |
         ((uint32_t)FIO___AES_SBOX[(w >> 8) & 0xFF] << 8) |
         ((uint32_t)FIO___AES_SBOX[(w >> 16) & 0xFF] << 16) |
         ((uint32_t)FIO___AES_SBOX[(w >> 24) & 0xFF] << 24);
}

FIO_IFUNC void fio___aes128_key_expand(uint32_t *w, const uint8_t key[16]) {
  for (int i = 0; i < 4; ++i)
    w[i] = fio_buf2u32_be(key + 4 * i);
  for (int i = 4; i < 44; ++i) {
    uint32_t tmp = w[i - 1];
    if ((i & 3) == 0)
      tmp = fio___aes_subword(fio_rrot32(tmp, 24)) ^
            ((uint32_t)FIO___AES_RCON[i / 4] << 24);
    w[i] = w[i - 4] ^ tmp;
  }
}

FIO_IFUNC void fio___aes256_key_expand(uint32_t *w, const uint8_t key[32]) {
  for (int i = 0; i < 8; ++i)
    w[i] = fio_buf2u32_be(key + 4 * i);
  for (int i = 8; i < 60; ++i) {
    uint32_t tmp = w[i - 1];
    if ((i & 7) == 0)
      tmp = fio___aes_subword(fio_rrot32(tmp, 24)) ^
            ((uint32_t)FIO___AES_RCON[i / 8] << 24);
    else if ((i & 7) == 4)
      tmp = fio___aes_subword(tmp);
    w[i] = w[i - 8] ^ tmp;
  }
}

FIO_IFUNC void fio___aes_encrypt_round(uint32_t *state, const uint32_t *rk) {
  uint32_t s0 = state[0], s1 = state[1], s2 = state[2], s3 = state[3];
  state[0] =
      FIO___AES_TE0[(s0 >> 24) & 0xFF] ^ FIO___AES_TE1[(s1 >> 16) & 0xFF] ^
      FIO___AES_TE2[(s2 >> 8) & 0xFF] ^ FIO___AES_TE3[(s3 >> 0) & 0xFF] ^ rk[0];
  state[1] =
      FIO___AES_TE0[(s1 >> 24) & 0xFF] ^ FIO___AES_TE1[(s2 >> 16) & 0xFF] ^
      FIO___AES_TE2[(s3 >> 8) & 0xFF] ^ FIO___AES_TE3[(s0 >> 0) & 0xFF] ^ rk[1];
  state[2] =
      FIO___AES_TE0[(s2 >> 24) & 0xFF] ^ FIO___AES_TE1[(s3 >> 16) & 0xFF] ^
      FIO___AES_TE2[(s0 >> 8) & 0xFF] ^ FIO___AES_TE3[(s1 >> 0) & 0xFF] ^ rk[2];
  state[3] =
      FIO___AES_TE0[(s3 >> 24) & 0xFF] ^ FIO___AES_TE1[(s0 >> 16) & 0xFF] ^
      FIO___AES_TE2[(s1 >> 8) & 0xFF] ^ FIO___AES_TE3[(s2 >> 0) & 0xFF] ^ rk[3];
}

FIO_IFUNC void fio___aes_encrypt_final_round(uint32_t *state,
                                             const uint32_t *rk) {
  uint32_t s0 = state[0], s1 = state[1], s2 = state[2], s3 = state[3];
  state[0] = ((uint32_t)FIO___AES_SBOX[(s0 >> 24) & 0xFF] << 24) ^
             ((uint32_t)FIO___AES_SBOX[(s1 >> 16) & 0xFF] << 16) ^
             ((uint32_t)FIO___AES_SBOX[(s2 >> 8) & 0xFF] << 8) ^
             ((uint32_t)FIO___AES_SBOX[(s3 >> 0) & 0xFF] << 0) ^ rk[0];
  state[1] = ((uint32_t)FIO___AES_SBOX[(s1 >> 24) & 0xFF] << 24) ^
             ((uint32_t)FIO___AES_SBOX[(s2 >> 16) & 0xFF] << 16) ^
             ((uint32_t)FIO___AES_SBOX[(s3 >> 8) & 0xFF] << 8) ^
             ((uint32_t)FIO___AES_SBOX[(s0 >> 0) & 0xFF] << 0) ^ rk[1];
  state[2] = ((uint32_t)FIO___AES_SBOX[(s2 >> 24) & 0xFF] << 24) ^
             ((uint32_t)FIO___AES_SBOX[(s3 >> 16) & 0xFF] << 16) ^
             ((uint32_t)FIO___AES_SBOX[(s0 >> 8) & 0xFF] << 8) ^
             ((uint32_t)FIO___AES_SBOX[(s1 >> 0) & 0xFF] << 0) ^ rk[2];
  state[3] = ((uint32_t)FIO___AES_SBOX[(s3 >> 24) & 0xFF] << 24) ^
             ((uint32_t)FIO___AES_SBOX[(s0 >> 16) & 0xFF] << 16) ^
             ((uint32_t)FIO___AES_SBOX[(s1 >> 8) & 0xFF] << 8) ^
             ((uint32_t)FIO___AES_SBOX[(s2 >> 0) & 0xFF] << 0) ^ rk[3];
}

FIO_IFUNC void fio___aes128_encrypt_block(uint8_t out[16],
                                          const uint8_t in[16],
                                          const uint32_t *rk) {
  uint32_t state[4];
  fio_memcpy16(state, in);
  state[0] = fio_lton32(state[0]) ^ rk[0];
  state[1] = fio_lton32(state[1]) ^ rk[1];
  state[2] = fio_lton32(state[2]) ^ rk[2];
  state[3] = fio_lton32(state[3]) ^ rk[3];
  for (int round = 1; round < 10; ++round)
    fio___aes_encrypt_round(state, rk + round * 4);
  fio___aes_encrypt_final_round(state, rk + 40);
  state[0] = fio_lton32(state[0]);
  state[1] = fio_lton32(state[1]);
  state[2] = fio_lton32(state[2]);
  state[3] = fio_lton32(state[3]);
  fio_memcpy16(out, state);
}

FIO_IFUNC void fio___aes256_encrypt_block(uint8_t out[16],
                                          const uint8_t in[16],
                                          const uint32_t *rk) {
  uint32_t state[4];
  fio_memcpy16(state, in);
  state[0] = fio_lton32(state[0]) ^ rk[0];
  state[1] = fio_lton32(state[1]) ^ rk[1];
  state[2] = fio_lton32(state[2]) ^ rk[2];
  state[3] = fio_lton32(state[3]) ^ rk[3];
  for (int round = 1; round < 14; ++round)
    fio___aes_encrypt_round(state, rk + round * 4);
  fio___aes_encrypt_final_round(state, rk + 56);
  state[0] = fio_lton32(state[0]);
  state[1] = fio_lton32(state[1]);
  state[2] = fio_lton32(state[2]);
  state[3] = fio_lton32(state[3]);
  fio_memcpy16(out, state);
}

/* 4-bit table-based GHASH using Shoup's method
 *
 * We precompute 16 entries: M[i] = i * H for i=0..15
 * This gives us 256 bytes of tables and 32 iterations per block.
 *
 * We process nibbles from least significant to most significant:
 *   Z = Z * x^4 + nibble * H
 *
 * The multiplication by x^4 is a right shift by 4 bits with reduction.
 * We use a 16-entry reduction table for the nibble that falls off.
 */
typedef struct {
  uint64_t hl[16]; /* Low 64 bits of i*H for i=0..15 */
  uint64_t hh[16]; /* High 64 bits of i*H for i=0..15 */
} fio___gcm_htable_s;

/* Reduction table: when shifting right by 4, the low nibble falls off.
 * Entry i contains the XOR value for the high word when nibble i falls off.
 * Computed as: i * (x^128 mod P) where P = x^128 + x^7 + x^2 + x + 1 */
/* clang-format off */
static const uint64_t FIO___GCM_REDUCE4[16] = {
    0x0000000000000000ULL, 0x1C20000000000000ULL,
    0x3840000000000000ULL, 0x2460000000000000ULL,
    0x7080000000000000ULL, 0x6CA0000000000000ULL,
    0x48C0000000000000ULL, 0x54E0000000000000ULL,
    0xE100000000000000ULL, 0xFD20000000000000ULL,
    0xD940000000000000ULL, 0xC560000000000000ULL,
    0x9180000000000000ULL, 0x8DA0000000000000ULL,
    0xA9C0000000000000ULL, 0xB5E0000000000000ULL
};
/* clang-format on */

/* Precompute the 16-entry multiplication table: M[i] = i * H */
FIO_IFUNC void fio___gcm_precompute_htable(fio___gcm_htable_s *ctx,
                                           const uint8_t h[16]) {
  uint64_t h0 = fio_buf2u64_be(h);
  uint64_t h1 = fio_buf2u64_be(h + 8);

  ctx->hh[0] = 0;
  ctx->hl[0] = 0;
  ctx->hh[8] = h0;
  ctx->hl[8] = h1;

  /* Powers of x times H: M[4] = x*H, M[2] = x^2*H, M[1] = x^3*H */
  uint64_t carry = h1 & 1;
  ctx->hl[4] = (h1 >> 1) | (h0 << 63);
  ctx->hh[4] = (h0 >> 1) ^ (carry ? 0xE100000000000000ULL : 0);

  carry = ctx->hl[4] & 1;
  ctx->hl[2] = (ctx->hl[4] >> 1) | (ctx->hh[4] << 63);
  ctx->hh[2] = (ctx->hh[4] >> 1) ^ (carry ? 0xE100000000000000ULL : 0);

  carry = ctx->hl[2] & 1;
  ctx->hl[1] = (ctx->hl[2] >> 1) | (ctx->hh[2] << 63);
  ctx->hh[1] = (ctx->hh[2] >> 1) ^ (carry ? 0xE100000000000000ULL : 0);

  /* Build remaining entries using XOR (linearity of GF multiplication) */
  ctx->hh[3] = ctx->hh[1] ^ ctx->hh[2];
  ctx->hl[3] = ctx->hl[1] ^ ctx->hl[2];
  ctx->hh[5] = ctx->hh[1] ^ ctx->hh[4];
  ctx->hl[5] = ctx->hl[1] ^ ctx->hl[4];
  ctx->hh[6] = ctx->hh[2] ^ ctx->hh[4];
  ctx->hl[6] = ctx->hl[2] ^ ctx->hl[4];
  ctx->hh[7] = ctx->hh[1] ^ ctx->hh[6];
  ctx->hl[7] = ctx->hl[1] ^ ctx->hl[6];
  ctx->hh[9] = ctx->hh[1] ^ ctx->hh[8];
  ctx->hl[9] = ctx->hl[1] ^ ctx->hl[8];
  ctx->hh[10] = ctx->hh[2] ^ ctx->hh[8];
  ctx->hl[10] = ctx->hl[2] ^ ctx->hl[8];
  ctx->hh[11] = ctx->hh[3] ^ ctx->hh[8];
  ctx->hl[11] = ctx->hl[3] ^ ctx->hl[8];
  ctx->hh[12] = ctx->hh[4] ^ ctx->hh[8];
  ctx->hl[12] = ctx->hl[4] ^ ctx->hl[8];
  ctx->hh[13] = ctx->hh[5] ^ ctx->hh[8];
  ctx->hl[13] = ctx->hl[5] ^ ctx->hl[8];
  ctx->hh[14] = ctx->hh[6] ^ ctx->hh[8];
  ctx->hl[14] = ctx->hl[6] ^ ctx->hl[8];
  ctx->hh[15] = ctx->hh[7] ^ ctx->hh[8];
  ctx->hl[15] = ctx->hl[7] ^ ctx->hl[8];
}

/* GHASH multiplication: result = x * H using 4-bit table
 * Process nibbles from byte 15 down to byte 0, low nibble first
 *
 * Unrolled for better performance - processes 2 bytes (4 nibbles) per iteration
 */
FIO_IFUNC void fio___gcm_ghash_mult(uint64_t z[2],
                                    const uint8_t x[16],
                                    const fio___gcm_htable_s *ctx) {
  uint64_t z0 = 0, z1 = 0;
  uint64_t rem;

  /* Unroll: process 2 bytes at a time */
  for (int i = 14; i >= 0; i -= 2) {
    uint8_t b0 = x[i + 1]; /* Lower byte first */
    uint8_t b1 = x[i];

    /* Byte 0, low nibble */
    rem = z1 & 0xF;
    z1 = (z1 >> 4) | (z0 << 60);
    z0 = (z0 >> 4) ^ FIO___GCM_REDUCE4[rem];
    z0 ^= ctx->hh[b0 & 0xF];
    z1 ^= ctx->hl[b0 & 0xF];

    /* Byte 0, high nibble */
    rem = z1 & 0xF;
    z1 = (z1 >> 4) | (z0 << 60);
    z0 = (z0 >> 4) ^ FIO___GCM_REDUCE4[rem];
    z0 ^= ctx->hh[b0 >> 4];
    z1 ^= ctx->hl[b0 >> 4];

    /* Byte 1, low nibble */
    rem = z1 & 0xF;
    z1 = (z1 >> 4) | (z0 << 60);
    z0 = (z0 >> 4) ^ FIO___GCM_REDUCE4[rem];
    z0 ^= ctx->hh[b1 & 0xF];
    z1 ^= ctx->hl[b1 & 0xF];

    /* Byte 1, high nibble */
    rem = z1 & 0xF;
    z1 = (z1 >> 4) | (z0 << 60);
    z0 = (z0 >> 4) ^ FIO___GCM_REDUCE4[rem];
    z0 ^= ctx->hh[b1 >> 4];
    z1 ^= ctx->hl[b1 >> 4];
  }

  z[0] = z0;
  z[1] = z1;
}

/* GHASH a block: tag = (tag XOR block) * H
 * Optimized to use 64-bit XOR operations */
FIO_IFUNC void fio___gcm_ghash_block(uint64_t tag[2],
                                     const uint8_t block[16],
                                     const fio___gcm_htable_s *ctx) {
  uint8_t tmp[16];
  uint64_t b0 = fio_buf2u64_be(block);
  uint64_t b1 = fio_buf2u64_be(block + 8);
  fio_u2buf64_be(tmp, tag[0] ^ b0);
  fio_u2buf64_be(tmp + 8, tag[1] ^ b1);
  fio___gcm_ghash_mult(tag, tmp, ctx);
}

/* GHASH over data */
FIO_IFUNC void fio___gcm_ghash(uint64_t tag[2],
                               const fio___gcm_htable_s *ctx,
                               const uint8_t *data,
                               size_t len) {
  while (len >= 16) {
    fio___gcm_ghash_block(tag, data, ctx);
    data += 16;
    len -= 16;
  }
  if (len > 0) {
    uint8_t block[16] = {0};
    FIO_MEMCPY(block, data, len);
    fio___gcm_ghash_block(tag, block, ctx);
  }
}

FIO_IFUNC void fio___gcm_inc_counter(uint8_t counter[16]) {
  uint32_t c = fio_buf2u32_be(counter + 12);
  c++;
  fio_u2buf32_be(counter + 12, c);
}

SFUNC void fio_aes128_gcm_enc(void *restrict mac,
                              void *restrict data,
                              size_t len,
                              const void *ad,
                              size_t adlen,
                              const void *key,
                              const void *nonce) {
  uint32_t rk[44];
  uint8_t h[16] = {0};
  fio___gcm_htable_s htbl;
  uint8_t j0[16];
  uint8_t counter[16];
  uint8_t keystream[16];
  uint64_t tag[2] = {0, 0};
  uint8_t len_block[16];
  uint8_t *p = (uint8_t *)data;
  size_t orig_len = len;

  fio___aes128_key_expand(rk, (const uint8_t *)key);
  fio___aes128_encrypt_block(h, h, rk);
  fio___gcm_precompute_htable(&htbl, h);

  FIO_MEMCPY(j0, nonce, 12);
  j0[12] = 0;
  j0[13] = 0;
  j0[14] = 0;
  j0[15] = 1;

  fio___gcm_ghash(tag, &htbl, (const uint8_t *)ad, adlen);

  FIO_MEMCPY(counter, j0, 16);
  while (len >= 16) {
    fio___gcm_inc_counter(counter);
    fio___aes128_encrypt_block(keystream, counter, rk);
    /* XOR 16 bytes - use byte-by-byte to avoid alignment issues */
    for (size_t i = 0; i < 16; ++i)
      p[i] ^= keystream[i];
    fio___gcm_ghash_block(tag, p, &htbl);
    p += 16;
    len -= 16;
  }
  if (len > 0) {
    fio___gcm_inc_counter(counter);
    fio___aes128_encrypt_block(keystream, counter, rk);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= keystream[i];
    uint8_t block[16] = {0};
    FIO_MEMCPY(block, p, len);
    fio___gcm_ghash_block(tag, block, &htbl);
  }

  FIO_MEMSET(len_block, 0, 16);
  fio_u2buf64_be(len_block, (uint64_t)adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  fio___gcm_ghash_block(tag, len_block, &htbl);

  fio___aes128_encrypt_block(keystream, j0, rk);
  fio_u2buf64_be((uint8_t *)mac, tag[0]);
  fio_u2buf64_be((uint8_t *)mac + 8, tag[1]);
  for (int i = 0; i < 16; ++i)
    ((uint8_t *)mac)[i] ^= keystream[i];
  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(&htbl, sizeof(htbl));
  fio_secure_zero(j0, sizeof(j0));
  fio_secure_zero(counter, sizeof(counter));
  fio_secure_zero(keystream, sizeof(keystream));
  fio_secure_zero(tag, sizeof(tag));
}

SFUNC void fio_aes256_gcm_enc(void *restrict mac,
                              void *restrict data,
                              size_t len,
                              const void *ad,
                              size_t adlen,
                              const void *key,
                              const void *nonce) {
  uint32_t rk[60];
  uint8_t h[16] = {0};
  fio___gcm_htable_s htbl;
  uint8_t j0[16];
  uint8_t counter[16];
  uint8_t keystream[16];
  uint64_t tag[2] = {0, 0};
  uint8_t len_block[16];
  uint8_t *p = (uint8_t *)data;
  size_t orig_len = len;

  fio___aes256_key_expand(rk, (const uint8_t *)key);
  fio___aes256_encrypt_block(h, h, rk);
  fio___gcm_precompute_htable(&htbl, h);

  FIO_MEMCPY(j0, nonce, 12);
  j0[12] = 0;
  j0[13] = 0;
  j0[14] = 0;
  j0[15] = 1;

  fio___gcm_ghash(tag, &htbl, (const uint8_t *)ad, adlen);

  FIO_MEMCPY(counter, j0, 16);
  while (len >= 16) {
    fio___gcm_inc_counter(counter);
    fio___aes256_encrypt_block(keystream, counter, rk);
    /* XOR 16 bytes - use byte-by-byte to avoid alignment issues */
    for (size_t i = 0; i < 16; ++i)
      p[i] ^= keystream[i];
    fio___gcm_ghash_block(tag, p, &htbl);
    p += 16;
    len -= 16;
  }
  if (len > 0) {
    fio___gcm_inc_counter(counter);
    fio___aes256_encrypt_block(keystream, counter, rk);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= keystream[i];
    uint8_t block[16] = {0};
    FIO_MEMCPY(block, p, len);
    fio___gcm_ghash_block(tag, block, &htbl);
  }

  FIO_MEMSET(len_block, 0, 16);
  fio_u2buf64_be(len_block, (uint64_t)adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  fio___gcm_ghash_block(tag, len_block, &htbl);

  fio___aes256_encrypt_block(keystream, j0, rk);
  fio_u2buf64_be((uint8_t *)mac, tag[0]);
  fio_u2buf64_be((uint8_t *)mac + 8, tag[1]);
  for (int i = 0; i < 16; ++i)
    ((uint8_t *)mac)[i] ^= keystream[i];
  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(&htbl, sizeof(htbl));
  fio_secure_zero(j0, sizeof(j0));
  fio_secure_zero(counter, sizeof(counter));
  fio_secure_zero(keystream, sizeof(keystream));
  fio_secure_zero(tag, sizeof(tag));
}

SFUNC int fio_aes128_gcm_dec(void *restrict mac,
                             void *restrict data,
                             size_t len,
                             const void *ad,
                             size_t adlen,
                             const void *key,
                             const void *nonce) {
  uint32_t rk[44];
  uint8_t h[16] = {0};
  fio___gcm_htable_s htbl;
  uint8_t j0[16];
  uint8_t counter[16];
  uint8_t keystream[16];
  uint64_t tag[2] = {0, 0};
  uint8_t len_block[16];
  uint8_t computed_mac[16];
  uint8_t *p = (uint8_t *)data;
  size_t orig_len = len;

  fio___aes128_key_expand(rk, (const uint8_t *)key);
  fio___aes128_encrypt_block(h, h, rk);
  fio___gcm_precompute_htable(&htbl, h);

  FIO_MEMCPY(j0, nonce, 12);
  j0[12] = 0;
  j0[13] = 0;
  j0[14] = 0;
  j0[15] = 1;

  fio___gcm_ghash(tag, &htbl, (const uint8_t *)ad, adlen);
  fio___gcm_ghash(tag, &htbl, p, orig_len);

  FIO_MEMSET(len_block, 0, 16);
  fio_u2buf64_be(len_block, (uint64_t)adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  fio___gcm_ghash_block(tag, len_block, &htbl);

  fio___aes128_encrypt_block(keystream, j0, rk);
  fio_u2buf64_be(computed_mac, tag[0]);
  fio_u2buf64_be(computed_mac + 8, tag[1]);
  for (int i = 0; i < 16; ++i)
    computed_mac[i] ^= keystream[i];

  if (!fio_ct_is_eq(computed_mac, mac, 16)) {
    fio_secure_zero(computed_mac, sizeof(computed_mac));
    fio_secure_zero(rk, sizeof(rk));
    fio_secure_zero(&htbl, sizeof(htbl));
    fio_secure_zero(j0, sizeof(j0));
    fio_secure_zero(counter, sizeof(counter));
    fio_secure_zero(keystream, sizeof(keystream));
    fio_secure_zero(tag, sizeof(tag));
    return -1;
  }
  fio_secure_zero(computed_mac, sizeof(computed_mac));

  FIO_MEMCPY(counter, j0, 16);
  while (len >= 16) {
    fio___gcm_inc_counter(counter);
    fio___aes128_encrypt_block(keystream, counter, rk);
    /* Use 64-bit XOR for better performance */
    uint64_t *p64 = (uint64_t *)p;
    uint64_t *ks64 = (uint64_t *)keystream;
    p64[0] ^= ks64[0];
    p64[1] ^= ks64[1];
    p += 16;
    len -= 16;
  }
  if (len > 0) {
    fio___gcm_inc_counter(counter);
    fio___aes128_encrypt_block(keystream, counter, rk);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= keystream[i];
  }
  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(&htbl, sizeof(htbl));
  fio_secure_zero(j0, sizeof(j0));
  fio_secure_zero(counter, sizeof(counter));
  fio_secure_zero(keystream, sizeof(keystream));
  fio_secure_zero(tag, sizeof(tag));
  return 0;
}

SFUNC int fio_aes256_gcm_dec(void *restrict mac,
                             void *restrict data,
                             size_t len,
                             const void *ad,
                             size_t adlen,
                             const void *key,
                             const void *nonce) {
  uint32_t rk[60];
  uint8_t h[16] = {0};
  fio___gcm_htable_s htbl;
  uint8_t j0[16];
  uint8_t counter[16];
  uint8_t keystream[16];
  uint64_t tag[2] = {0, 0};
  uint8_t len_block[16];
  uint8_t computed_mac[16];
  uint8_t *p = (uint8_t *)data;
  size_t orig_len = len;

  fio___aes256_key_expand(rk, (const uint8_t *)key);
  fio___aes256_encrypt_block(h, h, rk);
  fio___gcm_precompute_htable(&htbl, h);

  FIO_MEMCPY(j0, nonce, 12);
  j0[12] = 0;
  j0[13] = 0;
  j0[14] = 0;
  j0[15] = 1;

  fio___gcm_ghash(tag, &htbl, (const uint8_t *)ad, adlen);
  fio___gcm_ghash(tag, &htbl, p, orig_len);

  FIO_MEMSET(len_block, 0, 16);
  fio_u2buf64_be(len_block, (uint64_t)adlen * 8);
  fio_u2buf64_be(len_block + 8, (uint64_t)orig_len * 8);
  fio___gcm_ghash_block(tag, len_block, &htbl);

  fio___aes256_encrypt_block(keystream, j0, rk);
  fio_u2buf64_be(computed_mac, tag[0]);
  fio_u2buf64_be(computed_mac + 8, tag[1]);
  for (int i = 0; i < 16; ++i)
    computed_mac[i] ^= keystream[i];

  if (!fio_ct_is_eq(computed_mac, mac, 16)) {
    fio_secure_zero(computed_mac, sizeof(computed_mac));
    fio_secure_zero(rk, sizeof(rk));
    fio_secure_zero(&htbl, sizeof(htbl));
    fio_secure_zero(j0, sizeof(j0));
    fio_secure_zero(counter, sizeof(counter));
    fio_secure_zero(keystream, sizeof(keystream));
    fio_secure_zero(tag, sizeof(tag));
    return -1;
  }
  fio_secure_zero(computed_mac, sizeof(computed_mac));

  FIO_MEMCPY(counter, j0, 16);
  while (len >= 16) {
    fio___gcm_inc_counter(counter);
    fio___aes256_encrypt_block(keystream, counter, rk);
    /* Use 64-bit XOR for better performance */
    uint64_t *p64 = (uint64_t *)p;
    uint64_t *ks64 = (uint64_t *)keystream;
    p64[0] ^= ks64[0];
    p64[1] ^= ks64[1];
    p += 16;
    len -= 16;
  }
  if (len > 0) {
    fio___gcm_inc_counter(counter);
    fio___aes256_encrypt_block(keystream, counter, rk);
    for (size_t i = 0; i < len; ++i)
      p[i] ^= keystream[i];
  }
  /* Clear sensitive data */
  fio_secure_zero(rk, sizeof(rk));
  fio_secure_zero(&htbl, sizeof(htbl));
  fio_secure_zero(j0, sizeof(j0));
  fio_secure_zero(counter, sizeof(counter));
  fio_secure_zero(keystream, sizeof(keystream));
  fio_secure_zero(tag, sizeof(tag));
  return 0;
}

#endif /* Hardware vs Software implementation */

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_AES
#endif /* FIO_AES */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_ED25519            /* Development inclusion - ignore line */
#define FIO_SHA2               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                    Elliptic Curve Cryptography: Ed25519 & X25519




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_ED25519) && !defined(H___FIO_ED25519___H)
#define H___FIO_ED25519___H

/* *****************************************************************************
Curve25519 Cryptography Module

This module provides:
- Ed25519: Digital signatures (sign/verify)
- X25519:  Key exchange (ECDH) for deriving shared secrets

These are the minimal building blocks for secure inter-machine communication.
A tested cryptographic library (e.g., OpenSSL) is preferred when available,
but this implementation provides security when no alternative exists.

**Note**: This implementation has not been audited. Use at your own risk.
***************************************************************************** */

/* *****************************************************************************
Ed25519 Digital Signatures API

Ed25519 provides fast, secure digital signatures with 128-bit security level.
- Secret key (sk): 32 bytes (expanded internally to 64 bytes)
- Public key (pk): 32 bytes
- Signature:       64 bytes
***************************************************************************** */

/**
 * Generates a new random Ed25519 key pair.
 *
 * The secret key must be kept secret and securely erased when no longer
 * needed. The public key can be freely shared.
 */
SFUNC void fio_ed25519_keypair(uint8_t secret_key[32], uint8_t public_key[32]);

/**
 * Derives the public key from an Ed25519 secret key.
 *
 * Useful when the secret key is loaded from storage and the public key
 * needs to be recomputed.
 */
SFUNC void fio_ed25519_public_key(uint8_t public_key[32],
                                  const uint8_t secret_key[32]);

/**
 * Signs a message using Ed25519.
 *
 * The signature is 64 bytes and is deterministic (same message + key = same
 * signature).
 */
SFUNC void fio_ed25519_sign(uint8_t signature[64],
                            const void *message,
                            size_t len,
                            const uint8_t secret_key[32],
                            const uint8_t public_key[32]);

/**
 * Verifies an Ed25519 signature.
 *
 * Returns 0 on success (valid signature), -1 on failure (invalid signature).
 */
SFUNC int fio_ed25519_verify(const uint8_t signature[64],
                             const void *message,
                             size_t len,
                             const uint8_t public_key[32]);

/* *****************************************************************************
X25519 Key Exchange (ECDH) API

X25519 provides Elliptic Curve Diffie-Hellman key exchange with 128-bit
security level. Two parties can derive a shared secret using their secret
key and the other party's public key.

- Secret key (sk): 32 bytes
- Public key (pk): 32 bytes
- Shared secret:   32 bytes (should be passed through a KDF before use)
***************************************************************************** */

/**
 * Generates a new random X25519 key pair.
 *
 * The secret key must be kept secret. The public key can be shared with
 * the other party for key exchange.
 */
SFUNC void fio_x25519_keypair(uint8_t secret_key[32], uint8_t public_key[32]);

/**
 * Derives the public key from an X25519 secret key.
 *
 * This performs scalar multiplication of the secret key with the base point.
 */
SFUNC void fio_x25519_public_key(uint8_t public_key[32],
                                 const uint8_t secret_key[32]);

/**
 * Computes a shared secret using X25519 (ECDH).
 *
 * Both parties compute the same shared secret:
 *   shared = X25519(my_secret, their_public)
 *
 * The shared secret should be passed through a KDF (e.g., HKDF with SHA-256)
 * before being used as an encryption key.
 *
 * Returns 0 on success, -1 on failure (e.g., if their_public is a low-order
 * point, which would result in an all-zero shared secret).
 */
SFUNC int fio_x25519_shared_secret(uint8_t shared_secret[32],
                                   const uint8_t secret_key[32],
                                   const uint8_t their_public_key[32]);

/* *****************************************************************************
Key Conversion API

Ed25519 and X25519 use the same underlying curve but with different
representations. These functions convert between the two formats, allowing
a single key pair to be used for both signing and encryption.

Note: Converting keys is generally safe, but using the same key for both
signing and encryption is debated. Consider using separate key pairs for
maximum security.
***************************************************************************** */

/**
 * Converts an Ed25519 secret key to an X25519 secret key.
 *
 * This allows using an Ed25519 signing key for X25519 key exchange.
 */
SFUNC void fio_ed25519_sk_to_x25519(uint8_t x_secret_key[32],
                                    const uint8_t ed_secret_key[32]);

/**
 * Converts an Ed25519 public key to an X25519 public key.
 *
 * This allows encrypting to someone who has only shared their Ed25519
 * signing public key.
 */
SFUNC void fio_ed25519_pk_to_x25519(uint8_t x_public_key[32],
                                    const uint8_t ed_public_key[32]);

/* *****************************************************************************
Public Key Encryption API (ECIES - Elliptic Curve Integrated Encryption Scheme)

This provides asymmetric encryption where anyone can encrypt a message using
only the recipient's public key, and only the recipient can decrypt it using
their private key. No prior key exchange or handshake is required.

The scheme uses:
- X25519 for ephemeral key agreement
- SHA-256 for key derivation (HKDF-like)
- ChaCha20-Poly1305 or AES256-GCM for authenticated encryption

Ciphertext format: [32-byte ephemeral public key][16-byte MAC][encrypted data]
Total overhead: 48 bytes
***************************************************************************** */

/**
 * Encrypts a message using the recipient's X25519 public key.
 *
 * The ciphertext includes:
 * - 32 bytes: ephemeral public key (for key agreement)
 * - 16 bytes: authentication tag (MAC)
 * - N bytes:  encrypted message
 *
 * Total ciphertext size = message_len + 48 bytes
 *
 * @param ciphertext Output buffer (must be at least message_len + 48 bytes)
 * @param message    The plaintext message to encrypt
 * @param message_len Length of the message
 * @param encryption_function Encryption function (fio_chacha20_poly1305_enc)
 * @param recipient_pk The recipient's X25519 public key (32 bytes)
 * @return 0 on success, -1 on failure
 */
SFUNC int fio_x25519_encrypt(uint8_t *ciphertext,
                             const void *message,
                             size_t message_len,
                             fio_crypto_enc_fn encryption_function,
                             const uint8_t recipient_pk[32]);

/**
 * Decrypts a message using the recipient's X25519 secret key.
 *
 * @param plaintext   Output buffer (must be at least ciphertext_len - 48 bytes)
 * @param ciphertext  The ciphertext (ephemeral_pk || mac || encrypted_data)
 * @param ciphertext_len Length of the ciphertext (must be >= 48)
 * @param decryption_function Decryption function (fio_chacha20_poly1305_dec)
 * @param recipient_sk The recipient's X25519 secret key (32 bytes)
 * @return 0 on success, -1 on failure (authentication failed or invalid input)
 */
SFUNC int fio_x25519_decrypt(uint8_t *plaintext,
                             const uint8_t *ciphertext,
                             size_t ciphertext_len,
                             fio_crypto_dec_fn decryption_function,
                             const uint8_t recipient_sk[32]);

/**
 * Returns the ciphertext length for a given plaintext length.
 * Ciphertext = ephemeral_pk (32) + mac (16) + encrypted_message (message_len)
 */
#define FIO_X25519_CIPHERTEXT_LEN(message_len) ((message_len) + 48)

/**
 * Returns the plaintext length for a given ciphertext length.
 * Returns 0 if ciphertext_len < 48 (invalid ciphertext).
 */
#define FIO_X25519_PLAINTEXT_LEN(ciphertext_len)                               \
  ((ciphertext_len) > 48 ? ((ciphertext_len)-48) : 0)

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Field Arithmetic for GF(2^255 - 19) - Radix 2^51 Implementation

Based on curve25519-donna-64bit by Andrew Moon.
Uses 5 limbs of 51 bits each, stored in uint64_t.
Uses fio_math_mulc64 for portable 64x64->128 bit multiplication.

This provides ~10x fewer multiplications than radix-2^16 (25 vs 256).
***************************************************************************** */

/* Field element: 5 limbs in radix 2^51 */
typedef uint64_t fio___gf_s[5];

/* Masks for reduction */
#define FIO___GF_MASK51 ((1ULL << 51) - 1)

/* Load 32-byte little-endian number into field element */
FIO_IFUNC void fio___gf_frombytes(fio___gf_s r, const uint8_t in[32]) {
  uint64_t x0 = fio_buf2u64_le(in);
  uint64_t x1 = fio_buf2u64_le(in + 8);
  uint64_t x2 = fio_buf2u64_le(in + 16);
  uint64_t x3 = fio_buf2u64_le(in + 24);

  r[0] = x0 & FIO___GF_MASK51;
  x0 = (x0 >> 51) | (x1 << 13);
  r[1] = x0 & FIO___GF_MASK51;
  x1 = (x1 >> 38) | (x2 << 26);
  r[2] = x1 & FIO___GF_MASK51;
  x2 = (x2 >> 25) | (x3 << 39);
  r[3] = x2 & FIO___GF_MASK51;
  x3 = (x3 >> 12);
  r[4] = x3 & FIO___GF_MASK51;
}

/* Conditional swap: swap p and q if b is 1, else no-op (constant time) */
FIO_IFUNC void fio___gf_cswap(fio___gf_s p, fio___gf_s q, int b) {
  uint64_t mask = (uint64_t)0 - (uint64_t)b;
  uint64_t t;
  t = mask & (p[0] ^ q[0]);
  p[0] ^= t;
  q[0] ^= t;
  t = mask & (p[1] ^ q[1]);
  p[1] ^= t;
  q[1] ^= t;
  t = mask & (p[2] ^ q[2]);
  p[2] ^= t;
  q[2] ^= t;
  t = mask & (p[3] ^ q[3]);
  p[3] ^= t;
  q[3] ^= t;
  t = mask & (p[4] ^ q[4]);
  p[4] ^= t;
  q[4] ^= t;
}

/* Store field element to 32-byte little-endian output (fully reduced) */
FIO_IFUNC void fio___gf_tobytes(uint8_t out[32], fio___gf_s n) {
  uint64_t t0 = n[0], t1 = n[1], t2 = n[2], t3 = n[3], t4 = n[4];

  /* Carry chain */
  t1 += t0 >> 51;
  t0 &= FIO___GF_MASK51;
  t2 += t1 >> 51;
  t1 &= FIO___GF_MASK51;
  t3 += t2 >> 51;
  t2 &= FIO___GF_MASK51;
  t4 += t3 >> 51;
  t3 &= FIO___GF_MASK51;
  t0 += 19 * (t4 >> 51);
  t4 &= FIO___GF_MASK51;

  /* Second carry pass */
  t1 += t0 >> 51;
  t0 &= FIO___GF_MASK51;
  t2 += t1 >> 51;
  t1 &= FIO___GF_MASK51;
  t3 += t2 >> 51;
  t2 &= FIO___GF_MASK51;
  t4 += t3 >> 51;
  t3 &= FIO___GF_MASK51;
  t0 += 19 * (t4 >> 51);
  t4 &= FIO___GF_MASK51;

  /* Now t is between 0 and 2^255-1, properly carried.
   * Compute t - p = t - (2^255 - 19) = t + 19 - 2^255
   * If result is positive (no borrow from bit 255), use it. */
  t0 += 19;
  t1 += t0 >> 51;
  t0 &= FIO___GF_MASK51;
  t2 += t1 >> 51;
  t1 &= FIO___GF_MASK51;
  t3 += t2 >> 51;
  t2 &= FIO___GF_MASK51;
  t4 += t3 >> 51;
  t3 &= FIO___GF_MASK51;
  /* t4 now has bit 51 set if t >= p */
  uint64_t c = t4 >> 51;
  t4 &= FIO___GF_MASK51;

  /* If c == 0, we need to subtract 19 back (t was < p) */
  uint64_t mask = c - 1; /* 0 if c==1, all 1s if c==0 */
  t0 -= 19 & mask;
  /* Propagate borrow */
  c = (t0 >> 63);
  t0 &= FIO___GF_MASK51;
  t1 -= c;
  c = (t1 >> 63);
  t1 &= FIO___GF_MASK51;
  t2 -= c;
  c = (t2 >> 63);
  t2 &= FIO___GF_MASK51;
  t3 -= c;
  c = (t3 >> 63);
  t3 &= FIO___GF_MASK51;
  t4 -= c;
  t4 &= FIO___GF_MASK51;

  /* Pack into bytes */
  uint64_t r0 = t0 | (t1 << 51);
  uint64_t r1 = (t1 >> 13) | (t2 << 38);
  uint64_t r2 = (t2 >> 26) | (t3 << 25);
  uint64_t r3 = (t3 >> 39) | (t4 << 12);

  fio_u2buf64_le(out, r0);
  fio_u2buf64_le(out + 8, r1);
  fio_u2buf64_le(out + 16, r2);
  fio_u2buf64_le(out + 24, r3);
}

/* Field element addition: h = f + g */
FIO_IFUNC void fio___gf_add(fio___gf_s h,
                            const fio___gf_s f,
                            const fio___gf_s g) {
  h[0] = f[0] + g[0];
  h[1] = f[1] + g[1];
  h[2] = f[2] + g[2];
  h[3] = f[3] + g[3];
  h[4] = f[4] + g[4];
}

/* Constants for subtraction: 2^54 - 152 and 2^54 - 8 */
#define FIO___GF_TWO54M152 ((1ULL << 54) - 152)
#define FIO___GF_TWO54M8   ((1ULL << 54) - 8)

/* Field element subtraction: h = f - g */
FIO_IFUNC void fio___gf_sub(fio___gf_s h,
                            const fio___gf_s f,
                            const fio___gf_s g) {
  h[0] = f[0] + FIO___GF_TWO54M152 - g[0];
  h[1] = f[1] + FIO___GF_TWO54M8 - g[1];
  h[2] = f[2] + FIO___GF_TWO54M8 - g[2];
  h[3] = f[3] + FIO___GF_TWO54M8 - g[3];
  h[4] = f[4] + FIO___GF_TWO54M8 - g[4];
}

/* Helper: add 64-bit value to 128-bit accumulator (lo, hi) */
#define FIO___GF_ADD128_64(lo, hi, v)                                          \
  do {                                                                         \
    uint64_t _c;                                                               \
    (lo) = fio_math_addc64((lo), (v), 0, &_c);                                 \
    (hi) += _c;                                                                \
  } while (0)

/* Helper: 128-bit right shift by 51 bits, return result as 64-bit */
#define FIO___GF_SHR128_51(lo, hi) (((lo) >> 51) | ((hi) << 13))

/* Field element multiplication: o = a * b
 * Uses fio_math_mulc64 for 64x64->128 multiplication */
FIO_IFUNC void fio___gf_mul(fio___gf_s o,
                            const fio___gf_s a,
                            const fio___gf_s b) {
  uint64_t t0_lo, t0_hi, t1_lo, t1_hi, t2_lo, t2_hi, t3_lo, t3_hi, t4_lo, t4_hi;
  uint64_t tmp_lo, tmp_hi;
  uint64_t r0, r1, r2, r3, r4, s0, s1, s2, s3, s4, c;

  r0 = b[0];
  r1 = b[1];
  r2 = b[2];
  r3 = b[3];
  r4 = b[4];
  s0 = a[0];
  s1 = a[1];
  s2 = a[2];
  s3 = a[3];
  s4 = a[4];

  /* Compute direct products t[i] = sum of r[j]*s[i-j] for j <= i */
  t0_lo = fio_math_mulc64(r0, s0, &t0_hi);

  t1_lo = fio_math_mulc64(r0, s1, &t1_hi);
  tmp_lo = fio_math_mulc64(r1, s0, &tmp_hi);
  FIO___GF_ADD128_64(t1_lo, t1_hi, tmp_lo);
  t1_hi += tmp_hi;

  t2_lo = fio_math_mulc64(r0, s2, &t2_hi);
  tmp_lo = fio_math_mulc64(r2, s0, &tmp_hi);
  FIO___GF_ADD128_64(t2_lo, t2_hi, tmp_lo);
  t2_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r1, s1, &tmp_hi);
  FIO___GF_ADD128_64(t2_lo, t2_hi, tmp_lo);
  t2_hi += tmp_hi;

  t3_lo = fio_math_mulc64(r0, s3, &t3_hi);
  tmp_lo = fio_math_mulc64(r3, s0, &tmp_hi);
  FIO___GF_ADD128_64(t3_lo, t3_hi, tmp_lo);
  t3_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r1, s2, &tmp_hi);
  FIO___GF_ADD128_64(t3_lo, t3_hi, tmp_lo);
  t3_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r2, s1, &tmp_hi);
  FIO___GF_ADD128_64(t3_lo, t3_hi, tmp_lo);
  t3_hi += tmp_hi;

  t4_lo = fio_math_mulc64(r0, s4, &t4_hi);
  tmp_lo = fio_math_mulc64(r4, s0, &tmp_hi);
  FIO___GF_ADD128_64(t4_lo, t4_hi, tmp_lo);
  t4_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r3, s1, &tmp_hi);
  FIO___GF_ADD128_64(t4_lo, t4_hi, tmp_lo);
  t4_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r1, s3, &tmp_hi);
  FIO___GF_ADD128_64(t4_lo, t4_hi, tmp_lo);
  t4_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r2, s2, &tmp_hi);
  FIO___GF_ADD128_64(t4_lo, t4_hi, tmp_lo);
  t4_hi += tmp_hi;

  /* Multiply r1-r4 by 19 for wrapped terms */
  r1 *= 19;
  r2 *= 19;
  r3 *= 19;
  r4 *= 19;

  /* Add wrapped products */
  tmp_lo = fio_math_mulc64(r4, s1, &tmp_hi);
  FIO___GF_ADD128_64(t0_lo, t0_hi, tmp_lo);
  t0_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r1, s4, &tmp_hi);
  FIO___GF_ADD128_64(t0_lo, t0_hi, tmp_lo);
  t0_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r2, s3, &tmp_hi);
  FIO___GF_ADD128_64(t0_lo, t0_hi, tmp_lo);
  t0_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r3, s2, &tmp_hi);
  FIO___GF_ADD128_64(t0_lo, t0_hi, tmp_lo);
  t0_hi += tmp_hi;

  tmp_lo = fio_math_mulc64(r4, s2, &tmp_hi);
  FIO___GF_ADD128_64(t1_lo, t1_hi, tmp_lo);
  t1_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r2, s4, &tmp_hi);
  FIO___GF_ADD128_64(t1_lo, t1_hi, tmp_lo);
  t1_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r3, s3, &tmp_hi);
  FIO___GF_ADD128_64(t1_lo, t1_hi, tmp_lo);
  t1_hi += tmp_hi;

  tmp_lo = fio_math_mulc64(r4, s3, &tmp_hi);
  FIO___GF_ADD128_64(t2_lo, t2_hi, tmp_lo);
  t2_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r3, s4, &tmp_hi);
  FIO___GF_ADD128_64(t2_lo, t2_hi, tmp_lo);
  t2_hi += tmp_hi;

  tmp_lo = fio_math_mulc64(r4, s4, &tmp_hi);
  FIO___GF_ADD128_64(t3_lo, t3_hi, tmp_lo);
  t3_hi += tmp_hi;

  /* Carry propagation */
  r0 = t0_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t0_lo, t0_hi);
  FIO___GF_ADD128_64(t1_lo, t1_hi, c);
  r1 = t1_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t1_lo, t1_hi);
  FIO___GF_ADD128_64(t2_lo, t2_hi, c);
  r2 = t2_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t2_lo, t2_hi);
  FIO___GF_ADD128_64(t3_lo, t3_hi, c);
  r3 = t3_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t3_lo, t3_hi);
  FIO___GF_ADD128_64(t4_lo, t4_hi, c);
  r4 = t4_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t4_lo, t4_hi);
  r0 += c * 19;
  c = r0 >> 51;
  r0 &= FIO___GF_MASK51;
  r1 += c;

  o[0] = r0;
  o[1] = r1;
  o[2] = r2;
  o[3] = r3;
  o[4] = r4;
}

/* Field element squaring: o = f^2
 * Optimized: uses symmetry to reduce multiplications */
FIO_IFUNC void fio___gf_sqr(fio___gf_s o, const fio___gf_s f) {
  uint64_t t0_lo, t0_hi, t1_lo, t1_hi, t2_lo, t2_hi, t3_lo, t3_hi, t4_lo, t4_hi;
  uint64_t tmp_lo, tmp_hi;
  uint64_t r0, r1, r2, r3, r4, c;
  uint64_t d0, d1, d2, d419, d4;

  r0 = f[0];
  r1 = f[1];
  r2 = f[2];
  r3 = f[3];
  r4 = f[4];

  d0 = r0 * 2;
  d1 = r1 * 2;
  d2 = r2 * 2 * 19;
  d419 = r4 * 19;
  d4 = d419 * 2;

  /* t0 = r0^2 + 2*19*r4*r1 + 2*19*r2*r3 */
  t0_lo = fio_math_mulc64(r0, r0, &t0_hi);
  tmp_lo = fio_math_mulc64(d4, r1, &tmp_hi);
  FIO___GF_ADD128_64(t0_lo, t0_hi, tmp_lo);
  t0_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(d2, r3, &tmp_hi);
  FIO___GF_ADD128_64(t0_lo, t0_hi, tmp_lo);
  t0_hi += tmp_hi;

  /* t1 = 2*r0*r1 + 2*19*r4*r2 + 19*r3^2 */
  t1_lo = fio_math_mulc64(d0, r1, &t1_hi);
  tmp_lo = fio_math_mulc64(d4, r2, &tmp_hi);
  FIO___GF_ADD128_64(t1_lo, t1_hi, tmp_lo);
  t1_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r3, r3 * 19, &tmp_hi);
  FIO___GF_ADD128_64(t1_lo, t1_hi, tmp_lo);
  t1_hi += tmp_hi;

  /* t2 = 2*r0*r2 + r1^2 + 2*19*r4*r3 */
  t2_lo = fio_math_mulc64(d0, r2, &t2_hi);
  tmp_lo = fio_math_mulc64(r1, r1, &tmp_hi);
  FIO___GF_ADD128_64(t2_lo, t2_hi, tmp_lo);
  t2_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(d4, r3, &tmp_hi);
  FIO___GF_ADD128_64(t2_lo, t2_hi, tmp_lo);
  t2_hi += tmp_hi;

  /* t3 = 2*r0*r3 + 2*r1*r2 + 19*r4^2 */
  t3_lo = fio_math_mulc64(d0, r3, &t3_hi);
  tmp_lo = fio_math_mulc64(d1, r2, &tmp_hi);
  FIO___GF_ADD128_64(t3_lo, t3_hi, tmp_lo);
  t3_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r4, d419, &tmp_hi);
  FIO___GF_ADD128_64(t3_lo, t3_hi, tmp_lo);
  t3_hi += tmp_hi;

  /* t4 = 2*r0*r4 + 2*r1*r3 + r2^2 */
  t4_lo = fio_math_mulc64(d0, r4, &t4_hi);
  tmp_lo = fio_math_mulc64(d1, r3, &tmp_hi);
  FIO___GF_ADD128_64(t4_lo, t4_hi, tmp_lo);
  t4_hi += tmp_hi;
  tmp_lo = fio_math_mulc64(r2, r2, &tmp_hi);
  FIO___GF_ADD128_64(t4_lo, t4_hi, tmp_lo);
  t4_hi += tmp_hi;

  /* Carry propagation */
  r0 = t0_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t0_lo, t0_hi);
  FIO___GF_ADD128_64(t1_lo, t1_hi, c);
  r1 = t1_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t1_lo, t1_hi);
  FIO___GF_ADD128_64(t2_lo, t2_hi, c);
  r2 = t2_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t2_lo, t2_hi);
  FIO___GF_ADD128_64(t3_lo, t3_hi, c);
  r3 = t3_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t3_lo, t3_hi);
  FIO___GF_ADD128_64(t4_lo, t4_hi, c);
  r4 = t4_lo & FIO___GF_MASK51;
  c = FIO___GF_SHR128_51(t4_lo, t4_hi);
  r0 += c * 19;
  c = r0 >> 51;
  r0 &= FIO___GF_MASK51;
  r1 += c;

  o[0] = r0;
  o[1] = r1;
  o[2] = r2;
  o[3] = r3;
  o[4] = r4;
}

/* Field element inversion: o = 1/i using Fermat's little theorem
 * f^(-1) = f^(p-2) where p = 2^255 - 19 */
FIO_IFUNC void fio___gf_inv(fio___gf_s o, const fio___gf_s i) {
  fio___gf_s c;
  int a;
  c[0] = i[0];
  c[1] = i[1];
  c[2] = i[2];
  c[3] = i[3];
  c[4] = i[4];
  for (a = 253; a >= 0; --a) {
    fio___gf_sqr(c, c);
    if (a != 2 && a != 4)
      fio___gf_mul(c, c, i);
  }
  o[0] = c[0];
  o[1] = c[1];
  o[2] = c[2];
  o[3] = c[3];
  o[4] = c[4];
}

/* Compute f^((p-5)/8) for square root computation */
FIO_IFUNC void fio___gf_pow_pm5d8(fio___gf_s o, const fio___gf_s i) {
  fio___gf_s c;
  int a;
  c[0] = i[0];
  c[1] = i[1];
  c[2] = i[2];
  c[3] = i[3];
  c[4] = i[4];
  for (a = 250; a >= 0; --a) {
    fio___gf_sqr(c, c);
    if (a != 1)
      fio___gf_mul(c, c, i);
  }
  o[0] = c[0];
  o[1] = c[1];
  o[2] = c[2];
  o[3] = c[3];
  o[4] = c[4];
}

/* Check if field element is zero */
FIO_IFUNC int fio___gf_iszero(fio___gf_s f) {
  uint8_t s[32];
  fio___gf_tobytes(s, f);
  uint8_t r = 0;
  for (int i = 0; i < 32; ++i)
    r |= s[i];
  return r == 0;
}

/* Check if field element is negative (LSB of canonical form) */
FIO_IFUNC int fio___gf_isneg(fio___gf_s f) {
  uint8_t s[32];
  fio___gf_tobytes(s, f);
  return s[0] & 1;
}

/* Field element negation: o = -f */
FIO_IFUNC void fio___gf_neg(fio___gf_s o, const fio___gf_s f) {
  /* 0 - f = (2p - f) mod p, using subtraction constants */
  o[0] = FIO___GF_TWO54M152 - f[0];
  o[1] = FIO___GF_TWO54M8 - f[1];
  o[2] = FIO___GF_TWO54M8 - f[2];
  o[3] = FIO___GF_TWO54M8 - f[3];
  o[4] = FIO___GF_TWO54M8 - f[4];
}

/* Set field element to 1 */
FIO_IFUNC void fio___gf_one(fio___gf_s r) {
  r[0] = 1;
  r[1] = 0;
  r[2] = 0;
  r[3] = 0;
  r[4] = 0;
}

/* Set field element to 0 */
FIO_IFUNC void fio___gf_zero(fio___gf_s r) {
  r[0] = 0;
  r[1] = 0;
  r[2] = 0;
  r[3] = 0;
  r[4] = 0;
}

/* Copy field element: r = a */
FIO_IFUNC void fio___gf_copy(fio___gf_s r, const fio___gf_s a) {
  r[0] = a[0];
  r[1] = a[1];
  r[2] = a[2];
  r[3] = a[3];
  r[4] = a[4];
}

/* *****************************************************************************
X25519 Implementation - Montgomery Ladder
***************************************************************************** */

/* x25519 base point (u = 9) */
static const uint8_t FIO___X25519_BASEPOINT[32] = {9};

/* x25519 scalar multiplication using montgomery ladder (matches tweetnacl) */
FIO_IFUNC void fio___x25519_scalarmult(uint8_t out[32],
                                       const uint8_t scalar[32],
                                       const uint8_t point[32]) {
  uint8_t z[32];
  fio_memcpy32(z, scalar);
  z[31] = (scalar[31] & 127) | 64;
  z[0] &= 248;

  fio___gf_s x, a, b, c, d, e, f;

  fio___gf_frombytes(x, point);

  /* initialize: a=1, b=x, c=0, d=1 */
  fio___gf_copy(b, x);
  fio___gf_zero(c);
  fio___gf_one(a);
  fio___gf_one(d);

  /* constant for curve parameter (a-2)/4 = 121665 */
  static const fio___gf_s k121665 = {121665ULL, 0, 0, 0, 0};

  for (int i = 254; i >= 0; --i) {
    int64_t r = (z[i >> 3] >> (i & 7)) & 1;
    fio___gf_cswap(a, b, r);
    fio___gf_cswap(c, d, r);
    fio___gf_add(e, a, c);
    fio___gf_sub(a, a, c);
    fio___gf_add(c, b, d);
    fio___gf_sub(b, b, d);
    fio___gf_sqr(d, e);
    fio___gf_sqr(f, a);
    fio___gf_mul(a, c, a);
    fio___gf_mul(c, b, e);
    fio___gf_add(e, a, c);
    fio___gf_sub(a, a, c);
    fio___gf_sqr(b, a);
    fio___gf_sub(c, d, f);
    fio___gf_mul(a, c, k121665);
    fio___gf_add(a, a, d);
    fio___gf_mul(c, c, a);
    fio___gf_mul(a, d, f);
    fio___gf_mul(d, b, x);
    fio___gf_sqr(b, e);
    fio___gf_cswap(a, b, r);
    fio___gf_cswap(c, d, r);
  }

  fio___gf_inv(c, c);
  fio___gf_mul(a, a, c);
  fio___gf_tobytes(out, a);
}

/* *****************************************************************************
X25519 Public API Implementation
***************************************************************************** */

SFUNC void fio_x25519_keypair(uint8_t secret_key[32], uint8_t public_key[32]) {
  fio_rand_bytes(secret_key, 32);
  fio_x25519_public_key(public_key, secret_key);
}

SFUNC void fio_x25519_public_key(uint8_t public_key[32],
                                 const uint8_t secret_key[32]) {
  fio___x25519_scalarmult(public_key, secret_key, FIO___X25519_BASEPOINT);
}

SFUNC int fio_x25519_shared_secret(uint8_t shared_secret[32],
                                   const uint8_t secret_key[32],
                                   const uint8_t their_public_key[32]) {
  fio___x25519_scalarmult(shared_secret, secret_key, their_public_key);

  /* check for all-zero output (low-order point attack) */
  uint8_t zero_check = 0;
  for (int i = 0; i < 32; ++i)
    zero_check |= shared_secret[i];

  return zero_check ? 0 : -1;
}

/* *****************************************************************************
Ed25519 Implementation - Extended Coordinates

Ed25519 uses the twisted Edwards curve: -x^2 + y^2 = 1 + d*x^2*y^2
where d = -121665/121666

Points are represented in extended coordinates (x:y:z:t) where
x = x/z, y = y/z, x*y = t/z
***************************************************************************** */

/* ed25519 group element in extended coordinates (x, y, z, t) */
typedef fio___gf_s fio___ge_p3_s[4];

/* Curve constants in radix 2^51 (computed via node.js) */
/* d = -121665/121666 mod p */
static const fio___gf_s FIO___ED25519_D = {0x34dca135978a3ULL,
                                           0x1a8283b156ebdULL,
                                           0x5e7a26001c029ULL,
                                           0x739c663a03cbbULL,
                                           0x52036cee2b6ffULL};

/* 2*d */
static const fio___gf_s FIO___ED25519_D2 = {0x69b9426b2f159ULL,
                                            0x35050762add7aULL,
                                            0x3cf44c0038052ULL,
                                            0x6738cc7407977ULL,
                                            0x2406d9dc56dffULL};

/* sqrt(-1) mod p */
static const fio___gf_s FIO___ED25519_SQRTM1 = {0x61b274a0ea0b0ULL,
                                                0x0d5a5fc8f189dULL,
                                                0x7ef5e9cbd0c60ULL,
                                                0x78595a6804c9eULL,
                                                0x2b8324804fc1dULL};

/* ed25519 base point y = 4/5 */
static const fio___gf_s FIO___ED25519_BASE_Y = {0x6666666666658ULL,
                                                0x4ccccccccccccULL,
                                                0x1999999999999ULL,
                                                0x3333333333333ULL,
                                                0x6666666666666ULL};

/* ed25519 base point x */
static const fio___gf_s FIO___ED25519_BASE_X = {0x62d608f25d51aULL,
                                                0x412a4b4f6592aULL,
                                                0x75b7171a4b31dULL,
                                                0x1ff60527118feULL,
                                                0x216936d3cd6e5ULL};

/* set p to the base point */
FIO_IFUNC void fio___ge_p3_base(fio___ge_p3_s p) {
  fio___gf_copy(p[0], FIO___ED25519_BASE_X);
  fio___gf_copy(p[1], FIO___ED25519_BASE_Y);
  fio___gf_one(p[2]);
  fio___gf_mul(p[3], p[0], p[1]);
}

/* swap two p3 points conditionally (constant time) */
FIO_IFUNC void fio___ge_p3_cswap(fio___ge_p3_s p, fio___ge_p3_s q, int b) {
  fio___gf_cswap(p[0], q[0], b);
  fio___gf_cswap(p[1], q[1], b);
  fio___gf_cswap(p[2], q[2], b);
  fio___gf_cswap(p[3], q[3], b);
}

/* point addition: p = p + q (in-place, matches tweetnacl's add function) */
FIO_IFUNC void fio___ge_p3_add(fio___ge_p3_s p, const fio___ge_p3_s q) {
  fio___gf_s a, b, c, d, t, e, f, g, h;

  fio___gf_sub(a, p[1], p[0]);
  fio___gf_sub(t, q[1], q[0]);
  fio___gf_mul(a, a, t);
  fio___gf_add(b, p[0], p[1]);
  fio___gf_add(t, q[0], q[1]);
  fio___gf_mul(b, b, t);
  fio___gf_mul(c, p[3], q[3]);
  fio___gf_mul(c, c, FIO___ED25519_D2);
  fio___gf_mul(d, p[2], q[2]);
  fio___gf_add(d, d, d);
  fio___gf_sub(e, b, a);
  fio___gf_sub(f, d, c);
  fio___gf_add(g, d, c);
  fio___gf_add(h, b, a);

  fio___gf_mul(p[0], e, f);
  fio___gf_mul(p[1], h, g);
  fio___gf_mul(p[2], g, f);
  fio___gf_mul(p[3], e, h);
}

/* point doubling: p = 2*p (in-place) */
FIO_IFUNC void fio___ge_p3_dbl(fio___ge_p3_s p) {
  fio___gf_s a, b, c, d, t, e, f, g, h;

  fio___gf_sub(a, p[1], p[0]);
  fio___gf_sub(t, p[1], p[0]);
  fio___gf_mul(a, a, t);
  fio___gf_add(b, p[0], p[1]);
  fio___gf_add(t, p[0], p[1]);
  fio___gf_mul(b, b, t);
  fio___gf_mul(c, p[3], p[3]);
  fio___gf_mul(c, c, FIO___ED25519_D2);
  fio___gf_mul(d, p[2], p[2]);
  fio___gf_add(d, d, d);
  fio___gf_sub(e, b, a);
  fio___gf_sub(f, d, c);
  fio___gf_add(g, d, c);
  fio___gf_add(h, b, a);

  fio___gf_mul(p[0], e, f);
  fio___gf_mul(p[1], h, g);
  fio___gf_mul(p[2], g, f);
  fio___gf_mul(p[3], e, h);
}

/* scalar multiplication: r = scalar * base_point (montgomery ladder) */
FIO_IFUNC void fio___ge_scalarmult_base(fio___ge_p3_s r,
                                        const uint8_t scalar[32]) {
  fio___ge_p3_s p, q;

  /* p = identity point (0, 1, 1, 0) */
  fio___gf_zero(p[0]);
  fio___gf_one(p[1]);
  fio___gf_one(p[2]);
  fio___gf_zero(p[3]);

  /* q = base point */
  fio___ge_p3_base(q);

  for (int i = 255; i >= 0; --i) {
    uint8_t b = (scalar[i >> 3] >> (i & 7)) & 1;
    fio___ge_p3_cswap(p, q, b);
    fio___ge_p3_add(q, p);
    fio___ge_p3_dbl(p);
    fio___ge_p3_cswap(p, q, b);
  }

  fio___gf_copy(r[0], p[0]);
  fio___gf_copy(r[1], p[1]);
  fio___gf_copy(r[2], p[2]);
  fio___gf_copy(r[3], p[3]);
}

/* variable-base scalar multiplication: r = scalar * point */
FIO_SFUNC void fio___ge_scalarmult(fio___ge_p3_s r,
                                   const uint8_t scalar[32],
                                   fio___ge_p3_s point) {
  fio___ge_p3_s p, q;

  /* p = identity point */
  fio___gf_zero(p[0]);
  fio___gf_one(p[1]);
  fio___gf_one(p[2]);
  fio___gf_zero(p[3]);

  /* q = input point */
  fio___gf_copy(q[0], point[0]);
  fio___gf_copy(q[1], point[1]);
  fio___gf_copy(q[2], point[2]);
  fio___gf_copy(q[3], point[3]);

  for (int i = 255; i >= 0; --i) {
    uint8_t b = (scalar[i >> 3] >> (i & 7)) & 1;
    fio___ge_p3_cswap(p, q, b);
    fio___ge_p3_add(q, p);
    fio___ge_p3_dbl(p);
    fio___ge_p3_cswap(p, q, b);
  }

  fio___gf_copy(r[0], p[0]);
  fio___gf_copy(r[1], p[1]);
  fio___gf_copy(r[2], p[2]);
  fio___gf_copy(r[3], p[3]);
}

/* encode point to 32 bytes */
FIO_IFUNC void fio___ge_p3_tobytes(uint8_t out[32], fio___ge_p3_s p) {
  fio___gf_s z_inv, x, y;
  fio___gf_inv(z_inv, p[2]);
  fio___gf_mul(x, p[0], z_inv);
  fio___gf_mul(y, p[1], z_inv);
  fio___gf_tobytes(out, y);
  out[31] ^= (fio___gf_isneg(x) << 7);
}

/* decode 32 bytes to point (returns 0 on success, -1 on failure) */
FIO_SFUNC int fio___ge_p3_frombytes(fio___ge_p3_s p, const uint8_t in[32]) {
  uint8_t s[32];
  fio_memcpy32(s, in);
  int x_sign = s[31] >> 7;
  s[31] &= 0x7F;

  fio___gf_frombytes(p[1], s);
  fio___gf_one(p[2]);

  /* compute x from y: x^2 = (y^2 - 1) / (d*y^2 + 1) */
  fio___gf_s y2, u, v, one;
  fio___gf_one(one);
  fio___gf_sqr(y2, p[1]);
  fio___gf_sub(u, y2, one); /* y^2 - 1 */
  fio___gf_mul(v, y2, FIO___ED25519_D);
  fio___gf_add(v, v, one); /* d*y^2 + 1 */

  /* x = u * v^3 * (u * v^7)^((p-5)/8) */
  fio___gf_s v3, uv3, v7, uv7, x;
  fio___gf_sqr(v3, v);
  fio___gf_mul(v3, v3, v);
  fio___gf_mul(uv3, u, v3);
  fio___gf_sqr(v7, v3);
  fio___gf_mul(v7, v7, v);
  fio___gf_mul(uv7, u, v7);
  fio___gf_pow_pm5d8(x, uv7);
  fio___gf_mul(x, x, uv3);

  /* check if x^2 * v == u */
  fio___gf_s x2, vx2, check;
  fio___gf_sqr(x2, x);
  fio___gf_mul(vx2, v, x2);
  fio___gf_sub(check, vx2, u);

  if (!fio___gf_iszero(check)) {
    /* try x * sqrt(-1) */
    fio___gf_mul(x, x, FIO___ED25519_SQRTM1);
    fio___gf_sqr(x2, x);
    fio___gf_mul(vx2, v, x2);
    fio___gf_sub(check, vx2, u);
    if (!fio___gf_iszero(check))
      return -1; /* invalid point */
  }

  /* adjust sign */
  if (fio___gf_isneg(x) != x_sign)
    fio___gf_neg(x, x);

  fio___gf_copy(p[0], x);
  fio___gf_mul(p[3], p[0], p[1]);
  return 0;
}

/* *****************************************************************************
Scalar Arithmetic mod L (Ed25519 group order)

L = 2^252 + 27742317777372353535851937790883648493
***************************************************************************** */

/* reduce a 64-byte hash to a scalar mod l */
FIO_SFUNC void fio___sc_reduce(uint8_t s[32], const uint8_t r[64]) {
  /* l = 2^252 + 27742317777372353535851937790883648493 */
  static const unsigned long long l[32] = {
      0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7,
      0xa2, 0xde, 0xf9, 0xde, 0x14, 0,    0,    0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,    0,    0,    0,    0x10};
  long long x[64];
  int i;
  int j;
  for (i = 0; i < 64; ++i)
    x[i] = (unsigned long long)r[i];

  for (i = 63; i >= 32; --i) {
    long long carry = 0;
    for (j = i - 32; j < i - 12; ++j) {
      x[j] += carry - 16 * x[i] * l[j - (i - 32)];
      carry = (x[j] + 128) >> 8;
      x[j] -= carry * 256; /* avoid UB from left-shifting negative values */
    }
    x[j] += carry;
    x[i] = 0;
  }
  long long carry = 0;
  for (j = 0; j < 32; ++j) {
    x[j] += carry - (x[31] >> 4) * l[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; ++j)
    x[j] -= carry * l[j];
  for (i = 0; i < 32; ++i) {
    x[i + 1] += x[i] >> 8;
    s[i] = x[i] & 255;
  }
}

/* compute s = (a + b*c) mod l */
FIO_SFUNC void fio___sc_muladd(uint8_t s[32],
                               const uint8_t a[32],
                               const uint8_t b[32],
                               const uint8_t c[32]) {
  long long x[64] = {0};
  int i, j;
  for (i = 0; i < 32; ++i)
    x[i] = (unsigned long long)a[i];
  for (i = 0; i < 32; ++i)
    for (j = 0; j < 32; ++j)
      x[i + j] += (unsigned long long)b[i] * (unsigned long long)c[j];
  uint8_t tmp[64];
  for (i = 0; i < 63; ++i) {
    x[i + 1] += x[i] >> 8;
    tmp[i] = x[i] & 255;
  }
  tmp[63] = x[63] & 255;
  fio___sc_reduce(s, tmp);
}

/* *****************************************************************************
Ed25519 Public API Implementation
***************************************************************************** */

SFUNC void fio_ed25519_keypair(uint8_t secret_key[32], uint8_t public_key[32]) {
  fio_rand_bytes(secret_key, 32);
  fio_ed25519_public_key(public_key, secret_key);
}

SFUNC void fio_ed25519_public_key(uint8_t public_key[32],
                                  const uint8_t secret_key[32]) {
  /* hash secret key with sha-512 */
  fio_u512 h = fio_sha512(secret_key, 32);

  /* clamp the first 32 bytes */
  h.u8[0] &= 248;
  h.u8[31] &= 127;
  h.u8[31] |= 64;

  /* compute public key = h * b */
  fio___ge_p3_s pk;
  fio___ge_scalarmult_base(pk, h.u8);
  fio___ge_p3_tobytes(public_key, pk);
}

SFUNC void fio_ed25519_sign(uint8_t signature[64],
                            const void *message,
                            size_t len,
                            const uint8_t secret_key[32],
                            const uint8_t public_key[32]) {
  /* hash secret key */
  fio_u512 h = fio_sha512(secret_key, 32);

  /* clamp */
  h.u8[0] &= 248;
  h.u8[31] &= 127;
  h.u8[31] |= 64;

  /* r = h(h[32..63] || message) mod l */
  fio_sha512_s sha = fio_sha512_init();
  fio_sha512_consume(&sha, h.u8 + 32, 32);
  fio_sha512_consume(&sha, message, len);
  fio_u512 r_hash = fio_sha512_finalize(&sha);

  uint8_t r[32];
  fio___sc_reduce(r, r_hash.u8);

  /* r_point = r * b */
  fio___ge_p3_s r_point;
  fio___ge_scalarmult_base(r_point, r);
  fio___ge_p3_tobytes(signature, r_point); /* first 32 bytes of signature */

  /* k = h(r || public_key || message) mod l */
  sha = fio_sha512_init();
  fio_sha512_consume(&sha, signature, 32);
  fio_sha512_consume(&sha, public_key, 32);
  fio_sha512_consume(&sha, message, len);
  fio_u512 k_hash = fio_sha512_finalize(&sha);

  uint8_t k[32];
  fio___sc_reduce(k, k_hash.u8);

  /* s = (r + k * h) mod l */
  fio___sc_muladd(signature + 32, r, k, h.u8);
}

SFUNC int fio_ed25519_verify(const uint8_t signature[64],
                             const void *message,
                             size_t len,
                             const uint8_t public_key[32]) {
  /* decode public key */
  fio___ge_p3_s pk;
  if (fio___ge_p3_frombytes(pk, public_key) != 0)
    return -1;

  /* check s < l */
  { /* check s < l */
    static const uint64_t l_u64[4] FIO_ALIGN(16) = {
        0x5812631a5cf5d3edULL, /* l[0..7]   */
        0x14def9dea2f79cd6ULL, /* l[8..15]  */
        0x0000000000000000ULL, /* l[16..23] */
        0x1000000000000000ULL, /* l[24..31] */
    };
    /* Load s as little-endian uint64_t (handles endianness) */
    uint64_t s_u64[4] FIO_ALIGN(16);
    s_u64[0] = fio_buf2u64_le(signature + 32 + 0);
    s_u64[1] = fio_buf2u64_le(signature + 32 + 8);
    s_u64[2] = fio_buf2u64_le(signature + 32 + 16);
    s_u64[3] = fio_buf2u64_le(signature + 32 + 24);
    /* Constant-time comparison */
    uint8_t c = 0;
    for (int i = 0; i < 4; i++) {
      uint8_t gt = s_u64[i] > l_u64[i];
      uint8_t eq = s_u64[i] == l_u64[i];
      c = gt | (eq & c);
    }
    if (c)
      return -1;
  }

  /* k = h(r || public_key || message) mod l */
  fio_sha512_s sha = fio_sha512_init();
  fio_sha512_consume(&sha, signature, 32);
  fio_sha512_consume(&sha, public_key, 32);
  fio_sha512_consume(&sha, message, len);
  fio_u512 k_hash = fio_sha512_finalize(&sha);

  uint8_t k[32];
  fio___sc_reduce(k, k_hash.u8);

  /* compute s*b - k*a */
  /* first compute [s]b */
  fio___ge_p3_s sb;
  fio___ge_scalarmult_base(sb, signature + 32);

  /* compute [k]a (need to negate for subtraction) */
  fio___ge_p3_s ka;
  fio___ge_scalarmult(ka, k, pk);

  /* negate ka: negate x and t coordinates */
  fio___gf_neg(ka[0], ka[0]);
  fio___gf_neg(ka[3], ka[3]);

  /* add sb + (-ka) */
  fio___ge_p3_add(sb, ka);

  /* encode result and compare with r */
  uint8_t check[32];
  fio___ge_p3_tobytes(check, sb);

  /* constant-time comparison */
  uint8_t diff = 0;
  for (int i = 0; i < 32; ++i)
    diff |= check[i] ^ signature[i];

  return diff ? -1 : 0;
}

/* *****************************************************************************
Key Conversion Implementation
***************************************************************************** */

SFUNC void fio_ed25519_sk_to_x25519(uint8_t x_secret_key[32],
                                    const uint8_t ed_secret_key[32]) {
  /* hash ed25519 secret key and use first 32 bytes */
  fio_u512 h = fio_sha512(ed_secret_key, 32);
  fio_memcpy32(x_secret_key, h.u8);
  /* x25519 clamping is done in the scalar multiplication */
}

SFUNC void fio_ed25519_pk_to_x25519(uint8_t x_public_key[32],
                                    const uint8_t ed_public_key[32]) {
  /* ed25519 public key is (x, y) on edwards curve
   * x25519 public key is u on montgomery curve
   * conversion: u = (1 + y) / (1 - y)
   */
  fio___ge_p3_s p;
  if (fio___ge_p3_frombytes(p, ed_public_key) != 0) {
    /* invalid point - return zeros */
    FIO_MEMSET(x_public_key, 0, 32);
    return;
  }

  /* compute u = (z + y) / (z - y) */
  fio___gf_s one_plus_y, one_minus_y, one_minus_y_inv, u;
  fio___gf_add(one_plus_y, p[2], p[1]);
  fio___gf_sub(one_minus_y, p[2], p[1]);
  fio___gf_inv(one_minus_y_inv, one_minus_y);
  fio___gf_mul(u, one_plus_y, one_minus_y_inv);

  fio___gf_tobytes(x_public_key, u);
}

/* *****************************************************************************
ECIES Public Key Encryption Implementation

Encrypts data using X25519 key agreement + ChaCha20-Poly1305.
Format: [32-byte ephemeral public key][16-byte MAC][encrypted data]
***************************************************************************** */

SFUNC int fio_x25519_encrypt(uint8_t *ciphertext,
                             const void *message,
                             size_t message_len,
                             fio_crypto_enc_fn encryption_function,
                             const uint8_t recipient_pk[32]) {
  /* generate ephemeral key pair */
  uint8_t eph_sk[32], eph_pk[32];
  fio_x25519_keypair(eph_sk, eph_pk);

  /* compute shared secret */
  uint8_t shared[32];
  if (fio_x25519_shared_secret(shared, eph_sk, recipient_pk) != 0) {
    fio_secure_zero(eph_sk, 32);
    return -1; /* invalid recipient public key */
  }

  /* derive encryption key using sha-256(shared_secret || ephemeral_pk) */
  fio_sha256_s sha = fio_sha256_init();
  fio_sha256_consume(&sha, shared, 32);
  fio_sha256_consume(&sha, eph_pk, 32);
  fio_u256 key = fio_sha256_finalize(&sha);

  /* clear sensitive data */
  fio_secure_zero(eph_sk, 32);
  fio_secure_zero(shared, 32);

  /* copy ephemeral public key to output */
  fio_memcpy32(ciphertext, eph_pk);

  /* copy plaintext to ciphertext buffer (after eph_pk and mac space) */
  if (message_len > 0)
    FIO_MEMCPY(ciphertext + 48, message, message_len);

  /* encrypt with chacha20-poly1305 */
  /* nonce: first 12 bytes of ephemeral public key (unique per encryption) */
  encryption_function(ciphertext + 32, /* mac output */
                      ciphertext + 48, /* data to encrypt */
                      message_len,     /* data length */
                      ciphertext,      /* additional data: eph_pk */
                      32,              /* ad length */
                      key.u8,          /* encryption key */
                      eph_pk);         /* nonce (first 12 bytes) */

  fio_secure_zero(&key, sizeof(key));
  return 0;
}

SFUNC int fio_x25519_decrypt(uint8_t *plaintext,
                             const uint8_t *ciphertext,
                             size_t ciphertext_len,
                             fio_crypto_dec_fn decryption_function,
                             const uint8_t recipient_sk[32]) {
  /* validate minimum ciphertext length */
  if (ciphertext_len < 48)
    return -1;

  size_t message_len = ciphertext_len - 48;
  const uint8_t *eph_pk = ciphertext;
  const uint8_t *mac = ciphertext + 32;
  const uint8_t *encrypted = ciphertext + 48;

  /* compute shared secret */
  uint8_t shared[32];
  if (fio_x25519_shared_secret(shared, recipient_sk, eph_pk) != 0) {
    return -1; /* invalid ephemeral public key */
  }

  /* derive decryption key using sha-256(shared_secret || ephemeral_pk) */
  fio_sha256_s sha = fio_sha256_init();
  fio_sha256_consume(&sha, shared, 32);
  fio_sha256_consume(&sha, eph_pk, 32);
  fio_u256 key = fio_sha256_finalize(&sha);

  fio_secure_zero(shared, 32);

  /* copy ciphertext to output buffer for in-place decryption */
  if (message_len > 0)
    FIO_MEMCPY(plaintext, encrypted, message_len);

  /* copy mac for in-place verification (chacha20_poly1305_dec modifies it) */
  uint8_t mac_copy[16];
  fio_memcpy16(mac_copy, mac);

  /* decrypt and verify with chacha20-poly1305 */
  int result = decryption_function(mac_copy,    /* mac to verify */
                                   plaintext,   /* data to decrypt */
                                   message_len, /* data length */
                                   eph_pk,      /* additional data */
                                   32,          /* ad length */
                                   key.u8,      /* decryption key */
                                   eph_pk);     /* nonce */

  fio_secure_zero(&key, sizeof(key));
  return result;
}

/* *****************************************************************************
Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_ED25519
#endif /* FIO_ED25519 */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_P256               /* Development inclusion - ignore line */
#define FIO_SHA2               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                    Elliptic Curve Cryptography: ECDSA P-256 (secp256r1)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_P256) && !defined(H___FIO_P256___H)
#define H___FIO_P256___H

/* *****************************************************************************
P-256 (secp256r1) ECDSA Module

This module provides ECDSA signature verification for the P-256 curve,
primarily for TLS 1.3 certificate chain validation.

P-256 curve parameters (NIST FIPS 186-4):
- Prime p = 2^256 - 2^224 + 2^192 + 2^96 - 1
- Order n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551
- Curve equation: y = x - 3x + b (mod p)

**Note**: This implementation has not been audited. Use at your own risk.
***************************************************************************** */

/* *****************************************************************************
ECDSA P-256 Verification API
***************************************************************************** */

/**
 * Verifies an ECDSA P-256 signature.
 *
 * @param sig DER-encoded signature (SEQUENCE { r INTEGER, s INTEGER })
 * @param sig_len Length of signature in bytes
 * @param msg_hash SHA-256 hash of the message (32 bytes)
 * @param pubkey Uncompressed public key (65 bytes: 0x04 || x || y)
 * @param pubkey_len Length of public key (must be 65)
 * @return 0 on success (valid signature), -1 on failure (invalid signature)
 */
SFUNC int fio_ecdsa_p256_verify(const uint8_t *sig,
                                size_t sig_len,
                                const uint8_t *msg_hash,
                                const uint8_t *pubkey,
                                size_t pubkey_len);

/**
 * Signs a message hash using ECDSA P-256.
 *
 * @param sig Output: DER-encoded signature (max 72 bytes)
 * @param sig_len Output: actual signature length
 * @param sig_capacity Capacity of signature buffer (should be >= 72)
 * @param msg_hash SHA-256 hash of the message (32 bytes)
 * @param secret_key 32-byte secret key (scalar, big-endian)
 * @return 0 on success, -1 on failure
 */
SFUNC int fio_ecdsa_p256_sign(uint8_t *sig,
                              size_t *sig_len,
                              size_t sig_capacity,
                              const uint8_t msg_hash[32],
                              const uint8_t secret_key[32]);

/**
 * Verifies an ECDSA P-256 signature with raw r,s values.
 *
 * @param r The r component of the signature (32 bytes, big-endian)
 * @param s The s component of the signature (32 bytes, big-endian)
 * @param msg_hash SHA-256 hash of the message (32 bytes)
 * @param pubkey_x X coordinate of public key (32 bytes, big-endian)
 * @param pubkey_y Y coordinate of public key (32 bytes, big-endian)
 * @return 0 on success (valid signature), -1 on failure (invalid signature)
 */
SFUNC int fio_ecdsa_p256_verify_raw(const uint8_t r[32],
                                    const uint8_t s[32],
                                    const uint8_t msg_hash[32],
                                    const uint8_t pubkey_x[32],
                                    const uint8_t pubkey_y[32]);

/* *****************************************************************************
P-256 ECDHE (Elliptic Curve Diffie-Hellman) API
***************************************************************************** */

/**
 * Generates a P-256 keypair for ECDHE key exchange.
 *
 * @param secret_key Output: 32-byte secret key (scalar, big-endian)
 * @param public_key Output: 65-byte uncompressed public key (0x04 || x || y)
 * @return 0 on success, -1 on failure
 */
SFUNC int fio_p256_keypair(uint8_t secret_key[32], uint8_t public_key[65]);

/**
 * Computes P-256 ECDH shared secret.
 *
 * @param shared_secret Output: 32-byte shared secret (x-coordinate of result)
 * @param secret_key 32-byte secret key (scalar, big-endian)
 * @param their_public_key Their public key (uncompressed 65 bytes, or
 *                         compressed 33 bytes)
 * @param their_public_key_len Length of their public key (33 or 65)
 * @return 0 on success, -1 on failure (invalid key, point at infinity, etc.)
 */
SFUNC int fio_p256_shared_secret(uint8_t shared_secret[32],
                                 const uint8_t secret_key[32],
                                 const uint8_t *their_public_key,
                                 size_t their_public_key_len);

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
P-256 Field Arithmetic (mod p)

Prime p = 2^256 - 2^224 + 2^192 + 2^96 - 1
       = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF

We use 4 x 64-bit limbs in little-endian order.
***************************************************************************** */

/* P-256 prime p in little-endian limbs */
static const uint64_t FIO___P256_P[4] = {
    0xFFFFFFFFFFFFFFFFULL, /* p[0] */
    0x00000000FFFFFFFFULL, /* p[1] */
    0x0000000000000000ULL, /* p[2] */
    0xFFFFFFFF00000001ULL, /* p[3] */
};

/* P-256 curve order n in little-endian limbs */
static const uint64_t FIO___P256_N[4] = {
    0xF3B9CAC2FC632551ULL, /* n[0] */
    0xBCE6FAADA7179E84ULL, /* n[1] */
    0xFFFFFFFFFFFFFFFFULL, /* n[2] */
    0xFFFFFFFF00000000ULL, /* n[3] */
};

/* P-256 curve parameter b in little-endian limbs */
static const uint64_t FIO___P256_B[4] = {
    0x3BCE3C3E27D2604BULL, /* b[0] */
    0x651D06B0CC53B0F6ULL, /* b[1] */
    0xB3EBBD55769886BCULL, /* b[2] */
    0x5AC635D8AA3A93E7ULL, /* b[3] */
};

/* P-256 base point G x-coordinate in little-endian limbs */
static const uint64_t FIO___P256_GX[4] = {
    0xF4A13945D898C296ULL, /* Gx[0] */
    0x77037D812DEB33A0ULL, /* Gx[1] */
    0xF8BCE6E563A440F2ULL, /* Gx[2] */
    0x6B17D1F2E12C4247ULL, /* Gx[3] */
};

/* P-256 base point G y-coordinate in little-endian limbs */
static const uint64_t FIO___P256_GY[4] = {
    0xCBB6406837BF51F5ULL, /* Gy[0] */
    0x2BCE33576B315ECEULL, /* Gy[1] */
    0x8EE7EB4A7C0F9E16ULL, /* Gy[2] */
    0x4FE342E2FE1A7F9BULL, /* Gy[3] */
};

/* Field element type: 4 x 64-bit limbs in little-endian */
typedef uint64_t fio___p256_fe_s[4];

/* Point in affine coordinates */
typedef struct {
  fio___p256_fe_s x;
  fio___p256_fe_s y;
} fio___p256_point_affine_s;

/* Point in Jacobian coordinates (x = X/Z, y = Y/Z) */
typedef struct {
  fio___p256_fe_s x;
  fio___p256_fe_s y;
  fio___p256_fe_s z;
} fio___p256_point_jacobian_s;

/* *****************************************************************************
Field Element Operations (mod p)
***************************************************************************** */

/** Copy field element: dest = src */
FIO_IFUNC void fio___p256_fe_copy(fio___p256_fe_s dest,
                                  const fio___p256_fe_s src) {
  dest[0] = src[0];
  dest[1] = src[1];
  dest[2] = src[2];
  dest[3] = src[3];
}

/** Set field element to zero */
FIO_IFUNC void fio___p256_fe_zero(fio___p256_fe_s r) {
  r[0] = 0;
  r[1] = 0;
  r[2] = 0;
  r[3] = 0;
}

/** Set field element to one */
FIO_IFUNC void fio___p256_fe_one(fio___p256_fe_s r) {
  r[0] = 1;
  r[1] = 0;
  r[2] = 0;
  r[3] = 0;
}

/** Check if field element is zero */
FIO_IFUNC int fio___p256_fe_is_zero(const fio___p256_fe_s a) {
  return (a[0] | a[1] | a[2] | a[3]) == 0;
}

/** Compare two field elements: returns 0 if equal */
FIO_IFUNC int fio___p256_fe_eq(const fio___p256_fe_s a,
                               const fio___p256_fe_s b) {
  uint64_t diff = (a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]) | (a[3] ^ b[3]);
  return diff == 0 ? 0 : 1;
}

/** Load 32-byte big-endian number into field element */
FIO_IFUNC void fio___p256_fe_from_bytes(fio___p256_fe_s r,
                                        const uint8_t in[32]) {
  r[3] = fio_buf2u64_be(in);
  r[2] = fio_buf2u64_be(in + 8);
  r[1] = fio_buf2u64_be(in + 16);
  r[0] = fio_buf2u64_be(in + 24);
}

/** Store field element to 32-byte big-endian output */
FIO_IFUNC void fio___p256_fe_to_bytes(uint8_t out[32],
                                      const fio___p256_fe_s a) {
  fio_u2buf64_be(out, a[3]);
  fio_u2buf64_be(out + 8, a[2]);
  fio_u2buf64_be(out + 16, a[1]);
  fio_u2buf64_be(out + 24, a[0]);
}

/** Field addition: r = a + b mod p */
FIO_IFUNC void fio___p256_fe_add(fio___p256_fe_s r,
                                 const fio___p256_fe_s a,
                                 const fio___p256_fe_s b) {
  uint64_t c = 0;
  uint64_t t[4];

  /* Add a + b */
  t[0] = fio_math_addc64(a[0], b[0], 0, &c);
  t[1] = fio_math_addc64(a[1], b[1], c, &c);
  t[2] = fio_math_addc64(a[2], b[2], c, &c);
  t[3] = fio_math_addc64(a[3], b[3], c, &c);

  /* Reduce mod p if needed: subtract p if result >= p */
  uint64_t borrow = 0;
  uint64_t s[4];
  s[0] = fio_math_subc64(t[0], FIO___P256_P[0], 0, &borrow);
  s[1] = fio_math_subc64(t[1], FIO___P256_P[1], borrow, &borrow);
  s[2] = fio_math_subc64(t[2], FIO___P256_P[2], borrow, &borrow);
  s[3] = fio_math_subc64(t[3], FIO___P256_P[3], borrow, &borrow);

  /* If carry from addition or no borrow from subtraction, use subtracted value
   */
  uint64_t mask = (uint64_t)0 - (c | (borrow ^ 1));
  r[0] = (s[0] & mask) | (t[0] & ~mask);
  r[1] = (s[1] & mask) | (t[1] & ~mask);
  r[2] = (s[2] & mask) | (t[2] & ~mask);
  r[3] = (s[3] & mask) | (t[3] & ~mask);
}

/** Field subtraction: r = a - b mod p */
FIO_IFUNC void fio___p256_fe_sub(fio___p256_fe_s r,
                                 const fio___p256_fe_s a,
                                 const fio___p256_fe_s b) {
  uint64_t borrow = 0;
  uint64_t t[4];

  /* Subtract a - b */
  t[0] = fio_math_subc64(a[0], b[0], 0, &borrow);
  t[1] = fio_math_subc64(a[1], b[1], borrow, &borrow);
  t[2] = fio_math_subc64(a[2], b[2], borrow, &borrow);
  t[3] = fio_math_subc64(a[3], b[3], borrow, &borrow);

  /* If borrow, add p back */
  uint64_t c = 0;
  uint64_t mask = (uint64_t)0 - borrow;
  uint64_t s[4];
  s[0] = fio_math_addc64(t[0], FIO___P256_P[0] & mask, 0, &c);
  s[1] = fio_math_addc64(t[1], FIO___P256_P[1] & mask, c, &c);
  s[2] = fio_math_addc64(t[2], FIO___P256_P[2] & mask, c, &c);
  s[3] = fio_math_addc64(t[3], FIO___P256_P[3] & mask, c, &c);

  r[0] = s[0];
  r[1] = s[1];
  r[2] = s[2];
  r[3] = s[3];
}

/** Field negation: r = -a mod p */
FIO_IFUNC void fio___p256_fe_neg(fio___p256_fe_s r, const fio___p256_fe_s a) {
  fio___p256_fe_s zero = {0};
  fio___p256_fe_sub(r, zero, a);
}

/**
 * P-256 reduction using the NIST fast reduction formula.
 *
 * p = 2^256 - 2^224 + 2^192 + 2^96 - 1
 *
 * For a 512-bit number T, we use the NIST formula with 32-bit words.
 * T = (c15,...,c0) where each ci is 32 bits.
 * Note: NIST notation is big-endian (c7 is MSB of low 256 bits)
 *
 * The result is: T mod p = s1 + 2*s2 + 2*s3 + s4 + s5 - s6 - s7 - s8 - s9
 * where each si is a 256-bit value constructed from the 32-bit words.
 *
 * Reference: NIST FIPS 186-4, Section D.2.3
 */
FIO_SFUNC void fio___p256_fe_reduce(fio___p256_fe_s r, const uint64_t t[8]) {
  /* Extract 32-bit words from 512-bit input (little-endian) */
  uint32_t c[16];
  for (int i = 0; i < 8; ++i) {
    c[2 * i] = (uint32_t)t[i];
    c[2 * i + 1] = (uint32_t)(t[i] >> 32);
  }

  /* Use 64-bit accumulators for each 32-bit position to handle carries.
   * acc[0] is LSB (c0 position), acc[7] is MSB (c7 position).
   * NIST notation: (c7, c6, c5, c4, c3, c2, c1, c0) means
   * c7 is at position 7 (MSB), c0 is at position 0 (LSB). */
  int64_t acc[8] = {0};

  /* s1 = (c7, c6, c5, c4, c3, c2, c1, c0) - the low 256 bits */
  acc[0] += c[0];
  acc[1] += c[1];
  acc[2] += c[2];
  acc[3] += c[3];
  acc[4] += c[4];
  acc[5] += c[5];
  acc[6] += c[6];
  acc[7] += c[7];

  /* s2 = (c15, c14, c13, c12, c11, 0, 0, 0) - add twice
   * Position mapping: c15->acc[7], c14->acc[6], c13->acc[5], c12->acc[4],
   * c11->acc[3] */
  acc[3] += 2 * (int64_t)c[11];
  acc[4] += 2 * (int64_t)c[12];
  acc[5] += 2 * (int64_t)c[13];
  acc[6] += 2 * (int64_t)c[14];
  acc[7] += 2 * (int64_t)c[15];

  /* s3 = (0, c15, c14, c13, c12, 0, 0, 0) - add twice
   * Position mapping: c15->acc[6], c14->acc[5], c13->acc[4], c12->acc[3] */
  acc[3] += 2 * (int64_t)c[12];
  acc[4] += 2 * (int64_t)c[13];
  acc[5] += 2 * (int64_t)c[14];
  acc[6] += 2 * (int64_t)c[15];

  /* s4 = (c15, c14, 0, 0, 0, c10, c9, c8)
   * Position mapping: c15->acc[7], c14->acc[6], c10->acc[2], c9->acc[1],
   * c8->acc[0] */
  acc[0] += c[8];
  acc[1] += c[9];
  acc[2] += c[10];
  acc[6] += c[14];
  acc[7] += c[15];

  /* s5 = (c8, c13, c15, c14, c13, c11, c10, c9)
   * Position mapping: c8->acc[7], c13->acc[6], c15->acc[5], c14->acc[4],
   * c13->acc[3], c11->acc[2], c10->acc[1], c9->acc[0] */
  acc[0] += c[9];
  acc[1] += c[10];
  acc[2] += c[11];
  acc[3] += c[13];
  acc[4] += c[14];
  acc[5] += c[15];
  acc[6] += c[13];
  acc[7] += c[8];

  /* s6 = (c10, c8, 0, 0, 0, c13, c12, c11) - subtract
   * Position mapping: c10->acc[7], c8->acc[6], c13->acc[2], c12->acc[1],
   * c11->acc[0] */
  acc[0] -= c[11];
  acc[1] -= c[12];
  acc[2] -= c[13];
  acc[6] -= c[8];
  acc[7] -= c[10];

  /* s7 = (c11, c9, 0, 0, c15, c14, c13, c12) - subtract
   * Position mapping: c11->acc[7], c9->acc[6], c15->acc[3], c14->acc[2],
   * c13->acc[1], c12->acc[0] */
  acc[0] -= c[12];
  acc[1] -= c[13];
  acc[2] -= c[14];
  acc[3] -= c[15];
  acc[6] -= c[9];
  acc[7] -= c[11];

  /* s8 = (c12, 0, c10, c9, c8, c15, c14, c13) - subtract
   * Position mapping: c12->acc[7], c10->acc[5], c9->acc[4], c8->acc[3],
   * c15->acc[2], c14->acc[1], c13->acc[0] */
  acc[0] -= c[13];
  acc[1] -= c[14];
  acc[2] -= c[15];
  acc[3] -= c[8];
  acc[4] -= c[9];
  acc[5] -= c[10];
  acc[7] -= c[12];

  /* s9 = (c13, 0, c11, c10, c9, 0, c15, c14) - subtract
   * Position mapping: c13->acc[7], c11->acc[5], c10->acc[4], c9->acc[3],
   * c15->acc[1], c14->acc[0] */
  acc[0] -= c[14];
  acc[1] -= c[15];
  acc[3] -= c[9];
  acc[4] -= c[10];
  acc[5] -= c[11];
  acc[7] -= c[13];

  /* Carry propagation with signed arithmetic.
   * For signed right shift, we need to handle negative values properly.
   * The carry is the arithmetic right shift by 32 bits. */
  for (int i = 0; i < 7; ++i) {
    /* Arithmetic right shift for signed carry */
    int64_t carry = acc[i] >> 32;
    /* Keep only the low 32 bits (may be negative representation) */
    acc[i] = acc[i] & 0xFFFFFFFFLL;
    acc[i + 1] += carry;
  }

  /* Handle overflow/underflow in the top limb.
   * acc[7] may be negative or > 2^32.
   * We reduce by adding/subtracting multiples of p.
   *
   * p = 2^256 - 2^224 + 2^192 + 2^96 - 1
   * In 32-bit words (little-endian): p = (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
   * 0, 0, 0, 1, 0xFFFFFFFF) That is: p[0]=0xFFFFFFFF, p[1]=0xFFFFFFFF,
   * p[2]=0xFFFFFFFF, p[3]=0, p[4]=0, p[5]=0, p[6]=1, p[7]=0xFFFFFFFF
   *
   * When we add p: acc[0]+=0xFFFFFFFF, acc[1]+=0xFFFFFFFF, acc[2]+=0xFFFFFFFF,
   *                acc[6]+=1, acc[7]+=0xFFFFFFFF
   * When we subtract p: acc[0]-=0xFFFFFFFF, acc[1]-=0xFFFFFFFF,
   * acc[2]-=0xFFFFFFFF, acc[6]-=1, acc[7]-=0xFFFFFFFF
   */

  /* Reduce: while acc[7] is out of [0, 2^32), add or subtract p */
  while (acc[7] < 0 || acc[7] > (int64_t)0xFFFFFFFFLL) {
    if (acc[7] < 0) {
      /* Add p */
      acc[0] += 0xFFFFFFFFLL;
      acc[1] += 0xFFFFFFFFLL;
      acc[2] += 0xFFFFFFFFLL;
      acc[6] += 1;
      acc[7] += 0xFFFFFFFFLL;
    } else {
      /* Subtract p */
      acc[0] -= 0xFFFFFFFFLL;
      acc[1] -= 0xFFFFFFFFLL;
      acc[2] -= 0xFFFFFFFFLL;
      acc[6] -= 1;
      acc[7] -= 0xFFFFFFFFLL;
    }

    /* Re-propagate carries */
    for (int i = 0; i < 7; ++i) {
      int64_t carry = acc[i] >> 32;
      acc[i] = acc[i] & 0xFFFFFFFFLL;
      acc[i + 1] += carry;
    }
  }

  /* Convert back to 64-bit limbs */
  uint64_t res[4];
  res[0] = ((uint64_t)(uint32_t)acc[1] << 32) | (uint32_t)acc[0];
  res[1] = ((uint64_t)(uint32_t)acc[3] << 32) | (uint32_t)acc[2];
  res[2] = ((uint64_t)(uint32_t)acc[5] << 32) | (uint32_t)acc[4];
  res[3] = ((uint64_t)(uint32_t)acc[7] << 32) | (uint32_t)acc[6];

  /* Final reduction: if result >= p, subtract p */
  /* May need multiple subtractions */
  for (int iter = 0; iter < 3; ++iter) {
    uint64_t borrow = 0;
    uint64_t sub[4];
    sub[0] = fio_math_subc64(res[0], FIO___P256_P[0], 0, &borrow);
    sub[1] = fio_math_subc64(res[1], FIO___P256_P[1], borrow, &borrow);
    sub[2] = fio_math_subc64(res[2], FIO___P256_P[2], borrow, &borrow);
    sub[3] = fio_math_subc64(res[3], FIO___P256_P[3], borrow, &borrow);

    /* If no borrow (result >= p), use subtracted value */
    if (!borrow) {
      res[0] = sub[0];
      res[1] = sub[1];
      res[2] = sub[2];
      res[3] = sub[3];
    } else {
      break;
    }
  }

  r[0] = res[0];
  r[1] = res[1];
  r[2] = res[2];
  r[3] = res[3];
}

/** Field multiplication: r = a * b mod p */
FIO_SFUNC void fio___p256_fe_mul(fio___p256_fe_s r,
                                 const fio___p256_fe_s a,
                                 const fio___p256_fe_s b) {
  uint64_t t[8] = {0};

  /* Schoolbook multiplication to get 512-bit product */
  for (int i = 0; i < 4; ++i) {
    uint64_t carry = 0;
    for (int j = 0; j < 4; ++j) {
      uint64_t hi;
      uint64_t lo = fio_math_mulc64(a[i], b[j], &hi);
      uint64_t c1 = 0, c2 = 0;
      t[i + j] = fio_math_addc64(t[i + j], lo, 0, &c1);
      t[i + j] = fio_math_addc64(t[i + j], carry, 0, &c2);
      carry = hi + c1 + c2;
    }
    t[i + 4] += carry;
  }

  /* Reduce mod p */
  fio___p256_fe_reduce(r, t);
}

/** Field squaring: r = a mod p */
FIO_SFUNC void fio___p256_fe_sqr(fio___p256_fe_s r, const fio___p256_fe_s a) {
  fio___p256_fe_mul(r, a, a);
}

/**
 * Field inversion: r = a^(-1) mod p using Fermat's little theorem.
 * a^(-1) = a^(p-2) mod p
 *
 * p-2 = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD
 *
 * We use a simple square-and-multiply algorithm for correctness.
 */
FIO_SFUNC void fio___p256_fe_inv(fio___p256_fe_s r, const fio___p256_fe_s a) {
  /* p - 2 in little-endian 64-bit limbs */
  static const uint64_t pm2[4] = {
      0xFFFFFFFFFFFFFFFDULL, /* pm2[0] */
      0x00000000FFFFFFFFULL, /* pm2[1] */
      0x0000000000000000ULL, /* pm2[2] */
      0xFFFFFFFF00000001ULL, /* pm2[3] */
  };

  fio___p256_fe_s base, result, tmp;

  /* Initialize result = 1 */
  fio___p256_fe_one(result);

  /* Copy input to base */
  fio___p256_fe_copy(base, a);

  /* Square-and-multiply from LSB to MSB */
  for (int i = 0; i < 4; ++i) {
    uint64_t bits = pm2[i];
    for (int j = 0; j < 64; ++j) {
      if (bits & 1) {
        /* result = result * base */
        fio___p256_fe_mul(tmp, result, base);
        fio___p256_fe_copy(result, tmp);
      }
      /* base = base^2 */
      fio___p256_fe_sqr(tmp, base);
      fio___p256_fe_copy(base, tmp);
      bits >>= 1;
    }
  }

  fio___p256_fe_copy(r, result);
}

/* Note: Debug version of inversion removed - use fio___p256_fe_inv instead */

/* *****************************************************************************
Scalar Arithmetic (mod n)
***************************************************************************** */

/** Scalar element type: 4 x 64-bit limbs in little-endian */
typedef uint64_t fio___p256_scalar_s[4];

/** Load 32-byte big-endian number into scalar */
FIO_IFUNC void fio___p256_scalar_from_bytes(fio___p256_scalar_s r,
                                            const uint8_t in[32]) {
  r[3] = fio_buf2u64_be(in);
  r[2] = fio_buf2u64_be(in + 8);
  r[1] = fio_buf2u64_be(in + 16);
  r[0] = fio_buf2u64_be(in + 24);
}

/** Check if scalar is zero */
FIO_IFUNC int fio___p256_scalar_is_zero(const fio___p256_scalar_s a) {
  return (a[0] | a[1] | a[2] | a[3]) == 0;
}

/** Check if scalar >= n (curve order) */
FIO_IFUNC int fio___p256_scalar_gte_n(const fio___p256_scalar_s a) {
  /* Compare from most significant limb */
  if (a[3] > FIO___P256_N[3])
    return 1;
  if (a[3] < FIO___P256_N[3])
    return 0;
  if (a[2] > FIO___P256_N[2])
    return 1;
  if (a[2] < FIO___P256_N[2])
    return 0;
  if (a[1] > FIO___P256_N[1])
    return 1;
  if (a[1] < FIO___P256_N[1])
    return 0;
  if (a[0] >= FIO___P256_N[0])
    return 1;
  return 0;
}

/** Scalar reduction mod n using fio_math_div */
FIO_SFUNC void fio___p256_scalar_reduce(fio___p256_scalar_s r,
                                        const uint64_t t[8]) {
  /* Use fio_math_div to compute t mod n directly.
   * We need to extend n to 8 limbs for the division. */
  uint64_t n_ext[8] = {FIO___P256_N[0],
                       FIO___P256_N[1],
                       FIO___P256_N[2],
                       FIO___P256_N[3],
                       0,
                       0,
                       0,
                       0};
  uint64_t remainder[8] = {0};

  /* Compute t mod n */
  fio_math_div(NULL, remainder, t, n_ext, 8);

  /* Copy the low 4 limbs to result */
  r[0] = remainder[0];
  r[1] = remainder[1];
  r[2] = remainder[2];
  r[3] = remainder[3];
}

/** Scalar multiplication: r = a * b mod n */
FIO_SFUNC void fio___p256_scalar_mul(fio___p256_scalar_s r,
                                     const fio___p256_scalar_s a,
                                     const fio___p256_scalar_s b) {
  uint64_t t[8] = {0};

  /* Schoolbook multiplication */
  for (int i = 0; i < 4; ++i) {
    uint64_t carry = 0;
    for (int j = 0; j < 4; ++j) {
      uint64_t hi;
      uint64_t lo = fio_math_mulc64(a[i], b[j], &hi);
      uint64_t c1 = 0, c2 = 0;
      t[i + j] = fio_math_addc64(t[i + j], lo, 0, &c1);
      t[i + j] = fio_math_addc64(t[i + j], carry, 0, &c2);
      carry = hi + c1 + c2;
    }
    t[i + 4] += carry;
  }

  fio___p256_scalar_reduce(r, t);
}

/**
 * Scalar inversion: r = a^(-1) mod n using Fermat's little theorem.
 * a^(-1) = a^(n-2) mod n
 */
FIO_SFUNC void fio___p256_scalar_inv(fio___p256_scalar_s r,
                                     const fio___p256_scalar_s a) {
  /* n-2 = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F */
  fio___p256_scalar_s t, tmp;

  /* Start with a */
  fio___p256_scalar_s base;
  base[0] = a[0];
  base[1] = a[1];
  base[2] = a[2];
  base[3] = a[3];

  /* Initialize result to 1 */
  t[0] = 1;
  t[1] = 0;
  t[2] = 0;
  t[3] = 0;

  /* Binary exponentiation for n-2 */
  /* n-2 in binary has a specific pattern we can optimize */
  /* For now, use simple square-and-multiply */

  /* Process each bit of n-2 from LSB to MSB */
  static const uint64_t nm2[4] = {
      0xF3B9CAC2FC63254FULL, /* (n-2)[0] */
      0xBCE6FAADA7179E84ULL, /* (n-2)[1] */
      0xFFFFFFFFFFFFFFFFULL, /* (n-2)[2] */
      0xFFFFFFFF00000000ULL, /* (n-2)[3] */
  };

  for (int i = 0; i < 4; ++i) {
    uint64_t bits = nm2[i];
    for (int j = 0; j < 64; ++j) {
      if (bits & 1) {
        fio___p256_scalar_mul(tmp, t, base);
        t[0] = tmp[0];
        t[1] = tmp[1];
        t[2] = tmp[2];
        t[3] = tmp[3];
      }
      fio___p256_scalar_mul(tmp, base, base);
      base[0] = tmp[0];
      base[1] = tmp[1];
      base[2] = tmp[2];
      base[3] = tmp[3];
      bits >>= 1;
    }
  }

  r[0] = t[0];
  r[1] = t[1];
  r[2] = t[2];
  r[3] = t[3];
}

/* *****************************************************************************
Point Operations (Jacobian Coordinates)
***************************************************************************** */

/** Check if point is at infinity (Z = 0) */
FIO_IFUNC int fio___p256_point_is_infinity(
    const fio___p256_point_jacobian_s *p) {
  return fio___p256_fe_is_zero(p->z);
}

/** Set point to infinity */
FIO_IFUNC void fio___p256_point_set_infinity(fio___p256_point_jacobian_s *p) {
  fio___p256_fe_one(p->x);
  fio___p256_fe_one(p->y);
  fio___p256_fe_zero(p->z);
}

/** Convert affine point to Jacobian */
FIO_IFUNC void fio___p256_point_to_jacobian(
    fio___p256_point_jacobian_s *j,
    const fio___p256_point_affine_s *a) {
  fio___p256_fe_copy(j->x, a->x);
  fio___p256_fe_copy(j->y, a->y);
  fio___p256_fe_one(j->z);
}

/** Convert Jacobian point to affine (x = X/Z, y = Y/Z) */
FIO_SFUNC void fio___p256_point_to_affine(
    fio___p256_point_affine_s *a,
    const fio___p256_point_jacobian_s *j) {
  if (fio___p256_point_is_infinity(j)) {
    fio___p256_fe_zero(a->x);
    fio___p256_fe_zero(a->y);
    return;
  }

  fio___p256_fe_s z_inv, z_inv2, z_inv3;

  fio___p256_fe_inv(z_inv, j->z);
  fio___p256_fe_sqr(z_inv2, z_inv);
  fio___p256_fe_mul(z_inv3, z_inv2, z_inv);

  fio___p256_fe_mul(a->x, j->x, z_inv2);
  fio___p256_fe_mul(a->y, j->y, z_inv3);
}

/**
 * Point doubling in Jacobian coordinates.
 * Uses the formula from "Guide to Elliptic Curve Cryptography" (Hankerson et
 * al.)
 *
 * For P-256 where a = -3:
 *  = 3(X - Z)(X + Z)
 * X' =  - 2S where S = 4XY
 * Y' = (S - X') - 8Y
 * Z' = 2YZ
 */
FIO_SFUNC void fio___p256_point_double(fio___p256_point_jacobian_s *r,
                                       const fio___p256_point_jacobian_s *p) {
  if (fio___p256_point_is_infinity(p)) {
    fio___p256_point_set_infinity(r);
    return;
  }

  fio___p256_fe_s t1, t2, t3, t4, t5, yz;

  /* Save Y*Z early to handle aliasing (r == p) */
  fio___p256_fe_mul(yz, p->y, p->z);

  /* t1 = Z */
  fio___p256_fe_sqr(t1, p->z);

  /* t2 = X - Z */
  fio___p256_fe_sub(t2, p->x, t1);

  /* t3 = X + Z */
  fio___p256_fe_add(t3, p->x, t1);

  /* t2 = (X - Z)(X + Z) = X - Z */
  fio___p256_fe_mul(t2, t2, t3);

  /* t2 = 3(X - Z) =  (since a = -3, this equals 3X + aZ) */
  fio___p256_fe_add(t3, t2, t2);
  fio___p256_fe_add(t2, t3, t2);

  /* t4 = Y */
  fio___p256_fe_sqr(t4, p->y);

  /* t5 = XY */
  fio___p256_fe_mul(t5, p->x, t4);

  /* t5 = 4XY = S */
  fio___p256_fe_add(t5, t5, t5);
  fio___p256_fe_add(t5, t5, t5);

  /* t3 =  */
  fio___p256_fe_sqr(t3, t2);

  /* X' =  - 2S */
  fio___p256_fe_sub(r->x, t3, t5);
  fio___p256_fe_sub(r->x, r->x, t5);

  /* t4 = Y */
  fio___p256_fe_sqr(t4, t4);

  /* t4 = 8Y */
  fio___p256_fe_add(t4, t4, t4);
  fio___p256_fe_add(t4, t4, t4);
  fio___p256_fe_add(t4, t4, t4);

  /* t5 = S - X' */
  fio___p256_fe_sub(t5, t5, r->x);

  /* Y' = (S - X') - 8Y */
  fio___p256_fe_mul(r->y, t2, t5);
  fio___p256_fe_sub(r->y, r->y, t4);

  /* Z' = 2YZ (using pre-computed value to handle aliasing) */
  fio___p256_fe_add(r->z, yz, yz);
}

/**
 * Point addition in Jacobian coordinates.
 * r = p + q where p is Jacobian and q is affine.
 *
 * Mixed addition is faster than full Jacobian addition.
 */
FIO_SFUNC void fio___p256_point_add_mixed(fio___p256_point_jacobian_s *r,
                                          const fio___p256_point_jacobian_s *p,
                                          const fio___p256_point_affine_s *q) {
  if (fio___p256_point_is_infinity(p)) {
    fio___p256_point_to_jacobian(r, q);
    return;
  }

  fio___p256_fe_s t1, t2, t3, t4, t5, t6;

  /* t1 = Z */
  fio___p256_fe_sqr(t1, p->z);

  /* t2 = Z */
  fio___p256_fe_mul(t2, t1, p->z);

  /* t3 = XZ */
  fio___p256_fe_mul(t3, q->x, t1);

  /* t4 = YZ */
  fio___p256_fe_mul(t4, q->y, t2);

  /* t3 = XZ - X = H */
  fio___p256_fe_sub(t3, t3, p->x);

  /* t4 = YZ - Y = R */
  fio___p256_fe_sub(t4, t4, p->y);

  /* Check if points are equal or opposite */
  if (fio___p256_fe_is_zero(t3)) {
    if (fio___p256_fe_is_zero(t4)) {
      /* Points are equal - double */
      fio___p256_point_double(r, p);
      return;
    } else {
      /* Points are opposite - result is infinity */
      fio___p256_point_set_infinity(r);
      return;
    }
  }

  /* t5 = H */
  fio___p256_fe_sqr(t5, t3);

  /* t6 = H */
  fio___p256_fe_mul(t6, t5, t3);

  /* t1 = XH */
  fio___p256_fe_mul(t1, p->x, t5);

  /* t2 = YH (compute early to handle r == p aliasing) */
  fio___p256_fe_mul(t2, p->y, t6);

  /* Z = ZH (compute early to handle r == p aliasing) */
  fio___p256_fe_mul(r->z, p->z, t3);

  /* X = R - H - 2XH */
  fio___p256_fe_sqr(r->x, t4);
  fio___p256_fe_sub(r->x, r->x, t6);
  fio___p256_fe_sub(r->x, r->x, t1);
  fio___p256_fe_sub(r->x, r->x, t1);

  /* t1 = XH - X */
  fio___p256_fe_sub(t1, t1, r->x);

  /* Y = R(XH - X) - YH */
  fio___p256_fe_mul(r->y, t4, t1);
  fio___p256_fe_sub(r->y, r->y, t2);
}

/**
 * Scalar multiplication: r = k * P
 * Uses double-and-add algorithm (not constant-time for simplicity).
 * For production use, implement constant-time scalar multiplication.
 */
FIO_SFUNC void fio___p256_point_mul(fio___p256_point_jacobian_s *r,
                                    const fio___p256_scalar_s k,
                                    const fio___p256_point_affine_s *p) {
  fio___p256_point_set_infinity(r);

  /* Find the highest set bit */
  int start_bit = 255;
  while (start_bit >= 0) {
    int limb = start_bit / 64;
    int bit = start_bit % 64;
    if (k[limb] & (1ULL << bit))
      break;
    --start_bit;
  }

  if (start_bit < 0)
    return; /* k = 0 */

  /* Double-and-add from MSB to LSB */
  for (int i = start_bit; i >= 0; --i) {
    fio___p256_point_double(r, r);

    int limb = i / 64;
    int bit = i % 64;
    if (k[limb] & (1ULL << bit)) {
      fio___p256_point_add_mixed(r, r, p);
    }
  }
}

/**
 * Double scalar multiplication: r = u1*G + u2*Q
 * Uses Shamir's trick for efficiency.
 */
FIO_SFUNC void fio___p256_point_mul2(fio___p256_point_jacobian_s *r,
                                     const fio___p256_scalar_s u1,
                                     const fio___p256_scalar_s u2,
                                     const fio___p256_point_affine_s *q) {
  /* Base point G */
  fio___p256_point_affine_s g;
  fio___p256_fe_copy(g.x, FIO___P256_GX);
  fio___p256_fe_copy(g.y, FIO___P256_GY);

  /* Precompute G + Q */
  fio___p256_point_jacobian_s gpq;
  fio___p256_point_to_jacobian(&gpq, &g);
  fio___p256_point_add_mixed(&gpq, &gpq, q);
  fio___p256_point_affine_s gpq_affine;
  fio___p256_point_to_affine(&gpq_affine, &gpq);

  fio___p256_point_set_infinity(r);

  /* Find highest set bit in either scalar */
  int start_bit = 255;
  while (start_bit >= 0) {
    int limb = start_bit / 64;
    int bit = start_bit % 64;
    if ((u1[limb] & (1ULL << bit)) || (u2[limb] & (1ULL << bit)))
      break;
    --start_bit;
  }

  if (start_bit < 0)
    return;

  /* Shamir's trick: process both scalars simultaneously */
  for (int i = start_bit; i >= 0; --i) {
    fio___p256_point_double(r, r);

    int limb = i / 64;
    int bit = i % 64;
    int b1 = (u1[limb] >> bit) & 1;
    int b2 = (u2[limb] >> bit) & 1;

    if (b1 && b2) {
      fio___p256_point_add_mixed(r, r, &gpq_affine);
    } else if (b1) {
      fio___p256_point_add_mixed(r, r, &g);
    } else if (b2) {
      fio___p256_point_add_mixed(r, r, q);
    }
  }
}

/* *****************************************************************************
DER Signature Parsing
***************************************************************************** */

/**
 * Parse DER-encoded ECDSA signature.
 * Format: SEQUENCE { r INTEGER, s INTEGER }
 *
 * Returns 0 on success, -1 on error.
 */
FIO_SFUNC int fio___p256_parse_der_signature(uint8_t r[32],
                                             uint8_t s[32],
                                             const uint8_t *sig,
                                             size_t sig_len) {
  if (!sig || sig_len < 8)
    return -1;

  const uint8_t *p = sig;
  const uint8_t *end = sig + sig_len;

  /* SEQUENCE tag */
  if (*p++ != 0x30)
    return -1;

  /* SEQUENCE length */
  size_t seq_len;
  if (*p & 0x80) {
    /* Long form length */
    int len_bytes = *p++ & 0x7F;
    if (len_bytes > 2 || p + len_bytes > end)
      return -1;
    seq_len = 0;
    for (int i = 0; i < len_bytes; ++i)
      seq_len = (seq_len << 8) | *p++;
  } else {
    seq_len = *p++;
  }

  if (p + seq_len > end)
    return -1;

  /* Parse r INTEGER */
  if (*p++ != 0x02)
    return -1;

  size_t r_len = *p++;
  if (p + r_len > end || r_len > 33)
    return -1;

  /* Skip leading zero if present (positive integer encoding) */
  const uint8_t *r_data = p;
  if (r_len > 0 && *r_data == 0x00) {
    r_data++;
    r_len--;
  }
  p += (r_len + (r_data != p ? 1 : 0));

  /* Copy r, right-aligned in 32 bytes */
  FIO_MEMSET(r, 0, 32);
  if (r_len > 32)
    return -1;
  FIO_MEMCPY(r + (32 - r_len), r_data, r_len);

  /* Parse s INTEGER */
  if (*p++ != 0x02)
    return -1;

  size_t s_len = *p++;
  if (p + s_len > end || s_len > 33)
    return -1;

  /* Skip leading zero if present */
  const uint8_t *s_data = p;
  if (s_len > 0 && *s_data == 0x00) {
    s_data++;
    s_len--;
  }

  /* Copy s, right-aligned in 32 bytes */
  FIO_MEMSET(s, 0, 32);
  if (s_len > 32)
    return -1;
  FIO_MEMCPY(s + (32 - s_len), s_data, s_len);

  return 0;
}

/* *****************************************************************************
ECDSA Verification
***************************************************************************** */

SFUNC int fio_ecdsa_p256_verify_raw(const uint8_t r_bytes[32],
                                    const uint8_t s_bytes[32],
                                    const uint8_t msg_hash[32],
                                    const uint8_t pubkey_x[32],
                                    const uint8_t pubkey_y[32]) {
  fio___p256_scalar_s r, s, e;
  fio___p256_point_affine_s q;

  /* Load signature components */
  fio___p256_scalar_from_bytes(r, r_bytes);
  fio___p256_scalar_from_bytes(s, s_bytes);

  /* Verify r, s are in [1, n-1] */
  if (fio___p256_scalar_is_zero(r) || fio___p256_scalar_gte_n(r))
    return -1;
  if (fio___p256_scalar_is_zero(s) || fio___p256_scalar_gte_n(s))
    return -1;

  /* Load message hash as scalar e */
  fio___p256_scalar_from_bytes(e, msg_hash);

  /* Reduce e mod n if needed */
  if (fio___p256_scalar_gte_n(e)) {
    uint64_t borrow = 0;
    e[0] = fio_math_subc64(e[0], FIO___P256_N[0], 0, &borrow);
    e[1] = fio_math_subc64(e[1], FIO___P256_N[1], borrow, &borrow);
    e[2] = fio_math_subc64(e[2], FIO___P256_N[2], borrow, &borrow);
    e[3] = fio_math_subc64(e[3], FIO___P256_N[3], borrow, &borrow);
  }

  /* Load public key point Q */
  fio___p256_fe_from_bytes(q.x, pubkey_x);
  fio___p256_fe_from_bytes(q.y, pubkey_y);

  /* Verify Q is on the curve: y = x - 3x + b (mod p) */
  {
    fio___p256_fe_s y2, x3, t;

    /* y */
    fio___p256_fe_sqr(y2, q.y);

    /* x */
    fio___p256_fe_sqr(t, q.x);
    fio___p256_fe_mul(x3, t, q.x);

    /* x - 3x */
    fio___p256_fe_sub(t, x3, q.x);
    fio___p256_fe_sub(t, t, q.x);
    fio___p256_fe_sub(t, t, q.x);

    /* x - 3x + b */
    fio___p256_fe_add(t, t, FIO___P256_B);

    /* Check y == x - 3x + b */
    if (fio___p256_fe_eq(y2, t) != 0)
      return -1;
  }

  /* Compute w = s^(-1) mod n */
  fio___p256_scalar_s w;
  fio___p256_scalar_inv(w, s);

  /* Compute u1 = e * w mod n */
  fio___p256_scalar_s u1;
  fio___p256_scalar_mul(u1, e, w);

  /* Compute u2 = r * w mod n */
  fio___p256_scalar_s u2;
  fio___p256_scalar_mul(u2, r, w);

  /* Compute R = u1*G + u2*Q */
  fio___p256_point_jacobian_s R_jac;
  fio___p256_point_mul2(&R_jac, u1, u2, &q);

  /* If R is infinity, reject */
  if (fio___p256_point_is_infinity(&R_jac))
    return -1;

  /* Convert R to affine */
  fio___p256_point_affine_s R_aff;
  fio___p256_point_to_affine(&R_aff, &R_jac);

  /* Get R.x as bytes */
  uint8_t rx_bytes[32];
  fio___p256_fe_to_bytes(rx_bytes, R_aff.x);

  /* Load R.x as scalar and reduce mod n */
  fio___p256_scalar_s rx;
  fio___p256_scalar_from_bytes(rx, rx_bytes);
  while (fio___p256_scalar_gte_n(rx)) {
    uint64_t borrow = 0;
    rx[0] = fio_math_subc64(rx[0], FIO___P256_N[0], 0, &borrow);
    rx[1] = fio_math_subc64(rx[1], FIO___P256_N[1], borrow, &borrow);
    rx[2] = fio_math_subc64(rx[2], FIO___P256_N[2], borrow, &borrow);
    rx[3] = fio_math_subc64(rx[3], FIO___P256_N[3], borrow, &borrow);
  }

  /* Verify r == R.x mod n */
  if (r[0] != rx[0] || r[1] != rx[1] || r[2] != rx[2] || r[3] != rx[3])
    return -1;

  return 0;
}

SFUNC int fio_ecdsa_p256_verify(const uint8_t *sig,
                                size_t sig_len,
                                const uint8_t *msg_hash,
                                const uint8_t *pubkey,
                                size_t pubkey_len) {
  if (!sig || !msg_hash || !pubkey)
    return -1;

  /* Uncompressed public key format: 0x04 || x (32 bytes) || y (32 bytes) */
  if (pubkey_len != 65 || pubkey[0] != 0x04)
    return -1;

  /* Parse DER signature */
  uint8_t r[32], s[32];
  if (fio___p256_parse_der_signature(r, s, sig, sig_len) != 0)
    return -1;

  /* Verify */
  return fio_ecdsa_p256_verify_raw(r, s, msg_hash, pubkey + 1, pubkey + 33);
}

/* *****************************************************************************
ECDSA P-256 Signing Implementation
***************************************************************************** */

/**
 * Encode a 32-byte integer as DER INTEGER (handles leading zero for positive).
 * Returns number of bytes written.
 */
FIO_SFUNC size_t fio___p256_encode_der_integer(uint8_t *out,
                                               const uint8_t val[32]) {
  /* Skip leading zeros */
  size_t start = 0;
  while (start < 31 && val[start] == 0)
    ++start;

  /* Need leading zero if high bit is set (to keep positive) */
  int need_zero = (val[start] & 0x80) != 0;
  size_t len = 32 - start + (need_zero ? 1 : 0);

  out[0] = 0x02; /* INTEGER tag */
  out[1] = (uint8_t)len;
  size_t offset = 2;
  if (need_zero)
    out[offset++] = 0x00;
  FIO_MEMCPY(out + offset, val + start, 32 - start);

  return 2 + len;
}

SFUNC int fio_ecdsa_p256_sign(uint8_t *sig,
                              size_t *sig_len,
                              size_t sig_capacity,
                              const uint8_t msg_hash[32],
                              const uint8_t secret_key[32]) {
  if (!sig || !sig_len || !msg_hash || !secret_key || sig_capacity < 72)
    return -1;

  fio___p256_scalar_s d, e, k, r_scalar, s_scalar, tmp;

  /* Load secret key as scalar d */
  fio___p256_scalar_from_bytes(d, secret_key);

  /* Validate d: 0 < d < n */
  if (fio___p256_scalar_is_zero(d) || fio___p256_scalar_gte_n(d)) {
    fio_secure_zero(d, sizeof(d));
    return -1;
  }

  /* Load message hash as scalar e */
  fio___p256_scalar_from_bytes(e, msg_hash);

  /* Reduce e mod n if needed */
  if (fio___p256_scalar_gte_n(e)) {
    uint64_t borrow = 0;
    e[0] = fio_math_subc64(e[0], FIO___P256_N[0], 0, &borrow);
    e[1] = fio_math_subc64(e[1], FIO___P256_N[1], borrow, &borrow);
    e[2] = fio_math_subc64(e[2], FIO___P256_N[2], borrow, &borrow);
    e[3] = fio_math_subc64(e[3], FIO___P256_N[3], borrow, &borrow);
  }

  /* Generate random k and compute signature */
  /* Try up to 100 times to get valid k (should succeed on first try) */
  uint8_t k_bytes[32];
  uint8_t r_bytes[32], s_bytes[32];

  for (int attempts = 0; attempts < 100; ++attempts) {
    /* Generate random k */
    fio_rand_bytes(k_bytes, 32);
    fio___p256_scalar_from_bytes(k, k_bytes);

    /* Ensure 0 < k < n */
    if (fio___p256_scalar_is_zero(k) || fio___p256_scalar_gte_n(k))
      continue;

    /* Compute R = k * G */
    fio___p256_point_affine_s g;
    fio___p256_fe_copy(g.x, FIO___P256_GX);
    fio___p256_fe_copy(g.y, FIO___P256_GY);

    fio___p256_point_jacobian_s R_jac;
    fio___p256_point_mul(&R_jac, k, &g);

    if (fio___p256_point_is_infinity(&R_jac))
      continue;

    /* Convert R to affine */
    fio___p256_point_affine_s R_aff;
    fio___p256_point_to_affine(&R_aff, &R_jac);

    /* r = R.x mod n */
    fio___p256_fe_to_bytes(r_bytes, R_aff.x);
    fio___p256_scalar_from_bytes(r_scalar, r_bytes);

    /* Reduce r mod n if needed */
    while (fio___p256_scalar_gte_n(r_scalar)) {
      uint64_t borrow = 0;
      r_scalar[0] = fio_math_subc64(r_scalar[0], FIO___P256_N[0], 0, &borrow);
      r_scalar[1] =
          fio_math_subc64(r_scalar[1], FIO___P256_N[1], borrow, &borrow);
      r_scalar[2] =
          fio_math_subc64(r_scalar[2], FIO___P256_N[2], borrow, &borrow);
      r_scalar[3] =
          fio_math_subc64(r_scalar[3], FIO___P256_N[3], borrow, &borrow);
    }

    /* If r == 0, try again */
    if (fio___p256_scalar_is_zero(r_scalar))
      continue;

    /* Compute s = k^(-1) * (e + r*d) mod n */
    /* First: r*d mod n */
    fio___p256_scalar_mul(tmp, r_scalar, d);

    /* Then: e + r*d mod n */
    /* Add e to tmp */
    uint64_t carry = 0;
    tmp[0] = fio_math_addc64(tmp[0], e[0], 0, &carry);
    tmp[1] = fio_math_addc64(tmp[1], e[1], carry, &carry);
    tmp[2] = fio_math_addc64(tmp[2], e[2], carry, &carry);
    tmp[3] = fio_math_addc64(tmp[3], e[3], carry, &carry);

    /* Reduce mod n if needed */
    while (carry || fio___p256_scalar_gte_n(tmp)) {
      uint64_t borrow = 0;
      tmp[0] = fio_math_subc64(tmp[0], FIO___P256_N[0], 0, &borrow);
      tmp[1] = fio_math_subc64(tmp[1], FIO___P256_N[1], borrow, &borrow);
      tmp[2] = fio_math_subc64(tmp[2], FIO___P256_N[2], borrow, &borrow);
      tmp[3] = fio_math_subc64(tmp[3], FIO___P256_N[3], borrow, &borrow);
      carry = 0;
    }

    /* Compute k^(-1) mod n */
    fio___p256_scalar_s k_inv;
    fio___p256_scalar_inv(k_inv, k);

    /* s = k^(-1) * (e + r*d) mod n */
    fio___p256_scalar_mul(s_scalar, k_inv, tmp);

    /* If s == 0, try again */
    if (fio___p256_scalar_is_zero(s_scalar))
      continue;

    /* Convert r and s to bytes (big-endian) */
    /* r_scalar to r_bytes */
    fio_u2buf64_be(r_bytes, r_scalar[3]);
    fio_u2buf64_be(r_bytes + 8, r_scalar[2]);
    fio_u2buf64_be(r_bytes + 16, r_scalar[1]);
    fio_u2buf64_be(r_bytes + 24, r_scalar[0]);

    /* s_scalar to s_bytes */
    fio_u2buf64_be(s_bytes, s_scalar[3]);
    fio_u2buf64_be(s_bytes + 8, s_scalar[2]);
    fio_u2buf64_be(s_bytes + 16, s_scalar[1]);
    fio_u2buf64_be(s_bytes + 24, s_scalar[0]);

    /* Encode as DER: SEQUENCE { r INTEGER, s INTEGER } */
    uint8_t r_der[34], s_der[34];
    FIO_MEMSET(r_der, 0, sizeof(r_der));
    FIO_MEMSET(s_der, 0, sizeof(s_der));
    size_t r_der_len = fio___p256_encode_der_integer(r_der, r_bytes);
    size_t s_der_len = fio___p256_encode_der_integer(s_der, s_bytes);

    size_t seq_content_len = r_der_len + s_der_len;
    size_t total_len =
        2 + seq_content_len; /* SEQUENCE tag + length + content */

    if (total_len > sig_capacity) {
      fio_secure_zero(d, sizeof(d));
      fio_secure_zero(k, sizeof(k));
      fio_secure_zero(k_inv, sizeof(k_inv));
      return -1;
    }

    /* Write SEQUENCE header */
    sig[0] = 0x30; /* SEQUENCE tag */
    sig[1] = (uint8_t)seq_content_len;
    FIO_MEMCPY(sig + 2, r_der, r_der_len);
    FIO_MEMCPY(sig + 2 + r_der_len, s_der, s_der_len);

    *sig_len = total_len;

    /* Clear sensitive data */
    fio_secure_zero(d, sizeof(d));
    fio_secure_zero(k, sizeof(k));
    fio_secure_zero(k_inv, sizeof(k_inv));
    fio_secure_zero(k_bytes, sizeof(k_bytes));

    return 0;
  }

  /* Failed to generate valid signature after 100 attempts */
  fio_secure_zero(d, sizeof(d));
  return -1;
}

/* *****************************************************************************
P-256 ECDHE Implementation
***************************************************************************** */

/**
 * Validate that a point is on the P-256 curve.
 * Checks: y = x - 3x + b (mod p)
 *
 * @return 0 if valid, -1 if invalid
 */
FIO_SFUNC int fio___p256_point_validate(const fio___p256_point_affine_s *p) {
  fio___p256_fe_s y2, x3, t;

  /* y */
  fio___p256_fe_sqr(y2, p->y);

  /* x */
  fio___p256_fe_sqr(t, p->x);
  fio___p256_fe_mul(x3, t, p->x);

  /* x - 3x */
  fio___p256_fe_sub(t, x3, p->x);
  fio___p256_fe_sub(t, t, p->x);
  fio___p256_fe_sub(t, t, p->x);

  /* x - 3x + b */
  fio___p256_fe_add(t, t, FIO___P256_B);

  /* Check y == x - 3x + b */
  return (fio___p256_fe_eq(y2, t) == 0) ? 0 : -1;
}

/**
 * Decompress a compressed P-256 point (33 bytes: 0x02/0x03 || x).
 * Computes y from x using y = x - 3x + b, selects sign based on prefix.
 *
 * @return 0 on success, -1 on failure
 */
FIO_SFUNC int fio___p256_point_decompress(fio___p256_point_affine_s *p,
                                          const uint8_t compressed[33]) {
  uint8_t prefix = compressed[0];
  if (prefix != 0x02 && prefix != 0x03)
    return -1;

  /* Load x coordinate */
  fio___p256_fe_from_bytes(p->x, compressed + 1);

  /* Compute y = x - 3x + b */
  fio___p256_fe_s y2, x3, t;
  fio___p256_fe_sqr(t, p->x);
  fio___p256_fe_mul(x3, t, p->x);
  fio___p256_fe_sub(t, x3, p->x);
  fio___p256_fe_sub(t, t, p->x);
  fio___p256_fe_sub(t, t, p->x);
  fio___p256_fe_add(y2, t, FIO___P256_B);

  /* Compute y = sqrt(y) mod p using Tonelli-Shanks.
   * For P-256: p  3 (mod 4), so y = y^((p+1)/4) mod p */
  /* (p+1)/4 =
   * 0x3FFFFFFFC0000000400000000000000000000000400000000000000000000000 */
  fio___p256_fe_s y;

  /* Use Fermat's method: y = y2^((p+1)/4) mod p
   * We use a simple square-and-multiply with the exponent (p+1)/4 */
  static const uint64_t exp[4] = {
      0x0000000000000000ULL, /* exp[0] */
      0x0000000040000000ULL, /* exp[1] */
      0x4000000000000000ULL, /* exp[2] */
      0x3FFFFFFFC0000000ULL, /* exp[3] */
  };

  /* Start with result = 1 */
  fio___p256_fe_s result;
  fio___p256_fe_one(result);

  /* base = y2 */
  fio___p256_fe_s base;
  fio___p256_fe_copy(base, y2);

  /* Square-and-multiply from LSB to MSB */
  for (int i = 0; i < 4; ++i) {
    uint64_t bits = exp[i];
    for (int j = 0; j < 64; ++j) {
      if (bits & 1) {
        fio___p256_fe_mul(result, result, base);
      }
      fio___p256_fe_sqr(base, base);
      bits >>= 1;
    }
  }

  fio___p256_fe_copy(y, result);

  /* Verify: y should equal y2 */
  fio___p256_fe_s check;
  fio___p256_fe_sqr(check, y);
  if (fio___p256_fe_eq(check, y2) != 0)
    return -1; /* Not a quadratic residue - invalid point */

  /* Select correct sign: if (y mod 2) != (prefix - 2), negate y */
  uint8_t y_bytes[32];
  fio___p256_fe_to_bytes(y_bytes, y);
  int y_parity = y_bytes[31] & 1;
  int expected_parity = prefix - 0x02;

  if (y_parity != expected_parity) {
    fio___p256_fe_neg(p->y, y);
  } else {
    fio___p256_fe_copy(p->y, y);
  }

  return 0;
}

SFUNC int fio_p256_keypair(uint8_t secret_key[32], uint8_t public_key[65]) {
  if (!secret_key || !public_key)
    return -1;

  fio___p256_scalar_s k;

  /* Generate random scalar and ensure 0 < k < n */
  for (int attempts = 0; attempts < 100; ++attempts) {
    fio_rand_bytes(secret_key, 32);
    fio___p256_scalar_from_bytes(k, secret_key);

    /* Check k is not zero and k < n */
    if (!fio___p256_scalar_is_zero(k) && !fio___p256_scalar_gte_n(k))
      break;

    if (attempts == 99)
      return -1; /* Failed to generate valid scalar */
  }

  /* Compute public key = k * G */
  fio___p256_point_affine_s g;
  fio___p256_fe_copy(g.x, FIO___P256_GX);
  fio___p256_fe_copy(g.y, FIO___P256_GY);

  fio___p256_point_jacobian_s pub_jac;
  fio___p256_point_mul(&pub_jac, k, &g);

  /* Convert to affine */
  fio___p256_point_affine_s pub_aff;
  fio___p256_point_to_affine(&pub_aff, &pub_jac);

  /* Serialize: 0x04 || x || y */
  public_key[0] = 0x04;
  fio___p256_fe_to_bytes(public_key + 1, pub_aff.x);
  fio___p256_fe_to_bytes(public_key + 33, pub_aff.y);

  /* Clear sensitive data */
  FIO_MEMSET(k, 0, sizeof(k));

  return 0;
}

SFUNC int fio_p256_shared_secret(uint8_t shared_secret[32],
                                 const uint8_t secret_key[32],
                                 const uint8_t *their_public_key,
                                 size_t their_public_key_len) {
  if (!shared_secret || !secret_key || !their_public_key)
    return -1;

  fio___p256_point_affine_s their_point;

  /* Parse their public key */
  if (their_public_key_len == 65) {
    /* Uncompressed: 0x04 || x || y */
    if (their_public_key[0] != 0x04)
      return -1;
    fio___p256_fe_from_bytes(their_point.x, their_public_key + 1);
    fio___p256_fe_from_bytes(their_point.y, their_public_key + 33);
  } else if (their_public_key_len == 33) {
    /* Compressed: 0x02/0x03 || x */
    if (fio___p256_point_decompress(&their_point, their_public_key) != 0)
      return -1;
  } else {
    return -1; /* Invalid length */
  }

  /* Validate point is on curve */
  if (fio___p256_point_validate(&their_point) != 0)
    return -1;

  /* Load our secret key as scalar */
  fio___p256_scalar_s k;
  fio___p256_scalar_from_bytes(k, secret_key);

  /* Validate scalar: 0 < k < n */
  if (fio___p256_scalar_is_zero(k) || fio___p256_scalar_gte_n(k)) {
    FIO_MEMSET(k, 0, sizeof(k));
    return -1;
  }

  /* Compute shared = k * their_point */
  fio___p256_point_jacobian_s result_jac;
  fio___p256_point_mul(&result_jac, k, &their_point);

  /* Check for point at infinity (shouldn't happen with valid inputs) */
  if (fio___p256_point_is_infinity(&result_jac)) {
    FIO_MEMSET(k, 0, sizeof(k));
    return -1;
  }

  /* Convert to affine and extract x-coordinate */
  fio___p256_point_affine_s result_aff;
  fio___p256_point_to_affine(&result_aff, &result_jac);
  fio___p256_fe_to_bytes(shared_secret, result_aff.x);

  /* Clear sensitive data */
  FIO_MEMSET(k, 0, sizeof(k));
  FIO_MEMSET(&result_jac, 0, sizeof(result_jac));
  FIO_MEMSET(&result_aff, 0, sizeof(result_aff));

  /* Check for all-zero output (low-order point attack) */
  uint8_t zero_check = 0;
  for (int i = 0; i < 32; ++i)
    zero_check |= shared_secret[i];

  return zero_check ? 0 : -1;
}

/* *****************************************************************************
Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_P256
#endif /* FIO_P256 */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_P384               /* Development inclusion - ignore line */
#define FIO_SHA2               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                    Elliptic Curve Cryptography: ECDSA P-384 (secp384r1)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_P384) && !defined(H___FIO_P384___H)
#define H___FIO_P384___H

/* *****************************************************************************
P-384 (secp384r1) ECDSA Module

This module provides ECDSA signature verification for the P-384 curve,
primarily for TLS 1.3 certificate chain validation (Let's Encrypt root CAs).

P-384 curve parameters (NIST FIPS 186-4):
- Prime p = 2^384 - 2^128 - 2^96 + 2^32 - 1
- Order n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF
            581A0DB248B0A77AECEC196ACCC52973
- Curve equation: y^2 = x^3 - 3x + b (mod p)

**Note**: This implementation has not been audited. Use at your own risk.
***************************************************************************** */

/* *****************************************************************************
ECDSA P-384 Verification API
***************************************************************************** */

/**
 * Verifies an ECDSA P-384 signature.
 *
 * @param sig DER-encoded signature (SEQUENCE { r INTEGER, s INTEGER })
 * @param sig_len Length of signature in bytes
 * @param msg_hash SHA-384 hash of the message (48 bytes)
 * @param pubkey Uncompressed public key (97 bytes: 0x04 || x || y)
 * @param pubkey_len Length of public key (must be 97)
 * @return 0 on success (valid signature), -1 on failure (invalid signature)
 */
SFUNC int fio_ecdsa_p384_verify(const uint8_t *sig,
                                size_t sig_len,
                                const uint8_t *msg_hash,
                                const uint8_t *pubkey,
                                size_t pubkey_len);

/**
 * Verifies an ECDSA P-384 signature with raw r,s values.
 *
 * @param r The r component of the signature (48 bytes, big-endian)
 * @param s The s component of the signature (48 bytes, big-endian)
 * @param msg_hash SHA-384 hash of the message (48 bytes)
 * @param pubkey_x X coordinate of public key (48 bytes, big-endian)
 * @param pubkey_y Y coordinate of public key (48 bytes, big-endian)
 * @return 0 on success (valid signature), -1 on failure (invalid signature)
 */
SFUNC int fio_ecdsa_p384_verify_raw(const uint8_t r[48],
                                    const uint8_t s[48],
                                    const uint8_t msg_hash[48],
                                    const uint8_t pubkey_x[48],
                                    const uint8_t pubkey_y[48]);

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
P-384 Field Arithmetic (mod p)

Prime p = 2^384 - 2^128 - 2^96 + 2^32 - 1
       = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE
         FFFFFFFF0000000000000000FFFFFFFF

We use 6 x 64-bit limbs in little-endian order.
***************************************************************************** */

/* P-384 prime p in little-endian limbs */
static const uint64_t FIO___P384_P[6] = {
    0x00000000FFFFFFFFULL, /* p[0] */
    0xFFFFFFFF00000000ULL, /* p[1] */
    0xFFFFFFFFFFFFFFFEULL, /* p[2] */
    0xFFFFFFFFFFFFFFFFULL, /* p[3] */
    0xFFFFFFFFFFFFFFFFULL, /* p[4] */
    0xFFFFFFFFFFFFFFFFULL, /* p[5] */
};

/* P-384 curve order n in little-endian limbs */
static const uint64_t FIO___P384_N[6] = {
    0xECEC196ACCC52973ULL, /* n[0] */
    0x581A0DB248B0A77AULL, /* n[1] */
    0xC7634D81F4372DDFULL, /* n[2] */
    0xFFFFFFFFFFFFFFFFULL, /* n[3] */
    0xFFFFFFFFFFFFFFFFULL, /* n[4] */
    0xFFFFFFFFFFFFFFFFULL, /* n[5] */
};

/* P-384 curve parameter b in little-endian limbs */
static const uint64_t FIO___P384_B[6] = {
    0x2A85C8EDD3EC2AEFULL, /* b[0] */
    0xC656398D8A2ED19DULL, /* b[1] */
    0x0314088F5013875AULL, /* b[2] */
    0x181D9C6EFE814112ULL, /* b[3] */
    0x988E056BE3F82D19ULL, /* b[4] */
    0xB3312FA7E23EE7E4ULL, /* b[5] */
};

/* P-384 base point G x-coordinate in little-endian limbs */
static const uint64_t FIO___P384_GX[6] = {
    0x3A545E3872760AB7ULL, /* Gx[0] */
    0x5502F25DBF55296CULL, /* Gx[1] */
    0x59F741E082542A38ULL, /* Gx[2] */
    0x6E1D3B628BA79B98ULL, /* Gx[3] */
    0x8EB1C71EF320AD74ULL, /* Gx[4] */
    0xAA87CA22BE8B0537ULL, /* Gx[5] */
};

/* P-384 base point G y-coordinate in little-endian limbs */
static const uint64_t FIO___P384_GY[6] = {
    0x7A431D7C90EA0E5FULL, /* Gy[0] */
    0x0A60B1CE1D7E819DULL, /* Gy[1] */
    0xE9DA3113B5F0B8C0ULL, /* Gy[2] */
    0xF8F41DBD289A147CULL, /* Gy[3] */
    0x5D9E98BF9292DC29ULL, /* Gy[4] */
    0x3617DE4A96262C6FULL, /* Gy[5] */
};

/* Field element type: 6 x 64-bit limbs in little-endian */
typedef uint64_t fio___p384_fe_s[6];

/* Point in affine coordinates */
typedef struct {
  fio___p384_fe_s x;
  fio___p384_fe_s y;
} fio___p384_point_affine_s;

/* Point in Jacobian coordinates (x = X/Z^2, y = Y/Z^3) */
typedef struct {
  fio___p384_fe_s x;
  fio___p384_fe_s y;
  fio___p384_fe_s z;
} fio___p384_point_jacobian_s;

/* *****************************************************************************
Field Element Operations (mod p)
***************************************************************************** */

/** Copy field element: dest = src */
FIO_IFUNC void fio___p384_fe_copy(fio___p384_fe_s dest,
                                  const fio___p384_fe_s src) {
  dest[0] = src[0];
  dest[1] = src[1];
  dest[2] = src[2];
  dest[3] = src[3];
  dest[4] = src[4];
  dest[5] = src[5];
}

/** Set field element to zero */
FIO_IFUNC void fio___p384_fe_zero(fio___p384_fe_s r) {
  r[0] = 0;
  r[1] = 0;
  r[2] = 0;
  r[3] = 0;
  r[4] = 0;
  r[5] = 0;
}

/** Set field element to one */
FIO_IFUNC void fio___p384_fe_one(fio___p384_fe_s r) {
  r[0] = 1;
  r[1] = 0;
  r[2] = 0;
  r[3] = 0;
  r[4] = 0;
  r[5] = 0;
}

/** Check if field element is zero */
FIO_IFUNC int fio___p384_fe_is_zero(const fio___p384_fe_s a) {
  return (a[0] | a[1] | a[2] | a[3] | a[4] | a[5]) == 0;
}

/** Compare two field elements: returns 0 if equal */
FIO_IFUNC int fio___p384_fe_eq(const fio___p384_fe_s a,
                               const fio___p384_fe_s b) {
  uint64_t diff = (a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]) |
                  (a[3] ^ b[3]) | (a[4] ^ b[4]) | (a[5] ^ b[5]);
  return diff == 0 ? 0 : 1;
}

/** Load 48-byte big-endian number into field element */
FIO_IFUNC void fio___p384_fe_from_bytes(fio___p384_fe_s r,
                                        const uint8_t in[48]) {
  r[5] = fio_buf2u64_be(in);
  r[4] = fio_buf2u64_be(in + 8);
  r[3] = fio_buf2u64_be(in + 16);
  r[2] = fio_buf2u64_be(in + 24);
  r[1] = fio_buf2u64_be(in + 32);
  r[0] = fio_buf2u64_be(in + 40);
}

/** Store field element to 48-byte big-endian output */
FIO_IFUNC void fio___p384_fe_to_bytes(uint8_t out[48],
                                      const fio___p384_fe_s a) {
  fio_u2buf64_be(out, a[5]);
  fio_u2buf64_be(out + 8, a[4]);
  fio_u2buf64_be(out + 16, a[3]);
  fio_u2buf64_be(out + 24, a[2]);
  fio_u2buf64_be(out + 32, a[1]);
  fio_u2buf64_be(out + 40, a[0]);
}

/** Field addition: r = a + b mod p */
FIO_IFUNC void fio___p384_fe_add(fio___p384_fe_s r,
                                 const fio___p384_fe_s a,
                                 const fio___p384_fe_s b) {
  uint64_t c = 0;
  uint64_t t[6];

  /* Add a + b */
  t[0] = fio_math_addc64(a[0], b[0], 0, &c);
  t[1] = fio_math_addc64(a[1], b[1], c, &c);
  t[2] = fio_math_addc64(a[2], b[2], c, &c);
  t[3] = fio_math_addc64(a[3], b[3], c, &c);
  t[4] = fio_math_addc64(a[4], b[4], c, &c);
  t[5] = fio_math_addc64(a[5], b[5], c, &c);

  /* Reduce mod p if needed: subtract p if result >= p */
  uint64_t borrow = 0;
  uint64_t s[6];
  s[0] = fio_math_subc64(t[0], FIO___P384_P[0], 0, &borrow);
  s[1] = fio_math_subc64(t[1], FIO___P384_P[1], borrow, &borrow);
  s[2] = fio_math_subc64(t[2], FIO___P384_P[2], borrow, &borrow);
  s[3] = fio_math_subc64(t[3], FIO___P384_P[3], borrow, &borrow);
  s[4] = fio_math_subc64(t[4], FIO___P384_P[4], borrow, &borrow);
  s[5] = fio_math_subc64(t[5], FIO___P384_P[5], borrow, &borrow);

  /* If carry from addition or no borrow from subtraction, use subtracted value
   */
  uint64_t mask = (uint64_t)0 - (c | (borrow ^ 1));
  r[0] = (s[0] & mask) | (t[0] & ~mask);
  r[1] = (s[1] & mask) | (t[1] & ~mask);
  r[2] = (s[2] & mask) | (t[2] & ~mask);
  r[3] = (s[3] & mask) | (t[3] & ~mask);
  r[4] = (s[4] & mask) | (t[4] & ~mask);
  r[5] = (s[5] & mask) | (t[5] & ~mask);
}

/** Field subtraction: r = a - b mod p */
FIO_IFUNC void fio___p384_fe_sub(fio___p384_fe_s r,
                                 const fio___p384_fe_s a,
                                 const fio___p384_fe_s b) {
  uint64_t borrow = 0;
  uint64_t t[6];

  /* Subtract a - b */
  t[0] = fio_math_subc64(a[0], b[0], 0, &borrow);
  t[1] = fio_math_subc64(a[1], b[1], borrow, &borrow);
  t[2] = fio_math_subc64(a[2], b[2], borrow, &borrow);
  t[3] = fio_math_subc64(a[3], b[3], borrow, &borrow);
  t[4] = fio_math_subc64(a[4], b[4], borrow, &borrow);
  t[5] = fio_math_subc64(a[5], b[5], borrow, &borrow);

  /* If borrow, add p back */
  uint64_t c = 0;
  uint64_t mask = (uint64_t)0 - borrow;
  uint64_t s[6];
  s[0] = fio_math_addc64(t[0], FIO___P384_P[0] & mask, 0, &c);
  s[1] = fio_math_addc64(t[1], FIO___P384_P[1] & mask, c, &c);
  s[2] = fio_math_addc64(t[2], FIO___P384_P[2] & mask, c, &c);
  s[3] = fio_math_addc64(t[3], FIO___P384_P[3] & mask, c, &c);
  s[4] = fio_math_addc64(t[4], FIO___P384_P[4] & mask, c, &c);
  s[5] = fio_math_addc64(t[5], FIO___P384_P[5] & mask, c, &c);

  r[0] = s[0];
  r[1] = s[1];
  r[2] = s[2];
  r[3] = s[3];
  r[4] = s[4];
  r[5] = s[5];
}

/** Field negation: r = -a mod p */
FIO_IFUNC void fio___p384_fe_neg(fio___p384_fe_s r, const fio___p384_fe_s a) {
  fio___p384_fe_s zero = {0};
  fio___p384_fe_sub(r, zero, a);
}

/**
 * P-384 reduction using the NIST fast reduction formula.
 *
 * p = 2^384 - 2^128 - 2^96 + 2^32 - 1
 *
 * For a 768-bit number T, we use the NIST formula with 32-bit words.
 * T = (c23,...,c0) where each ci is 32 bits.
 *
 * The result is: T mod p = s1 + 2*s2 + s3 + s4 + s5 + s6 + s7 - s8 - s9 - s10
 * where each si is a 384-bit value constructed from the 32-bit words.
 *
 * Reference: NIST FIPS 186-4, Section D.2.4
 */
FIO_SFUNC void fio___p384_fe_reduce(fio___p384_fe_s r, const uint64_t t[12]) {
  /* Extract 32-bit words from 768-bit input (little-endian) */
  uint32_t c[24];
  for (int i = 0; i < 12; ++i) {
    c[2 * i] = (uint32_t)t[i];
    c[2 * i + 1] = (uint32_t)(t[i] >> 32);
  }

  /* Use 64-bit accumulators for each 32-bit position to handle carries.
   * acc[0] is LSB (c0 position), acc[11] is MSB (c11 position).
   * NIST notation: (c11, c10, ..., c1, c0) means
   * c11 is at position 11 (MSB), c0 is at position 0 (LSB). */
  int64_t acc[12] = {0};

  /* s1 = (c11, c10, c9, c8, c7, c6, c5, c4, c3, c2, c1, c0) - the low 384 bits
   */
  acc[0] += c[0];
  acc[1] += c[1];
  acc[2] += c[2];
  acc[3] += c[3];
  acc[4] += c[4];
  acc[5] += c[5];
  acc[6] += c[6];
  acc[7] += c[7];
  acc[8] += c[8];
  acc[9] += c[9];
  acc[10] += c[10];
  acc[11] += c[11];

  /* s2 = (0, 0, 0, 0, 0, c23, c22, c21, 0, 0, 0, 0) - add twice */
  acc[4] += 2 * (int64_t)c[21];
  acc[5] += 2 * (int64_t)c[22];
  acc[6] += 2 * (int64_t)c[23];

  /* s3 = (c23, c22, c21, c20, c19, c18, c17, c16, c15, c14, c13, c12) */
  acc[0] += c[12];
  acc[1] += c[13];
  acc[2] += c[14];
  acc[3] += c[15];
  acc[4] += c[16];
  acc[5] += c[17];
  acc[6] += c[18];
  acc[7] += c[19];
  acc[8] += c[20];
  acc[9] += c[21];
  acc[10] += c[22];
  acc[11] += c[23];

  /* s4 = (c20, c19, c18, c17, c16, c15, c14, c13, c12, c23, c22, c21) */
  acc[0] += c[21];
  acc[1] += c[22];
  acc[2] += c[23];
  acc[3] += c[12];
  acc[4] += c[13];
  acc[5] += c[14];
  acc[6] += c[15];
  acc[7] += c[16];
  acc[8] += c[17];
  acc[9] += c[18];
  acc[10] += c[19];
  acc[11] += c[20];

  /* s5 = (c19, c18, c17, c16, c15, c14, c13, c12, c20, 0, c23, 0) */
  acc[1] += c[23];
  acc[3] += c[20];
  acc[4] += c[12];
  acc[5] += c[13];
  acc[6] += c[14];
  acc[7] += c[15];
  acc[8] += c[16];
  acc[9] += c[17];
  acc[10] += c[18];
  acc[11] += c[19];

  /* s6 = (0, 0, 0, 0, c23, c22, c21, c20, 0, 0, 0, 0) */
  acc[4] += c[20];
  acc[5] += c[21];
  acc[6] += c[22];
  acc[7] += c[23];

  /* s7 = (0, 0, 0, 0, 0, 0, c23, c22, c21, 0, 0, c20) */
  acc[0] += c[20];
  acc[3] += c[21];
  acc[4] += c[22];
  acc[5] += c[23];

  /* s8 = (c22, c21, c20, c19, c18, c17, c16, c15, c14, c13, c12, c23) -
   * subtract */
  acc[0] -= c[23];
  acc[1] -= c[12];
  acc[2] -= c[13];
  acc[3] -= c[14];
  acc[4] -= c[15];
  acc[5] -= c[16];
  acc[6] -= c[17];
  acc[7] -= c[18];
  acc[8] -= c[19];
  acc[9] -= c[20];
  acc[10] -= c[21];
  acc[11] -= c[22];

  /* s9 = (0, 0, 0, 0, 0, 0, 0, c23, c22, c21, c20, 0) - subtract */
  acc[1] -= c[20];
  acc[2] -= c[21];
  acc[3] -= c[22];
  acc[4] -= c[23];

  /* s10 = (0, 0, 0, 0, 0, 0, 0, c23, c23, 0, 0, 0) - subtract */
  acc[3] -= c[23];
  acc[4] -= c[23];

  /* Carry propagation with signed arithmetic. */
  for (int i = 0; i < 11; ++i) {
    int64_t carry = acc[i] >> 32;
    acc[i] = acc[i] & 0xFFFFFFFFLL;
    acc[i + 1] += carry;
  }

  /* Handle overflow/underflow in the top limb.
   * p = 2^384 - 2^128 - 2^96 + 2^32 - 1
   * In 32-bit words (little-endian):
   * p[0]=0xFFFFFFFF, p[1]=0, p[2]=0, p[3]=0xFFFFFFFF, p[4]=0xFFFFFFFE,
   * p[5..11]=0xFFFFFFFF */
  while (acc[11] < 0 || acc[11] > (int64_t)0xFFFFFFFFLL) {
    if (acc[11] < 0) {
      /* Add p */
      acc[0] += 0xFFFFFFFFLL;
      acc[1] += 0;
      acc[2] += 0;
      acc[3] += 0xFFFFFFFFLL;
      acc[4] += 0xFFFFFFFELL;
      acc[5] += 0xFFFFFFFFLL;
      acc[6] += 0xFFFFFFFFLL;
      acc[7] += 0xFFFFFFFFLL;
      acc[8] += 0xFFFFFFFFLL;
      acc[9] += 0xFFFFFFFFLL;
      acc[10] += 0xFFFFFFFFLL;
      acc[11] += 0xFFFFFFFFLL;
    } else {
      /* Subtract p */
      acc[0] -= 0xFFFFFFFFLL;
      acc[1] -= 0;
      acc[2] -= 0;
      acc[3] -= 0xFFFFFFFFLL;
      acc[4] -= 0xFFFFFFFELL;
      acc[5] -= 0xFFFFFFFFLL;
      acc[6] -= 0xFFFFFFFFLL;
      acc[7] -= 0xFFFFFFFFLL;
      acc[8] -= 0xFFFFFFFFLL;
      acc[9] -= 0xFFFFFFFFLL;
      acc[10] -= 0xFFFFFFFFLL;
      acc[11] -= 0xFFFFFFFFLL;
    }

    /* Re-propagate carries */
    for (int i = 0; i < 11; ++i) {
      int64_t carry = acc[i] >> 32;
      acc[i] = acc[i] & 0xFFFFFFFFLL;
      acc[i + 1] += carry;
    }
  }

  /* Convert back to 64-bit limbs */
  uint64_t res[6];
  res[0] = ((uint64_t)(uint32_t)acc[1] << 32) | (uint32_t)acc[0];
  res[1] = ((uint64_t)(uint32_t)acc[3] << 32) | (uint32_t)acc[2];
  res[2] = ((uint64_t)(uint32_t)acc[5] << 32) | (uint32_t)acc[4];
  res[3] = ((uint64_t)(uint32_t)acc[7] << 32) | (uint32_t)acc[6];
  res[4] = ((uint64_t)(uint32_t)acc[9] << 32) | (uint32_t)acc[8];
  res[5] = ((uint64_t)(uint32_t)acc[11] << 32) | (uint32_t)acc[10];

  /* Final reduction: if result >= p, subtract p */
  for (int iter = 0; iter < 3; ++iter) {
    uint64_t borrow = 0;
    uint64_t sub[6];
    sub[0] = fio_math_subc64(res[0], FIO___P384_P[0], 0, &borrow);
    sub[1] = fio_math_subc64(res[1], FIO___P384_P[1], borrow, &borrow);
    sub[2] = fio_math_subc64(res[2], FIO___P384_P[2], borrow, &borrow);
    sub[3] = fio_math_subc64(res[3], FIO___P384_P[3], borrow, &borrow);
    sub[4] = fio_math_subc64(res[4], FIO___P384_P[4], borrow, &borrow);
    sub[5] = fio_math_subc64(res[5], FIO___P384_P[5], borrow, &borrow);

    /* If no borrow (result >= p), use subtracted value */
    if (!borrow) {
      res[0] = sub[0];
      res[1] = sub[1];
      res[2] = sub[2];
      res[3] = sub[3];
      res[4] = sub[4];
      res[5] = sub[5];
    } else {
      break;
    }
  }

  r[0] = res[0];
  r[1] = res[1];
  r[2] = res[2];
  r[3] = res[3];
  r[4] = res[4];
  r[5] = res[5];
}

/** Field multiplication: r = a * b mod p */
FIO_SFUNC void fio___p384_fe_mul(fio___p384_fe_s r,
                                 const fio___p384_fe_s a,
                                 const fio___p384_fe_s b) {
  uint64_t t[12] = {0};

  /* Schoolbook multiplication to get 768-bit product */
  for (int i = 0; i < 6; ++i) {
    uint64_t carry = 0;
    for (int j = 0; j < 6; ++j) {
      uint64_t hi;
      uint64_t lo = fio_math_mulc64(a[i], b[j], &hi);
      uint64_t c1 = 0, c2 = 0;
      t[i + j] = fio_math_addc64(t[i + j], lo, 0, &c1);
      t[i + j] = fio_math_addc64(t[i + j], carry, 0, &c2);
      carry = hi + c1 + c2;
    }
    t[i + 6] += carry;
  }

  /* Reduce mod p */
  fio___p384_fe_reduce(r, t);
}

/** Field squaring: r = a^2 mod p */
FIO_SFUNC void fio___p384_fe_sqr(fio___p384_fe_s r, const fio___p384_fe_s a) {
  fio___p384_fe_mul(r, a, a);
}

/**
 * Field inversion: r = a^(-1) mod p using Fermat's little theorem.
 * a^(-1) = a^(p-2) mod p
 *
 * p-2 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE
 *       FFFFFFFF0000000000000000FFFFFFFD
 *
 * We use a simple square-and-multiply algorithm for correctness.
 */
FIO_SFUNC void fio___p384_fe_inv(fio___p384_fe_s r, const fio___p384_fe_s a) {
  /* p - 2 in little-endian 64-bit limbs */
  static const uint64_t pm2[6] = {
      0x00000000FFFFFFFDULL, /* pm2[0] */
      0xFFFFFFFF00000000ULL, /* pm2[1] */
      0xFFFFFFFFFFFFFFFEULL, /* pm2[2] */
      0xFFFFFFFFFFFFFFFFULL, /* pm2[3] */
      0xFFFFFFFFFFFFFFFFULL, /* pm2[4] */
      0xFFFFFFFFFFFFFFFFULL, /* pm2[5] */
  };

  fio___p384_fe_s base, result, tmp;

  /* Initialize result = 1 */
  fio___p384_fe_one(result);

  /* Copy input to base */
  fio___p384_fe_copy(base, a);

  /* Square-and-multiply from LSB to MSB */
  for (int i = 0; i < 6; ++i) {
    uint64_t bits = pm2[i];
    for (int j = 0; j < 64; ++j) {
      if (bits & 1) {
        /* result = result * base */
        fio___p384_fe_mul(tmp, result, base);
        fio___p384_fe_copy(result, tmp);
      }
      /* base = base^2 */
      fio___p384_fe_sqr(tmp, base);
      fio___p384_fe_copy(base, tmp);
      bits >>= 1;
    }
  }

  fio___p384_fe_copy(r, result);
}

/* *****************************************************************************
Scalar Arithmetic (mod n)
***************************************************************************** */

/** Scalar element type: 6 x 64-bit limbs in little-endian */
typedef uint64_t fio___p384_scalar_s[6];

/** Load 48-byte big-endian number into scalar */
FIO_IFUNC void fio___p384_scalar_from_bytes(fio___p384_scalar_s r,
                                            const uint8_t in[48]) {
  r[5] = fio_buf2u64_be(in);
  r[4] = fio_buf2u64_be(in + 8);
  r[3] = fio_buf2u64_be(in + 16);
  r[2] = fio_buf2u64_be(in + 24);
  r[1] = fio_buf2u64_be(in + 32);
  r[0] = fio_buf2u64_be(in + 40);
}

/** Check if scalar is zero */
FIO_IFUNC int fio___p384_scalar_is_zero(const fio___p384_scalar_s a) {
  return (a[0] | a[1] | a[2] | a[3] | a[4] | a[5]) == 0;
}

/** Check if scalar >= n (curve order) */
FIO_IFUNC int fio___p384_scalar_gte_n(const fio___p384_scalar_s a) {
  /* Compare from most significant limb */
  if (a[5] > FIO___P384_N[5])
    return 1;
  if (a[5] < FIO___P384_N[5])
    return 0;
  if (a[4] > FIO___P384_N[4])
    return 1;
  if (a[4] < FIO___P384_N[4])
    return 0;
  if (a[3] > FIO___P384_N[3])
    return 1;
  if (a[3] < FIO___P384_N[3])
    return 0;
  if (a[2] > FIO___P384_N[2])
    return 1;
  if (a[2] < FIO___P384_N[2])
    return 0;
  if (a[1] > FIO___P384_N[1])
    return 1;
  if (a[1] < FIO___P384_N[1])
    return 0;
  if (a[0] >= FIO___P384_N[0])
    return 1;
  return 0;
}

/** Scalar reduction mod n using fio_math_div */
FIO_SFUNC void fio___p384_scalar_reduce(fio___p384_scalar_s r,
                                        const uint64_t t[12]) {
  /* Use fio_math_div to compute t mod n directly.
   * We need to extend n to 12 limbs for the division. */
  uint64_t n_ext[12] = {FIO___P384_N[0],
                        FIO___P384_N[1],
                        FIO___P384_N[2],
                        FIO___P384_N[3],
                        FIO___P384_N[4],
                        FIO___P384_N[5],
                        0,
                        0,
                        0,
                        0,
                        0,
                        0};
  uint64_t remainder[12] = {0};

  /* Compute t mod n */
  fio_math_div(NULL, remainder, t, n_ext, 12);

  /* Copy the low 6 limbs to result */
  r[0] = remainder[0];
  r[1] = remainder[1];
  r[2] = remainder[2];
  r[3] = remainder[3];
  r[4] = remainder[4];
  r[5] = remainder[5];
}

/** Scalar multiplication: r = a * b mod n */
FIO_SFUNC void fio___p384_scalar_mul(fio___p384_scalar_s r,
                                     const fio___p384_scalar_s a,
                                     const fio___p384_scalar_s b) {
  uint64_t t[12] = {0};

  /* Schoolbook multiplication */
  for (int i = 0; i < 6; ++i) {
    uint64_t carry = 0;
    for (int j = 0; j < 6; ++j) {
      uint64_t hi;
      uint64_t lo = fio_math_mulc64(a[i], b[j], &hi);
      uint64_t c1 = 0, c2 = 0;
      t[i + j] = fio_math_addc64(t[i + j], lo, 0, &c1);
      t[i + j] = fio_math_addc64(t[i + j], carry, 0, &c2);
      carry = hi + c1 + c2;
    }
    t[i + 6] += carry;
  }

  fio___p384_scalar_reduce(r, t);
}

/**
 * Scalar inversion: r = a^(-1) mod n using Fermat's little theorem.
 * a^(-1) = a^(n-2) mod n
 */
FIO_SFUNC void fio___p384_scalar_inv(fio___p384_scalar_s r,
                                     const fio___p384_scalar_s a) {
  /* n-2 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF
   *       581A0DB248B0A77AECEC196ACCC52971 */
  fio___p384_scalar_s t, tmp;

  /* Start with a */
  fio___p384_scalar_s base;
  base[0] = a[0];
  base[1] = a[1];
  base[2] = a[2];
  base[3] = a[3];
  base[4] = a[4];
  base[5] = a[5];

  /* Initialize result to 1 */
  t[0] = 1;
  t[1] = 0;
  t[2] = 0;
  t[3] = 0;
  t[4] = 0;
  t[5] = 0;

  /* Process each bit of n-2 from LSB to MSB */
  static const uint64_t nm2[6] = {
      0xECEC196ACCC52971ULL, /* (n-2)[0] */
      0x581A0DB248B0A77AULL, /* (n-2)[1] */
      0xC7634D81F4372DDFULL, /* (n-2)[2] */
      0xFFFFFFFFFFFFFFFFULL, /* (n-2)[3] */
      0xFFFFFFFFFFFFFFFFULL, /* (n-2)[4] */
      0xFFFFFFFFFFFFFFFFULL, /* (n-2)[5] */
  };

  for (int i = 0; i < 6; ++i) {
    uint64_t bits = nm2[i];
    for (int j = 0; j < 64; ++j) {
      if (bits & 1) {
        fio___p384_scalar_mul(tmp, t, base);
        t[0] = tmp[0];
        t[1] = tmp[1];
        t[2] = tmp[2];
        t[3] = tmp[3];
        t[4] = tmp[4];
        t[5] = tmp[5];
      }
      fio___p384_scalar_mul(tmp, base, base);
      base[0] = tmp[0];
      base[1] = tmp[1];
      base[2] = tmp[2];
      base[3] = tmp[3];
      base[4] = tmp[4];
      base[5] = tmp[5];
      bits >>= 1;
    }
  }

  r[0] = t[0];
  r[1] = t[1];
  r[2] = t[2];
  r[3] = t[3];
  r[4] = t[4];
  r[5] = t[5];
}

/* *****************************************************************************
Point Operations (Jacobian Coordinates)
***************************************************************************** */

/** Check if point is at infinity (Z = 0) */
FIO_IFUNC int fio___p384_point_is_infinity(
    const fio___p384_point_jacobian_s *p) {
  return fio___p384_fe_is_zero(p->z);
}

/** Set point to infinity */
FIO_IFUNC void fio___p384_point_set_infinity(fio___p384_point_jacobian_s *p) {
  fio___p384_fe_one(p->x);
  fio___p384_fe_one(p->y);
  fio___p384_fe_zero(p->z);
}

/** Convert affine point to Jacobian */
FIO_IFUNC void fio___p384_point_to_jacobian(
    fio___p384_point_jacobian_s *j,
    const fio___p384_point_affine_s *a) {
  fio___p384_fe_copy(j->x, a->x);
  fio___p384_fe_copy(j->y, a->y);
  fio___p384_fe_one(j->z);
}

/** Convert Jacobian point to affine (x = X/Z^2, y = Y/Z^3) */
FIO_SFUNC void fio___p384_point_to_affine(
    fio___p384_point_affine_s *a,
    const fio___p384_point_jacobian_s *j) {
  if (fio___p384_point_is_infinity(j)) {
    fio___p384_fe_zero(a->x);
    fio___p384_fe_zero(a->y);
    return;
  }

  fio___p384_fe_s z_inv, z_inv2, z_inv3;

  fio___p384_fe_inv(z_inv, j->z);
  fio___p384_fe_sqr(z_inv2, z_inv);
  fio___p384_fe_mul(z_inv3, z_inv2, z_inv);

  fio___p384_fe_mul(a->x, j->x, z_inv2);
  fio___p384_fe_mul(a->y, j->y, z_inv3);
}

/**
 * Point doubling in Jacobian coordinates.
 * Uses the formula from "Guide to Elliptic Curve Cryptography" (Hankerson et
 * al.)
 *
 * For P-384 where a = -3:
 * lambda = 3(X - Z^2)(X + Z^2)
 * X' = lambda^2 - 2S where S = 4XY^2
 * Y' = lambda(S - X') - 8Y^4
 * Z' = 2YZ
 */
FIO_SFUNC void fio___p384_point_double(fio___p384_point_jacobian_s *r,
                                       const fio___p384_point_jacobian_s *p) {
  if (fio___p384_point_is_infinity(p)) {
    fio___p384_point_set_infinity(r);
    return;
  }

  fio___p384_fe_s t1, t2, t3, t4, t5, yz;

  /* Save Y*Z early to handle aliasing (r == p) */
  fio___p384_fe_mul(yz, p->y, p->z);

  /* t1 = Z^2 */
  fio___p384_fe_sqr(t1, p->z);

  /* t2 = X - Z^2 */
  fio___p384_fe_sub(t2, p->x, t1);

  /* t3 = X + Z^2 */
  fio___p384_fe_add(t3, p->x, t1);

  /* t2 = (X - Z^2)(X + Z^2) = X^2 - Z^4 */
  fio___p384_fe_mul(t2, t2, t3);

  /* t2 = 3(X^2 - Z^4) = lambda (since a = -3, this equals 3X^2 + aZ^4) */
  fio___p384_fe_add(t3, t2, t2);
  fio___p384_fe_add(t2, t3, t2);

  /* t4 = Y^2 */
  fio___p384_fe_sqr(t4, p->y);

  /* t5 = XY^2 */
  fio___p384_fe_mul(t5, p->x, t4);

  /* t5 = 4XY^2 = S */
  fio___p384_fe_add(t5, t5, t5);
  fio___p384_fe_add(t5, t5, t5);

  /* t3 = lambda^2 */
  fio___p384_fe_sqr(t3, t2);

  /* X' = lambda^2 - 2S */
  fio___p384_fe_sub(r->x, t3, t5);
  fio___p384_fe_sub(r->x, r->x, t5);

  /* t4 = Y^4 */
  fio___p384_fe_sqr(t4, t4);

  /* t4 = 8Y^4 */
  fio___p384_fe_add(t4, t4, t4);
  fio___p384_fe_add(t4, t4, t4);
  fio___p384_fe_add(t4, t4, t4);

  /* t5 = S - X' */
  fio___p384_fe_sub(t5, t5, r->x);

  /* Y' = lambda(S - X') - 8Y^4 */
  fio___p384_fe_mul(r->y, t2, t5);
  fio___p384_fe_sub(r->y, r->y, t4);

  /* Z' = 2YZ (using pre-computed value to handle aliasing) */
  fio___p384_fe_add(r->z, yz, yz);
}

/**
 * Point addition in Jacobian coordinates.
 * r = p + q where p is Jacobian and q is affine.
 *
 * Mixed addition is faster than full Jacobian addition.
 */
FIO_SFUNC void fio___p384_point_add_mixed(fio___p384_point_jacobian_s *r,
                                          const fio___p384_point_jacobian_s *p,
                                          const fio___p384_point_affine_s *q) {
  if (fio___p384_point_is_infinity(p)) {
    fio___p384_point_to_jacobian(r, q);
    return;
  }

  fio___p384_fe_s t1, t2, t3, t4, t5, t6;

  /* t1 = Z1^2 */
  fio___p384_fe_sqr(t1, p->z);

  /* t2 = Z1^3 */
  fio___p384_fe_mul(t2, t1, p->z);

  /* t3 = X2*Z1^2 */
  fio___p384_fe_mul(t3, q->x, t1);

  /* t4 = Y2*Z1^3 */
  fio___p384_fe_mul(t4, q->y, t2);

  /* t3 = X2*Z1^2 - X1 = H */
  fio___p384_fe_sub(t3, t3, p->x);

  /* t4 = Y2*Z1^3 - Y1 = R */
  fio___p384_fe_sub(t4, t4, p->y);

  /* Check if points are equal or opposite */
  if (fio___p384_fe_is_zero(t3)) {
    if (fio___p384_fe_is_zero(t4)) {
      /* Points are equal - double */
      fio___p384_point_double(r, p);
      return;
    } else {
      /* Points are opposite - result is infinity */
      fio___p384_point_set_infinity(r);
      return;
    }
  }

  /* t5 = H^2 */
  fio___p384_fe_sqr(t5, t3);

  /* t6 = H^3 */
  fio___p384_fe_mul(t6, t5, t3);

  /* t1 = X1*H^2 */
  fio___p384_fe_mul(t1, p->x, t5);

  /* t2 = Y1*H^3 (compute early to handle r == p aliasing) */
  fio___p384_fe_mul(t2, p->y, t6);

  /* Z3 = Z1*H (compute early to handle r == p aliasing) */
  fio___p384_fe_mul(r->z, p->z, t3);

  /* X3 = R^2 - H^3 - 2*X1*H^2 */
  fio___p384_fe_sqr(r->x, t4);
  fio___p384_fe_sub(r->x, r->x, t6);
  fio___p384_fe_sub(r->x, r->x, t1);
  fio___p384_fe_sub(r->x, r->x, t1);

  /* t1 = X1*H^2 - X3 */
  fio___p384_fe_sub(t1, t1, r->x);

  /* Y3 = R(X1*H^2 - X3) - Y1*H^3 */
  fio___p384_fe_mul(r->y, t4, t1);
  fio___p384_fe_sub(r->y, r->y, t2);
}

/**
 * Scalar multiplication: r = k * P
 * Uses double-and-add algorithm (not constant-time for simplicity).
 * For production use, implement constant-time scalar multiplication.
 */
FIO_SFUNC void fio___p384_point_mul(fio___p384_point_jacobian_s *r,
                                    const fio___p384_scalar_s k,
                                    const fio___p384_point_affine_s *p) {
  fio___p384_point_set_infinity(r);

  /* Find the highest set bit */
  int start_bit = 383;
  while (start_bit >= 0) {
    int limb = start_bit / 64;
    int bit = start_bit % 64;
    if (k[limb] & (1ULL << bit))
      break;
    --start_bit;
  }

  if (start_bit < 0)
    return; /* k = 0 */

  /* Double-and-add from MSB to LSB */
  for (int i = start_bit; i >= 0; --i) {
    fio___p384_point_double(r, r);

    int limb = i / 64;
    int bit = i % 64;
    if (k[limb] & (1ULL << bit)) {
      fio___p384_point_add_mixed(r, r, p);
    }
  }
}

/**
 * Double scalar multiplication: r = u1*G + u2*Q
 * Uses Shamir's trick for efficiency.
 */
FIO_SFUNC void fio___p384_point_mul2(fio___p384_point_jacobian_s *r,
                                     const fio___p384_scalar_s u1,
                                     const fio___p384_scalar_s u2,
                                     const fio___p384_point_affine_s *q) {
  /* Base point G */
  fio___p384_point_affine_s g;
  fio___p384_fe_copy(g.x, FIO___P384_GX);
  fio___p384_fe_copy(g.y, FIO___P384_GY);

  /* Precompute G + Q */
  fio___p384_point_jacobian_s gpq;
  fio___p384_point_to_jacobian(&gpq, &g);
  fio___p384_point_add_mixed(&gpq, &gpq, q);
  fio___p384_point_affine_s gpq_affine;
  fio___p384_point_to_affine(&gpq_affine, &gpq);

  fio___p384_point_set_infinity(r);

  /* Find highest set bit in either scalar */
  int start_bit = 383;
  while (start_bit >= 0) {
    int limb = start_bit / 64;
    int bit = start_bit % 64;
    if ((u1[limb] & (1ULL << bit)) || (u2[limb] & (1ULL << bit)))
      break;
    --start_bit;
  }

  if (start_bit < 0)
    return;

  /* Shamir's trick: process both scalars simultaneously */
  for (int i = start_bit; i >= 0; --i) {
    fio___p384_point_double(r, r);

    int limb = i / 64;
    int bit = i % 64;
    int b1 = (u1[limb] >> bit) & 1;
    int b2 = (u2[limb] >> bit) & 1;

    if (b1 && b2) {
      fio___p384_point_add_mixed(r, r, &gpq_affine);
    } else if (b1) {
      fio___p384_point_add_mixed(r, r, &g);
    } else if (b2) {
      fio___p384_point_add_mixed(r, r, q);
    }
  }
}

/* *****************************************************************************
DER Signature Parsing
***************************************************************************** */

/**
 * Parse DER-encoded ECDSA signature for P-384.
 * Format: SEQUENCE { r INTEGER, s INTEGER }
 *
 * Returns 0 on success, -1 on error.
 */
FIO_SFUNC int fio___p384_parse_der_signature(uint8_t r[48],
                                             uint8_t s[48],
                                             const uint8_t *sig,
                                             size_t sig_len) {
  if (!sig || sig_len < 8)
    return -1;

  const uint8_t *p = sig;
  const uint8_t *end = sig + sig_len;

  /* SEQUENCE tag */
  if (*p++ != 0x30)
    return -1;

  /* SEQUENCE length */
  size_t seq_len;
  if (*p & 0x80) {
    /* Long form length */
    int len_bytes = *p++ & 0x7F;
    if (len_bytes > 2 || p + len_bytes > end)
      return -1;
    seq_len = 0;
    for (int i = 0; i < len_bytes; ++i)
      seq_len = (seq_len << 8) | *p++;
  } else {
    seq_len = *p++;
  }

  if (p + seq_len > end)
    return -1;

  /* Parse r INTEGER */
  if (*p++ != 0x02)
    return -1;

  size_t r_len = *p++;
  if (p + r_len > end || r_len > 49)
    return -1;

  /* Skip leading zero if present (positive integer encoding) */
  const uint8_t *r_data = p;
  if (r_len > 0 && *r_data == 0x00) {
    r_data++;
    r_len--;
  }
  p += (r_len + (r_data != p ? 1 : 0));

  /* Copy r, right-aligned in 48 bytes */
  FIO_MEMSET(r, 0, 48);
  if (r_len > 48)
    return -1;
  FIO_MEMCPY(r + (48 - r_len), r_data, r_len);

  /* Parse s INTEGER */
  if (*p++ != 0x02)
    return -1;

  size_t s_len = *p++;
  if (p + s_len > end || s_len > 49)
    return -1;

  /* Skip leading zero if present */
  const uint8_t *s_data = p;
  if (s_len > 0 && *s_data == 0x00) {
    s_data++;
    s_len--;
  }

  /* Copy s, right-aligned in 48 bytes */
  FIO_MEMSET(s, 0, 48);
  if (s_len > 48)
    return -1;
  FIO_MEMCPY(s + (48 - s_len), s_data, s_len);

  return 0;
}

/* *****************************************************************************
ECDSA Verification
***************************************************************************** */

SFUNC int fio_ecdsa_p384_verify_raw(const uint8_t r_bytes[48],
                                    const uint8_t s_bytes[48],
                                    const uint8_t msg_hash[48],
                                    const uint8_t pubkey_x[48],
                                    const uint8_t pubkey_y[48]) {
  fio___p384_scalar_s r, s, e;
  fio___p384_point_affine_s q;

  /* Load signature components */
  fio___p384_scalar_from_bytes(r, r_bytes);
  fio___p384_scalar_from_bytes(s, s_bytes);

  /* Verify r, s are in [1, n-1] */
  if (fio___p384_scalar_is_zero(r) || fio___p384_scalar_gte_n(r))
    return -1;
  if (fio___p384_scalar_is_zero(s) || fio___p384_scalar_gte_n(s))
    return -1;

  /* Load message hash as scalar e */
  fio___p384_scalar_from_bytes(e, msg_hash);

  /* Reduce e mod n if needed */
  if (fio___p384_scalar_gte_n(e)) {
    uint64_t borrow = 0;
    e[0] = fio_math_subc64(e[0], FIO___P384_N[0], 0, &borrow);
    e[1] = fio_math_subc64(e[1], FIO___P384_N[1], borrow, &borrow);
    e[2] = fio_math_subc64(e[2], FIO___P384_N[2], borrow, &borrow);
    e[3] = fio_math_subc64(e[3], FIO___P384_N[3], borrow, &borrow);
    e[4] = fio_math_subc64(e[4], FIO___P384_N[4], borrow, &borrow);
    e[5] = fio_math_subc64(e[5], FIO___P384_N[5], borrow, &borrow);
  }

  /* Load public key point Q */
  fio___p384_fe_from_bytes(q.x, pubkey_x);
  fio___p384_fe_from_bytes(q.y, pubkey_y);

  /* Verify Q is on the curve: y^2 = x^3 - 3x + b (mod p) */
  {
    fio___p384_fe_s y2, x3, t;

    /* y^2 */
    fio___p384_fe_sqr(y2, q.y);

    /* x^3 */
    fio___p384_fe_sqr(t, q.x);
    fio___p384_fe_mul(x3, t, q.x);

    /* x^3 - 3x */
    fio___p384_fe_sub(t, x3, q.x);
    fio___p384_fe_sub(t, t, q.x);
    fio___p384_fe_sub(t, t, q.x);

    /* x^3 - 3x + b */
    fio___p384_fe_add(t, t, FIO___P384_B);

    /* Check y^2 == x^3 - 3x + b */
    if (fio___p384_fe_eq(y2, t) != 0)
      return -1;
  }

  /* Compute w = s^(-1) mod n */
  fio___p384_scalar_s w;
  fio___p384_scalar_inv(w, s);

  /* Compute u1 = e * w mod n */
  fio___p384_scalar_s u1;
  fio___p384_scalar_mul(u1, e, w);

  /* Compute u2 = r * w mod n */
  fio___p384_scalar_s u2;
  fio___p384_scalar_mul(u2, r, w);

  /* Compute R = u1*G + u2*Q */
  fio___p384_point_jacobian_s R_jac;
  fio___p384_point_mul2(&R_jac, u1, u2, &q);

  /* If R is infinity, reject */
  if (fio___p384_point_is_infinity(&R_jac))
    return -1;

  /* Convert R to affine */
  fio___p384_point_affine_s R_aff;
  fio___p384_point_to_affine(&R_aff, &R_jac);

  /* Get R.x as bytes */
  uint8_t rx_bytes[48];
  fio___p384_fe_to_bytes(rx_bytes, R_aff.x);

  /* Load R.x as scalar and reduce mod n */
  fio___p384_scalar_s rx;
  fio___p384_scalar_from_bytes(rx, rx_bytes);
  while (fio___p384_scalar_gte_n(rx)) {
    uint64_t borrow = 0;
    rx[0] = fio_math_subc64(rx[0], FIO___P384_N[0], 0, &borrow);
    rx[1] = fio_math_subc64(rx[1], FIO___P384_N[1], borrow, &borrow);
    rx[2] = fio_math_subc64(rx[2], FIO___P384_N[2], borrow, &borrow);
    rx[3] = fio_math_subc64(rx[3], FIO___P384_N[3], borrow, &borrow);
    rx[4] = fio_math_subc64(rx[4], FIO___P384_N[4], borrow, &borrow);
    rx[5] = fio_math_subc64(rx[5], FIO___P384_N[5], borrow, &borrow);
  }

  /* Verify r == R.x mod n */
  if (r[0] != rx[0] || r[1] != rx[1] || r[2] != rx[2] || r[3] != rx[3] ||
      r[4] != rx[4] || r[5] != rx[5])
    return -1;

  return 0;
}

SFUNC int fio_ecdsa_p384_verify(const uint8_t *sig,
                                size_t sig_len,
                                const uint8_t *msg_hash,
                                const uint8_t *pubkey,
                                size_t pubkey_len) {
  if (!sig || !msg_hash || !pubkey)
    return -1;

  /* Uncompressed public key format: 0x04 || x (48 bytes) || y (48 bytes) */
  if (pubkey_len != 97 || pubkey[0] != 0x04)
    return -1;

  /* Parse DER signature */
  uint8_t r[48], s[48];
  if (fio___p384_parse_der_signature(r, s, sig, sig_len) != 0)
    return -1;

  /* Verify */
  return fio_ecdsa_p384_verify_raw(r, s, msg_hash, pubkey + 1, pubkey + 49);
}

/* *****************************************************************************
Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_P384
#endif /* FIO_P384 */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_ASN1               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                          ASN.1 DER Parser for X.509
                        (RFC 5280 Certificate Parsing)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_ASN1) && !defined(H___FIO_ASN1___H)
#define H___FIO_ASN1___H

/* *****************************************************************************
ASN.1 Tag Types (Universal Class)
***************************************************************************** */

/** ASN.1 Universal Tag Types */
typedef enum {
  FIO_ASN1_EOC = 0x00,               /**< End-of-contents */
  FIO_ASN1_BOOLEAN = 0x01,           /**< Boolean */
  FIO_ASN1_INTEGER = 0x02,           /**< Integer */
  FIO_ASN1_BIT_STRING = 0x03,        /**< Bit String */
  FIO_ASN1_OCTET_STRING = 0x04,      /**< Octet String */
  FIO_ASN1_NULL = 0x05,              /**< Null */
  FIO_ASN1_OID = 0x06,               /**< Object Identifier */
  FIO_ASN1_OBJECT_DESCRIPTOR = 0x07, /**< Object Descriptor */
  FIO_ASN1_EXTERNAL = 0x08,          /**< External */
  FIO_ASN1_REAL = 0x09,              /**< Real (float) */
  FIO_ASN1_ENUMERATED = 0x0A,        /**< Enumerated */
  FIO_ASN1_EMBEDDED_PDV = 0x0B,      /**< Embedded PDV */
  FIO_ASN1_UTF8_STRING = 0x0C,       /**< UTF-8 String */
  FIO_ASN1_RELATIVE_OID = 0x0D,      /**< Relative OID */
  FIO_ASN1_SEQUENCE = 0x10,         /**< Sequence (0x30 with constructed bit) */
  FIO_ASN1_SET = 0x11,              /**< Set (0x31 with constructed bit) */
  FIO_ASN1_NUMERIC_STRING = 0x12,   /**< Numeric String */
  FIO_ASN1_PRINTABLE_STRING = 0x13, /**< Printable String */
  FIO_ASN1_T61_STRING = 0x14,       /**< T61 String (Teletex) */
  FIO_ASN1_VIDEOTEX_STRING = 0x15,  /**< Videotex String */
  FIO_ASN1_IA5_STRING = 0x16,       /**< IA5 String (ASCII) */
  FIO_ASN1_UTC_TIME = 0x17,         /**< UTC Time */
  FIO_ASN1_GENERALIZED_TIME = 0x18, /**< Generalized Time */
  FIO_ASN1_GRAPHIC_STRING = 0x19,   /**< Graphic String */
  FIO_ASN1_VISIBLE_STRING = 0x1A,   /**< Visible String */
  FIO_ASN1_GENERAL_STRING = 0x1B,   /**< General String */
  FIO_ASN1_UNIVERSAL_STRING = 0x1C, /**< Universal String */
  FIO_ASN1_BMP_STRING = 0x1E,       /**< BMP String (UCS-2) */
  /* Context-specific tags (0x80 | tag_number) with constructed bit (0x20) */
  FIO_ASN1_CONTEXT_0 = 0xA0, /**< [0] EXPLICIT/IMPLICIT */
  FIO_ASN1_CONTEXT_1 = 0xA1, /**< [1] EXPLICIT/IMPLICIT */
  FIO_ASN1_CONTEXT_2 = 0xA2, /**< [2] EXPLICIT/IMPLICIT */
  FIO_ASN1_CONTEXT_3 = 0xA3, /**< [3] EXPLICIT/IMPLICIT */
} fio_asn1_tag_e;

/** ASN.1 Tag Class (bits 7-6 of tag byte) */
typedef enum {
  FIO_ASN1_CLASS_UNIVERSAL = 0,   /**< Universal (built-in types) */
  FIO_ASN1_CLASS_APPLICATION = 1, /**< Application-specific */
  FIO_ASN1_CLASS_CONTEXT = 2,     /**< Context-specific */
  FIO_ASN1_CLASS_PRIVATE = 3,     /**< Private */
} fio_asn1_class_e;

/* *****************************************************************************
Common OID Constants for X.509 and TLS
***************************************************************************** */

/* Signature Algorithms */
#define FIO_OID_SHA256_WITH_RSA   "1.2.840.113549.1.1.11"
#define FIO_OID_SHA384_WITH_RSA   "1.2.840.113549.1.1.12"
#define FIO_OID_SHA512_WITH_RSA   "1.2.840.113549.1.1.13"
#define FIO_OID_RSA_PSS           "1.2.840.113549.1.1.10"
#define FIO_OID_ECDSA_WITH_SHA256 "1.2.840.10045.4.3.2"
#define FIO_OID_ECDSA_WITH_SHA384 "1.2.840.10045.4.3.3"
#define FIO_OID_ECDSA_WITH_SHA512 "1.2.840.10045.4.3.4"
#define FIO_OID_ED25519           "1.3.101.112"
#define FIO_OID_ED448             "1.3.101.113"

/* Public Key Algorithms */
#define FIO_OID_RSA_ENCRYPTION "1.2.840.113549.1.1.1"
#define FIO_OID_EC_PUBLIC_KEY  "1.2.840.10045.2.1"

/* Elliptic Curves */
#define FIO_OID_SECP256R1 "1.2.840.10045.3.1.7"
#define FIO_OID_SECP384R1 "1.3.132.0.34"
#define FIO_OID_SECP521R1 "1.3.132.0.35"
#define FIO_OID_X25519    "1.3.101.110"
#define FIO_OID_X448      "1.3.101.111"

/* X.509 Extensions */
#define FIO_OID_SUBJECT_KEY_ID    "2.5.29.14"
#define FIO_OID_KEY_USAGE         "2.5.29.15"
#define FIO_OID_SUBJECT_ALT_NAME  "2.5.29.17"
#define FIO_OID_BASIC_CONSTRAINTS "2.5.29.19"
#define FIO_OID_CRL_DIST_POINTS   "2.5.29.31"
#define FIO_OID_CERT_POLICIES     "2.5.29.32"
#define FIO_OID_AUTH_KEY_ID       "2.5.29.35"
#define FIO_OID_EXT_KEY_USAGE     "2.5.29.37"

/* Extended Key Usage OIDs (RFC 5280 Section 4.2.1.12) */
#define FIO_OID_EKU_SERVER_AUTH "1.3.6.1.5.5.7.3.1"
#define FIO_OID_EKU_CLIENT_AUTH "1.3.6.1.5.5.7.3.2"

/* X.509 Distinguished Name Attributes */
#define FIO_OID_COMMON_NAME  "2.5.4.3"
#define FIO_OID_COUNTRY      "2.5.4.6"
#define FIO_OID_LOCALITY     "2.5.4.7"
#define FIO_OID_STATE        "2.5.4.8"
#define FIO_OID_ORGANIZATION "2.5.4.10"
#define FIO_OID_ORG_UNIT     "2.5.4.11"

/* *****************************************************************************
ASN.1 Parsed Element Structure
***************************************************************************** */

/** Parsed ASN.1 DER element */
typedef struct {
  const uint8_t *data;    /**< Pointer to element content (after tag+length) */
  size_t len;             /**< Length of content */
  uint8_t tag;            /**< Raw tag byte */
  uint8_t is_constructed; /**< 1 if constructed (contains other elements) */
  uint8_t tag_class;  /**< 0=Universal, 1=Application, 2=Context, 3=Private */
  uint8_t tag_number; /**< Tag number (bits 4-0, or extended) */
} fio_asn1_element_s;

/** Iterator for SEQUENCE or SET contents */
typedef struct {
  const uint8_t *pos; /**< Current position */
  const uint8_t *end; /**< End of sequence */
} fio_asn1_iterator_s;

/* *****************************************************************************
ASN.1 Parser API - Core Functions
***************************************************************************** */

/**
 * Parse one ASN.1 element from DER-encoded data.
 *
 * @param elem Output structure to fill with parsed element info
 * @param data Pointer to DER-encoded data
 * @param data_len Length of data buffer
 * @return Pointer to next element (after this one), or NULL on error
 */
SFUNC const uint8_t *fio_asn1_parse(fio_asn1_element_s *elem,
                                    const uint8_t *data,
                                    size_t data_len);

/**
 * Get the total encoded length of an ASN.1 element (tag + length + content).
 *
 * @param elem Parsed element
 * @param data Original data pointer where element was parsed from
 * @return Total bytes used by the element encoding
 */
FIO_IFUNC size_t fio_asn1_element_total_len(const fio_asn1_element_s *elem,
                                            const uint8_t *data);

/* *****************************************************************************
ASN.1 Parser API - Type-Specific Parsers
***************************************************************************** */

/**
 * Parse an ASN.1 INTEGER element.
 *
 * For small integers (<= 64-bit), sets *value.
 * For large integers (RSA modulus), use elem->data/len directly.
 * Leading zero bytes for positive numbers are handled correctly.
 *
 * @param elem Parsed element (must be INTEGER type)
 * @param value Output for integer value (can be NULL for large integers)
 * @return 0 on success, -1 on error
 */
SFUNC int fio_asn1_parse_integer(const fio_asn1_element_s *elem,
                                 uint64_t *value);

/**
 * Parse an ASN.1 BIT STRING element.
 *
 * @param elem Parsed element (must be BIT STRING type)
 * @param bits Output pointer to bit data (first byte is unused bits count)
 * @param bit_len Output length of bit data in bytes
 * @param unused_bits Output number of unused bits in last byte (0-7)
 * @return 0 on success, -1 on error
 */
SFUNC int fio_asn1_parse_bit_string(const fio_asn1_element_s *elem,
                                    const uint8_t **bits,
                                    size_t *bit_len,
                                    uint8_t *unused_bits);

/**
 * Parse an ASN.1 OID into a dot-separated string.
 *
 * Example output: "1.2.840.113549.1.1.11"
 *
 * @param elem Parsed element (must be OID type)
 * @param buf Output buffer for string
 * @param buf_len Buffer size
 * @return Number of chars written (excluding NUL), or -1 on error
 */
SFUNC int fio_asn1_parse_oid(const fio_asn1_element_s *elem,
                             char *buf,
                             size_t buf_len);

/**
 * Compare an ASN.1 OID element to a known OID string.
 *
 * @param elem Parsed element (must be OID type)
 * @param oid_string OID in dot notation (e.g., "1.2.840.113549.1.1.11")
 * @return 1 if match, 0 if no match
 */
SFUNC int fio_asn1_oid_eq(const fio_asn1_element_s *elem,
                          const char *oid_string);

/**
 * Parse an ASN.1 time (UTC Time or Generalized Time) to Unix timestamp.
 *
 * @param elem Parsed element (must be UTC_TIME or GENERALIZED_TIME type)
 * @param unix_time Output Unix timestamp (seconds since 1970-01-01 00:00:00
 * UTC)
 * @return 0 on success, -1 on error
 */
SFUNC int fio_asn1_parse_time(const fio_asn1_element_s *elem,
                              int64_t *unix_time);

/**
 * Parse an ASN.1 string element.
 *
 * Supports UTF8String, PrintableString, IA5String, etc.
 * Returns pointer directly into the element data (no copy).
 *
 * @param elem Parsed element (must be a string type)
 * @param len Output length of string
 * @return Pointer to string data, or NULL on error
 */
FIO_IFUNC const char *fio_asn1_parse_string(const fio_asn1_element_s *elem,
                                            size_t *len);

/**
 * Parse an ASN.1 BOOLEAN element.
 *
 * @param elem Parsed element (must be BOOLEAN type)
 * @param value Output boolean value (0 = false, non-zero = true)
 * @return 0 on success, -1 on error
 */
FIO_IFUNC int fio_asn1_parse_boolean(const fio_asn1_element_s *elem,
                                     int *value);

/* *****************************************************************************
ASN.1 Parser API - Sequence/Set Iteration
***************************************************************************** */

/**
 * Initialize an iterator for a SEQUENCE or SET element.
 *
 * @param it Iterator to initialize
 * @param sequence Parsed element (must be SEQUENCE or SET)
 */
FIO_IFUNC void fio_asn1_iterator_init(fio_asn1_iterator_s *it,
                                      const fio_asn1_element_s *sequence);

/**
 * Get the next element from an iterator.
 *
 * @param it Iterator (updated to point to next element)
 * @param elem Output for parsed element
 * @return 0 if element available, -1 if end or error
 */
SFUNC int fio_asn1_iterator_next(fio_asn1_iterator_s *it,
                                 fio_asn1_element_s *elem);

/**
 * Check if iterator has more elements.
 *
 * @param it Iterator
 * @return 1 if more elements available, 0 otherwise
 */
FIO_IFUNC int fio_asn1_iterator_has_next(const fio_asn1_iterator_s *it);

/* *****************************************************************************
ASN.1 Parser API - Helper Functions
***************************************************************************** */

/**
 * Check if an element is a specific tag type.
 *
 * @param elem Parsed element
 * @param tag Expected tag (e.g., FIO_ASN1_INTEGER)
 * @return 1 if match, 0 otherwise
 */
FIO_IFUNC int fio_asn1_is_tag(const fio_asn1_element_s *elem, uint8_t tag);

/**
 * Check if an element is a context-specific tag.
 *
 * @param elem Parsed element
 * @param tag_num Context tag number (0-31)
 * @return 1 if match, 0 otherwise
 */
FIO_IFUNC int fio_asn1_is_context_tag(const fio_asn1_element_s *elem,
                                      uint8_t tag_num);

/**
 * Get the tag number from an element.
 *
 * For universal tags, returns the tag value (0-30).
 * For context-specific tags, returns the context number.
 *
 * @param elem Parsed element
 * @return Tag number
 */
FIO_IFUNC uint8_t fio_asn1_tag_number(const fio_asn1_element_s *elem);

/* *****************************************************************************
Implementation - Inline Functions
***************************************************************************** */

/** Get total encoded length of element */
FIO_IFUNC size_t fio_asn1_element_total_len(const fio_asn1_element_s *elem,
                                            const uint8_t *data) {
  if (!elem || !data || !elem->data)
    return 0;
  return (size_t)(elem->data - data) + elem->len;
}

/** Parse string types - returns pointer to data */
FIO_IFUNC const char *fio_asn1_parse_string(const fio_asn1_element_s *elem,
                                            size_t *len) {
  if (!elem || !len)
    return NULL;
  /* Accept various string types */
  uint8_t tag_num = elem->tag & 0x1F;
  if (elem->tag_class != FIO_ASN1_CLASS_UNIVERSAL)
    return NULL;
  switch (tag_num) {
  case FIO_ASN1_UTF8_STRING:
  case FIO_ASN1_PRINTABLE_STRING:
  case FIO_ASN1_IA5_STRING:
  case FIO_ASN1_T61_STRING:
  case FIO_ASN1_VISIBLE_STRING:
  case FIO_ASN1_GENERAL_STRING:
  case FIO_ASN1_UNIVERSAL_STRING:
  case FIO_ASN1_BMP_STRING:
  case FIO_ASN1_NUMERIC_STRING:
    *len = elem->len;
    return (const char *)elem->data;
  default: return NULL;
  }
}

/** Parse boolean value */
FIO_IFUNC int fio_asn1_parse_boolean(const fio_asn1_element_s *elem,
                                     int *value) {
  if (!elem || !value)
    return -1;
  if ((elem->tag & 0x1F) != FIO_ASN1_BOOLEAN ||
      elem->tag_class != FIO_ASN1_CLASS_UNIVERSAL)
    return -1;
  if (elem->len != 1)
    return -1;
  *value = (elem->data[0] != 0);
  return 0;
}

/** Initialize iterator for sequence/set */
FIO_IFUNC void fio_asn1_iterator_init(fio_asn1_iterator_s *it,
                                      const fio_asn1_element_s *sequence) {
  if (!it)
    return;
  if (!sequence || !sequence->data) {
    it->pos = NULL;
    it->end = NULL;
    return;
  }
  it->pos = sequence->data;
  it->end = sequence->data + sequence->len;
}

/** Check if iterator has more elements */
FIO_IFUNC int fio_asn1_iterator_has_next(const fio_asn1_iterator_s *it) {
  return (it && it->pos && it->end && it->pos < it->end);
}

/** Check if element matches tag */
FIO_IFUNC int fio_asn1_is_tag(const fio_asn1_element_s *elem, uint8_t tag) {
  if (!elem)
    return 0;
  /* For universal tags, compare the tag number */
  if (elem->tag_class == FIO_ASN1_CLASS_UNIVERSAL)
    return (elem->tag & 0x1F) == (tag & 0x1F);
  /* For other classes, compare full tag byte */
  return elem->tag == tag;
}

/** Check if element is context-specific tag */
FIO_IFUNC int fio_asn1_is_context_tag(const fio_asn1_element_s *elem,
                                      uint8_t tag_num) {
  if (!elem)
    return 0;
  return (elem->tag_class == FIO_ASN1_CLASS_CONTEXT) &&
         ((elem->tag & 0x1F) == (tag_num & 0x1F));
}

/** Get tag number from element */
FIO_IFUNC uint8_t fio_asn1_tag_number(const fio_asn1_element_s *elem) {
  if (!elem)
    return 0;
  return elem->tag & 0x1F;
}

/* *****************************************************************************
Implementation - Possibly Externed Functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Implementation - Core Parser
***************************************************************************** */

/**
 * Parse DER length field.
 * Returns pointer past length field, or NULL on error.
 * Sets *out_len to the parsed length value.
 */
FIO_SFUNC const uint8_t *fio___asn1_parse_length(const uint8_t *data,
                                                 const uint8_t *end,
                                                 size_t *out_len) {
  if (!data || !end || !out_len || data >= end)
    return NULL;

  uint8_t first = *data++;

  /* Short form: 0x00-0x7F = length directly */
  if (!(first & 0x80)) {
    *out_len = first;
    return data;
  }

  /* Long form: first byte & 0x7F = number of length bytes */
  size_t num_bytes = first & 0x7F;

  /* Indefinite length (0x80) not allowed in DER */
  if (num_bytes == 0)
    return NULL;

  /* Too many length bytes (protect against overflow) */
  if (num_bytes > sizeof(size_t) || (size_t)(end - data) < num_bytes)
    return NULL;

  size_t len = 0;
  for (size_t i = 0; i < num_bytes; ++i) {
    /* Check for overflow before shifting */
    if (len > (SIZE_MAX >> 8))
      return NULL;
    len = (len << 8) | *data++;
  }

  *out_len = len;
  return data;
}

/** Parse one ASN.1 element from DER data */
SFUNC const uint8_t *fio_asn1_parse(fio_asn1_element_s *elem,
                                    const uint8_t *data,
                                    size_t data_len) {
  if (!elem || !data || data_len == 0)
    return NULL;

  const uint8_t *end = data + data_len;
  const uint8_t *p = data;

  /* Parse tag byte */
  if (p >= end)
    return NULL;

  uint8_t tag = *p++;
  elem->tag = tag;
  elem->tag_class = (tag >> 6) & 0x03;
  elem->is_constructed = (tag >> 5) & 0x01;
  elem->tag_number = tag & 0x1F;

  /* Handle long-form tags (tag number >= 31) */
  if (elem->tag_number == 0x1F) {
    /* Multi-byte tag number - accumulate until high bit clear */
    uint32_t tag_num = 0;
    while (p < end) {
      uint8_t b = *p++;
      if (tag_num > (0xFFFFFFFF >> 7))
        return NULL; /* Overflow */
      tag_num = (tag_num << 7) | (b & 0x7F);
      if (!(b & 0x80))
        break;
    }
    /* Store as much as fits in tag_number (used for context tags mainly) */
    elem->tag_number = (uint8_t)(tag_num & 0xFF);
  }

  /* Parse length */
  size_t content_len;
  p = fio___asn1_parse_length(p, end, &content_len);
  if (!p)
    return NULL;

  /* Validate content fits in remaining data */
  if ((size_t)(end - p) < content_len)
    return NULL;

  elem->data = p;
  elem->len = content_len;

  return p + content_len;
}

/* *****************************************************************************
Implementation - Integer Parser
***************************************************************************** */

SFUNC int fio_asn1_parse_integer(const fio_asn1_element_s *elem,
                                 uint64_t *value) {
  if (!elem)
    return -1;

  /* Verify it's an INTEGER */
  if (elem->tag_class != FIO_ASN1_CLASS_UNIVERSAL ||
      (elem->tag & 0x1F) != FIO_ASN1_INTEGER)
    return -1;

  if (elem->len == 0)
    return -1;

  const uint8_t *p = elem->data;
  size_t len = elem->len;

  /* Skip leading zero byte used for positive numbers */
  if (len > 1 && p[0] == 0x00 && (p[1] & 0x80)) {
    p++;
    len--;
  }

  /* If caller wants the value and it fits in uint64_t */
  if (value) {
    if (len > 8)
      return -1; /* Too large for uint64_t */

    uint64_t v = 0;
    for (size_t i = 0; i < len; ++i)
      v = (v << 8) | p[i];
    *value = v;
  }

  return 0;
}

/* *****************************************************************************
Implementation - Bit String Parser
***************************************************************************** */

SFUNC int fio_asn1_parse_bit_string(const fio_asn1_element_s *elem,
                                    const uint8_t **bits,
                                    size_t *bit_len,
                                    uint8_t *unused_bits) {
  if (!elem || !bits || !bit_len || !unused_bits)
    return -1;

  /* Verify it's a BIT STRING */
  if (elem->tag_class != FIO_ASN1_CLASS_UNIVERSAL ||
      (elem->tag & 0x1F) != FIO_ASN1_BIT_STRING)
    return -1;

  if (elem->len < 1)
    return -1;

  /* First byte is unused bits count (0-7) */
  uint8_t unused = elem->data[0];
  if (unused > 7)
    return -1;

  /* Empty bit string */
  if (elem->len == 1) {
    if (unused != 0)
      return -1;
    *bits = NULL;
    *bit_len = 0;
    *unused_bits = 0;
    return 0;
  }

  *bits = elem->data + 1;
  *bit_len = elem->len - 1;
  *unused_bits = unused;
  return 0;
}

/* *****************************************************************************
Implementation - OID Parser
***************************************************************************** */

/** Parse OID component from base-128 encoding */
FIO_SFUNC const uint8_t *fio___asn1_parse_oid_component(const uint8_t *p,
                                                        const uint8_t *end,
                                                        uint64_t *value) {
  uint64_t v = 0;
  size_t count = 0;

  while (p < end) {
    uint8_t b = *p++;
    /* Protect against overflow - OID components shouldn't be this large */
    if (count++ > 9)
      return NULL;
    v = (v << 7) | (b & 0x7F);
    if (!(b & 0x80)) {
      *value = v;
      return p;
    }
  }
  return NULL; /* Incomplete encoding */
}

/** Write unsigned integer to string */
FIO_SFUNC int fio___asn1_write_uint(char *buf, size_t buf_len, uint64_t value) {
  if (!buf || buf_len == 0)
    return -1;

  /* Count digits */
  char tmp[24];
  int len = 0;
  uint64_t v = value;
  do {
    tmp[len++] = '0' + (char)(v % 10);
    v /= 10;
  } while (v > 0);

  if ((size_t)len >= buf_len)
    return -1;

  /* Reverse into output buffer */
  for (int i = 0; i < len; ++i)
    buf[i] = tmp[len - 1 - i];
  buf[len] = '\0';

  return len;
}

SFUNC int fio_asn1_parse_oid(const fio_asn1_element_s *elem,
                             char *buf,
                             size_t buf_len) {
  if (!elem || !buf || buf_len < 4)
    return -1;

  /* Verify it's an OID */
  if (elem->tag_class != FIO_ASN1_CLASS_UNIVERSAL ||
      (elem->tag & 0x1F) != FIO_ASN1_OID)
    return -1;

  if (elem->len == 0)
    return -1;

  const uint8_t *p = elem->data;
  const uint8_t *end = elem->data + elem->len;

  char *out = buf;
  char *out_end = buf + buf_len - 1;
  int total = 0;

  /* First byte encodes first two components: X.Y where byte = X*40 + Y */
  uint8_t first = *p++;
  uint64_t c1 = first / 40;
  uint64_t c2 = first % 40;

  /* First component can only be 0, 1, or 2 */
  if (c1 > 2) {
    c1 = 2;
    c2 = first - 80;
  }

  int len = fio___asn1_write_uint(out, (size_t)(out_end - out), c1);
  if (len < 0)
    return -1;
  out += len;
  total += len;

  if (out >= out_end)
    return -1;
  *out++ = '.';
  total++;

  len = fio___asn1_write_uint(out, (size_t)(out_end - out), c2);
  if (len < 0)
    return -1;
  out += len;
  total += len;

  /* Remaining components */
  while (p < end) {
    uint64_t component;
    p = fio___asn1_parse_oid_component(p, end, &component);
    if (!p)
      return -1;

    if (out >= out_end)
      return -1;
    *out++ = '.';
    total++;

    len = fio___asn1_write_uint(out, (size_t)(out_end - out), component);
    if (len < 0)
      return -1;
    out += len;
    total += len;
  }

  *out = '\0';
  return total;
}

SFUNC int fio_asn1_oid_eq(const fio_asn1_element_s *elem,
                          const char *oid_string) {
  if (!elem || !oid_string)
    return 0;

  /* Parse OID to string and compare */
  char buf[128];
  int len = fio_asn1_parse_oid(elem, buf, sizeof(buf));
  if (len < 0)
    return 0;

  /* Compare strings */
  size_t oid_len = FIO_STRLEN(oid_string);
  if ((size_t)len != oid_len)
    return 0;

  return FIO_MEMCMP(buf, oid_string, oid_len) == 0;
}

/* *****************************************************************************
Implementation - Time Parser
***************************************************************************** */

/** Parse 2-digit number from string */
FIO_SFUNC int fio___asn1_parse_2digits(const char *p, int *value) {
  if (p[0] < '0' || p[0] > '9' || p[1] < '0' || p[1] > '9')
    return -1;
  *value = (p[0] - '0') * 10 + (p[1] - '0');
  return 0;
}

/** Days in each month (non-leap year) */
static const int fio___days_in_month[] =
    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

/** Check if year is leap year */
FIO_SFUNC int fio___is_leap_year(int year) {
  return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

/** Convert broken-down time to Unix timestamp */
FIO_SFUNC int64_t
fio___asn1_mktime(int year, int month, int day, int hour, int min, int sec) {
  /* Validate ranges */
  if (month < 1 || month > 12)
    return -1;
  if (day < 1 || day > 31)
    return -1;
  if (hour < 0 || hour > 23)
    return -1;
  if (min < 0 || min > 59)
    return -1;
  if (sec < 0 || sec > 60) /* Allow leap second */
    return -1;

  /* Calculate days since Unix epoch (1970-01-01) */
  int64_t days = 0;

  /* Years from 1970 to year-1 */
  for (int y = 1970; y < year; ++y)
    days += fio___is_leap_year(y) ? 366 : 365;
  for (int y = year; y < 1970; ++y)
    days -= fio___is_leap_year(y) ? 366 : 365;

  /* Months in current year */
  for (int m = 1; m < month; ++m) {
    days += fio___days_in_month[m - 1];
    if (m == 2 && fio___is_leap_year(year))
      days += 1;
  }

  /* Days in current month */
  days += day - 1;

  /* Convert to seconds */
  int64_t ts = days * 86400LL + hour * 3600LL + min * 60LL + sec;
  return ts;
}

SFUNC int fio_asn1_parse_time(const fio_asn1_element_s *elem,
                              int64_t *unix_time) {
  if (!elem || !unix_time)
    return -1;

  uint8_t tag = elem->tag & 0x1F;
  if (elem->tag_class != FIO_ASN1_CLASS_UNIVERSAL)
    return -1;

  const char *p = (const char *)elem->data;
  size_t len = elem->len;

  int year, month, day, hour, min, sec = 0;

  if (tag == FIO_ASN1_UTC_TIME) {
    /* UTCTime: YYMMDDhhmmZ or YYMMDDhhmmssZ */
    if (len != 11 && len != 13)
      return -1;

    int yy;
    if (fio___asn1_parse_2digits(p, &yy) < 0)
      return -1;
    /* RFC 5280: years 00-49 = 2000-2049, 50-99 = 1950-1999 */
    year = (yy < 50) ? 2000 + yy : 1900 + yy;
    p += 2;

    if (fio___asn1_parse_2digits(p, &month) < 0)
      return -1;
    p += 2;
    if (fio___asn1_parse_2digits(p, &day) < 0)
      return -1;
    p += 2;
    if (fio___asn1_parse_2digits(p, &hour) < 0)
      return -1;
    p += 2;
    if (fio___asn1_parse_2digits(p, &min) < 0)
      return -1;
    p += 2;

    if (len == 13) {
      if (fio___asn1_parse_2digits(p, &sec) < 0)
        return -1;
      p += 2;
    }

    if (*p != 'Z')
      return -1;
  } else if (tag == FIO_ASN1_GENERALIZED_TIME) {
    /* GeneralizedTime: YYYYMMDDhhmmssZ */
    if (len < 15)
      return -1;

    int yy1, yy2;
    if (fio___asn1_parse_2digits(p, &yy1) < 0)
      return -1;
    p += 2;
    if (fio___asn1_parse_2digits(p, &yy2) < 0)
      return -1;
    p += 2;
    year = yy1 * 100 + yy2;

    if (fio___asn1_parse_2digits(p, &month) < 0)
      return -1;
    p += 2;
    if (fio___asn1_parse_2digits(p, &day) < 0)
      return -1;
    p += 2;
    if (fio___asn1_parse_2digits(p, &hour) < 0)
      return -1;
    p += 2;
    if (fio___asn1_parse_2digits(p, &min) < 0)
      return -1;
    p += 2;
    if (fio___asn1_parse_2digits(p, &sec) < 0)
      return -1;
    p += 2;

    /* Skip optional fractional seconds */
    if (*p == '.') {
      p++;
      while (*p >= '0' && *p <= '9')
        p++;
    }

    if (*p != 'Z')
      return -1;
  } else {
    return -1;
  }

  *unix_time = fio___asn1_mktime(year, month, day, hour, min, sec);
  return (*unix_time == -1) ? -1 : 0;
}

/* *****************************************************************************
Implementation - Iterator
***************************************************************************** */

SFUNC int fio_asn1_iterator_next(fio_asn1_iterator_s *it,
                                 fio_asn1_element_s *elem) {
  if (!it || !elem || !it->pos || !it->end || it->pos >= it->end)
    return -1;

  size_t remaining = (size_t)(it->end - it->pos);
  const uint8_t *next = fio_asn1_parse(elem, it->pos, remaining);
  if (!next)
    return -1;

  it->pos = next;
  return 0;
}

/* *****************************************************************************
ASN.1 DER Encoding API
***************************************************************************** */

/**
 * Encode DER length field.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param len Length value to encode
 * @return Number of bytes written/needed
 */
SFUNC size_t fio_asn1_encode_length(uint8_t *buf, size_t len);

/**
 * Encode an ASN.1 INTEGER.
 *
 * Handles positive integers with proper leading zero byte when needed.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param data Integer data in big-endian format
 * @param data_len Length of integer data
 * @return Number of bytes written/needed
 */
SFUNC size_t fio_asn1_encode_integer(uint8_t *buf,
                                     const uint8_t *data,
                                     size_t data_len);

/**
 * Encode an ASN.1 INTEGER from a small value.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param value Integer value (up to 64-bit)
 * @return Number of bytes written/needed
 */
SFUNC size_t fio_asn1_encode_integer_small(uint8_t *buf, uint64_t value);

/**
 * Encode an ASN.1 OID from dot notation string.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param oid_string OID in dot notation (e.g., "1.2.840.113549.1.1.11")
 * @return Number of bytes written/needed, or 0 on error
 */
SFUNC size_t fio_asn1_encode_oid(uint8_t *buf, const char *oid_string);

/**
 * Encode an ASN.1 UTF8String.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param str String data
 * @param str_len String length
 * @return Number of bytes written/needed
 */
SFUNC size_t fio_asn1_encode_utf8_string(uint8_t *buf,
                                         const char *str,
                                         size_t str_len);

/**
 * Encode an ASN.1 PrintableString.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param str String data
 * @param str_len String length
 * @return Number of bytes written/needed
 */
SFUNC size_t fio_asn1_encode_printable_string(uint8_t *buf,
                                              const char *str,
                                              size_t str_len);

/**
 * Encode an ASN.1 BIT STRING.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param bits Bit data
 * @param bit_len Length of bit data in bytes
 * @param unused_bits Number of unused bits in last byte (0-7)
 * @return Number of bytes written/needed
 */
SFUNC size_t fio_asn1_encode_bit_string(uint8_t *buf,
                                        const uint8_t *bits,
                                        size_t bit_len,
                                        uint8_t unused_bits);

/**
 * Encode an ASN.1 OCTET STRING.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param data Octet data
 * @param data_len Length of data
 * @return Number of bytes written/needed
 */
SFUNC size_t fio_asn1_encode_octet_string(uint8_t *buf,
                                          const uint8_t *data,
                                          size_t data_len);

/**
 * Encode an ASN.1 SEQUENCE wrapper around existing content.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param content_len Length of content that will follow
 * @return Number of bytes written/needed for tag+length only
 */
SFUNC size_t fio_asn1_encode_sequence_header(uint8_t *buf, size_t content_len);

/**
 * Encode an ASN.1 SET wrapper around existing content.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param content_len Length of content that will follow
 * @return Number of bytes written/needed for tag+length only
 */
SFUNC size_t fio_asn1_encode_set_header(uint8_t *buf, size_t content_len);

/**
 * Encode an ASN.1 context-specific tag wrapper.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param tag_num Context tag number (0-30)
 * @param content_len Length of content that will follow
 * @param constructed 1 if constructed (contains other elements), 0 if primitive
 * @return Number of bytes written/needed for tag+length only
 */
SFUNC size_t fio_asn1_encode_context_header(uint8_t *buf,
                                            uint8_t tag_num,
                                            size_t content_len,
                                            int constructed);

/**
 * Encode an ASN.1 NULL.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @return Number of bytes written/needed (always 2)
 */
SFUNC size_t fio_asn1_encode_null(uint8_t *buf);

/**
 * Encode an ASN.1 BOOLEAN.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param value Boolean value (0 = false, non-zero = true)
 * @return Number of bytes written/needed (always 3)
 */
SFUNC size_t fio_asn1_encode_boolean(uint8_t *buf, int value);

/**
 * Encode an ASN.1 UTCTime from Unix timestamp.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param unix_time Unix timestamp (seconds since 1970-01-01 00:00:00 UTC)
 * @return Number of bytes written/needed
 */
SFUNC size_t fio_asn1_encode_utc_time(uint8_t *buf, int64_t unix_time);

/**
 * Encode an ASN.1 GeneralizedTime from Unix timestamp.
 *
 * @param buf Output buffer (can be NULL to calculate length only)
 * @param unix_time Unix timestamp (seconds since 1970-01-01 00:00:00 UTC)
 * @return Number of bytes written/needed
 */
SFUNC size_t fio_asn1_encode_generalized_time(uint8_t *buf, int64_t unix_time);

/* *****************************************************************************
Implementation - ASN.1 Encoding Functions
***************************************************************************** */

/** Encode DER length field */
SFUNC size_t fio_asn1_encode_length(uint8_t *buf, size_t len) {
  if (len < 128) {
    /* Short form */
    if (buf)
      buf[0] = (uint8_t)len;
    return 1;
  }

  /* Long form - count bytes needed */
  size_t num_bytes = 0;
  size_t tmp = len;
  while (tmp > 0) {
    ++num_bytes;
    tmp >>= 8;
  }

  if (buf) {
    buf[0] = (uint8_t)(0x80 | num_bytes);
    for (size_t i = num_bytes; i > 0; --i)
      buf[i] = (uint8_t)(len >> ((num_bytes - i) * 8));
  }

  return 1 + num_bytes;
}

/** Encode ASN.1 INTEGER */
SFUNC size_t fio_asn1_encode_integer(uint8_t *buf,
                                     const uint8_t *data,
                                     size_t data_len) {
  if (!data || data_len == 0)
    return 0;

  /* Skip leading zeros (but keep at least one byte) */
  while (data_len > 1 && data[0] == 0) {
    ++data;
    --data_len;
  }

  /* Check if we need a leading zero (positive number with high bit set) */
  int need_zero = (data[0] & 0x80) ? 1 : 0;
  size_t content_len = data_len + need_zero;

  /* Calculate total length */
  size_t len_bytes = fio_asn1_encode_length(NULL, content_len);
  size_t total = 1 + len_bytes + content_len;

  if (buf) {
    buf[0] = FIO_ASN1_INTEGER;
    fio_asn1_encode_length(buf + 1, content_len);
    size_t offset = 1 + len_bytes;
    if (need_zero)
      buf[offset++] = 0x00;
    FIO_MEMCPY(buf + offset, data, data_len);
  }

  return total;
}

/** Encode ASN.1 INTEGER from small value */
SFUNC size_t fio_asn1_encode_integer_small(uint8_t *buf, uint64_t value) {
  uint8_t tmp[9];
  size_t len = 0;

  /* Convert to big-endian bytes */
  if (value == 0) {
    tmp[0] = 0;
    len = 1;
  } else {
    /* Find number of bytes needed */
    uint64_t v = value;
    while (v > 0) {
      ++len;
      v >>= 8;
    }
    /* Write big-endian */
    for (size_t i = 0; i < len; ++i)
      tmp[i] = (uint8_t)(value >> ((len - 1 - i) * 8));
  }

  return fio_asn1_encode_integer(buf, tmp, len);
}

/** Encode ASN.1 OID from dot notation */
SFUNC size_t fio_asn1_encode_oid(uint8_t *buf, const char *oid_string) {
  if (!oid_string)
    return 0;

  /* Parse OID components */
  uint64_t components[32];
  size_t num_components = 0;
  const char *p = oid_string;

  while (*p && num_components < 32) {
    uint64_t val = 0;
    while (*p >= '0' && *p <= '9') {
      val = val * 10 + (*p - '0');
      ++p;
    }
    components[num_components++] = val;
    if (*p == '.')
      ++p;
    else if (*p != '\0')
      return 0; /* Invalid character */
  }

  if (num_components < 2)
    return 0;

  /* Calculate encoded length */
  /* First two components encoded as single byte: X*40 + Y */
  size_t content_len = 1;

  /* Remaining components in base-128 */
  for (size_t i = 2; i < num_components; ++i) {
    uint64_t v = components[i];
    if (v == 0) {
      content_len += 1;
    } else {
      size_t bytes = 0;
      while (v > 0) {
        ++bytes;
        v >>= 7;
      }
      content_len += bytes;
    }
  }

  size_t len_bytes = fio_asn1_encode_length(NULL, content_len);
  size_t total = 1 + len_bytes + content_len;

  if (buf) {
    buf[0] = FIO_ASN1_OID;
    fio_asn1_encode_length(buf + 1, content_len);
    size_t offset = 1 + len_bytes;

    /* First two components */
    buf[offset++] = (uint8_t)(components[0] * 40 + components[1]);

    /* Remaining components in base-128 */
    for (size_t i = 2; i < num_components; ++i) {
      uint64_t v = components[i];
      if (v == 0) {
        buf[offset++] = 0;
      } else {
        /* Count bytes needed */
        size_t bytes = 0;
        uint64_t tmp = v;
        while (tmp > 0) {
          ++bytes;
          tmp >>= 7;
        }
        /* Write base-128 with continuation bits */
        for (size_t j = bytes; j > 0; --j) {
          uint8_t b = (uint8_t)((v >> ((j - 1) * 7)) & 0x7F);
          if (j > 1)
            b |= 0x80;
          buf[offset++] = b;
        }
      }
    }
  }

  return total;
}

/** Encode ASN.1 UTF8String */
SFUNC size_t fio_asn1_encode_utf8_string(uint8_t *buf,
                                         const char *str,
                                         size_t str_len) {
  size_t len_bytes = fio_asn1_encode_length(NULL, str_len);
  size_t total = 1 + len_bytes + str_len;

  if (buf) {
    buf[0] = FIO_ASN1_UTF8_STRING;
    fio_asn1_encode_length(buf + 1, str_len);
    if (str_len > 0)
      FIO_MEMCPY(buf + 1 + len_bytes, str, str_len);
  }

  return total;
}

/** Encode ASN.1 PrintableString */
SFUNC size_t fio_asn1_encode_printable_string(uint8_t *buf,
                                              const char *str,
                                              size_t str_len) {
  size_t len_bytes = fio_asn1_encode_length(NULL, str_len);
  size_t total = 1 + len_bytes + str_len;

  if (buf) {
    buf[0] = FIO_ASN1_PRINTABLE_STRING;
    fio_asn1_encode_length(buf + 1, str_len);
    if (str_len > 0)
      FIO_MEMCPY(buf + 1 + len_bytes, str, str_len);
  }

  return total;
}

/** Encode ASN.1 BIT STRING */
SFUNC size_t fio_asn1_encode_bit_string(uint8_t *buf,
                                        const uint8_t *bits,
                                        size_t bit_len,
                                        uint8_t unused_bits) {
  size_t content_len = 1 + bit_len; /* unused bits byte + data */
  size_t len_bytes = fio_asn1_encode_length(NULL, content_len);
  size_t total = 1 + len_bytes + content_len;

  if (buf) {
    buf[0] = FIO_ASN1_BIT_STRING;
    fio_asn1_encode_length(buf + 1, content_len);
    buf[1 + len_bytes] = unused_bits;
    if (bit_len > 0)
      FIO_MEMCPY(buf + 2 + len_bytes, bits, bit_len);
  }

  return total;
}

/** Encode ASN.1 OCTET STRING */
SFUNC size_t fio_asn1_encode_octet_string(uint8_t *buf,
                                          const uint8_t *data,
                                          size_t data_len) {
  size_t len_bytes = fio_asn1_encode_length(NULL, data_len);
  size_t total = 1 + len_bytes + data_len;

  if (buf) {
    buf[0] = FIO_ASN1_OCTET_STRING;
    fio_asn1_encode_length(buf + 1, data_len);
    if (data && data_len > 0)
      FIO_MEMCPY(buf + 1 + len_bytes, data, data_len);
  }

  return total;
}

/** Encode ASN.1 SEQUENCE header */
SFUNC size_t fio_asn1_encode_sequence_header(uint8_t *buf, size_t content_len) {
  size_t len_bytes = fio_asn1_encode_length(NULL, content_len);
  size_t total = 1 + len_bytes;

  if (buf) {
    buf[0] = 0x30; /* SEQUENCE tag (constructed) */
    fio_asn1_encode_length(buf + 1, content_len);
  }

  return total;
}

/** Encode ASN.1 SET header */
SFUNC size_t fio_asn1_encode_set_header(uint8_t *buf, size_t content_len) {
  size_t len_bytes = fio_asn1_encode_length(NULL, content_len);
  size_t total = 1 + len_bytes;

  if (buf) {
    buf[0] = 0x31; /* SET tag (constructed) */
    fio_asn1_encode_length(buf + 1, content_len);
  }

  return total;
}

/** Encode ASN.1 context-specific tag header */
SFUNC size_t fio_asn1_encode_context_header(uint8_t *buf,
                                            uint8_t tag_num,
                                            size_t content_len,
                                            int constructed) {
  size_t len_bytes = fio_asn1_encode_length(NULL, content_len);
  size_t total = 1 + len_bytes;

  if (buf) {
    buf[0] = (uint8_t)(0x80 | (constructed ? 0x20 : 0) | (tag_num & 0x1F));
    fio_asn1_encode_length(buf + 1, content_len);
  }

  return total;
}

/** Encode ASN.1 NULL */
SFUNC size_t fio_asn1_encode_null(uint8_t *buf) {
  if (buf) {
    buf[0] = FIO_ASN1_NULL;
    buf[1] = 0x00;
  }
  return 2;
}

/** Encode ASN.1 BOOLEAN */
SFUNC size_t fio_asn1_encode_boolean(uint8_t *buf, int value) {
  if (buf) {
    buf[0] = FIO_ASN1_BOOLEAN;
    buf[1] = 0x01;
    buf[2] = value ? 0xFF : 0x00;
  }
  return 3;
}

/** Helper: convert Unix timestamp to broken-down time */
FIO_SFUNC void fio___asn1_gmtime(int64_t unix_time,
                                 int *year,
                                 int *month,
                                 int *day,
                                 int *hour,
                                 int *min,
                                 int *sec) {
  /* Days since epoch */
  int64_t days = unix_time / 86400;
  int64_t rem = unix_time % 86400;
  if (rem < 0) {
    --days;
    rem += 86400;
  }

  *hour = (int)(rem / 3600);
  rem %= 3600;
  *min = (int)(rem / 60);
  *sec = (int)(rem % 60);

  /* Calculate year and day of year */
  int y = 1970;
  while (days >= (fio___is_leap_year(y) ? 366 : 365)) {
    days -= fio___is_leap_year(y) ? 366 : 365;
    ++y;
  }
  while (days < 0) {
    --y;
    days += fio___is_leap_year(y) ? 366 : 365;
  }
  *year = y;

  /* Calculate month and day */
  int m = 1;
  while (days >= fio___days_in_month[m - 1] +
                     (m == 2 && fio___is_leap_year(y) ? 1 : 0)) {
    days -=
        fio___days_in_month[m - 1] + (m == 2 && fio___is_leap_year(y) ? 1 : 0);
    ++m;
  }
  *month = m;
  *day = (int)days + 1;
}

/** Encode ASN.1 UTCTime */
SFUNC size_t fio_asn1_encode_utc_time(uint8_t *buf, int64_t unix_time) {
  /* UTCTime format: YYMMDDhhmmssZ (13 bytes) */
  size_t content_len = 13;
  size_t total = 1 + 1 + content_len; /* tag + length + content */

  if (buf) {
    int year, month, day, hour, min, sec;
    fio___asn1_gmtime(unix_time, &year, &month, &day, &hour, &min, &sec);

    buf[0] = FIO_ASN1_UTC_TIME;
    buf[1] = (uint8_t)content_len;

    /* Year (2 digits) */
    int yy = year % 100;
    buf[2] = (uint8_t)('0' + yy / 10);
    buf[3] = (uint8_t)('0' + yy % 10);
    /* Month */
    buf[4] = (uint8_t)('0' + month / 10);
    buf[5] = (uint8_t)('0' + month % 10);
    /* Day */
    buf[6] = (uint8_t)('0' + day / 10);
    buf[7] = (uint8_t)('0' + day % 10);
    /* Hour */
    buf[8] = (uint8_t)('0' + hour / 10);
    buf[9] = (uint8_t)('0' + hour % 10);
    /* Minute */
    buf[10] = (uint8_t)('0' + min / 10);
    buf[11] = (uint8_t)('0' + min % 10);
    /* Second */
    buf[12] = (uint8_t)('0' + sec / 10);
    buf[13] = (uint8_t)('0' + sec % 10);
    /* Zulu */
    buf[14] = 'Z';
  }

  return total;
}

/** Encode ASN.1 GeneralizedTime */
SFUNC size_t fio_asn1_encode_generalized_time(uint8_t *buf, int64_t unix_time) {
  /* GeneralizedTime format: YYYYMMDDhhmmssZ (15 bytes) */
  size_t content_len = 15;
  size_t total = 1 + 1 + content_len; /* tag + length + content */

  if (buf) {
    int year, month, day, hour, min, sec;
    fio___asn1_gmtime(unix_time, &year, &month, &day, &hour, &min, &sec);

    buf[0] = FIO_ASN1_GENERALIZED_TIME;
    buf[1] = (uint8_t)content_len;

    /* Year (4 digits) */
    buf[2] = (uint8_t)('0' + (year / 1000) % 10);
    buf[3] = (uint8_t)('0' + (year / 100) % 10);
    buf[4] = (uint8_t)('0' + (year / 10) % 10);
    buf[5] = (uint8_t)('0' + year % 10);
    /* Month */
    buf[6] = (uint8_t)('0' + month / 10);
    buf[7] = (uint8_t)('0' + month % 10);
    /* Day */
    buf[8] = (uint8_t)('0' + day / 10);
    buf[9] = (uint8_t)('0' + day % 10);
    /* Hour */
    buf[10] = (uint8_t)('0' + hour / 10);
    buf[11] = (uint8_t)('0' + hour % 10);
    /* Minute */
    buf[12] = (uint8_t)('0' + min / 10);
    buf[13] = (uint8_t)('0' + min % 10);
    /* Second */
    buf[14] = (uint8_t)('0' + sec / 10);
    buf[15] = (uint8_t)('0' + sec % 10);
    /* Zulu */
    buf[16] = 'Z';
  }

  return total;
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_ASN1 */
#undef FIO_ASN1
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_RSA                /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                    RSA Signature Verification for TLS 1.3
                         (PKCS#1 v1.5 and RSA-PSS)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_RSA) && !defined(H___FIO_RSA___H)
#define H___FIO_RSA___H

/* *****************************************************************************
RSA Signature Verification Module

This module provides RSA signature verification (NOT signing) for TLS 1.3
certificate chain validation. It supports:

- PKCS#1 v1.5 signatures (sha256WithRSAEncryption, etc.)
- RSA-PSS signatures (required for TLS 1.3 CertificateVerify)
- Key sizes: 2048, 3072, 4096 bits

**Note**: This is verification-only. No private key operations are supported.
**Note**: This implementation has not been audited. Use at your own risk.
***************************************************************************** */

/* *****************************************************************************
RSA Constants
***************************************************************************** */

/** Maximum RSA key size in bits */
#define FIO_RSA_MAX_BITS 4096

/** Maximum RSA key size in bytes */
#define FIO_RSA_MAX_BYTES (FIO_RSA_MAX_BITS / 8)

/** Maximum RSA key size in 64-bit words */
#define FIO_RSA_MAX_WORDS (FIO_RSA_MAX_BYTES / 8)

/** Hash algorithm identifiers for RSA verification */
typedef enum {
  FIO_RSA_HASH_SHA256 = 0, /**< SHA-256 (32 bytes) */
  FIO_RSA_HASH_SHA384 = 1, /**< SHA-384 (48 bytes) */
  FIO_RSA_HASH_SHA512 = 2, /**< SHA-512 (64 bytes) */
} fio_rsa_hash_e;

/* *****************************************************************************
RSA Public Key Structure
***************************************************************************** */

/**
 * RSA public key for signature verification.
 *
 * The modulus (n) and exponent (e) are stored as big-endian byte arrays.
 * This matches the DER encoding used in X.509 certificates.
 */
typedef struct {
  const uint8_t *n; /**< Modulus (big-endian) */
  size_t n_len;     /**< Modulus length in bytes */
  const uint8_t *e; /**< Public exponent (big-endian) */
  size_t e_len;     /**< Exponent length in bytes */
} fio_rsa_pubkey_s;

/* *****************************************************************************
RSA Signature Verification API
***************************************************************************** */

/**
 * Verify an RSA PKCS#1 v1.5 signature.
 *
 * This verifies signatures with DigestInfo encoding as used in:
 * - sha256WithRSAEncryption (OID 1.2.840.113549.1.1.11)
 * - sha384WithRSAEncryption (OID 1.2.840.113549.1.1.12)
 * - sha512WithRSAEncryption (OID 1.2.840.113549.1.1.13)
 *
 * @param sig        Signature bytes (same length as modulus)
 * @param sig_len    Signature length in bytes
 * @param msg_hash   Pre-computed hash of the message
 * @param hash_len   Hash length (32, 48, or 64 bytes)
 * @param hash_alg   Hash algorithm used (FIO_RSA_HASH_SHA256, etc.)
 * @param key        RSA public key
 * @return 0 on success (valid signature), -1 on failure
 */
SFUNC int fio_rsa_verify_pkcs1(const uint8_t *sig,
                               size_t sig_len,
                               const uint8_t *msg_hash,
                               size_t hash_len,
                               fio_rsa_hash_e hash_alg,
                               const fio_rsa_pubkey_s *key);

/**
 * Verify an RSA-PSS signature (required for TLS 1.3).
 *
 * RSA-PSS uses probabilistic padding and is the mandatory signature scheme
 * for TLS 1.3 CertificateVerify messages with RSA keys.
 *
 * This implementation uses:
 * - MGF1 with the same hash function
 * - Salt length = hash length (as required by TLS 1.3)
 * - Trailer field = 0xBC
 *
 * @param sig        Signature bytes (same length as modulus)
 * @param sig_len    Signature length in bytes
 * @param msg_hash   Pre-computed hash of the message
 * @param hash_len   Hash length (32, 48, or 64 bytes)
 * @param hash_alg   Hash algorithm used
 * @param key        RSA public key
 * @return 0 on success (valid signature), -1 on failure
 */
SFUNC int fio_rsa_verify_pss(const uint8_t *sig,
                             size_t sig_len,
                             const uint8_t *msg_hash,
                             size_t hash_len,
                             fio_rsa_hash_e hash_alg,
                             const fio_rsa_pubkey_s *key);

/* *****************************************************************************
Implementation - Possibly Externed Functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
PKCS#1 v1.5 DigestInfo ASN.1 Prefixes

These encode: SEQUENCE { AlgorithmIdentifier, OCTET STRING hash }

RFC 8017 Section 9.2 defines these prefixes.
***************************************************************************** */

/** DigestInfo prefix for SHA-256 (19 bytes) */
static const uint8_t fio___rsa_digestinfo_sha256[] = {0x30,
                                                      0x31,
                                                      0x30,
                                                      0x0D,
                                                      0x06,
                                                      0x09,
                                                      0x60,
                                                      0x86,
                                                      0x48,
                                                      0x01,
                                                      0x65,
                                                      0x03,
                                                      0x04,
                                                      0x02,
                                                      0x01,
                                                      0x05,
                                                      0x00,
                                                      0x04,
                                                      0x20};

/** DigestInfo prefix for SHA-384 (19 bytes) */
static const uint8_t fio___rsa_digestinfo_sha384[] = {0x30,
                                                      0x41,
                                                      0x30,
                                                      0x0D,
                                                      0x06,
                                                      0x09,
                                                      0x60,
                                                      0x86,
                                                      0x48,
                                                      0x01,
                                                      0x65,
                                                      0x03,
                                                      0x04,
                                                      0x02,
                                                      0x02,
                                                      0x05,
                                                      0x00,
                                                      0x04,
                                                      0x30};

/** DigestInfo prefix for SHA-512 (19 bytes) */
static const uint8_t fio___rsa_digestinfo_sha512[] = {0x30,
                                                      0x51,
                                                      0x30,
                                                      0x0D,
                                                      0x06,
                                                      0x09,
                                                      0x60,
                                                      0x86,
                                                      0x48,
                                                      0x01,
                                                      0x65,
                                                      0x03,
                                                      0x04,
                                                      0x02,
                                                      0x03,
                                                      0x05,
                                                      0x00,
                                                      0x04,
                                                      0x40};

#define FIO___RSA_DIGESTINFO_PREFIX_LEN 19

/* *****************************************************************************
Implementation - Big Integer Helpers

Internal representation: Little-endian uint64_t array (word[0] = LSW)
Input/Output: Big-endian byte arrays (as used in X.509/TLS)
***************************************************************************** */

/** Convert big-endian bytes to little-endian uint64_t array */
FIO_SFUNC void fio___rsa_bytes_to_words(uint64_t *words,
                                        size_t word_count,
                                        const uint8_t *bytes,
                                        size_t byte_len) {
  FIO_MEMSET(words, 0, word_count * sizeof(uint64_t));

  /* Start from the end of bytes (least significant) */
  size_t word_idx = 0;
  size_t byte_idx = byte_len;

  while (byte_idx > 0 && word_idx < word_count) {
    uint64_t word = 0;
    size_t shift = 0;

    /* Collect up to 8 bytes into one word */
    while (byte_idx > 0 && shift < 64) {
      --byte_idx;
      word |= ((uint64_t)bytes[byte_idx]) << shift;
      shift += 8;
    }
    words[word_idx++] = word;
  }
}

/** Convert little-endian uint64_t array to big-endian bytes */
FIO_SFUNC void fio___rsa_words_to_bytes(uint8_t *bytes,
                                        size_t byte_len,
                                        const uint64_t *words,
                                        size_t word_count) {
  FIO_MEMSET(bytes, 0, byte_len);

  /* Start from the end of bytes (least significant) */
  size_t byte_idx = byte_len;
  size_t word_idx = 0;

  while (byte_idx > 0 && word_idx < word_count) {
    uint64_t word = words[word_idx++];

    for (int i = 0; i < 8 && byte_idx > 0; ++i) {
      --byte_idx;
      bytes[byte_idx] = (uint8_t)(word & 0xFF);
      word >>= 8;
    }
  }
}

/** Compare two big integers. Returns: <0 if a<b, 0 if a==b, >0 if a>b */
FIO_SFUNC int fio___rsa_cmp(const uint64_t *a,
                            const uint64_t *b,
                            size_t word_count) {
  for (size_t i = word_count; i > 0;) {
    --i;
    if (a[i] < b[i])
      return -1;
    if (a[i] > b[i])
      return 1;
  }
  return 0;
}

/* *****************************************************************************
Implementation - Modular Exponentiation

Compute: result = base^exp mod n

Uses square-and-multiply algorithm with constant-time modular reduction.
For RSA verification, exp is typically 65537 (0x10001) = 17 bits.
***************************************************************************** */

/**
 * Modular exponentiation: result = base^exp mod n
 *
 * This uses a simple square-and-multiply algorithm.
 * For RSA verification with e=65537, this does 17 squarings + 1 multiply.
 */
FIO_SFUNC void fio___rsa_modexp(uint64_t *result,
                                const uint64_t *base,
                                const uint64_t *exp,
                                const uint64_t *n,
                                size_t word_count) {
/* Double-size buffer for multiplication results */
#if !defined(_MSC_VER) && (!defined(__cplusplus) || __cplusplus > 201402L)
  uint64_t tmp[word_count * 2];
  uint64_t acc[word_count];
  uint64_t sqr[word_count];
  uint64_t n_ext[word_count * 2];
#else
  uint64_t tmp[FIO_RSA_MAX_WORDS * 2];
  uint64_t acc[FIO_RSA_MAX_WORDS];
  uint64_t sqr[FIO_RSA_MAX_WORDS];
  uint64_t n_ext[FIO_RSA_MAX_WORDS * 2];
  FIO_ASSERT(word_count <= FIO_RSA_MAX_WORDS,
             "RSA key size exceeds maximum supported");
#endif

  /* Zero-extend n to double size for use with fio_math_div */
  FIO_MEMCPY(n_ext, n, word_count * sizeof(uint64_t));
  FIO_MEMSET(n_ext + word_count, 0, word_count * sizeof(uint64_t));

  /* Initialize accumulator to 1 */
  FIO_MEMSET(acc, 0, word_count * sizeof(uint64_t));
  acc[0] = 1;

  /* Copy base to squaring buffer */
  FIO_MEMCPY(sqr, base, word_count * sizeof(uint64_t));

  /* Find the highest set bit in the exponent */
  size_t exp_bits = fio_math_msb_index((uint64_t *)exp, word_count);
  if (exp_bits == (size_t)-1) {
    /* exp = 0, result = 1 (already set) */
    FIO_MEMCPY(result, acc, word_count * sizeof(uint64_t));
    return;
  }

  /* Square-and-multiply from LSB to MSB */
  for (size_t bit = 0; bit <= exp_bits; ++bit) {
    size_t word_idx = bit / 64;
    size_t bit_idx = bit % 64;

    /* If this bit is set, multiply accumulator by current square */
    if (exp[word_idx] & (1ULL << bit_idx)) {
      fio_math_mul(tmp, acc, sqr, word_count);
      fio_math_div(NULL, acc, tmp, n_ext, word_count * 2);
    }

    /* Square the current value (unless this is the last bit) */
    if (bit < exp_bits) {
      fio_math_mul(tmp, sqr, sqr, word_count);
      fio_math_div(NULL, sqr, tmp, n_ext, word_count * 2);
    }
  }

  FIO_MEMCPY(result, acc, word_count * sizeof(uint64_t));
}

/**
 * Optimized modular exponentiation for e = 65537 (0x10001).
 *
 * This is the most common RSA public exponent. It has only 2 bits set,
 * so we can do: result = base^65537 = base^(2^16 + 1) = base^(2^16) * base
 *
 * This requires 16 squarings + 1 multiplication.
 */
FIO_SFUNC int fio___rsa_modexp_65537(uint64_t *result,
                                     const uint64_t *base,
                                     const uint64_t *n,
                                     size_t word_count) {
/* Double-size buffer for multiplication results */
#if !defined(_MSC_VER) && (!defined(__cplusplus) || __cplusplus > 201402L)
  uint64_t tmp[word_count * 2];
  uint64_t sqr[word_count];
  uint64_t rem[word_count * 2];
  uint64_t n_ext[word_count * 2];
#else
  uint64_t tmp[FIO_RSA_MAX_WORDS * 2];
  uint64_t sqr[FIO_RSA_MAX_WORDS];
  uint64_t rem[FIO_RSA_MAX_WORDS * 2];
  uint64_t n_ext[FIO_RSA_MAX_WORDS * 2];
  FIO_ASSERT(word_count <= FIO_RSA_MAX_WORDS,
             "RSA key size exceeds maximum supported");
#endif

  /* Zero-extend n to double size for use with fio_math_div */
  FIO_MEMCPY(n_ext, n, word_count * sizeof(uint64_t));
  FIO_MEMSET(n_ext + word_count, 0, word_count * sizeof(uint64_t));

  /* sqr = base (mod n is already ensured by caller if base < n) */
  FIO_MEMCPY(sqr, base, word_count * sizeof(uint64_t));

  /* Square 16 times to get base^(2^16) */
  for (int i = 0; i < 16; ++i) {
    fio_math_mul(tmp, sqr, sqr, word_count);
    /* Reduce mod n */
    FIO_MEMSET(rem, 0, word_count * 2 * sizeof(uint64_t));
    fio_math_div(NULL, rem, tmp, n_ext, word_count * 2);
    FIO_MEMCPY(sqr, rem, word_count * sizeof(uint64_t));
  }

  /* result = sqr * base (mod n) = base^(2^16) * base = base^65537 */
  fio_math_mul(tmp, sqr, base, word_count);
  FIO_MEMSET(rem, 0, word_count * 2 * sizeof(uint64_t));
  fio_math_div(NULL, rem, tmp, n_ext, word_count * 2);
  FIO_MEMCPY(result, rem, word_count * sizeof(uint64_t));

  return 0;
}

/**
 * RSA public key operation: result = sig^e mod n
 *
 * Verifies the signature by computing the modular exponentiation and
 * returns the result (which should match the padded hash).
 */
FIO_SFUNC int fio___rsa_public_op(uint8_t *result,
                                  const uint8_t *sig,
                                  size_t sig_len,
                                  const fio_rsa_pubkey_s *key) {
  if (!result || !sig || !key || !key->n || !key->e)
    return -1;

  /* Validate key size */
  if (key->n_len > FIO_RSA_MAX_BYTES || key->n_len < 256)
    return -1; /* Only support 2048-4096 bit keys */

  if (sig_len != key->n_len)
    return -1; /* Signature must be same length as modulus */

  size_t word_count = (key->n_len + 7) / 8;

#if !defined(_MSC_VER) && (!defined(__cplusplus) || __cplusplus > 201402L)
  uint64_t n_words[word_count];
  uint64_t sig_words[word_count];
  uint64_t result_words[word_count];
#else
  uint64_t n_words[FIO_RSA_MAX_WORDS];
  uint64_t sig_words[FIO_RSA_MAX_WORDS];
  uint64_t result_words[FIO_RSA_MAX_WORDS];
#endif

  /* Convert to internal representation */
  fio___rsa_bytes_to_words(n_words, word_count, key->n, key->n_len);
  fio___rsa_bytes_to_words(sig_words, word_count, sig, sig_len);

  /* Verify signature < modulus */
  if (fio___rsa_cmp(sig_words, n_words, word_count) >= 0)
    return -1;

  /* Check if exponent is 65537 (common case) */
  uint64_t e_val = 0;
  if (key->e_len <= 8) {
    for (size_t i = 0; i < key->e_len; ++i)
      e_val = (e_val << 8) | key->e[i];
  }

  if (e_val == 65537) {
    /* Use optimized path for e = 65537 */
    if (fio___rsa_modexp_65537(result_words, sig_words, n_words, word_count) !=
        0)
      return -1;
  } else {
    /* General case - use square-and-multiply */
#if !defined(_MSC_VER) && (!defined(__cplusplus) || __cplusplus > 201402L)
    uint64_t e_words[word_count];
#else
    uint64_t e_words[FIO_RSA_MAX_WORDS];
#endif
    FIO_MEMSET(e_words, 0, word_count * sizeof(uint64_t));
    fio___rsa_bytes_to_words(e_words, word_count, key->e, key->e_len);
    fio___rsa_modexp(result_words, sig_words, e_words, n_words, word_count);
  }

  /* Convert back to bytes */
  fio___rsa_words_to_bytes(result, key->n_len, result_words, word_count);

  return 0;
}

/* *****************************************************************************
Implementation - PKCS#1 v1.5 Signature Verification
***************************************************************************** */

/**
 * Constant-time memory comparison.
 * Returns 0 if equal, non-zero otherwise.
 */
FIO_SFUNC int fio___rsa_memcmp_ct(const uint8_t *a,
                                  const uint8_t *b,
                                  size_t len) {
  uint8_t diff = 0;
  for (size_t i = 0; i < len; ++i)
    diff |= a[i] ^ b[i];
  return diff;
}

SFUNC int fio_rsa_verify_pkcs1(const uint8_t *sig,
                               size_t sig_len,
                               const uint8_t *msg_hash,
                               size_t hash_len,
                               fio_rsa_hash_e hash_alg,
                               const fio_rsa_pubkey_s *key) {
  if (!sig || !msg_hash || !key)
    return -1;

  /* Validate hash algorithm and length */
  const uint8_t *digestinfo_prefix;
  size_t expected_hash_len;

  switch (hash_alg) {
  case FIO_RSA_HASH_SHA256:
    digestinfo_prefix = fio___rsa_digestinfo_sha256;
    expected_hash_len = 32;
    break;
  case FIO_RSA_HASH_SHA384:
    digestinfo_prefix = fio___rsa_digestinfo_sha384;
    expected_hash_len = 48;
    break;
  case FIO_RSA_HASH_SHA512:
    digestinfo_prefix = fio___rsa_digestinfo_sha512;
    expected_hash_len = 64;
    break;
  default: return -1;
  }

  if (hash_len != expected_hash_len)
    return -1;

  /* Compute sig^e mod n */
  uint8_t decrypted[FIO_RSA_MAX_BYTES];
  if (fio___rsa_public_op(decrypted, sig, sig_len, key) != 0)
    return -1;

  /*
   * Verify PKCS#1 v1.5 padding (RFC 8017 Section 8.2.2):
   *
   * EM = 0x00 || 0x01 || PS || 0x00 || DigestInfo
   *
   * where PS is padding bytes (all 0xFF), minimum 8 bytes
   * DigestInfo = prefix || hash
   */

  size_t k = key->n_len; /* Encoded message length */
  size_t digestinfo_len = FIO___RSA_DIGESTINFO_PREFIX_LEN + hash_len;
  size_t ps_len = k - 3 - digestinfo_len;

  if (k < 11 + digestinfo_len)
    return -1; /* Message too short */

  /* Verify: 0x00 || 0x01 */
  int result = 0;
  result |= decrypted[0];        /* Must be 0x00 */
  result |= decrypted[1] ^ 0x01; /* Must be 0x01 */

  /* Verify PS (all 0xFF bytes) */
  for (size_t i = 2; i < 2 + ps_len; ++i)
    result |= decrypted[i] ^ 0xFF;

  /* Verify separator 0x00 */
  result |= decrypted[2 + ps_len];

  /* Verify DigestInfo prefix */
  result |= fio___rsa_memcmp_ct(decrypted + 3 + ps_len,
                                digestinfo_prefix,
                                FIO___RSA_DIGESTINFO_PREFIX_LEN);

  /* Verify hash */
  result |= fio___rsa_memcmp_ct(decrypted + 3 + ps_len +
                                    FIO___RSA_DIGESTINFO_PREFIX_LEN,
                                msg_hash,
                                hash_len);

  return result ? -1 : 0;
}

/* *****************************************************************************
Implementation - RSA-PSS Signature Verification
***************************************************************************** */

/**
 * MGF1 (Mask Generation Function) per RFC 8017 Appendix B.2.1.
 *
 * mask = Hash(seed || counter) for counter = 0, 1, 2, ...
 */
FIO_SFUNC void fio___rsa_mgf1(uint8_t *mask,
                              size_t mask_len,
                              const uint8_t *seed,
                              size_t seed_len,
                              fio_rsa_hash_e hash_alg) {
  size_t hash_len;
  switch (hash_alg) {
  case FIO_RSA_HASH_SHA256: hash_len = 32; break;
  case FIO_RSA_HASH_SHA384: hash_len = 48; break;
  case FIO_RSA_HASH_SHA512: hash_len = 64; break;
  default: return;
  }

  uint8_t counter_buf[4];
  uint8_t hash_input[FIO_RSA_MAX_BYTES + 4]; /* seed || counter */
  size_t offset = 0;
  uint32_t counter = 0;

  FIO_MEMCPY(hash_input, seed, seed_len);

  while (offset < mask_len) {
    /* Append counter (big-endian) */
    counter_buf[0] = (uint8_t)(counter >> 24);
    counter_buf[1] = (uint8_t)(counter >> 16);
    counter_buf[2] = (uint8_t)(counter >> 8);
    counter_buf[3] = (uint8_t)(counter);
    FIO_MEMCPY(hash_input + seed_len, counter_buf, 4);

    /* Hash and copy to output */
    size_t to_copy = mask_len - offset;
    if (to_copy > hash_len)
      to_copy = hash_len;

    switch (hash_alg) {
    case FIO_RSA_HASH_SHA256: {
      fio_u256 h = fio_sha256(hash_input, seed_len + 4);
      FIO_MEMCPY(mask + offset, h.u8, to_copy);
      break;
    }
    case FIO_RSA_HASH_SHA384: {
      fio_u512 h = fio_sha512(hash_input, seed_len + 4);
      /* SHA-384 is truncated SHA-512 */
      FIO_MEMCPY(mask + offset, h.u8, to_copy);
      break;
    }
    case FIO_RSA_HASH_SHA512: {
      fio_u512 h = fio_sha512(hash_input, seed_len + 4);
      FIO_MEMCPY(mask + offset, h.u8, to_copy);
      break;
    }
    }

    offset += to_copy;
    ++counter;
  }
}

SFUNC int fio_rsa_verify_pss(const uint8_t *sig,
                             size_t sig_len,
                             const uint8_t *msg_hash,
                             size_t hash_len,
                             fio_rsa_hash_e hash_alg,
                             const fio_rsa_pubkey_s *key) {
  if (!sig || !msg_hash || !key)
    return -1;

  /* Validate hash algorithm and length */
  size_t expected_hash_len;
  switch (hash_alg) {
  case FIO_RSA_HASH_SHA256: expected_hash_len = 32; break;
  case FIO_RSA_HASH_SHA384: expected_hash_len = 48; break;
  case FIO_RSA_HASH_SHA512: expected_hash_len = 64; break;
  default: return -1;
  }

  if (hash_len != expected_hash_len)
    return -1;

  /* For TLS 1.3, salt length = hash length */
  size_t salt_len = hash_len;

  /* Compute sig^e mod n */
  uint8_t em[FIO_RSA_MAX_BYTES];
  if (fio___rsa_public_op(em, sig, sig_len, key) != 0)
    return -1;

  /*
   * RSA-PSS Verification (RFC 8017 Section 9.1.2):
   *
   * EM = maskedDB || H || 0xBC
   *
   * where:
   *   - maskedDB = DB XOR dbMask
   *   - H = Hash(M')
   *   - M' = 0x00 00 00 00 00 00 00 00 || mHash || salt
   *   - DB = PS || 0x01 || salt
   *   - PS = zero bytes
   */

  size_t em_len = key->n_len;
  size_t db_len = em_len - hash_len - 1;

  /* Verify trailing byte is 0xBC */
  if (em[em_len - 1] != 0xBC)
    return -1;

  /* The top bits of EM should be 0 (based on modulus bit length) */
  size_t em_bits = key->n_len * 8 - 1; /* One less than modulus bits */
  size_t top_mask = 0xFF >> (8 * em_len - em_bits - 1);
  if ((em[0] & ~top_mask) != 0)
    return -1;

  /* Extract H (hash) from EM */
  const uint8_t *masked_db = em;
  const uint8_t *h = em + db_len;

  /* Compute dbMask = MGF1(H, db_len) */
  uint8_t db_mask[FIO_RSA_MAX_BYTES];
  fio___rsa_mgf1(db_mask, db_len, h, hash_len, hash_alg);

  /* Compute DB = maskedDB XOR dbMask */
  uint8_t db[FIO_RSA_MAX_BYTES];
  for (size_t i = 0; i < db_len; ++i)
    db[i] = masked_db[i] ^ db_mask[i];

  /* Clear top bits of DB */
  db[0] &= top_mask;

  /* Verify DB = PS || 0x01 || salt */
  /* PS should be all zeros, length = db_len - salt_len - 1 */
  size_t ps_len = db_len - salt_len - 1;
  int result = 0;

  /* Verify PS (all zeros) */
  for (size_t i = 0; i < ps_len; ++i)
    result |= db[i];

  /* Verify separator 0x01 */
  result |= db[ps_len] ^ 0x01;

  /* Extract salt */
  const uint8_t *salt = db + ps_len + 1;

  /* Compute M' = 0x0000000000000000 || mHash || salt */
  uint8_t m_prime[8 + 64 + 64]; /* max: 8 + hash_len + salt_len */
  FIO_MEMSET(m_prime, 0, 8);
  FIO_MEMCPY(m_prime + 8, msg_hash, hash_len);
  FIO_MEMCPY(m_prime + 8 + hash_len, salt, salt_len);

  /* Compute H' = Hash(M') */
  uint8_t h_prime[64];
  switch (hash_alg) {
  case FIO_RSA_HASH_SHA256: {
    fio_u256 hp = fio_sha256(m_prime, 8 + hash_len + salt_len);
    FIO_MEMCPY(h_prime, hp.u8, 32);
    break;
  }
  case FIO_RSA_HASH_SHA384: {
    fio_u512 hp = fio_sha512(m_prime, 8 + hash_len + salt_len);
    FIO_MEMCPY(h_prime, hp.u8, 48);
    break;
  }
  case FIO_RSA_HASH_SHA512: {
    fio_u512 hp = fio_sha512(m_prime, 8 + hash_len + salt_len);
    FIO_MEMCPY(h_prime, hp.u8, 64);
    break;
  }
  }

  /* Verify H == H' */
  result |= fio___rsa_memcmp_ct(h, h_prime, hash_len);

  return result ? -1 : 0;
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_RSA */
#undef FIO_RSA
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_X509               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                        X.509 Certificate Parser for TLS 1.3
                            (RFC 5280 Certificate Parsing)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_X509) && !defined(H___FIO_X509___H)
#define H___FIO_X509___H

/* *****************************************************************************
X.509 Certificate Parser Module

This module provides X.509v3 certificate parsing for TLS 1.3 certificate
verification. It supports:

- RSA, ECDSA (P-256, P-384), and Ed25519 public keys
- Signature verification using issuer certificates
- Validity period checking
- Hostname matching (CN and SAN with wildcards)
- Basic constraints and key usage extensions
- Certificate chain validation
- Trust store management

**Note**: This is a minimal parser for TLS 1.3. Not all X.509 features
are supported. The implementation is non-allocating (pointers into DER data).
***************************************************************************** */

/* *****************************************************************************
X.509 Type Definitions
***************************************************************************** */

/** Public key algorithm types */
typedef enum {
  FIO_X509_KEY_UNKNOWN = 0,
  FIO_X509_KEY_RSA = 1,        /**< RSA (any key size) */
  FIO_X509_KEY_ECDSA_P256 = 2, /**< ECDSA with P-256/secp256r1 */
  FIO_X509_KEY_ECDSA_P384 = 3, /**< ECDSA with P-384/secp384r1 */
  FIO_X509_KEY_ED25519 = 4,    /**< Ed25519 (EdDSA) */
} fio_x509_key_type_e;

/** Signature algorithm types */
typedef enum {
  FIO_X509_SIG_UNKNOWN = 0,
  FIO_X509_SIG_RSA_PKCS1_SHA256 = 1, /**< sha256WithRSAEncryption */
  FIO_X509_SIG_RSA_PKCS1_SHA384 = 2, /**< sha384WithRSAEncryption */
  FIO_X509_SIG_RSA_PKCS1_SHA512 = 3, /**< sha512WithRSAEncryption */
  FIO_X509_SIG_RSA_PSS_SHA256 = 4,   /**< RSA-PSS with SHA-256 */
  FIO_X509_SIG_RSA_PSS_SHA384 = 5,   /**< RSA-PSS with SHA-384 */
  FIO_X509_SIG_RSA_PSS_SHA512 = 6,   /**< RSA-PSS with SHA-512 */
  FIO_X509_SIG_ECDSA_SHA256 = 7,     /**< ecdsa-with-SHA256 */
  FIO_X509_SIG_ECDSA_SHA384 = 8,     /**< ecdsa-with-SHA384 */
  FIO_X509_SIG_ED25519 = 9,          /**< Ed25519 */
} fio_x509_sig_alg_e;

/** Key Usage bit flags (RFC 5280 Section 4.2.1.3)
 *
 * ASN.1 BIT STRING uses MSB-first bit ordering:
 * - Bit 0 = MSB of first byte (0x80)
 * - Bit 1 = 0x40, Bit 2 = 0x20, etc.
 * - Bits 8+ are in the second byte
 */
typedef enum {
  FIO_X509_KU_DIGITAL_SIGNATURE = 0x0080, /* bit 0 = MSB of byte 0 */
  FIO_X509_KU_NON_REPUDIATION = 0x0040,   /* bit 1 */
  FIO_X509_KU_KEY_ENCIPHERMENT = 0x0020,  /* bit 2 */
  FIO_X509_KU_DATA_ENCIPHERMENT = 0x0010, /* bit 3 */
  FIO_X509_KU_KEY_AGREEMENT = 0x0008,     /* bit 4 */
  FIO_X509_KU_KEY_CERT_SIGN = 0x0004,     /* bit 5 */
  FIO_X509_KU_CRL_SIGN = 0x0002,          /* bit 6 */
  FIO_X509_KU_ENCIPHER_ONLY = 0x0001,     /* bit 7 */
  FIO_X509_KU_DECIPHER_ONLY = 0x8000,     /* bit 8 = MSB of byte 1 */
} fio_x509_key_usage_e;

/** X.509 chain validation error codes */
typedef enum {
  FIO_X509_OK = 0,                   /**< Validation successful */
  FIO_X509_ERR_PARSE = -1,           /**< Failed to parse certificate */
  FIO_X509_ERR_EXPIRED = -2,         /**< Certificate expired */
  FIO_X509_ERR_NOT_YET_VALID = -3,   /**< Certificate not yet valid */
  FIO_X509_ERR_SIGNATURE = -4,       /**< Signature verification failed */
  FIO_X509_ERR_ISSUER_MISMATCH = -5, /**< Issuer DN doesn't match subject DN */
  FIO_X509_ERR_NOT_CA = -6,          /**< Issuer is not a CA certificate */
  FIO_X509_ERR_NO_TRUST_ANCHOR = -7, /**< Certificate not in trust store */
  FIO_X509_ERR_HOSTNAME_MISMATCH = -8, /**< Hostname doesn't match cert */
  FIO_X509_ERR_EMPTY_CHAIN = -9,       /**< Empty certificate chain */
  FIO_X509_ERR_CHAIN_TOO_LONG = -10,   /**< Chain exceeds maximum depth */
} fio_x509_error_e;

/** Trust store for root CA certificates */
typedef struct {
  const uint8_t **roots;   /**< Array of root CA certificate DER data */
  const size_t *root_lens; /**< Array of root CA certificate lengths */
  size_t root_count;       /**< Number of root CAs */
} fio_x509_trust_store_s;

/** TLS certificate entry (parsed from Certificate message) */
typedef struct {
  const uint8_t *cert; /**< DER-encoded certificate data */
  size_t cert_len;     /**< Certificate length */
} fio_tls_cert_entry_s;

/** Parsed X.509 certificate structure */
typedef struct {
  /** Certificate version (0=v1, 1=v2, 2=v3) */
  int version;

  /** Validity period (Unix timestamps) */
  int64_t not_before;
  int64_t not_after;

  /** Subject Distinguished Name (raw DER for comparison) */
  const uint8_t *subject_der;
  size_t subject_der_len;

  /** Issuer Distinguished Name (raw DER for comparison) */
  const uint8_t *issuer_der;
  size_t issuer_der_len;

  /** Subject Common Name (if present, pointer into DER data) */
  const char *subject_cn;
  size_t subject_cn_len;

  /** Public Key Type */
  fio_x509_key_type_e key_type;

  /** Public Key Data (union based on key_type) */
  union {
    struct {
      const uint8_t *n; /**< RSA modulus (big-endian) */
      size_t n_len;
      const uint8_t *e; /**< RSA exponent (big-endian) */
      size_t e_len;
    } rsa;
    struct {
      const uint8_t *point; /**< Uncompressed EC point (04 || x || y) */
      size_t point_len;
    } ecdsa;
    struct {
      const uint8_t *key; /**< 32-byte Ed25519 public key */
    } ed25519;
  } pubkey;

  /** Signature Algorithm */
  fio_x509_sig_alg_e sig_alg;

  /** Signature value (pointer into DER data) */
  const uint8_t *signature;
  size_t signature_len;

  /** TBS Certificate (for signature verification) */
  const uint8_t *tbs_data;
  size_t tbs_len;

  /** Basic Constraints: is CA */
  int is_ca;

  /** Key Usage extension present */
  int has_key_usage;
  /** Key Usage bits */
  uint16_t key_usage;

  /** Subject Alternative Name: first DNS name (if present) */
  const char *san_dns;
  size_t san_dns_len;

  /** Subject Alternative Name extension raw data (for iterating all SANs) */
  const uint8_t *san_ext_data;
  size_t san_ext_len;

} fio_x509_cert_s;

/* *****************************************************************************
X.509 Parser API
***************************************************************************** */

/**
 * Parse a DER-encoded X.509 certificate.
 *
 * The cert structure will contain pointers into the original DER data,
 * so the DER data must remain valid while the cert is in use.
 *
 * @param cert Output certificate structure (will be zeroed first)
 * @param der_data Pointer to DER-encoded certificate
 * @param der_len Length of DER data in bytes
 * @return 0 on success, -1 on error
 */
SFUNC int fio_x509_parse(fio_x509_cert_s *cert,
                         const uint8_t *der_data,
                         size_t der_len);

/**
 * Verify certificate signature using issuer's public key.
 *
 * This verifies that the certificate was signed by the issuer.
 *
 * @param cert Certificate to verify
 * @param issuer Certificate of the issuer (contains the public key)
 * @return 0 if valid, -1 if invalid or error
 */
SFUNC int fio_x509_verify_signature(const fio_x509_cert_s *cert,
                                    const fio_x509_cert_s *issuer);

/**
 * Check if certificate is currently valid (not expired, not yet valid).
 *
 * @param cert Certificate to check
 * @param current_time Current Unix timestamp (seconds since epoch)
 * @return 0 if valid, -1 if expired or not yet valid
 */
FIO_IFUNC int fio_x509_check_validity(const fio_x509_cert_s *cert,
                                      int64_t current_time);

/**
 * Check if hostname matches certificate (CN or SAN).
 *
 * Supports wildcard matching (*.example.com).
 * Per RFC 6125, wildcards only match one label.
 *
 * @param cert Certificate to check
 * @param hostname Hostname to match
 * @param hostname_len Length of hostname
 * @return 0 if match, -1 if no match
 */
SFUNC int fio_x509_match_hostname(const fio_x509_cert_s *cert,
                                  const char *hostname,
                                  size_t hostname_len);

/**
 * Compare two Distinguished Names for equality.
 *
 * Used for checking if issuer DN matches subject DN.
 *
 * @param dn1 First DN (DER-encoded)
 * @param dn1_len Length of first DN
 * @param dn2 Second DN (DER-encoded)
 * @param dn2_len Length of second DN
 * @return 0 if equal, non-zero if different
 */
FIO_IFUNC int fio_x509_dn_equals(const uint8_t *dn1,
                                 size_t dn1_len,
                                 const uint8_t *dn2,
                                 size_t dn2_len);

/* *****************************************************************************
X.509 Certificate Chain Validation API
***************************************************************************** */

/**
 * Validate a certificate chain for TLS 1.3.
 *
 * The chain should be ordered from end-entity to closest-to-root:
 *   - certs[0] = server's certificate (end-entity)
 *   - certs[1] = intermediate CA (signed certs[0])
 *   - certs[n-1] = closest to root (may be root or intermediate)
 *
 * Validation performs:
 *   1. Parse all certificates
 *   2. Check validity period for all certificates
 *   3. Verify hostname matches end-entity certificate (if hostname provided)
 *   4. Verify each certificate's signature using the next certificate's key
 *   5. Verify issuer DNs match subject DNs in the chain
 *   6. Verify intermediate/root certificates have CA:TRUE
 *   7. Verify the chain terminates at a trusted root (if trust store provided)
 *
 * @param certs Array of DER-encoded certificates
 * @param cert_lens Array of certificate lengths
 * @param cert_count Number of certificates in chain
 * @param hostname Expected hostname for end-entity (NULL to skip check)
 * @param current_time Current Unix timestamp for validity checking
 * @param trust_store Root CA certificates (NULL to skip trust check)
 * @return FIO_X509_OK (0) on success, or error code on failure
 */
SFUNC int fio_x509_verify_chain(const uint8_t **certs,
                                const size_t *cert_lens,
                                size_t cert_count,
                                const char *hostname,
                                int64_t current_time,
                                fio_x509_trust_store_s *trust_store);

/**
 * Check if a certificate is in the trust store.
 *
 * Comparison is done by matching subject DN.
 *
 * @param cert Certificate to check
 * @param trust_store Trust store to search
 * @return 0 if trusted, -1 if not found
 */
SFUNC int fio_x509_is_trusted(const fio_x509_cert_s *cert,
                              fio_x509_trust_store_s *trust_store);

/** Error value for fio_tls_parse_certificate_message */
#define FIO_TLS_CERT_PARSE_ERROR ((size_t)-1)

/**
 * Parse TLS 1.3 Certificate message into individual certificates.
 *
 * TLS 1.3 Certificate message format (RFC 8446):
 *   certificate_request_context<0..2^8-1>
 *   certificate_list<0..2^24-1>:
 *     CertificateEntry:
 *       cert_data<1..2^24-1>
 *       extensions<0..2^16-1>
 *
 * @param entries Output array for certificate entries
 * @param max_entries Maximum entries to parse
 * @param data Raw Certificate message data (after handshake header)
 * @param data_len Length of Certificate message data
 * @return Number of certificates parsed, or FIO_TLS_CERT_PARSE_ERROR on error
 */
SFUNC size_t fio_tls_parse_certificate_message(fio_tls_cert_entry_s *entries,
                                               size_t max_entries,
                                               const uint8_t *data,
                                               size_t data_len);

/**
 * Get human-readable error string for X.509 validation error code.
 *
 * @param error Error code from fio_x509_verify_chain
 * @return Static string describing the error
 */
FIO_IFUNC const char *fio_x509_error_str(int error);

/* *****************************************************************************
Implementation - Inline Functions
***************************************************************************** */

/** Check if certificate is within validity period */
FIO_IFUNC int fio_x509_check_validity(const fio_x509_cert_s *cert,
                                      int64_t current_time) {
  if (!cert)
    return -1;
  if (current_time < cert->not_before)
    return -1; /* Not yet valid */
  if (current_time > cert->not_after)
    return -1; /* Expired */
  return 0;
}

/** Compare two Distinguished Names */
FIO_IFUNC int fio_x509_dn_equals(const uint8_t *dn1,
                                 size_t dn1_len,
                                 const uint8_t *dn2,
                                 size_t dn2_len) {
  if (dn1_len != dn2_len)
    return 1;
  if (!dn1 || !dn2)
    return 1;
  return FIO_MEMCMP(dn1, dn2, dn1_len);
}

/** Get human-readable error string for X.509 validation error code */
FIO_IFUNC const char *fio_x509_error_str(int error) {
  switch (error) {
  case FIO_X509_OK: return "OK";
  case FIO_X509_ERR_PARSE: return "Failed to parse certificate";
  case FIO_X509_ERR_EXPIRED: return "Certificate expired";
  case FIO_X509_ERR_NOT_YET_VALID: return "Certificate not yet valid";
  case FIO_X509_ERR_SIGNATURE: return "Signature verification failed";
  case FIO_X509_ERR_ISSUER_MISMATCH: return "Issuer DN mismatch";
  case FIO_X509_ERR_NOT_CA: return "Issuer is not a CA";
  case FIO_X509_ERR_NO_TRUST_ANCHOR: return "No trusted root CA found";
  case FIO_X509_ERR_HOSTNAME_MISMATCH: return "Hostname mismatch";
  case FIO_X509_ERR_EMPTY_CHAIN: return "Empty certificate chain";
  case FIO_X509_ERR_CHAIN_TOO_LONG: return "Certificate chain too long";
  default: return "Unknown error";
  }
}

/* *****************************************************************************
Implementation - Possibly Externed Functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Implementation - Internal Helpers
***************************************************************************** */

/** Parse signature algorithm OID to enum */
FIO_SFUNC fio_x509_sig_alg_e
fio___x509_parse_sig_alg(const fio_asn1_element_s *alg_id) {
  if (!alg_id || !alg_id->data)
    return FIO_X509_SIG_UNKNOWN;

  /* AlgorithmIdentifier ::= SEQUENCE { algorithm OID, parameters ANY } */
  fio_asn1_iterator_s it;
  fio_asn1_element_s oid;

  fio_asn1_iterator_init(&it, alg_id);
  if (fio_asn1_iterator_next(&it, &oid) != 0)
    return FIO_X509_SIG_UNKNOWN;

  if (!fio_asn1_is_tag(&oid, FIO_ASN1_OID))
    return FIO_X509_SIG_UNKNOWN;

  /* Check against known OIDs */
  if (fio_asn1_oid_eq(&oid, FIO_OID_SHA256_WITH_RSA))
    return FIO_X509_SIG_RSA_PKCS1_SHA256;
  if (fio_asn1_oid_eq(&oid, FIO_OID_SHA384_WITH_RSA))
    return FIO_X509_SIG_RSA_PKCS1_SHA384;
  if (fio_asn1_oid_eq(&oid, FIO_OID_SHA512_WITH_RSA))
    return FIO_X509_SIG_RSA_PKCS1_SHA512;
  if (fio_asn1_oid_eq(&oid, FIO_OID_ECDSA_WITH_SHA256))
    return FIO_X509_SIG_ECDSA_SHA256;
  if (fio_asn1_oid_eq(&oid, FIO_OID_ECDSA_WITH_SHA384))
    return FIO_X509_SIG_ECDSA_SHA384;
  if (fio_asn1_oid_eq(&oid, FIO_OID_ED25519))
    return FIO_X509_SIG_ED25519;
  if (fio_asn1_oid_eq(&oid, FIO_OID_RSA_PSS)) {
    /* RSA-PSS - need to check parameters to determine hash */
    /* For simplicity, default to SHA-256 for now */
    /* TODO: Parse RSA-PSS parameters to determine actual hash */
    return FIO_X509_SIG_RSA_PSS_SHA256;
  }

  return FIO_X509_SIG_UNKNOWN;
}

/** Parse SubjectPublicKeyInfo to extract public key */
FIO_SFUNC int fio___x509_parse_pubkey(fio_x509_cert_s *cert,
                                      const fio_asn1_element_s *spki) {
  if (!cert || !spki)
    return -1;

  /*
   * SubjectPublicKeyInfo ::= SEQUENCE {
   *   algorithm        AlgorithmIdentifier,
   *   subjectPublicKey BIT STRING
   * }
   */
  fio_asn1_iterator_s it;
  fio_asn1_element_s alg_id, pubkey_bits;

  fio_asn1_iterator_init(&it, spki);

  /* Get AlgorithmIdentifier */
  if (fio_asn1_iterator_next(&it, &alg_id) != 0)
    return -1;
  if (!fio_asn1_is_tag(&alg_id, FIO_ASN1_SEQUENCE))
    return -1;

  /* Get BIT STRING containing public key */
  if (fio_asn1_iterator_next(&it, &pubkey_bits) != 0)
    return -1;
  if (!fio_asn1_is_tag(&pubkey_bits, FIO_ASN1_BIT_STRING))
    return -1;

  /* Parse the BIT STRING */
  const uint8_t *bits;
  size_t bit_len;
  uint8_t unused_bits;
  if (fio_asn1_parse_bit_string(&pubkey_bits, &bits, &bit_len, &unused_bits) !=
      0)
    return -1;

  /* Parse AlgorithmIdentifier to get key type */
  fio_asn1_iterator_s alg_it;
  fio_asn1_element_s oid, params;

  fio_asn1_iterator_init(&alg_it, &alg_id);
  if (fio_asn1_iterator_next(&alg_it, &oid) != 0)
    return -1;

  if (fio_asn1_oid_eq(&oid, FIO_OID_RSA_ENCRYPTION)) {
    /* RSA public key - bits contains SEQUENCE { n INTEGER, e INTEGER } */
    cert->key_type = FIO_X509_KEY_RSA;

    fio_asn1_element_s rsa_seq;
    if (!fio_asn1_parse(&rsa_seq, bits, bit_len))
      return -1;
    if (!fio_asn1_is_tag(&rsa_seq, FIO_ASN1_SEQUENCE))
      return -1;

    fio_asn1_iterator_s rsa_it;
    fio_asn1_element_s n_elem, e_elem;

    fio_asn1_iterator_init(&rsa_it, &rsa_seq);

    /* Get modulus (n) */
    if (fio_asn1_iterator_next(&rsa_it, &n_elem) != 0)
      return -1;
    if (!fio_asn1_is_tag(&n_elem, FIO_ASN1_INTEGER))
      return -1;

    /* Get exponent (e) */
    if (fio_asn1_iterator_next(&rsa_it, &e_elem) != 0)
      return -1;
    if (!fio_asn1_is_tag(&e_elem, FIO_ASN1_INTEGER))
      return -1;

    /* Store pointers - handle leading zero byte for positive integers */
    cert->pubkey.rsa.n = n_elem.data;
    cert->pubkey.rsa.n_len = n_elem.len;
    cert->pubkey.rsa.e = e_elem.data;
    cert->pubkey.rsa.e_len = e_elem.len;

    /* Skip leading zero byte if present (positive integer encoding) */
    if (cert->pubkey.rsa.n_len > 1 && cert->pubkey.rsa.n[0] == 0x00) {
      cert->pubkey.rsa.n++;
      cert->pubkey.rsa.n_len--;
    }
    if (cert->pubkey.rsa.e_len > 1 && cert->pubkey.rsa.e[0] == 0x00) {
      cert->pubkey.rsa.e++;
      cert->pubkey.rsa.e_len--;
    }

  } else if (fio_asn1_oid_eq(&oid, FIO_OID_EC_PUBLIC_KEY)) {
    /* ECDSA - need to check curve parameter */
    if (fio_asn1_iterator_next(&alg_it, &params) != 0)
      return -1;

    if (fio_asn1_oid_eq(&params, FIO_OID_SECP256R1)) {
      cert->key_type = FIO_X509_KEY_ECDSA_P256;
    } else if (fio_asn1_oid_eq(&params, FIO_OID_SECP384R1)) {
      cert->key_type = FIO_X509_KEY_ECDSA_P384;
    } else {
      return -1; /* Unsupported curve */
    }

    /* EC public key is the uncompressed point directly in BIT STRING */
    cert->pubkey.ecdsa.point = bits;
    cert->pubkey.ecdsa.point_len = bit_len;

  } else if (fio_asn1_oid_eq(&oid, FIO_OID_ED25519)) {
    /* Ed25519 - public key is 32 bytes directly in BIT STRING */
    cert->key_type = FIO_X509_KEY_ED25519;

    if (bit_len != 32)
      return -1; /* Ed25519 public key must be 32 bytes */

    cert->pubkey.ed25519.key = bits;

  } else {
    cert->key_type = FIO_X509_KEY_UNKNOWN;
  }

  return 0;
}

/** Extract Common Name from a Name sequence */
FIO_SFUNC void fio___x509_extract_cn(fio_x509_cert_s *cert,
                                     const fio_asn1_element_s *name) {
  if (!cert || !name)
    return;

  /*
   * Name ::= SEQUENCE OF RelativeDistinguishedName
   * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
   * AttributeTypeAndValue ::= SEQUENCE { type OID, value ANY }
   */
  fio_asn1_iterator_s name_it;
  fio_asn1_element_s rdn;

  fio_asn1_iterator_init(&name_it, name);

  while (fio_asn1_iterator_next(&name_it, &rdn) == 0) {
    if (!fio_asn1_is_tag(&rdn, FIO_ASN1_SET))
      continue;

    fio_asn1_iterator_s rdn_it;
    fio_asn1_element_s atv;

    fio_asn1_iterator_init(&rdn_it, &rdn);

    while (fio_asn1_iterator_next(&rdn_it, &atv) == 0) {
      if (!fio_asn1_is_tag(&atv, FIO_ASN1_SEQUENCE))
        continue;

      fio_asn1_iterator_s atv_it;
      fio_asn1_element_s type_oid, value;

      fio_asn1_iterator_init(&atv_it, &atv);

      if (fio_asn1_iterator_next(&atv_it, &type_oid) != 0)
        continue;
      if (fio_asn1_iterator_next(&atv_it, &value) != 0)
        continue;

      /* Check if this is Common Name */
      if (fio_asn1_oid_eq(&type_oid, FIO_OID_COMMON_NAME)) {
        size_t len;
        const char *cn = fio_asn1_parse_string(&value, &len);
        if (cn) {
          cert->subject_cn = cn;
          cert->subject_cn_len = len;
        }
        return;
      }
    }
  }
}

/** Parse X.509v3 extensions */
FIO_SFUNC void fio___x509_parse_extensions(fio_x509_cert_s *cert,
                                           const fio_asn1_element_s *exts) {
  if (!cert || !exts)
    return;

  /*
   * Extensions ::= SEQUENCE OF Extension
   * Extension ::= SEQUENCE {
   *   extnID      OID,
   *   critical    BOOLEAN DEFAULT FALSE,
   *   extnValue   OCTET STRING (DER-encoded extension value)
   * }
   */
  fio_asn1_iterator_s exts_it;
  fio_asn1_element_s ext;

  fio_asn1_iterator_init(&exts_it, exts);

  while (fio_asn1_iterator_next(&exts_it, &ext) == 0) {
    if (!fio_asn1_is_tag(&ext, FIO_ASN1_SEQUENCE))
      continue;

    fio_asn1_iterator_s ext_it;
    fio_asn1_element_s oid, elem;

    fio_asn1_iterator_init(&ext_it, &ext);

    /* Get extension OID */
    if (fio_asn1_iterator_next(&ext_it, &oid) != 0)
      continue;

    /* Skip critical flag if present, get value */
    if (fio_asn1_iterator_next(&ext_it, &elem) != 0)
      continue;

    /* If BOOLEAN (critical), skip to get OCTET STRING */
    const fio_asn1_element_s *value = &elem;
    fio_asn1_element_s value_storage;
    if (fio_asn1_is_tag(&elem, FIO_ASN1_BOOLEAN)) {
      if (fio_asn1_iterator_next(&ext_it, &value_storage) != 0)
        continue;
      value = &value_storage;
    }

    if (!fio_asn1_is_tag(value, FIO_ASN1_OCTET_STRING))
      continue;

    /* Parse based on extension type */
    if (fio_asn1_oid_eq(&oid, FIO_OID_BASIC_CONSTRAINTS)) {
      /* BasicConstraints ::= SEQUENCE { cA BOOLEAN DEFAULT FALSE, ... } */
      fio_asn1_element_s bc_seq;
      if (fio_asn1_parse(&bc_seq, value->data, value->len)) {
        if (fio_asn1_is_tag(&bc_seq, FIO_ASN1_SEQUENCE)) {
          fio_asn1_iterator_s bc_it;
          fio_asn1_element_s ca_elem;

          fio_asn1_iterator_init(&bc_it, &bc_seq);
          if (fio_asn1_iterator_next(&bc_it, &ca_elem) == 0) {
            if (fio_asn1_is_tag(&ca_elem, FIO_ASN1_BOOLEAN)) {
              int ca_val;
              if (fio_asn1_parse_boolean(&ca_elem, &ca_val) == 0) {
                cert->is_ca = ca_val;
              }
            }
          }
        }
      }
    } else if (fio_asn1_oid_eq(&oid, FIO_OID_KEY_USAGE)) {
      /* KeyUsage ::= BIT STRING */
      fio_asn1_element_s ku_bits;
      if (fio_asn1_parse(&ku_bits, value->data, value->len)) {
        if (fio_asn1_is_tag(&ku_bits, FIO_ASN1_BIT_STRING)) {
          const uint8_t *bits;
          size_t bit_len;
          uint8_t unused;
          if (fio_asn1_parse_bit_string(&ku_bits, &bits, &bit_len, &unused) ==
              0) {
            cert->has_key_usage = 1;
            if (bit_len >= 1) {
              cert->key_usage = bits[0];
              if (bit_len >= 2)
                cert->key_usage |= (uint16_t)bits[1] << 8;
            }
          }
        }
      }
    } else if (fio_asn1_oid_eq(&oid, FIO_OID_SUBJECT_ALT_NAME)) {
      /* SubjectAltName ::= GeneralNames = SEQUENCE OF GeneralName
       * GeneralName ::= CHOICE { dNSName [2] IA5String, ... }
       */
      /* Store raw SAN extension data for later iteration */
      cert->san_ext_data = value->data;
      cert->san_ext_len = value->len;

      fio_asn1_element_s san_seq;
      if (fio_asn1_parse(&san_seq, value->data, value->len)) {
        if (fio_asn1_is_tag(&san_seq, FIO_ASN1_SEQUENCE)) {
          fio_asn1_iterator_s san_it;
          fio_asn1_element_s gn;

          fio_asn1_iterator_init(&san_it, &san_seq);

          while (fio_asn1_iterator_next(&san_it, &gn) == 0) {
            /* dNSName is context tag [2] */
            if (fio_asn1_is_context_tag(&gn, 2)) {
              /* Store first DNS name only (for backward compatibility) */
              if (!cert->san_dns) {
                cert->san_dns = (const char *)gn.data;
                cert->san_dns_len = gn.len;
              }
            }
          }
        }
      }
    }
  }
}

/* *****************************************************************************
Implementation - Main Parsing Function
***************************************************************************** */

SFUNC int fio_x509_parse(fio_x509_cert_s *cert,
                         const uint8_t *der_data,
                         size_t der_len) {
  if (!cert || !der_data || der_len == 0)
    return -1;

  /* Zero the certificate structure */
  FIO_MEMSET(cert, 0, sizeof(*cert));

  /*
   * Certificate ::= SEQUENCE {
   *   tbsCertificate       TBSCertificate,
   *   signatureAlgorithm   AlgorithmIdentifier,
   *   signatureValue       BIT STRING
   * }
   */
  fio_asn1_element_s cert_seq;
  if (!fio_asn1_parse(&cert_seq, der_data, der_len))
    return -1;

  if (!fio_asn1_is_tag(&cert_seq, FIO_ASN1_SEQUENCE))
    return -1;

  fio_asn1_iterator_s cert_it;
  fio_asn1_element_s tbs, sig_alg, sig_value;

  fio_asn1_iterator_init(&cert_it, &cert_seq);

  /* Parse tbsCertificate */
  if (fio_asn1_iterator_next(&cert_it, &tbs) != 0)
    return -1;
  if (!fio_asn1_is_tag(&tbs, FIO_ASN1_SEQUENCE))
    return -1;

  /* Store TBS data for signature verification */
  cert->tbs_data =
      der_data + (tbs.data - cert_seq.data) -
      (tbs.data > der_data ? (tbs.data - der_data) - (tbs.data - cert_seq.data)
                           : 0);
  /* Calculate proper TBS bounds including tag and length */
  {
    const uint8_t *tbs_start = tbs.data;
    /* Walk backwards to find the tag byte */
    while (tbs_start > der_data && tbs_start[-1] != 0x30)
      --tbs_start;
    if (tbs_start > der_data)
      --tbs_start;
    cert->tbs_data = tbs_start;
    cert->tbs_len = (tbs.data + tbs.len) - tbs_start;
  }

  /* Parse signatureAlgorithm */
  if (fio_asn1_iterator_next(&cert_it, &sig_alg) != 0)
    return -1;
  if (!fio_asn1_is_tag(&sig_alg, FIO_ASN1_SEQUENCE))
    return -1;

  cert->sig_alg = fio___x509_parse_sig_alg(&sig_alg);

  /* Parse signatureValue (BIT STRING) */
  if (fio_asn1_iterator_next(&cert_it, &sig_value) != 0)
    return -1;
  if (!fio_asn1_is_tag(&sig_value, FIO_ASN1_BIT_STRING))
    return -1;

  {
    const uint8_t *bits;
    size_t bit_len;
    uint8_t unused;
    if (fio_asn1_parse_bit_string(&sig_value, &bits, &bit_len, &unused) != 0)
      return -1;
    cert->signature = bits;
    cert->signature_len = bit_len;
  }

  /*
   * TBSCertificate ::= SEQUENCE {
   *   version         [0]  EXPLICIT Version DEFAULT v1,
   *   serialNumber         CertificateSerialNumber,
   *   signature            AlgorithmIdentifier,
   *   issuer               Name,
   *   validity             Validity,
   *   subject              Name,
   *   subjectPublicKeyInfo SubjectPublicKeyInfo,
   *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
   *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
   *   extensions      [3]  EXPLICIT Extensions OPTIONAL
   * }
   */
  fio_asn1_iterator_s tbs_it;
  fio_asn1_element_s elem;

  fio_asn1_iterator_init(&tbs_it, &tbs);

  /* Get first element - may be version or serial */
  if (fio_asn1_iterator_next(&tbs_it, &elem) != 0)
    return -1;

  /* Check for version (context tag [0]) */
  if (fio_asn1_is_context_tag(&elem, 0)) {
    /* Parse version */
    fio_asn1_element_s version_int;
    if (fio_asn1_parse(&version_int, elem.data, elem.len)) {
      uint64_t ver;
      if (fio_asn1_parse_integer(&version_int, &ver) == 0) {
        cert->version = (int)ver;
      }
    }
    /* Get next element (serial number) */
    if (fio_asn1_iterator_next(&tbs_it, &elem) != 0)
      return -1;
  } else {
    cert->version = 0; /* v1 (default) */
  }

  /* Skip serialNumber (INTEGER) */
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_INTEGER))
    return -1;

  /* Skip signature (AlgorithmIdentifier) */
  if (fio_asn1_iterator_next(&tbs_it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_SEQUENCE))
    return -1;

  /* Parse issuer (Name = SEQUENCE) */
  if (fio_asn1_iterator_next(&tbs_it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_SEQUENCE))
    return -1;

  /* Store issuer DN (including tag and length for comparison) */
  {
    const uint8_t *issuer_start = elem.data;
    while (issuer_start > tbs.data && issuer_start[-1] != 0x30)
      --issuer_start;
    if (issuer_start > tbs.data)
      --issuer_start;
    cert->issuer_der = issuer_start;
    cert->issuer_der_len = (elem.data + elem.len) - issuer_start;
  }

  /* Parse validity (SEQUENCE { notBefore, notAfter }) */
  if (fio_asn1_iterator_next(&tbs_it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_SEQUENCE))
    return -1;

  {
    fio_asn1_iterator_s val_it;
    fio_asn1_element_s not_before, not_after;

    fio_asn1_iterator_init(&val_it, &elem);

    if (fio_asn1_iterator_next(&val_it, &not_before) == 0) {
      fio_asn1_parse_time(&not_before, &cert->not_before);
    }
    if (fio_asn1_iterator_next(&val_it, &not_after) == 0) {
      fio_asn1_parse_time(&not_after, &cert->not_after);
    }
  }

  /* Parse subject (Name = SEQUENCE) */
  if (fio_asn1_iterator_next(&tbs_it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_SEQUENCE))
    return -1;

  /* Store subject DN */
  {
    const uint8_t *subject_start = elem.data;
    while (subject_start > tbs.data && subject_start[-1] != 0x30)
      --subject_start;
    if (subject_start > tbs.data)
      --subject_start;
    cert->subject_der = subject_start;
    cert->subject_der_len = (elem.data + elem.len) - subject_start;
  }

  /* Extract Common Name */
  fio___x509_extract_cn(cert, &elem);

  /* Parse subjectPublicKeyInfo (SEQUENCE) */
  if (fio_asn1_iterator_next(&tbs_it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_SEQUENCE))
    return -1;

  if (fio___x509_parse_pubkey(cert, &elem) != 0)
    return -1;

  /* Check for extensions [3] (v3 only) */
  while (fio_asn1_iterator_next(&tbs_it, &elem) == 0) {
    if (fio_asn1_is_context_tag(&elem, 3)) {
      /* Extensions wrapped in context tag [3] */
      fio_asn1_element_s exts;
      if (fio_asn1_parse(&exts, elem.data, elem.len)) {
        if (fio_asn1_is_tag(&exts, FIO_ASN1_SEQUENCE)) {
          fio___x509_parse_extensions(cert, &exts);
        }
      }
      break;
    }
  }

  return 0;
}

/* *****************************************************************************
Implementation - Hostname Matching
***************************************************************************** */

/** Case-insensitive character comparison */
FIO_SFUNC int fio___x509_char_eq_nocase(char a, char b) {
  /* Convert to lowercase */
  char la = a | (char)((uint8_t)(a >= 'A' && a <= 'Z') << 5);
  char lb = b | (char)((uint8_t)(b >= 'A' && b <= 'Z') << 5);
  return la == lb;
}

/** Match a single hostname against a pattern (with wildcard support) */
FIO_SFUNC int fio___x509_match_name(const char *pattern,
                                    size_t pattern_len,
                                    const char *hostname,
                                    size_t hostname_len) {
  if (!pattern || !hostname || pattern_len == 0 || hostname_len == 0)
    return -1;

  /* Check for wildcard pattern */
  if (pattern_len >= 2 && pattern[0] == '*' && pattern[1] == '.') {
    /* Wildcard certificate: *.example.com
     * Per RFC 6125: wildcard matches only one label
     */
    const char *pattern_rest = pattern + 2;
    size_t pattern_rest_len = pattern_len - 2;

    /* Find first dot in hostname */
    size_t dot_pos = 0;
    for (size_t i = 0; i < hostname_len; ++i) {
      if (hostname[i] == '.') {
        dot_pos = i;
        break;
      }
    }

    /* Hostname must have at least one label before the matched part */
    if (dot_pos == 0 || dot_pos == hostname_len - 1)
      return -1;

    /* Compare rest of pattern with rest of hostname (after first dot) */
    const char *hostname_rest = hostname + dot_pos + 1;
    size_t hostname_rest_len = hostname_len - dot_pos - 1;

    if (pattern_rest_len != hostname_rest_len)
      return -1;

    for (size_t i = 0; i < pattern_rest_len; ++i) {
      if (!fio___x509_char_eq_nocase(pattern_rest[i], hostname_rest[i]))
        return -1;
    }

    return 0;
  }

  /* Exact match (case-insensitive) */
  if (pattern_len != hostname_len)
    return -1;

  for (size_t i = 0; i < pattern_len; ++i) {
    if (!fio___x509_char_eq_nocase(pattern[i], hostname[i]))
      return -1;
  }

  return 0;
}

SFUNC int fio_x509_match_hostname(const fio_x509_cert_s *cert,
                                  const char *hostname,
                                  size_t hostname_len) {
  if (!cert || !hostname || hostname_len == 0)
    return -1;

  FIO_LOG_DEBUG2("X.509 hostname match: checking '%.*s'",
                 (int)hostname_len,
                 hostname);

  /* Per RFC 6125: If SAN extension is present, check ALL SAN DNS names */
  if (cert->san_ext_data && cert->san_ext_len > 0) {
    FIO_LOG_DEBUG2("X.509 hostname match: SAN extension present (%zu bytes)",
                   cert->san_ext_len);
    /* Re-parse the SAN extension to iterate through all DNS names */
    fio_asn1_element_s san_seq;
    if (fio_asn1_parse(&san_seq, cert->san_ext_data, cert->san_ext_len)) {
      if (fio_asn1_is_tag(&san_seq, FIO_ASN1_SEQUENCE)) {
        fio_asn1_iterator_s san_it;
        fio_asn1_element_s gn;

        fio_asn1_iterator_init(&san_it, &san_seq);

        while (fio_asn1_iterator_next(&san_it, &gn) == 0) {
          /* dNSName is context tag [2] */
          if (fio_asn1_is_context_tag(&gn, 2)) {
            FIO_LOG_DEBUG2("X.509 hostname match: SAN DNS name: '%.*s'",
                           (int)gn.len,
                           (const char *)gn.data);
            /* Try to match this DNS name */
            if (fio___x509_match_name((const char *)gn.data,
                                      gn.len,
                                      hostname,
                                      hostname_len) == 0) {
              FIO_LOG_DEBUG2("X.509 hostname match: MATCH FOUND");
              return 0; /* Match found */
            }
          }
        }
      }
    }
    /* SAN extension present but no match found - do NOT fall back to CN */
    FIO_LOG_DEBUG2("X.509 hostname match: no SAN match found");
    return -1;
  }

  /* Check if san_dns is set directly (without raw extension data) */
  if (cert->san_dns && cert->san_dns_len > 0) {
    FIO_LOG_DEBUG2("X.509 hostname match: SAN DNS set directly: '%.*s'",
                   (int)cert->san_dns_len,
                   cert->san_dns);
    if (fio___x509_match_name(cert->san_dns,
                              cert->san_dns_len,
                              hostname,
                              hostname_len) == 0) {
      FIO_LOG_DEBUG2("X.509 hostname match: MATCH FOUND");
      return 0;
    }
    /* SAN present but no match - do NOT fall back to CN */
    FIO_LOG_DEBUG2("X.509 hostname match: no SAN match found");
    return -1;
  }

  /* No SAN extension present - fall back to Common Name */
  FIO_LOG_DEBUG2("X.509 hostname match: no SAN, checking CN");
  if (cert->subject_cn && cert->subject_cn_len > 0) {
    FIO_LOG_DEBUG2("X.509 hostname match: CN='%.*s'",
                   (int)cert->subject_cn_len,
                   cert->subject_cn);
    return fio___x509_match_name(cert->subject_cn,
                                 cert->subject_cn_len,
                                 hostname,
                                 hostname_len);
  }

  FIO_LOG_DEBUG2("X.509 hostname match: no CN either");
  return -1;
}

/* *****************************************************************************
Implementation - Signature Verification
***************************************************************************** */

SFUNC int fio_x509_verify_signature(const fio_x509_cert_s *cert,
                                    const fio_x509_cert_s *issuer) {
  if (!cert || !issuer)
    return -1;

  if (!cert->tbs_data || cert->tbs_len == 0)
    return -1;
  if (!cert->signature || cert->signature_len == 0)
    return -1;

  /* Hash the TBS certificate data based on signature algorithm */
  uint8_t hash[64]; /* Max hash size (SHA-512) */
  size_t hash_len = 0;

  switch (cert->sig_alg) {
  case FIO_X509_SIG_RSA_PKCS1_SHA256:
  case FIO_X509_SIG_RSA_PSS_SHA256:
  case FIO_X509_SIG_ECDSA_SHA256: {
    fio_u256 h = fio_sha256(cert->tbs_data, cert->tbs_len);
    FIO_MEMCPY(hash, h.u8, 32);
    hash_len = 32;
    break;
  }
  case FIO_X509_SIG_RSA_PKCS1_SHA384:
  case FIO_X509_SIG_RSA_PSS_SHA384:
  case FIO_X509_SIG_ECDSA_SHA384: {
    /* SHA-384 is truncated SHA-512 - we use fio_sha512 and truncate */
    fio_sha512_s sh = fio_sha512_init();
    /* Modify initial hash values for SHA-384 */
    sh.hash.u64[0] = 0xCBBB9D5DC1059ED8ULL;
    sh.hash.u64[1] = 0x629A292A367CD507ULL;
    sh.hash.u64[2] = 0x9159015A3070DD17ULL;
    sh.hash.u64[3] = 0x152FECD8F70E5939ULL;
    sh.hash.u64[4] = 0x67332667FFC00B31ULL;
    sh.hash.u64[5] = 0x8EB44A8768581511ULL;
    sh.hash.u64[6] = 0xDB0C2E0D64F98FA7ULL;
    sh.hash.u64[7] = 0x47B5481DBEFA4FA4ULL;
    fio_sha512_consume(&sh, cert->tbs_data, cert->tbs_len);
    fio_u512 h = fio_sha512_finalize(&sh);
    FIO_MEMCPY(hash, h.u8, 48);
    hash_len = 48;
    break;
  }
  case FIO_X509_SIG_RSA_PKCS1_SHA512:
  case FIO_X509_SIG_RSA_PSS_SHA512: {
    fio_u512 h = fio_sha512(cert->tbs_data, cert->tbs_len);
    FIO_MEMCPY(hash, h.u8, 64);
    hash_len = 64;
    break;
  }
  case FIO_X509_SIG_ED25519: {
    /* Ed25519 doesn't pre-hash - the data is hashed internally */
    /* Verification would be done directly with fio_ed25519_verify */
    break;
  }
  default: return -1; /* Unknown algorithm */
  }

  /* Verify signature based on issuer's key type */
  switch (issuer->key_type) {
  case FIO_X509_KEY_RSA: {
    if (!issuer->pubkey.rsa.n || !issuer->pubkey.rsa.e)
      return -1;

    fio_rsa_pubkey_s rsa_key = {
        .n = issuer->pubkey.rsa.n,
        .n_len = issuer->pubkey.rsa.n_len,
        .e = issuer->pubkey.rsa.e,
        .e_len = issuer->pubkey.rsa.e_len,
    };

    fio_rsa_hash_e rsa_hash;
    switch (hash_len) {
    case 32: rsa_hash = FIO_RSA_HASH_SHA256; break;
    case 48: rsa_hash = FIO_RSA_HASH_SHA384; break;
    case 64: rsa_hash = FIO_RSA_HASH_SHA512; break;
    default: return -1;
    }

    switch (cert->sig_alg) {
    case FIO_X509_SIG_RSA_PKCS1_SHA256:
    case FIO_X509_SIG_RSA_PKCS1_SHA384:
    case FIO_X509_SIG_RSA_PKCS1_SHA512:
      return fio_rsa_verify_pkcs1(cert->signature,
                                  cert->signature_len,
                                  hash,
                                  hash_len,
                                  rsa_hash,
                                  &rsa_key);
    case FIO_X509_SIG_RSA_PSS_SHA256:
    case FIO_X509_SIG_RSA_PSS_SHA384:
    case FIO_X509_SIG_RSA_PSS_SHA512:
      return fio_rsa_verify_pss(cert->signature,
                                cert->signature_len,
                                hash,
                                hash_len,
                                rsa_hash,
                                &rsa_key);
    default: return -1;
    }
  }

  case FIO_X509_KEY_ECDSA_P256:
  case FIO_X509_KEY_ECDSA_P384: {
#if defined(H___FIO_P256___H)
    /* ECDSA P-256 verification */
    if (issuer->key_type == FIO_X509_KEY_ECDSA_P256) {
      if (!issuer->pubkey.ecdsa.point || issuer->pubkey.ecdsa.point_len != 65)
        return -1;

      /* P-256 uses SHA-256, verify hash_len matches */
      if (hash_len != 32)
        return -1;

      return fio_ecdsa_p256_verify(cert->signature,
                                   cert->signature_len,
                                   hash,
                                   issuer->pubkey.ecdsa.point,
                                   issuer->pubkey.ecdsa.point_len);
    }
#endif
#if defined(H___FIO_P384___H)
    /* ECDSA P-384 verification */
    if (issuer->key_type == FIO_X509_KEY_ECDSA_P384) {
      if (!issuer->pubkey.ecdsa.point || issuer->pubkey.ecdsa.point_len != 97)
        return -1;

      /* P-384 uses SHA-384, verify hash_len matches */
      if (hash_len != 48)
        return -1;

      return fio_ecdsa_p384_verify(cert->signature,
                                   cert->signature_len,
                                   hash,
                                   issuer->pubkey.ecdsa.point,
                                   issuer->pubkey.ecdsa.point_len);
    }
#endif
    /* Unsupported ECDSA curve */
    return -1;
  }

  case FIO_X509_KEY_ED25519: {
#if defined(H___FIO_ED25519___H)
    /* Ed25519 verification */
    if (!issuer->pubkey.ed25519.key)
      return -1;

    /* Ed25519 signature should be 64 bytes */
    if (cert->signature_len != 64)
      return -1;

    return fio_ed25519_verify(cert->signature,
                              cert->tbs_data,
                              cert->tbs_len,
                              issuer->pubkey.ed25519.key);
#else
    return -1;
#endif
  }

  default: return -1;
  }
}

/* *****************************************************************************
Implementation - Certificate Chain Validation
***************************************************************************** */

/** Maximum certificate chain depth (prevents DoS via deep chains) */
#ifndef FIO_X509_MAX_CHAIN_DEPTH
#define FIO_X509_MAX_CHAIN_DEPTH 10
#endif

SFUNC int fio_x509_is_trusted(const fio_x509_cert_s *cert,
                              fio_x509_trust_store_s *trust_store) {
  if (!cert || !trust_store)
    return -1;
  if (!trust_store->roots || trust_store->root_count == 0)
    return -1;

  /* Check each root certificate in the trust store */
  for (size_t i = 0; i < trust_store->root_count; ++i) {
    if (!trust_store->roots[i] || trust_store->root_lens[i] == 0)
      continue;

    /* Parse the root certificate */
    fio_x509_cert_s root;
    if (fio_x509_parse(&root,
                       trust_store->roots[i],
                       trust_store->root_lens[i]) != 0)
      continue;

    /* Compare subject DNs (the cert's issuer should match root's subject) */
    if (fio_x509_dn_equals(cert->issuer_der,
                           cert->issuer_der_len,
                           root.subject_der,
                           root.subject_der_len) == 0) {
      return 0; /* Found trusted root */
    }

    /* Also check if the cert itself is a trusted root */
    if (fio_x509_dn_equals(cert->subject_der,
                           cert->subject_der_len,
                           root.subject_der,
                           root.subject_der_len) == 0) {
      return 0; /* Cert is in trust store */
    }
  }

  return -1; /* Not found in trust store */
}

/**
 * Find issuing certificate in trust store for signature verification.
 * Returns 0 if found and parsed into `issuer`, -1 if not found.
 */
FIO_SFUNC int fio___x509_find_issuer_in_trust_store(
    fio_x509_cert_s *issuer,
    const fio_x509_cert_s *cert,
    fio_x509_trust_store_s *trust_store) {
  if (!issuer || !cert || !trust_store)
    return -1;
  if (!trust_store->roots || trust_store->root_count == 0)
    return -1;

  for (size_t i = 0; i < trust_store->root_count; ++i) {
    if (!trust_store->roots[i] || trust_store->root_lens[i] == 0)
      continue;

    if (fio_x509_parse(issuer,
                       trust_store->roots[i],
                       trust_store->root_lens[i]) != 0)
      continue;

    /* Check if this root's subject matches cert's issuer */
    if (fio_x509_dn_equals(cert->issuer_der,
                           cert->issuer_der_len,
                           issuer->subject_der,
                           issuer->subject_der_len) == 0) {
      return 0; /* Found issuer */
    }
  }

  return -1; /* Not found */
}

SFUNC int fio_x509_verify_chain(const uint8_t **certs,
                                const size_t *cert_lens,
                                size_t cert_count,
                                const char *hostname,
                                int64_t current_time,
                                fio_x509_trust_store_s *trust_store) {
  /* Validate inputs */
  if (!certs || !cert_lens)
    return FIO_X509_ERR_PARSE;
  if (cert_count == 0)
    return FIO_X509_ERR_EMPTY_CHAIN;
  if (cert_count > FIO_X509_MAX_CHAIN_DEPTH)
    return FIO_X509_ERR_CHAIN_TOO_LONG;

  /* Parse all certificates in the chain */
  fio_x509_cert_s chain[FIO_X509_MAX_CHAIN_DEPTH];

  for (size_t i = 0; i < cert_count; ++i) {
    if (!certs[i] || cert_lens[i] == 0) {
      FIO_LOG_DEBUG("X.509 chain: certificate %zu is empty", i);
      return FIO_X509_ERR_PARSE;
    }

    if (fio_x509_parse(&chain[i], certs[i], cert_lens[i]) != 0) {
      FIO_LOG_DEBUG("X.509 chain: failed to parse certificate %zu", i);
      return FIO_X509_ERR_PARSE;
    }

    /* Check validity period */
    if (current_time < chain[i].not_before) {
      FIO_LOG_DEBUG("X.509 chain: certificate %zu not yet valid", i);
      return FIO_X509_ERR_NOT_YET_VALID;
    }
    if (current_time > chain[i].not_after) {
      FIO_LOG_DEBUG("X.509 chain: certificate %zu expired", i);
      return FIO_X509_ERR_EXPIRED;
    }
  }

  /* Check hostname on end-entity certificate (index 0) */
  if (hostname) {
    size_t hostname_len = FIO_STRLEN(hostname);
    if (fio_x509_match_hostname(&chain[0], hostname, hostname_len) != 0) {
      FIO_LOG_DEBUG("X.509 chain: hostname mismatch for '%s'", hostname);
      return FIO_X509_ERR_HOSTNAME_MISMATCH;
    }
  }

  /* Verify chain signatures and issuer relationships */
  for (size_t i = 0; i < cert_count - 1; ++i) {
    /* Verify issuer DN of cert[i] matches subject DN of cert[i+1] */
    if (fio_x509_dn_equals(chain[i].issuer_der,
                           chain[i].issuer_der_len,
                           chain[i + 1].subject_der,
                           chain[i + 1].subject_der_len) != 0) {
      FIO_LOG_DEBUG("X.509 chain: issuer mismatch at position %zu", i);
      return FIO_X509_ERR_ISSUER_MISMATCH;
    }

    /* Verify that the issuer (i+1) is a CA certificate */
    if (!chain[i + 1].is_ca) {
      /* Check if it's a self-signed root (may not have BasicConstraints) */
      int is_self_signed =
          fio_x509_dn_equals(chain[i + 1].issuer_der,
                             chain[i + 1].issuer_der_len,
                             chain[i + 1].subject_der,
                             chain[i + 1].subject_der_len) == 0;
      /* Allow self-signed certs even without CA flag for compatibility */
      if (!is_self_signed) {
        FIO_LOG_DEBUG("X.509 chain: certificate %zu is not a CA", i + 1);
        return FIO_X509_ERR_NOT_CA;
      }
    }

    /* Verify signature of cert[i] using public key from cert[i+1] */
    if (fio_x509_verify_signature(&chain[i], &chain[i + 1]) != 0) {
      FIO_LOG_DEBUG("X.509 chain: signature verification failed at %zu", i);
      return FIO_X509_ERR_SIGNATURE;
    }
  }

  /* Handle the last certificate in the chain */
  size_t last = cert_count - 1;

  /* Check if the last certificate is self-signed */
  int is_self_signed = fio_x509_dn_equals(chain[last].issuer_der,
                                          chain[last].issuer_der_len,
                                          chain[last].subject_der,
                                          chain[last].subject_der_len) == 0;

  if (is_self_signed) {
    /* Self-signed: verify its own signature */
    if (fio_x509_verify_signature(&chain[last], &chain[last]) != 0) {
      FIO_LOG_DEBUG("X.509 chain: self-signed root signature invalid");
      return FIO_X509_ERR_SIGNATURE;
    }

    /* Check if self-signed root is in trust store */
    if (trust_store) {
      if (fio_x509_is_trusted(&chain[last], trust_store) != 0) {
        FIO_LOG_DEBUG("X.509 chain: self-signed root not in trust store");
        return FIO_X509_ERR_NO_TRUST_ANCHOR;
      }
    }
  } else {
    /* Not self-signed: must be signed by a certificate in trust store */
    if (trust_store) {
      /* Find issuer in trust store */
      fio_x509_cert_s issuer;
      if (fio___x509_find_issuer_in_trust_store(&issuer,
                                                &chain[last],
                                                trust_store) != 0) {
        FIO_LOG_DEBUG("X.509 chain: issuer not found in trust store");
        return FIO_X509_ERR_NO_TRUST_ANCHOR;
      }

      /* Verify signature using trust store certificate */
      if (fio_x509_verify_signature(&chain[last], &issuer) != 0) {
        FIO_LOG_DEBUG("X.509 chain: signature by trusted CA failed");
        return FIO_X509_ERR_SIGNATURE;
      }
    }
  }

  FIO_LOG_DEBUG("X.509 chain: validation successful (%zu certificates)",
                cert_count);
  return FIO_X509_OK;
}

SFUNC size_t fio_tls_parse_certificate_message(fio_tls_cert_entry_s *entries,
                                               size_t max_entries,
                                               const uint8_t *data,
                                               size_t data_len) {
  if (!entries || max_entries == 0 || !data || data_len == 0)
    return FIO_TLS_CERT_PARSE_ERROR;

  const uint8_t *p = data;
  const uint8_t *end = data + data_len;

  /*
   * TLS 1.3 Certificate message format (RFC 8446 Section 4.4.2):
   *
   * struct {
   *     opaque certificate_request_context<0..2^8-1>;
   *     CertificateEntry certificate_list<0..2^24-1>;
   * } Certificate;
   *
   * struct {
   *     opaque cert_data<1..2^24-1>;
   *     Extension extensions<0..2^16-1>;
   * } CertificateEntry;
   */

  /* Parse certificate_request_context length (1 byte) */
  if (p >= end)
    return FIO_TLS_CERT_PARSE_ERROR;
  uint8_t ctx_len = *p++;
  if (p + ctx_len > end)
    return FIO_TLS_CERT_PARSE_ERROR;
  p += ctx_len; /* Skip context (usually empty for server certificates) */

  /* Parse certificate_list length (3 bytes, big-endian) */
  if (p + 3 > end)
    return FIO_TLS_CERT_PARSE_ERROR;
  size_t list_len = ((size_t)p[0] << 16) | ((size_t)p[1] << 8) | p[2];
  p += 3;

  if (p + list_len > end)
    return FIO_TLS_CERT_PARSE_ERROR;

  const uint8_t *list_end = p + list_len;
  size_t count = 0;

  /* Parse each CertificateEntry */
  while (p < list_end && count < max_entries) {
    /* cert_data length (3 bytes, big-endian) */
    if (p + 3 > list_end)
      return FIO_TLS_CERT_PARSE_ERROR;
    size_t cert_len = ((size_t)p[0] << 16) | ((size_t)p[1] << 8) | p[2];
    p += 3;

    if (cert_len == 0 || p + cert_len > list_end)
      return FIO_TLS_CERT_PARSE_ERROR;

    /* Store certificate entry */
    entries[count].cert = p;
    entries[count].cert_len = cert_len;
    ++count;
    p += cert_len;

    /* extensions length (2 bytes, big-endian) */
    if (p + 2 > list_end)
      return FIO_TLS_CERT_PARSE_ERROR;
    size_t ext_len = ((size_t)p[0] << 8) | p[1];
    p += 2;

    if (p + ext_len > list_end)
      return FIO_TLS_CERT_PARSE_ERROR;
    p += ext_len; /* Skip extensions */
  }

  return count;
}

/* *****************************************************************************
X.509 Certificate Generation API
***************************************************************************** */

/** Key pair types for certificate generation */
typedef enum {
  FIO_X509_KEYPAIR_ED25519 = 1, /**< Ed25519 (preferred) */
  FIO_X509_KEYPAIR_P256 = 2,    /**< ECDSA P-256 */
} fio_x509_keypair_type_e;

/** Key pair structure for certificate generation */
typedef struct {
  fio_x509_keypair_type_e type; /**< Key type */
  uint8_t secret_key[64];       /**< Secret key (32 bytes for Ed25519, P-256) */
  uint8_t public_key[65]; /**< Public key (32 for Ed25519, 65 for P-256) */
  size_t secret_key_len;  /**< Actual secret key length */
  size_t public_key_len;  /**< Actual public key length */
} fio_x509_keypair_s;

/** Certificate generation options */
typedef struct {
  const char *subject_cn;  /**< Subject Common Name (required) */
  size_t subject_cn_len;   /**< Length of subject_cn (0 = use strlen) */
  const char *subject_org; /**< Subject Organization (optional) */
  size_t subject_org_len;  /**< Length of subject_org */
  const char *subject_ou;  /**< Subject Organizational Unit (optional) */
  size_t subject_ou_len;   /**< Length of subject_ou */
  const char *subject_c;   /**< Subject Country (optional, 2 chars) */
  int64_t not_before;      /**< Validity start (Unix timestamp, 0 = now) */
  int64_t not_after;       /**< Validity end (Unix timestamp, 0 = +1 year) */
  const char **san_dns;    /**< Subject Alternative Names (DNS) */
  size_t san_dns_count;    /**< Number of SAN DNS entries */
  int is_ca;               /**< Set CA:TRUE in BasicConstraints */
  uint16_t key_usage;      /**< Key Usage bits (0 = default for type) */
} fio_x509_cert_options_s;

/**
 * Generate an Ed25519 key pair for certificate signing.
 *
 * @param keypair Output key pair structure
 * @return 0 on success, -1 on error
 */
SFUNC int fio_x509_keypair_ed25519(fio_x509_keypair_s *keypair);

/**
 * Generate a P-256 key pair for certificate signing.
 *
 * @param keypair Output key pair structure
 * @return 0 on success, -1 on error
 */
SFUNC int fio_x509_keypair_p256(fio_x509_keypair_s *keypair);

/**
 * Generate a self-signed X.509v3 certificate.
 *
 * The certificate is DER-encoded and written to the output buffer.
 * Call with buf=NULL to calculate required buffer size.
 *
 * @param buf Output buffer (can be NULL to calculate size)
 * @param buf_len Buffer size (ignored if buf is NULL)
 * @param keypair Key pair to use for signing
 * @param options Certificate options
 * @return Number of bytes written/needed, or 0 on error
 */
SFUNC size_t fio_x509_self_signed_cert(uint8_t *buf,
                                       size_t buf_len,
                                       const fio_x509_keypair_s *keypair,
                                       const fio_x509_cert_options_s *options);

/**
 * Securely clear a key pair structure.
 *
 * @param keypair Key pair to clear
 */
FIO_IFUNC void fio_x509_keypair_clear(fio_x509_keypair_s *keypair);

/* *****************************************************************************
Implementation - Certificate Generation
***************************************************************************** */

/** Securely clear key pair */
FIO_IFUNC void fio_x509_keypair_clear(fio_x509_keypair_s *keypair) {
  if (keypair) {
    fio_secure_zero(keypair->secret_key, sizeof(keypair->secret_key));
    FIO_MEMSET(keypair, 0, sizeof(*keypair));
  }
}

/** Generate Ed25519 key pair */
SFUNC int fio_x509_keypair_ed25519(fio_x509_keypair_s *keypair) {
  if (!keypair)
    return -1;

  FIO_MEMSET(keypair, 0, sizeof(*keypair));
  keypair->type = FIO_X509_KEYPAIR_ED25519;

#if defined(H___FIO_ED25519___H)
  fio_ed25519_keypair(keypair->secret_key, keypair->public_key);
  keypair->secret_key_len = 32;
  keypair->public_key_len = 32;
  return 0;
#else
  FIO_LOG_ERROR("Ed25519 not available - define FIO_ED25519 before including");
  return -1;
#endif
}

/** Generate P-256 key pair */
SFUNC int fio_x509_keypair_p256(fio_x509_keypair_s *keypair) {
  if (!keypair)
    return -1;

  FIO_MEMSET(keypair, 0, sizeof(*keypair));
  keypair->type = FIO_X509_KEYPAIR_P256;

#if defined(H___FIO_P256___H)
  if (fio_p256_keypair(keypair->secret_key, keypair->public_key) != 0)
    return -1;
  keypair->secret_key_len = 32;
  keypair->public_key_len = 65;
  return 0;
#else
  FIO_LOG_ERROR("P-256 not available - define FIO_P256 before including");
  return -1;
#endif
}

/** Helper: encode a single RDN (Relative Distinguished Name) */
FIO_SFUNC size_t fio___x509_encode_rdn(uint8_t *buf,
                                       const char *oid,
                                       const char *value,
                                       size_t value_len) {
  if (!value || value_len == 0)
    return 0;

  /* AttributeTypeAndValue ::= SEQUENCE { type OID, value ANY } */
  size_t oid_len = fio_asn1_encode_oid(NULL, oid);
  size_t str_len = fio_asn1_encode_utf8_string(NULL, value, value_len);
  size_t atv_content = oid_len + str_len;
  size_t atv_len =
      fio_asn1_encode_sequence_header(NULL, atv_content) + atv_content;

  /* SET { AttributeTypeAndValue } */
  size_t set_len = fio_asn1_encode_set_header(NULL, atv_len) + atv_len;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_set_header(buf + offset, atv_len);
    offset += fio_asn1_encode_sequence_header(buf + offset, atv_content);
    offset += fio_asn1_encode_oid(buf + offset, oid);
    offset += fio_asn1_encode_utf8_string(buf + offset, value, value_len);
    (void)offset;
  }

  return set_len;
}

/** Helper: encode Name (sequence of RDNs) */
FIO_SFUNC size_t fio___x509_encode_name(uint8_t *buf,
                                        const fio_x509_cert_options_s *opts) {
  /* Calculate content length */
  size_t content_len = 0;

  /* Country (C) */
  if (opts->subject_c)
    content_len +=
        fio___x509_encode_rdn(NULL, FIO_OID_COUNTRY, opts->subject_c, 2);

  /* Organization (O) */
  if (opts->subject_org && opts->subject_org_len > 0)
    content_len += fio___x509_encode_rdn(NULL,
                                         FIO_OID_ORGANIZATION,
                                         opts->subject_org,
                                         opts->subject_org_len);

  /* Organizational Unit (OU) */
  if (opts->subject_ou && opts->subject_ou_len > 0)
    content_len += fio___x509_encode_rdn(NULL,
                                         FIO_OID_ORG_UNIT,
                                         opts->subject_ou,
                                         opts->subject_ou_len);

  /* Common Name (CN) - required */
  size_t cn_len = opts->subject_cn_len;
  if (cn_len == 0 && opts->subject_cn)
    cn_len = FIO_STRLEN(opts->subject_cn);
  content_len += fio___x509_encode_rdn(NULL,
                                       FIO_OID_COMMON_NAME,
                                       opts->subject_cn,
                                       cn_len);

  size_t total =
      fio_asn1_encode_sequence_header(NULL, content_len) + content_len;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_sequence_header(buf + offset, content_len);

    if (opts->subject_c)
      offset += fio___x509_encode_rdn(buf + offset,
                                      FIO_OID_COUNTRY,
                                      opts->subject_c,
                                      2);

    if (opts->subject_org && opts->subject_org_len > 0)
      offset += fio___x509_encode_rdn(buf + offset,
                                      FIO_OID_ORGANIZATION,
                                      opts->subject_org,
                                      opts->subject_org_len);

    if (opts->subject_ou && opts->subject_ou_len > 0)
      offset += fio___x509_encode_rdn(buf + offset,
                                      FIO_OID_ORG_UNIT,
                                      opts->subject_ou,
                                      opts->subject_ou_len);

    offset += fio___x509_encode_rdn(buf + offset,
                                    FIO_OID_COMMON_NAME,
                                    opts->subject_cn,
                                    cn_len);
    (void)offset;
  }

  return total;
}

/** Helper: encode Validity */
FIO_SFUNC size_t fio___x509_encode_validity(uint8_t *buf,
                                            int64_t not_before,
                                            int64_t not_after) {
  size_t time_len = fio_asn1_encode_utc_time(NULL, 0);
  size_t content_len = time_len * 2;
  size_t total =
      fio_asn1_encode_sequence_header(NULL, content_len) + content_len;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_sequence_header(buf + offset, content_len);
    offset += fio_asn1_encode_utc_time(buf + offset, not_before);
    offset += fio_asn1_encode_utc_time(buf + offset, not_after);
    (void)offset;
  }

  return total;
}

/** Helper: encode SubjectPublicKeyInfo for Ed25519 */
FIO_SFUNC size_t fio___x509_encode_spki_ed25519(uint8_t *buf,
                                                const uint8_t pubkey[32]) {
  /* AlgorithmIdentifier for Ed25519: SEQUENCE { OID } (no params) */
  size_t oid_len = fio_asn1_encode_oid(NULL, FIO_OID_ED25519);
  size_t alg_content = oid_len;
  size_t alg_len =
      fio_asn1_encode_sequence_header(NULL, alg_content) + alg_content;

  /* BIT STRING containing 32-byte public key */
  size_t bits_len = fio_asn1_encode_bit_string(NULL, pubkey, 32, 0);

  size_t content_len = alg_len + bits_len;
  size_t total =
      fio_asn1_encode_sequence_header(NULL, content_len) + content_len;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_sequence_header(buf + offset, content_len);
    offset += fio_asn1_encode_sequence_header(buf + offset, alg_content);
    offset += fio_asn1_encode_oid(buf + offset, FIO_OID_ED25519);
    offset += fio_asn1_encode_bit_string(buf + offset, pubkey, 32, 0);
    (void)offset;
  }

  return total;
}

/** Helper: encode SubjectPublicKeyInfo for P-256 */
FIO_SFUNC size_t fio___x509_encode_spki_p256(uint8_t *buf,
                                             const uint8_t pubkey[65]) {
  /* AlgorithmIdentifier: SEQUENCE { ecPublicKey OID, secp256r1 OID } */
  size_t ec_oid_len = fio_asn1_encode_oid(NULL, FIO_OID_EC_PUBLIC_KEY);
  size_t curve_oid_len = fio_asn1_encode_oid(NULL, FIO_OID_SECP256R1);
  size_t alg_content = ec_oid_len + curve_oid_len;
  size_t alg_len =
      fio_asn1_encode_sequence_header(NULL, alg_content) + alg_content;

  /* BIT STRING containing 65-byte uncompressed point */
  size_t bits_len = fio_asn1_encode_bit_string(NULL, pubkey, 65, 0);

  size_t content_len = alg_len + bits_len;
  size_t total =
      fio_asn1_encode_sequence_header(NULL, content_len) + content_len;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_sequence_header(buf + offset, content_len);
    offset += fio_asn1_encode_sequence_header(buf + offset, alg_content);
    offset += fio_asn1_encode_oid(buf + offset, FIO_OID_EC_PUBLIC_KEY);
    offset += fio_asn1_encode_oid(buf + offset, FIO_OID_SECP256R1);
    offset += fio_asn1_encode_bit_string(buf + offset, pubkey, 65, 0);
    (void)offset;
  }

  return total;
}

/** Helper: encode BasicConstraints extension */
FIO_SFUNC size_t fio___x509_encode_ext_basic_constraints(uint8_t *buf,
                                                         int is_ca) {
  /* BasicConstraints ::= SEQUENCE { cA BOOLEAN DEFAULT FALSE } */
  size_t bc_content = is_ca ? fio_asn1_encode_boolean(NULL, 1) : 0;
  size_t bc_len =
      fio_asn1_encode_sequence_header(NULL, bc_content) + bc_content;

  /* Wrap in OCTET STRING */
  size_t octet_len = fio_asn1_encode_octet_string(NULL, NULL, bc_len);

  /* Extension: SEQUENCE { OID, critical BOOLEAN, value OCTET STRING } */
  size_t oid_len = fio_asn1_encode_oid(NULL, FIO_OID_BASIC_CONSTRAINTS);
  size_t crit_len = fio_asn1_encode_boolean(NULL, 1); /* critical = TRUE */
  size_t ext_content = oid_len + crit_len + octet_len;
  size_t total =
      fio_asn1_encode_sequence_header(NULL, ext_content) + ext_content;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_sequence_header(buf + offset, ext_content);
    offset += fio_asn1_encode_oid(buf + offset, FIO_OID_BASIC_CONSTRAINTS);
    offset += fio_asn1_encode_boolean(buf + offset, 1); /* critical */

    /* OCTET STRING containing BasicConstraints */
    size_t octet_hdr = fio_asn1_encode_octet_string(buf + offset, NULL, bc_len);
    /* Write the actual BasicConstraints content */
    uint8_t *bc_buf = buf + offset + octet_hdr - bc_len;
    size_t bc_off = 0;
    bc_off += fio_asn1_encode_sequence_header(bc_buf + bc_off, bc_content);
    if (is_ca)
      bc_off += fio_asn1_encode_boolean(bc_buf + bc_off, 1);
    (void)bc_off;
    offset += octet_hdr;
    (void)offset;
  }

  return total;
}

/** Helper: encode KeyUsage extension */
FIO_SFUNC size_t fio___x509_encode_ext_key_usage(uint8_t *buf,
                                                 uint16_t key_usage) {
  /* KeyUsage ::= BIT STRING */
  /* Encode as 2 bytes with unused bits calculated */
  uint8_t ku_bytes[2];
  ku_bytes[0] = (uint8_t)(key_usage & 0xFF);
  ku_bytes[1] = (uint8_t)((key_usage >> 8) & 0xFF);

  /* Calculate unused bits in last byte */
  uint8_t unused = 0;
  size_t ku_len = 2;
  if (ku_bytes[1] == 0) {
    ku_len = 1;
    /* Count trailing zeros in first byte */
    uint8_t b = ku_bytes[0];
    while (b && !(b & 1)) {
      ++unused;
      b >>= 1;
    }
  } else {
    /* Count trailing zeros in second byte */
    uint8_t b = ku_bytes[1];
    while (b && !(b & 1)) {
      ++unused;
      b >>= 1;
    }
  }

  size_t bits_len = fio_asn1_encode_bit_string(NULL, ku_bytes, ku_len, unused);

  /* Wrap in OCTET STRING */
  size_t octet_len = fio_asn1_encode_octet_string(NULL, NULL, bits_len);

  /* Extension: SEQUENCE { OID, critical BOOLEAN, value OCTET STRING } */
  size_t oid_len = fio_asn1_encode_oid(NULL, FIO_OID_KEY_USAGE);
  size_t crit_len = fio_asn1_encode_boolean(NULL, 1); /* critical = TRUE */
  size_t ext_content = oid_len + crit_len + octet_len;
  size_t total =
      fio_asn1_encode_sequence_header(NULL, ext_content) + ext_content;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_sequence_header(buf + offset, ext_content);
    offset += fio_asn1_encode_oid(buf + offset, FIO_OID_KEY_USAGE);
    offset += fio_asn1_encode_boolean(buf + offset, 1); /* critical */

    /* OCTET STRING containing KeyUsage BIT STRING */
    size_t octet_hdr =
        fio_asn1_encode_octet_string(buf + offset, NULL, bits_len);
    uint8_t *ku_buf = buf + offset + octet_hdr - bits_len;
    fio_asn1_encode_bit_string(ku_buf, ku_bytes, ku_len, unused);
    offset += octet_hdr;
    (void)offset;
  }

  return total;
}

/** Helper: encode SubjectAltName extension */
FIO_SFUNC size_t fio___x509_encode_ext_san(uint8_t *buf,
                                           const char **dns_names,
                                           size_t dns_count) {
  if (!dns_names || dns_count == 0)
    return 0;

  /* GeneralNames ::= SEQUENCE OF GeneralName
   * GeneralName ::= CHOICE { dNSName [2] IA5String, ... } */
  size_t san_content = 0;
  for (size_t i = 0; i < dns_count; ++i) {
    size_t name_len = FIO_STRLEN(dns_names[i]);
    /* Context tag [2] + length + data */
    san_content +=
        fio_asn1_encode_context_header(NULL, 2, name_len, 0) + name_len;
  }

  size_t san_len =
      fio_asn1_encode_sequence_header(NULL, san_content) + san_content;

  /* Wrap in OCTET STRING */
  size_t octet_len = fio_asn1_encode_octet_string(NULL, NULL, san_len);

  /* Extension: SEQUENCE { OID, value OCTET STRING } (not critical) */
  size_t oid_len = fio_asn1_encode_oid(NULL, FIO_OID_SUBJECT_ALT_NAME);
  size_t ext_content = oid_len + octet_len;
  size_t total =
      fio_asn1_encode_sequence_header(NULL, ext_content) + ext_content;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_sequence_header(buf + offset, ext_content);
    offset += fio_asn1_encode_oid(buf + offset, FIO_OID_SUBJECT_ALT_NAME);

    /* OCTET STRING containing SAN */
    size_t octet_hdr =
        fio_asn1_encode_octet_string(buf + offset, NULL, san_len);
    uint8_t *san_buf = buf + offset + octet_hdr - san_len;
    size_t san_off = 0;
    san_off += fio_asn1_encode_sequence_header(san_buf + san_off, san_content);
    for (size_t i = 0; i < dns_count; ++i) {
      size_t name_len = FIO_STRLEN(dns_names[i]);
      san_off +=
          fio_asn1_encode_context_header(san_buf + san_off, 2, name_len, 0);
      FIO_MEMCPY(san_buf + san_off, dns_names[i], name_len);
      san_off += name_len;
    }
    offset += octet_hdr;
    (void)offset;
  }

  return total;
}

/** Helper: encode Extended Key Usage extension (serverAuth for TLS servers) */
FIO_SFUNC size_t fio___x509_encode_ext_eku(uint8_t *buf, int is_ca) {
  /* For CA certificates, we don't add EKU (it's for end-entity certs) */
  if (is_ca)
    return 0;

  /*
   * ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId
   * KeyPurposeId ::= OBJECT IDENTIFIER
   *
   * For TLS servers, we need serverAuth (1.3.6.1.5.5.7.3.1)
   */
  size_t server_auth_oid_len =
      fio_asn1_encode_oid(NULL, FIO_OID_EKU_SERVER_AUTH);
  size_t eku_content = server_auth_oid_len;
  size_t eku_len =
      fio_asn1_encode_sequence_header(NULL, eku_content) + eku_content;

  /* Wrap in OCTET STRING */
  size_t octet_len = fio_asn1_encode_octet_string(NULL, NULL, eku_len);

  /* Extension: SEQUENCE { OID, value OCTET STRING } (not critical) */
  size_t oid_len = fio_asn1_encode_oid(NULL, FIO_OID_EXT_KEY_USAGE);
  size_t ext_content = oid_len + octet_len;
  size_t total =
      fio_asn1_encode_sequence_header(NULL, ext_content) + ext_content;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_sequence_header(buf + offset, ext_content);
    offset += fio_asn1_encode_oid(buf + offset, FIO_OID_EXT_KEY_USAGE);

    /* OCTET STRING containing EKU SEQUENCE */
    size_t octet_hdr =
        fio_asn1_encode_octet_string(buf + offset, NULL, eku_len);
    uint8_t *eku_buf = buf + offset + octet_hdr - eku_len;
    size_t eku_off = 0;
    eku_off += fio_asn1_encode_sequence_header(eku_buf + eku_off, eku_content);
    eku_off += fio_asn1_encode_oid(eku_buf + eku_off, FIO_OID_EKU_SERVER_AUTH);
    (void)eku_off;
    offset += octet_hdr;
    (void)offset;
  }

  return total;
}

/** Helper: encode Extensions wrapper */
FIO_SFUNC size_t
fio___x509_encode_extensions(uint8_t *buf,
                             const fio_x509_keypair_s *kp,
                             const fio_x509_cert_options_s *opts) {
  /* Calculate extensions content */
  size_t ext_content = 0;

  /* BasicConstraints */
  ext_content += fio___x509_encode_ext_basic_constraints(NULL, opts->is_ca);

  /* KeyUsage */
  uint16_t ku = opts->key_usage;
  if (ku == 0) {
    /* Default key usage based on certificate type and key algorithm */
    if (opts->is_ca) {
      ku = FIO_X509_KU_KEY_CERT_SIGN | FIO_X509_KU_CRL_SIGN;
    } else {
      /*
       * For ECDSA/Ed25519 certificates: digitalSignature only
       * KEY_ENCIPHERMENT is for RSA key exchange, NOT for ECDSA!
       * Using KEY_ENCIPHERMENT with ECDSA causes Chrome to reject with
       * ERR_SSL_KEY_USAGE_INCOMPATIBLE
       */
      ku = FIO_X509_KU_DIGITAL_SIGNATURE;
    }
  }
  ext_content += fio___x509_encode_ext_key_usage(NULL, ku);

  /* Extended Key Usage (serverAuth for TLS server certificates) */
  ext_content += fio___x509_encode_ext_eku(NULL, opts->is_ca);

  /* SubjectAltName */
  if (opts->san_dns && opts->san_dns_count > 0)
    ext_content +=
        fio___x509_encode_ext_san(NULL, opts->san_dns, opts->san_dns_count);

  /* Extensions SEQUENCE */
  size_t exts_len =
      fio_asn1_encode_sequence_header(NULL, ext_content) + ext_content;

  /* Wrap in context tag [3] */
  size_t total =
      fio_asn1_encode_context_header(NULL, 3, exts_len, 1) + exts_len;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_context_header(buf + offset, 3, exts_len, 1);
    offset += fio_asn1_encode_sequence_header(buf + offset, ext_content);
    offset +=
        fio___x509_encode_ext_basic_constraints(buf + offset, opts->is_ca);
    offset += fio___x509_encode_ext_key_usage(buf + offset, ku);
    offset += fio___x509_encode_ext_eku(buf + offset, opts->is_ca);
    if (opts->san_dns && opts->san_dns_count > 0)
      offset += fio___x509_encode_ext_san(buf + offset,
                                          opts->san_dns,
                                          opts->san_dns_count);
    (void)offset;
  }

  return total;
  (void)kp;
}

/** Helper: encode AlgorithmIdentifier for signature */
FIO_SFUNC size_t fio___x509_encode_sig_alg(uint8_t *buf,
                                           fio_x509_keypair_type_e type) {
  const char *oid;
  int has_params;

  switch (type) {
  case FIO_X509_KEYPAIR_ED25519:
    oid = FIO_OID_ED25519;
    has_params = 0;
    break;
  case FIO_X509_KEYPAIR_P256:
    oid = FIO_OID_ECDSA_WITH_SHA256;
    has_params = 0;
    break;
  default: return 0;
  }

  size_t oid_len = fio_asn1_encode_oid(NULL, oid);
  size_t content_len = oid_len;
  if (has_params)
    content_len += fio_asn1_encode_null(NULL);

  size_t total =
      fio_asn1_encode_sequence_header(NULL, content_len) + content_len;

  if (buf) {
    size_t offset = 0;
    offset += fio_asn1_encode_sequence_header(buf + offset, content_len);
    offset += fio_asn1_encode_oid(buf + offset, oid);
    if (has_params)
      offset += fio_asn1_encode_null(buf + offset);
    (void)offset;
  }

  return total;
}

/** Generate self-signed certificate */
SFUNC size_t fio_x509_self_signed_cert(uint8_t *buf,
                                       size_t buf_len,
                                       const fio_x509_keypair_s *keypair,
                                       const fio_x509_cert_options_s *options) {
  if (!keypair || !options || !options->subject_cn)
    return 0;

  /* Set default validity if not specified */
  int64_t not_before = options->not_before;
  int64_t not_after = options->not_after;
  if (not_before == 0)
    not_before = (int64_t)fio_time_real().tv_sec;
  if (not_after == 0)
    not_after = not_before + (365 * 24 * 60 * 60); /* +1 year */

  /* Generate random serial number (20 bytes max per RFC 5280) */
  uint8_t serial[16];
  fio_rand_bytes(serial, sizeof(serial));
  serial[0] &= 0x7F; /* Ensure positive */

  /* Calculate TBSCertificate content length */
  size_t tbs_content = 0;

  /* Version [0] EXPLICIT INTEGER (v3 = 2) */
  size_t version_int = fio_asn1_encode_integer_small(NULL, 2);
  size_t version_len =
      fio_asn1_encode_context_header(NULL, 0, version_int, 1) + version_int;
  tbs_content += version_len;

  /* Serial number */
  size_t serial_len = fio_asn1_encode_integer(NULL, serial, sizeof(serial));
  tbs_content += serial_len;

  /* Signature algorithm */
  size_t sig_alg_len = fio___x509_encode_sig_alg(NULL, keypair->type);
  tbs_content += sig_alg_len;

  /* Issuer (same as subject for self-signed) */
  size_t issuer_len = fio___x509_encode_name(NULL, options);
  tbs_content += issuer_len;

  /* Validity */
  size_t validity_len = fio___x509_encode_validity(NULL, not_before, not_after);
  tbs_content += validity_len;

  /* Subject */
  size_t subject_len = fio___x509_encode_name(NULL, options);
  tbs_content += subject_len;

  /* SubjectPublicKeyInfo */
  size_t spki_len = 0;
  switch (keypair->type) {
  case FIO_X509_KEYPAIR_ED25519:
    spki_len = fio___x509_encode_spki_ed25519(NULL, keypair->public_key);
    break;
  case FIO_X509_KEYPAIR_P256:
    spki_len = fio___x509_encode_spki_p256(NULL, keypair->public_key);
    break;
  default: return 0;
  }
  tbs_content += spki_len;

  /* Extensions */
  size_t exts_len = fio___x509_encode_extensions(NULL, keypair, options);
  tbs_content += exts_len;

  /* TBSCertificate SEQUENCE */
  size_t tbs_len =
      fio_asn1_encode_sequence_header(NULL, tbs_content) + tbs_content;

  /* Signature algorithm (again, in outer Certificate) */
  size_t outer_sig_alg_len = fio___x509_encode_sig_alg(NULL, keypair->type);

  /* Signature value (BIT STRING) */
  size_t sig_value_len;
  switch (keypair->type) {
  case FIO_X509_KEYPAIR_ED25519:
    sig_value_len = fio_asn1_encode_bit_string(NULL, NULL, 64, 0);
    break;
  case FIO_X509_KEYPAIR_P256:
    /* ECDSA signature is DER-encoded SEQUENCE { r INTEGER, s INTEGER }
     * Maximum size: 2 + 2 + (2 + 33) + (2 + 33) = 74 bytes */
    sig_value_len = fio_asn1_encode_bit_string(NULL, NULL, 74, 0);
    break;
  default: return 0;
  }

  /* Certificate SEQUENCE */
  size_t cert_content = tbs_len + outer_sig_alg_len + sig_value_len;
  size_t total =
      fio_asn1_encode_sequence_header(NULL, cert_content) + cert_content;

  if (!buf)
    return total;

  if (buf_len < total)
    return 0;

  /* Now encode everything */
  size_t offset = 0;

  /* We need to encode TBS first to sign it, but we don't know the final
   * certificate length yet. Encode TBS to a temporary location. */
  uint8_t *tbs_start =
      buf + fio_asn1_encode_sequence_header(NULL, cert_content);

  /* Encode TBSCertificate */
  size_t tbs_offset = 0;
  tbs_offset +=
      fio_asn1_encode_sequence_header(tbs_start + tbs_offset, tbs_content);

  /* Version */
  tbs_offset +=
      fio_asn1_encode_context_header(tbs_start + tbs_offset, 0, version_int, 1);
  tbs_offset += fio_asn1_encode_integer_small(tbs_start + tbs_offset, 2);

  /* Serial */
  tbs_offset +=
      fio_asn1_encode_integer(tbs_start + tbs_offset, serial, sizeof(serial));

  /* Signature algorithm */
  tbs_offset +=
      fio___x509_encode_sig_alg(tbs_start + tbs_offset, keypair->type);

  /* Issuer */
  tbs_offset += fio___x509_encode_name(tbs_start + tbs_offset, options);

  /* Validity */
  tbs_offset +=
      fio___x509_encode_validity(tbs_start + tbs_offset, not_before, not_after);

  /* Subject */
  tbs_offset += fio___x509_encode_name(tbs_start + tbs_offset, options);

  /* SubjectPublicKeyInfo */
  switch (keypair->type) {
  case FIO_X509_KEYPAIR_ED25519:
    tbs_offset += fio___x509_encode_spki_ed25519(tbs_start + tbs_offset,
                                                 keypair->public_key);
    break;
  case FIO_X509_KEYPAIR_P256:
    tbs_offset += fio___x509_encode_spki_p256(tbs_start + tbs_offset,
                                              keypair->public_key);
    break;
  default: return 0;
  }

  /* Extensions */
  tbs_offset +=
      fio___x509_encode_extensions(tbs_start + tbs_offset, keypair, options);

  /* Sign the TBSCertificate */
  uint8_t signature[128]; /* Large enough for any signature */
  size_t actual_sig_len = 0;

  switch (keypair->type) {
  case FIO_X509_KEYPAIR_ED25519: {
#if defined(H___FIO_ED25519___H)
    fio_ed25519_sign(signature,
                     tbs_start,
                     tbs_len,
                     keypair->secret_key,
                     keypair->public_key);
    actual_sig_len = 64;
#else
    return 0;
#endif
    break;
  }
  case FIO_X509_KEYPAIR_P256: {
#if defined(H___FIO_P256___H) && defined(H___FIO_SHA2___H)
    /* Hash the TBS with SHA-256 */
    fio_u256 hash = fio_sha256(tbs_start, tbs_len);

    /* Sign using proper ECDSA P-256 (returns DER-encoded signature) */
    if (fio_ecdsa_p256_sign(signature,
                            &actual_sig_len,
                            sizeof(signature),
                            hash.u8,
                            keypair->secret_key) != 0)
      return 0;
#else
    return 0;
#endif
    break;
  }
  default: return 0;
  }

  /* Recalculate actual signature BIT STRING length */
  size_t actual_sig_bits_len =
      fio_asn1_encode_bit_string(NULL, signature, actual_sig_len, 0);

  /* Recalculate certificate content length */
  cert_content = tbs_len + outer_sig_alg_len + actual_sig_bits_len;
  total = fio_asn1_encode_sequence_header(NULL, cert_content) + cert_content;

  if (buf_len < total)
    return 0;

  /* Encode final certificate */
  offset = 0;
  offset += fio_asn1_encode_sequence_header(buf + offset, cert_content);

  /* Copy TBS (already encoded) */
  FIO_MEMMOVE(buf + offset, tbs_start, tbs_len);
  offset += tbs_len;

  /* Signature algorithm */
  offset += fio___x509_encode_sig_alg(buf + offset, keypair->type);

  /* Signature value */
  offset +=
      fio_asn1_encode_bit_string(buf + offset, signature, actual_sig_len, 0);

  return total;
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_X509 */
#undef FIO_X509
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_OTP                /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                    OTP (SHA1)



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_OTP) && !defined(H___FIO_OTP___H)
#define H___FIO_OTP___H

/* *****************************************************************************
TOTP API
***************************************************************************** */

typedef struct {
  /** The time interval for TOTP rotation. */
  size_t interval; /* 30 == Google OTP */
  /** The number of digits in the OTP. */
  size_t digits; /* 6 == Google OTP */
  /** The time offset (in `interval` units) from the current time. */
  int64_t offset; /* 0 == Google OTP */
  /** Set to true if the secret / key is in Hex instead of Byte32 encoding. */
  uint8_t is_hex;
  /** Set to true if the secret / key is raw bit data (no encoding). */
  uint8_t is_raw;
} fio_otp_settings_s;

/** Generates a random 128 bit key for TOTP processing. */
FIO_IFUNC fio_u128 fio_otp_generate_key(void);

/** Prints out an OTP secret (big endian number) as a Byte32 encoded String. */
FIO_IFUNC size_t fio_otp_print_key(char *dest, uint8_t *key, size_t len);

/** Returns a TOTP based on `secret` and the otp settings. */
SFUNC uint32_t fio_otp(fio_buf_info_s secret, fio_otp_settings_s settings);
#define fio_otp(secret, ...) fio_otp(secret, (fio_otp_settings_s){__VA_ARGS__})

/**
 * Returns a TOTP for a specific unix timestamp (for testing/verification).
 * This is useful for verifying OTPs at specific times or for RFC test vectors.
 */
SFUNC uint32_t fio_otp_at(fio_buf_info_s secret,
                          uint64_t unix_time,
                          fio_otp_settings_s settings);
#define fio_otp_at(secret, unix_time, ...)                                     \
  fio_otp_at(secret, unix_time, (fio_otp_settings_s){__VA_ARGS__})

/* *****************************************************************************
TOTP Implementation
***************************************************************************** */

/**
 * Generates a cryptographically secure random 128 bit key for TOTP processing.
 * Uses system CSPRNG via fio_rand_bytes_secure().
 */
FIO_IFUNC fio_u128 fio_otp_generate_key(void) {
  fio_u128 k = {0};
  /* Ensure non-zero (extremely unlikely to be zero with 128 bits) */
  while (k.u64[0] == 0 || k.u64[1] == 0) {
    if (fio_rand_bytes_secure(k.u8, sizeof(k)) != 0)
      k = fio_rand128();
  }
  return k;
}

/** Prints out an OTP secret (big endian number) as a Byte32 encoded String. */
FIO_IFUNC size_t fio_otp_print_key(char *dest, uint8_t *key, size_t len) {
  fio_u128 buf;
  if (!key) {
    buf = fio_otp_generate_key();
    key = buf.u8;
    len = sizeof(buf); /* 16 bytes */
  }
  /* Base32 encoding: 5 bits per char, so len*8/5 chars + null terminator */
  /* Using len*2 as safe upper bound (1.6x actual need) */
  fio_str_info_s s = FIO_STR_INFO3(dest, 0, (len * 2) + 1);
  FIO_ASSERT(!fio_string_write_base32enc(&s, NULL, key, len),
             "writing the generated OTP key failed");
  return s.len;
}

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_IFUNC void fio___otp_settings_validate(fio_otp_settings_s *s) {
  if (!s->interval)
    s->interval = 30;
  if (!s->digits)
    s->digits = 6;
}

/* Internal: compute OTP from raw secret and time counter */
FIO_SFUNC uint32_t fio___otp_compute(fio_buf_info_s key,
                                     uint64_t unix_time,
                                     fio_otp_settings_s settings) {
  uint32_t r = 0;
  uint64_t t = unix_time;
  fio_u1024 s = fio_u1024_init64(0);
  fio_sha1_s hash;
  fio_str_info_s secret = FIO_STR_INFO3((char *)s.u8, 0, (1024 / 8));
  fio___otp_settings_validate(&settings);

  /* Prep time */
  t -= (settings.offset * settings.interval);
  t /= settings.interval;
  /* t should be big endian */
  t = fio_lton64(t);

  if (settings.is_raw)
    secret = FIO_BUF2STR_INFO(key);
  else if (settings.is_hex) {
    /* decode Hex key input OTP */
    FIO_ASSERT(key.len < (1024 / (8 * 2)), "key too long");
    size_t written = 0; /* fun times... */
    for (size_t i = 0; i < key.len; ++i) {
      if (key.buf[i] == '-' || key.buf[i] == ' ' || key.buf[i] == '\n')
        continue;
      const size_t pos = written >> 1;
      if (!(written & 1))
        secret.buf[pos] = 0;
      secret.buf[pos] |= (fio_c2i(key.buf[i]) << (((++written) & 1) << 2));
    }
    secret.len = (written >> 1) + (written & 1);
  } else {
    /* decode Byte32 key input OTP */
    FIO_ASSERT(key.len < ((64 * 8) / 5), "key too long");
    if (fio_string_write_base32dec(&secret, NULL, key.buf, key.len))
      return -1;
  }

  /* compute HMAC (HOTP of T / TOTP)  */
  hash = fio_sha1_hmac(secret.buf, secret.len, &t, sizeof(t));

  /* compute unsigned int as a function of offset from hash */
  size_t offset = (fio_sha1_digest(&hash)[fio_sha1_len() - 1] & 0x0F);
  fio_sha1_digest(&hash)[offset] &= 0x7F;
  r = fio_buf2u32_be(fio_sha1_digest(&hash) + offset);

  /*  reduce number of digits */
  switch (settings.digits) {
  case 1: offset = 10; break;
  case 2: offset = 100; break;
  case 3: offset = 1000; break;
  case 4: offset = 10000; break;
  case 5: offset = 100000; break;
  case 6: offset = 1000000; break;
  case 7: offset = 10000000; break;
  case 8: offset = 100000000; break;
  case 9: offset = 1000000000; break;
  case 10: offset = 10000000000; break;
  }
  r %= offset;

  return r;
}

uint32_t fio_otp___(void);
SFUNC uint32_t fio_otp FIO_NOOP(fio_buf_info_s key,
                                fio_otp_settings_s settings) {
  return fio___otp_compute(key, (uint64_t)fio_time_real().tv_sec, settings);
}

SFUNC uint32_t fio_otp_at FIO_NOOP(fio_buf_info_s key,
                                   uint64_t unix_time,
                                   fio_otp_settings_s settings) {
  return fio___otp_compute(key, unix_time, settings);
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_OTP */
#undef FIO_OTP
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_CRYPTO_CORE        /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                  A Template for New Types / Modules




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_SECRET) && !defined(H___FIO_SECRET___H)
#define H___FIO_SECRET___H

/** Returns true if the secret was randomly generated. */
SFUNC bool fio_secret_is_random(void);

/** Gets the SHA512 of a (possibly shared) secret. */
SFUNC fio_u512 fio_secret(void);

/** Sets a (possibly shared) secret and stores its SHA512 hash. */
SFUNC void fio_secret_set(char *str, size_t len, bool is_random);

/** Sets a (possibly shared) secret and stores its SHA512 hash. */
SFUNC void fio_secret_set_at(fio_u512 *secret, char *str, size_t len);

/** Gets the SHA512 of a (possibly shared) secret. */
SFUNC fio_u512 fio_secret_at(fio_u512 *secret);

/* *****************************************************************************
Module Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

static fio_u512 fio___secret;
static bool fio___secret_is_random;
static uint64_t fio___secret_masker;

FIO_DEFINE_RANDOM128_FN(static, fio___secret_rand, 1, 0)

/** Returns true if the secret was randomly generated. */
SFUNC bool fio_secret_is_random(void) { return fio___secret_is_random; }

/** Gets the SHA512 of a (possibly shared) secret. */
SFUNC fio_u512 fio_secret(void) {
  fio_u512 r;
  fio_u512_cxor64(&r, &fio___secret, fio___secret_masker);
  return r;
}

/** Sets a (possibly shared) secret and stores its SHA512 hash. */
SFUNC void fio_secret_set(char *str, size_t len, bool is_random) {
  if (!str || !len)
    is_random = 1;
  fio_secret_set_at(&fio___secret, str, len);
  fio___secret_is_random = is_random;
}

/** Sets a (possibly shared) secret and stores its SHA512 hash. */
SFUNC void fio_secret_set_at(fio_u512 *secret, char *str, size_t len) {
  if (!secret)
    return;
  fio_u512 random_buffer = {0};
  fio_u512 zero = {0};
  size_t i = 0;
  FIO_STR_INFO_TMP_VAR(from_hex, 4096);
  if (!str)
    len = 0;
  if (len > 8191)
    goto done;
  /* convert any Hex data to bytes */
  for (i = 0; i + 1 < len; i += 2) {
    /* skip white space */
    if (str[i] == ' ' || str[i] == '\t' || str[i] == '\n' || str[i] == '\r') {
      --i;
      continue;
    }
    const size_t hi = fio_c2i(str[i]);
    const size_t lo = fio_c2i(str[i + 1]);
    if ((unsigned)(hi > 15) | (lo > 15))
      goto done;
    from_hex.buf[from_hex.len++] = (hi << 4) | lo;
  }
  from_hex.buf[from_hex.len] = 0;
  while (i < len &&
         (str[i] == ' ' || str[i] == '\t' || str[i] == '\n' || str[i] == '\r'))
    ++i;
  if (i == len) { /* test if the secret was all Hex encoded */
    FIO_LOG_DDEBUG2("(secret) Decoded HEX encoded secret (%zu bytes).",
                    from_hex.len);
    str = from_hex.buf;
    len = from_hex.len;
  }
  if (!len) {
    str = (char *)random_buffer.u8;
    len = sizeof(random_buffer);
    fio___secret_rand_bytes(random_buffer.u8, sizeof(random_buffer));
  }

done:

  *secret = fio_sha512(str, len);
  if (fio_u512_is_eq(&zero, secret)) {
    secret->u64[0] = len;
    secret[0] = fio_sha512(secret->u8, sizeof(*secret));
  }
  while (!(fio___secret_masker = fio___secret_rand64()))
    ;
  fio_u512_cxor64(secret, secret, fio___secret_masker);
}

/** Gets the SHA512 of a (possibly shared) secret. */
SFUNC fio_u512 fio_secret_at(fio_u512 *secret) {
  fio_u512 r;
  fio_u512_cxor64(&r, secret, fio___secret_masker);
  return r;
}

FIO_CONSTRUCTOR(fio___secret_constructor) {
  char *str = NULL;
  size_t len = 0;
  if ((str = getenv("SECRET"))) {
    const char *secret_length = getenv("SECRET_LENGTH");
    len = secret_length ? fio_atol((char **)&secret_length) : 0;
    if (!len)
      len = strlen(str);
    if (!len)
      str = NULL;
  }
  fio_secret_set(str, len, 0);
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_SECRET
#endif /* FIO_CRYPTO_CORE */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_TLS13              /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                              TLS 1.3 Implementation
                    Key Schedule (RFC 8446 Section 7) and
                    Record Layer (RFC 8446 Section 5)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_TLS13) && !defined(H___FIO_TLS13___H)
#define H___FIO_TLS13___H

/* *****************************************************************************
TLS 1.3 Key Schedule API

Note: Requires FIO_HKDF (which requires FIO_SHA2).
      Either define FIO_HKDF before FIO_TLS13, or use FIO_CRYPTO to include all
      crypto modules.

Reference: RFC 8446 Section 7.1
***************************************************************************** */

/** SHA-256 hash length (32 bytes). */
#define FIO_TLS13_SHA256_HASH_LEN 32
/** SHA-384 hash length (48 bytes). */
#define FIO_TLS13_SHA384_HASH_LEN 48
/** Maximum hash length supported. */
#define FIO_TLS13_MAX_HASH_LEN 48

/** AES-128-GCM key length. */
#define FIO_TLS13_AES128_KEY_LEN 16
/** AES-256-GCM key length. */
#define FIO_TLS13_AES256_KEY_LEN 32
/** ChaCha20-Poly1305 key length. */
#define FIO_TLS13_CHACHA_KEY_LEN 32
/** IV length for all AEAD ciphers. */
#define FIO_TLS13_IV_LEN 12

/* *****************************************************************************
HKDF-Expand-Label (RFC 8446 Section 7.1)

HKDF-Expand-Label(Secret, Label, Context, Length) =
    HKDF-Expand(Secret, HkdfLabel, Length)

Where HkdfLabel is:
    struct {
        uint16 length = Length;
        opaque label<7..255> = "tls13 " + Label;
        opaque context<0..255> = Context;
    } HkdfLabel;
***************************************************************************** */

/**
 * TLS 1.3 HKDF-Expand-Label function.
 *
 * Derives keying material using the TLS 1.3 specific label format.
 *
 * @param out Output buffer for derived key material
 * @param out_len Desired output length (max 255)
 * @param secret The secret to expand (PRK from HKDF-Extract)
 * @param secret_len Secret length (32 for SHA-256, 48 for SHA-384)
 * @param label The label string (without "tls13 " prefix)
 * @param label_len Label length (max 249 to fit in 255 with prefix)
 * @param context Optional context (transcript hash or empty)
 * @param context_len Context length (max 255)
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_tls13_hkdf_expand_label(void *restrict out,
                                       size_t out_len,
                                       const void *restrict secret,
                                       size_t secret_len,
                                       const char *label,
                                       size_t label_len,
                                       const void *restrict context,
                                       size_t context_len,
                                       int use_sha384);

/* *****************************************************************************
Derive-Secret (RFC 8446 Section 7.1)

Derive-Secret(Secret, Label, Messages) =
    HKDF-Expand-Label(Secret, Label, Transcript-Hash(Messages), Hash.length)
***************************************************************************** */

/**
 * TLS 1.3 Derive-Secret function.
 *
 * Derives a secret from a base secret and transcript hash.
 *
 * @param out Output buffer (32 bytes for SHA-256, 48 for SHA-384)
 * @param secret The base secret
 * @param secret_len Secret length
 * @param label The label string (e.g., "c hs traffic")
 * @param label_len Label length
 * @param transcript_hash Hash of handshake messages (or empty hash for "")
 * @param hash_len Hash length (32 or 48)
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_tls13_derive_secret(void *restrict out,
                                   const void *restrict secret,
                                   size_t secret_len,
                                   const char *label,
                                   size_t label_len,
                                   const void *restrict transcript_hash,
                                   size_t hash_len,
                                   int use_sha384);

/* *****************************************************************************
Key Schedule Derivation Functions (RFC 8446 Section 7.1)

             0
             |
             v
   PSK ->  HKDF-Extract = Early Secret
             |
             +-----> Derive-Secret(., "ext binder" | "res binder", "")
             |                     = binder_key
             |
             +-----> Derive-Secret(., "c e traffic", ClientHello)
             |                     = client_early_traffic_secret
             |
             +-----> Derive-Secret(., "e exp master", ClientHello)
             |                     = early_exporter_master_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   (EC)DHE -> HKDF-Extract = Handshake Secret
             |
             +-----> Derive-Secret(., "c hs traffic",
             |                     ClientHello...ServerHello)
             |                     = client_handshake_traffic_secret
             |
             +-----> Derive-Secret(., "s hs traffic",
             |                     ClientHello...ServerHello)
             |                     = server_handshake_traffic_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   0 -> HKDF-Extract = Master Secret
             |
             +-----> Derive-Secret(., "c ap traffic",
             |                     ClientHello...server Finished)
             |                     = client_application_traffic_secret_0
             |
             +-----> Derive-Secret(., "s ap traffic",
             |                     ClientHello...server Finished)
             |                     = server_application_traffic_secret_0
             |
             +-----> Derive-Secret(., "exp master",
             |                     ClientHello...server Finished)
             |                     = exporter_master_secret
             |
             +-----> Derive-Secret(., "res master",
                                   ClientHello...client Finished)
                                   = resumption_master_secret
***************************************************************************** */

/**
 * Derive the Early Secret from PSK.
 *
 * Early Secret = HKDF-Extract(salt=0, IKM=PSK)
 *
 * @param early_secret Output buffer (32 or 48 bytes)
 * @param psk Pre-shared key (or NULL/zeros for no PSK)
 * @param psk_len PSK length (0 if no PSK)
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_tls13_derive_early_secret(void *restrict early_secret,
                                         const void *restrict psk,
                                         size_t psk_len,
                                         int use_sha384);

/**
 * Derive the Handshake Secret from ECDHE shared secret.
 *
 * Handshake Secret = HKDF-Extract(
 *     salt=Derive-Secret(Early Secret, "derived", ""),
 *     IKM=ECDHE shared secret
 * )
 *
 * @param handshake_secret Output buffer (32 or 48 bytes)
 * @param early_secret The early secret (from fio_tls13_derive_early_secret)
 * @param ecdhe_secret The ECDHE shared secret (e.g., from X25519)
 * @param ecdhe_len ECDHE secret length (32 for X25519)
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_tls13_derive_handshake_secret(void *restrict handshake_secret,
                                             const void *restrict early_secret,
                                             const void *restrict ecdhe_secret,
                                             size_t ecdhe_len,
                                             int use_sha384);

/**
 * Derive the Master Secret.
 *
 * Master Secret = HKDF-Extract(
 *     salt=Derive-Secret(Handshake Secret, "derived", ""),
 *     IKM=0
 * )
 *
 * @param master_secret Output buffer (32 or 48 bytes)
 * @param handshake_secret The handshake secret
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_tls13_derive_master_secret(void *restrict master_secret,
                                          const void *restrict handshake_secret,
                                          int use_sha384);

/* *****************************************************************************
Traffic Key Derivation (RFC 8446 Section 7.3)

[sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
[sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)
***************************************************************************** */

/**
 * Derive traffic keys and IV from a traffic secret.
 *
 * @param key Output buffer for write key
 * @param key_len Key length (16 for AES-128, 32 for AES-256/ChaCha20)
 * @param iv Output buffer for write IV (12 bytes)
 * @param traffic_secret The traffic secret (client/server handshake/app)
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_tls13_derive_traffic_keys(void *restrict key,
                                         size_t key_len,
                                         void *restrict iv,
                                         const void *restrict traffic_secret,
                                         int use_sha384);

/**
 * Derive the Finished key from a traffic secret.
 *
 * finished_key = HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)
 *
 * @param finished_key Output buffer (32 or 48 bytes)
 * @param traffic_secret The handshake traffic secret
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_tls13_derive_finished_key(void *restrict finished_key,
                                         const void *restrict traffic_secret,
                                         int use_sha384);

/**
 * Compute the Finished verify_data.
 *
 * verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context))
 *
 * @param verify_data Output buffer (32 or 48 bytes)
 * @param finished_key The finished key (from fio_tls13_derive_finished_key)
 * @param transcript_hash Hash of handshake messages up to this point
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_tls13_compute_finished(void *restrict verify_data,
                                      const void *restrict finished_key,
                                      const void *restrict transcript_hash,
                                      int use_sha384);

/**
 * Update application traffic secret for key update.
 *
 * application_traffic_secret_N+1 =
 *     HKDF-Expand-Label(application_traffic_secret_N, "traffic upd", "",
 * Hash.length)
 *
 * @param new_secret Output buffer (32 or 48 bytes)
 * @param current_secret Current application traffic secret
 * @param use_sha384 If non-zero, use SHA-384; otherwise SHA-256
 */
SFUNC void fio_tls13_update_traffic_secret(void *restrict new_secret,
                                           const void *restrict current_secret,
                                           int use_sha384);

/* *****************************************************************************
TLS 1.3 Record Layer Constants (RFC 8446 Section 5)
***************************************************************************** */

/** TLS record header length (5 bytes) */
#define FIO_TLS13_RECORD_HEADER_LEN 5
/** Maximum plaintext fragment length (2^14 = 16384 bytes) */
#define FIO_TLS13_MAX_PLAINTEXT_LEN 16384
/** Maximum ciphertext length (plaintext + padding + tag) */
#define FIO_TLS13_MAX_CIPHERTEXT_LEN (16384 + 256)
/** AEAD authentication tag length (16 bytes for all TLS 1.3 ciphers) */
#define FIO_TLS13_TAG_LEN 16
/** Legacy TLS version bytes (0x0303 = TLS 1.2) */
#define FIO_TLS13_LEGACY_VERSION_MAJOR 0x03
#define FIO_TLS13_LEGACY_VERSION_MINOR 0x03

/* *****************************************************************************
TLS 1.3 Content Types (RFC 8446 Section 5.1)
***************************************************************************** */

/** TLS 1.3 content types */
typedef enum {
  FIO_TLS13_CONTENT_INVALID = 0,
  FIO_TLS13_CONTENT_CHANGE_CIPHER_SPEC = 20, /* Legacy, ignored in TLS 1.3 */
  FIO_TLS13_CONTENT_ALERT = 21,
  FIO_TLS13_CONTENT_HANDSHAKE = 22,
  FIO_TLS13_CONTENT_APPLICATION_DATA = 23,
} fio_tls13_content_type_e;

/* *****************************************************************************
TLS 1.3 Handshake Message Types (RFC 8446 Section 4)
***************************************************************************** */

/** TLS 1.3 Handshake Message Types */
typedef enum {
  FIO_TLS13_HS_CLIENT_HELLO = 1,
  FIO_TLS13_HS_SERVER_HELLO = 2,
  FIO_TLS13_HS_NEW_SESSION_TICKET = 4,
  FIO_TLS13_HS_END_OF_EARLY_DATA = 5,
  FIO_TLS13_HS_ENCRYPTED_EXTENSIONS = 8,
  FIO_TLS13_HS_CERTIFICATE = 11,
  FIO_TLS13_HS_CERTIFICATE_REQUEST = 13,
  FIO_TLS13_HS_CERTIFICATE_VERIFY = 15,
  FIO_TLS13_HS_FINISHED = 20,
  FIO_TLS13_HS_KEY_UPDATE = 24,
  FIO_TLS13_HS_MESSAGE_HASH = 254,
} fio_tls13_handshake_type_e;

/** TLS 1.3 KeyUpdate Request Types (RFC 8446 Section 4.6.3) */
typedef enum {
  FIO_TLS13_KEY_UPDATE_NOT_REQUESTED = 0,
  FIO_TLS13_KEY_UPDATE_REQUESTED = 1,
} fio_tls13_key_update_request_e;

/** TLS 1.3 Extension Types (RFC 8446 Section 4.2) */
typedef enum {
  FIO_TLS13_EXT_SERVER_NAME = 0,           /* SNI */
  FIO_TLS13_EXT_SUPPORTED_GROUPS = 10,     /* Key exchange groups */
  FIO_TLS13_EXT_SIGNATURE_ALGORITHMS = 13, /* Signature schemes */
  FIO_TLS13_EXT_ALPN = 16, /* Application-Layer Protocol Negotiation */
  FIO_TLS13_EXT_SUPPORTED_VERSIONS = 43, /* TLS version negotiation */
  FIO_TLS13_EXT_COOKIE = 44,             /* Cookie for HRR (RFC 8446 4.2.2) */
  FIO_TLS13_EXT_KEY_SHARE = 51,          /* ECDHE key shares */
} fio_tls13_extension_type_e;

/** TLS 1.3 Cipher Suites (RFC 8446 Section B.4) */
typedef enum {
  FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256 = 0x1301,
  FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384 = 0x1302,
  FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256 = 0x1303,
} fio_tls13_cipher_suite_e;

/** TLS 1.3 Named Groups (RFC 8446 Section 4.2.7) */
typedef enum {
  FIO_TLS13_GROUP_SECP256R1 = 23, /* P-256 */
  FIO_TLS13_GROUP_SECP384R1 = 24, /* P-384 */
  FIO_TLS13_GROUP_X25519 = 29,    /* Curve25519 */
} fio_tls13_named_group_e;

/** TLS 1.3 Signature Algorithms (RFC 8446 Section 4.2.3) */
typedef enum {
  FIO_TLS13_SIG_RSA_PKCS1_SHA256 = 0x0401,
  FIO_TLS13_SIG_RSA_PKCS1_SHA384 = 0x0501,
  FIO_TLS13_SIG_RSA_PKCS1_SHA512 = 0x0601,
  FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256 = 0x0403,
  FIO_TLS13_SIG_ECDSA_SECP384R1_SHA384 = 0x0503,
  FIO_TLS13_SIG_RSA_PSS_RSAE_SHA256 = 0x0804,
  FIO_TLS13_SIG_RSA_PSS_RSAE_SHA384 = 0x0805,
  FIO_TLS13_SIG_ED25519 = 0x0807,
} fio_tls13_signature_scheme_e;

/** TLS 1.3 Protocol Version Constants */
#define FIO_TLS13_VERSION_TLS12 0x0303
#define FIO_TLS13_VERSION_TLS13 0x0304

/** HelloRetryRequest magic random value (RFC 8446 Section 4.1.3) */
#define FIO_TLS13_HRR_RANDOM                                                   \
  "\xCF\x21\xAD\x74\xE5\x9A\x61\x11\xBE\x1D\x8C\x02\x1E\x65\xB8\x91"           \
  "\xC2\xA2\x11\x16\x7A\xBB\x8C\x5E\x07\x9E\x09\xE2\xC8\xA8\x33\x9C"

/* *****************************************************************************
TLS 1.3 Parsed Handshake Message Structures
***************************************************************************** */

/** Parsed ServerHello message */
typedef struct {
  uint8_t random[32];         /* Server random */
  uint16_t cipher_suite;      /* Selected cipher suite */
  uint8_t key_share[128];     /* Server's key share (max size for P-384) */
  uint8_t key_share_len;      /* Length of key share */
  uint16_t key_share_group;   /* Selected group */
  int is_hello_retry_request; /* 1 if HRR */
} fio_tls13_server_hello_s;

/** Parsed EncryptedExtensions message */
typedef struct {
  int has_server_name; /* Server acknowledged SNI */
} fio_tls13_encrypted_extensions_s;

/** Parsed Certificate message (minimal - first cert only) */
typedef struct {
  const uint8_t *cert_data; /* Pointer to first certificate */
  size_t cert_len;          /* Length of first certificate */
} fio_tls13_certificate_s;

/** Parsed CertificateVerify message */
typedef struct {
  uint16_t signature_scheme;
  const uint8_t *signature;
  size_t signature_len;
} fio_tls13_certificate_verify_s;

/* *****************************************************************************
TLS 1.3 Cipher Suite Types
***************************************************************************** */

/** Supported AEAD cipher types for TLS 1.3 */
typedef enum {
  FIO_TLS13_CIPHER_AES_128_GCM = 0,       /* TLS_AES_128_GCM_SHA256 */
  FIO_TLS13_CIPHER_AES_256_GCM = 1,       /* TLS_AES_256_GCM_SHA384 */
  FIO_TLS13_CIPHER_CHACHA20_POLY1305 = 2, /* TLS_CHACHA20_POLY1305_SHA256 */
} fio_tls13_cipher_type_e;

/* *****************************************************************************
TLS 1.3 Record Structures
***************************************************************************** */

/** TLSPlaintext header structure (RFC 8446 Section 5.1) */
typedef struct {
  uint8_t content_type;      /* ContentType */
  uint8_t legacy_version[2]; /* 0x03, 0x03 (TLS 1.2) */
  uint16_t length;           /* Fragment length (big-endian) */
  /* Fragment follows (up to 2^14 bytes) */
} fio_tls13_plaintext_header_s;

/** TLSCiphertext header structure (RFC 8446 Section 5.2) */
typedef struct {
  uint8_t opaque_type;       /* Always 23 (application_data) */
  uint8_t legacy_version[2]; /* 0x03, 0x03 */
  uint16_t length;           /* Encrypted length + tag (big-endian) */
  /* Encrypted content follows */
} fio_tls13_ciphertext_header_s;

/** Record encryption context (per-direction keys) */
typedef struct {
  uint8_t key[32];          /* Write key (16 or 32 bytes depending on cipher) */
  uint8_t iv[12];           /* Write IV (always 12 bytes) */
  uint64_t sequence_number; /* Per-record sequence number (starts at 0) */
  uint8_t key_len;          /* 16 for AES-128, 32 for AES-256/ChaCha20 */
  uint8_t cipher_type;      /* fio_tls13_cipher_type_e */
} fio_tls13_record_keys_s;

/* *****************************************************************************
TLS 1.3 Record Layer API
***************************************************************************** */

/**
 * Build per-record nonce by XORing sequence number with IV.
 *
 * Per RFC 8446 Section 5.3:
 * - Pad 64-bit sequence number to 12 bytes (big-endian, left-padded with zeros)
 * - XOR with the static IV derived from traffic secret
 *
 * @param nonce Output buffer (must be 12 bytes)
 * @param iv    Static IV from key derivation (12 bytes)
 * @param seq   64-bit sequence number
 */
FIO_IFUNC void fio_tls13_build_nonce(uint8_t nonce[12],
                                     const uint8_t iv[12],
                                     uint64_t seq);

/**
 * Parse a TLS record header.
 *
 * @param data         Input buffer containing record data
 * @param data_len     Length of input buffer
 * @param content_type Output: content type from header
 * @param payload_len  Output: payload length from header
 * @return Pointer to payload data, or NULL if incomplete/invalid
 */
SFUNC const uint8_t *fio_tls13_record_parse_header(
    const uint8_t *data,
    size_t data_len,
    fio_tls13_content_type_e *content_type,
    size_t *payload_len);

/**
 * Encrypt a TLS 1.3 record.
 *
 * Per RFC 8446 Section 5.2:
 * - Output format: 5-byte header + encrypted(plaintext + content_type) + tag
 * - AAD is the 5-byte record header
 * - Sequence number is incremented after encryption
 *
 * @param out          Output buffer for encrypted record
 * @param out_capacity Capacity of output buffer
 * @param plaintext    Plaintext data to encrypt
 * @param plaintext_len Length of plaintext
 * @param content_type  Content type (appended to plaintext before encryption)
 * @param keys         Encryption keys (sequence number will be incremented)
 * @return Total output length (header + ciphertext + tag), or -1 on error
 */
SFUNC int fio_tls13_record_encrypt(uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *plaintext,
                                   size_t plaintext_len,
                                   fio_tls13_content_type_e content_type,
                                   fio_tls13_record_keys_s *keys);

/**
 * Decrypt a TLS 1.3 record.
 *
 * Per RFC 8446 Section 5.2:
 * - Input includes 5-byte header
 * - Decrypts and verifies AEAD tag
 * - Scans backwards to find real content type (removes padding)
 * - Sequence number is incremented after successful decryption
 *
 * @param out          Output buffer for decrypted plaintext
 * @param out_capacity Capacity of output buffer
 * @param content_type Output: actual content type from inner plaintext
 * @param ciphertext   Input ciphertext (includes 5-byte header)
 * @param ciphertext_len Total length including header
 * @param keys         Decryption keys (sequence number will be incremented)
 * @return Plaintext length (excluding padding and content type), or -1 on error
 */
SFUNC int fio_tls13_record_decrypt(uint8_t *out,
                                   size_t out_capacity,
                                   fio_tls13_content_type_e *content_type,
                                   const uint8_t *ciphertext,
                                   size_t ciphertext_len,
                                   fio_tls13_record_keys_s *keys);

/**
 * Initialize record keys structure.
 *
 * @param keys        Keys structure to initialize
 * @param key         Key material (16 or 32 bytes)
 * @param key_len     Key length (16 for AES-128, 32 for AES-256/ChaCha20)
 * @param iv          IV material (12 bytes)
 * @param cipher_type Cipher type (fio_tls13_cipher_type_e)
 */
SFUNC void fio_tls13_record_keys_init(fio_tls13_record_keys_s *keys,
                                      const uint8_t *key,
                                      uint8_t key_len,
                                      const uint8_t iv[12],
                                      fio_tls13_cipher_type_e cipher_type);

/**
 * Clear sensitive key material from memory.
 *
 * @param keys Keys structure to clear
 */
FIO_IFUNC void fio_tls13_record_keys_clear(fio_tls13_record_keys_s *keys);

/* *****************************************************************************
TLS 1.3 Handshake Message API (RFC 8446 Section 4)
***************************************************************************** */

/**
 * Parse handshake header, return message type and body pointer.
 *
 * Returns pointer to message body, or NULL on error.
 * Sets msg_type and body_len on success.
 */
SFUNC const uint8_t *fio_tls13_parse_handshake_header(
    const uint8_t *data,
    size_t data_len,
    fio_tls13_handshake_type_e *msg_type,
    size_t *body_len);

/**
 * Write handshake header (4 bytes).
 *
 * Format: HandshakeType (1 byte) + uint24 length (3 bytes)
 */
SFUNC void fio_tls13_write_handshake_header(uint8_t *out,
                                            fio_tls13_handshake_type_e msg_type,
                                            size_t body_len);

/**
 * Build a ClientHello message.
 *
 * Returns: message length on success, -1 on error.
 *
 * Parameters:
 * - out: output buffer
 * - out_capacity: size of output buffer
 * - random: 32-byte client random
 * - server_name: SNI hostname (NULL if not used)
 * - x25519_pubkey: 32-byte X25519 public key
 * - cipher_suites: array of cipher suites to offer
 * - cipher_suite_count: number of cipher suites
 */
SFUNC int fio_tls13_build_client_hello(uint8_t *out,
                                       size_t out_capacity,
                                       const uint8_t random[32],
                                       const char *server_name,
                                       const uint8_t *x25519_pubkey,
                                       const uint16_t *cipher_suites,
                                       size_t cipher_suite_count);

/**
 * Parse ServerHello message.
 *
 * Returns: 0 on success, -1 on error.
 *
 * Note: data should point to the handshake body (after the 4-byte header).
 */
SFUNC int fio_tls13_parse_server_hello(fio_tls13_server_hello_s *out,
                                       const uint8_t *data,
                                       size_t data_len);

/**
 * Parse EncryptedExtensions message.
 *
 * Returns: 0 on success, -1 on error.
 */
SFUNC int fio_tls13_parse_encrypted_extensions(
    fio_tls13_encrypted_extensions_s *out,
    const uint8_t *data,
    size_t data_len);

/**
 * Parse Certificate message (extracts first certificate only).
 *
 * Returns: 0 on success, -1 on error.
 */
SFUNC int fio_tls13_parse_certificate(fio_tls13_certificate_s *out,
                                      const uint8_t *data,
                                      size_t data_len);

/**
 * Parse CertificateVerify message.
 *
 * Returns: 0 on success, -1 on error.
 */
SFUNC int fio_tls13_parse_certificate_verify(
    fio_tls13_certificate_verify_s *out,
    const uint8_t *data,
    size_t data_len);

/**
 * Build Finished message.
 *
 * verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context))
 *
 * Returns: message length on success, -1 on error.
 */
SFUNC int fio_tls13_build_finished(uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *verify_data,
                                   size_t verify_data_len);

/**
 * Parse and verify Finished message.
 *
 * Returns: 0 on success (MAC matches), -1 on error.
 */
SFUNC int fio_tls13_parse_finished(const uint8_t *data,
                                   size_t data_len,
                                   const uint8_t *expected_verify_data,
                                   size_t verify_data_len);

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
HKDF-Expand-Label Implementation
***************************************************************************** */

SFUNC void fio_tls13_hkdf_expand_label(void *restrict out,
                                       size_t out_len,
                                       const void *restrict secret,
                                       size_t secret_len,
                                       const char *label,
                                       size_t label_len,
                                       const void *restrict context,
                                       size_t context_len,
                                       int use_sha384) {
  if (!out || !secret || out_len == 0 || out_len > 255)
    return;

  /* Clamp label and context lengths */
  if (label_len > 249)
    label_len = 249;
  if (context_len > 255)
    context_len = 255;

  /*
   * HkdfLabel structure:
   *   uint16 length = out_len
   *   opaque label<7..255> = "tls13 " + Label
   *   opaque context<0..255> = Context
   *
   * Encoded as:
   *   [2 bytes: out_len]
   *   [1 byte: label_len + 6]
   *   [6 bytes: "tls13 "]
   *   [label_len bytes: label]
   *   [1 byte: context_len]
   *   [context_len bytes: context]
   */
  uint8_t hkdf_label[2 + 1 + 6 + 249 + 1 + 255];
  size_t hkdf_label_len = 0;

  /* Length (2 bytes, big-endian) */
  hkdf_label[hkdf_label_len++] = (uint8_t)(out_len >> 8);
  hkdf_label[hkdf_label_len++] = (uint8_t)(out_len & 0xFF);

  /* Label length (1 byte) = 6 + label_len */
  hkdf_label[hkdf_label_len++] = (uint8_t)(6 + label_len);

  /* "tls13 " prefix (6 bytes) */
  hkdf_label[hkdf_label_len++] = 't';
  hkdf_label[hkdf_label_len++] = 'l';
  hkdf_label[hkdf_label_len++] = 's';
  hkdf_label[hkdf_label_len++] = '1';
  hkdf_label[hkdf_label_len++] = '3';
  hkdf_label[hkdf_label_len++] = ' ';

  /* Label */
  if (label && label_len > 0) {
    FIO_MEMCPY(hkdf_label + hkdf_label_len, label, label_len);
    hkdf_label_len += label_len;
  }

  /* Context length (1 byte) */
  hkdf_label[hkdf_label_len++] = (uint8_t)context_len;

  /* Context */
  if (context && context_len > 0) {
    FIO_MEMCPY(hkdf_label + hkdf_label_len, context, context_len);
    hkdf_label_len += context_len;
  }

  /* Call HKDF-Expand with the constructed label */
  fio_hkdf_expand(out,
                  out_len,
                  secret,
                  secret_len,
                  hkdf_label,
                  hkdf_label_len,
                  use_sha384);
}

/* *****************************************************************************
Derive-Secret Implementation
***************************************************************************** */

SFUNC void fio_tls13_derive_secret(void *restrict out,
                                   const void *restrict secret,
                                   size_t secret_len,
                                   const char *label,
                                   size_t label_len,
                                   const void *restrict transcript_hash,
                                   size_t hash_len,
                                   int use_sha384) {
  const size_t out_len = use_sha384 ? 48 : 32;

  /* If no transcript hash provided, use hash of empty string */
  uint8_t empty_hash[48];
  const void *hash_to_use = transcript_hash;
  size_t hash_len_to_use = hash_len;

  if (!transcript_hash || hash_len == 0) {
    /* Hash of empty string */
    if (use_sha384) {
      fio_u512 h = fio_sha512("", 0);
      FIO_MEMCPY(empty_hash, h.u8, 48);
      hash_len_to_use = 48;
    } else {
      fio_u256 h = fio_sha256("", 0);
      FIO_MEMCPY(empty_hash, h.u8, 32);
      hash_len_to_use = 32;
    }
    hash_to_use = empty_hash;
  }

  fio_tls13_hkdf_expand_label(out,
                              out_len,
                              secret,
                              secret_len,
                              label,
                              label_len,
                              hash_to_use,
                              hash_len_to_use,
                              use_sha384);
}

/* *****************************************************************************
Key Schedule Derivation Implementation
***************************************************************************** */

SFUNC void fio_tls13_derive_early_secret(void *restrict early_secret,
                                         const void *restrict psk,
                                         size_t psk_len,
                                         int use_sha384) {
  const size_t hash_len = use_sha384 ? 48 : 32;

  /* If no PSK, use zeros of hash length */
  uint8_t zero_psk[48] = {0};
  const void *ikm = psk;
  size_t ikm_len = psk_len;

  if (!psk || psk_len == 0) {
    ikm = zero_psk;
    ikm_len = hash_len;
  }

  /* Early Secret = HKDF-Extract(salt=0, IKM=PSK) */
  fio_hkdf_extract(early_secret, NULL, 0, ikm, ikm_len, use_sha384);
}

SFUNC void fio_tls13_derive_handshake_secret(void *restrict handshake_secret,
                                             const void *restrict early_secret,
                                             const void *restrict ecdhe_secret,
                                             size_t ecdhe_len,
                                             int use_sha384) {
  const size_t hash_len = use_sha384 ? 48 : 32;
  uint8_t derived[48];

  /* Derive-Secret(Early Secret, "derived", "") */
  fio_tls13_derive_secret(derived,
                          early_secret,
                          hash_len,
                          "derived",
                          7,
                          NULL,
                          0,
                          use_sha384);

  /* Handshake Secret = HKDF-Extract(salt=derived, IKM=ECDHE) */
  fio_hkdf_extract(handshake_secret,
                   derived,
                   hash_len,
                   ecdhe_secret,
                   ecdhe_len,
                   use_sha384);
}

SFUNC void fio_tls13_derive_master_secret(void *restrict master_secret,
                                          const void *restrict handshake_secret,
                                          int use_sha384) {
  const size_t hash_len = use_sha384 ? 48 : 32;
  uint8_t derived[48];
  uint8_t zero_ikm[48] = {0};

  /* Derive-Secret(Handshake Secret, "derived", "") */
  fio_tls13_derive_secret(derived,
                          handshake_secret,
                          hash_len,
                          "derived",
                          7,
                          NULL,
                          0,
                          use_sha384);

  /* Master Secret = HKDF-Extract(salt=derived, IKM=0) */
  fio_hkdf_extract(master_secret,
                   derived,
                   hash_len,
                   zero_ikm,
                   hash_len,
                   use_sha384);
}

/* *****************************************************************************
Traffic Key Derivation Implementation
***************************************************************************** */

SFUNC void fio_tls13_derive_traffic_keys(void *restrict key,
                                         size_t key_len,
                                         void *restrict iv,
                                         const void *restrict traffic_secret,
                                         int use_sha384) {
  const size_t secret_len = use_sha384 ? 48 : 32;

  /* [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length) */
  fio_tls13_hkdf_expand_label(key,
                              key_len,
                              traffic_secret,
                              secret_len,
                              "key",
                              3,
                              NULL,
                              0,
                              use_sha384);

  /* [sender]_write_iv = HKDF-Expand-Label(Secret, "iv", "", iv_length) */
  fio_tls13_hkdf_expand_label(iv,
                              FIO_TLS13_IV_LEN,
                              traffic_secret,
                              secret_len,
                              "iv",
                              2,
                              NULL,
                              0,
                              use_sha384);
}

SFUNC void fio_tls13_derive_finished_key(void *restrict finished_key,
                                         const void *restrict traffic_secret,
                                         int use_sha384) {
  const size_t hash_len = use_sha384 ? 48 : 32;

  /* finished_key = HKDF-Expand-Label(BaseKey, "finished", "", Hash.length) */
  fio_tls13_hkdf_expand_label(finished_key,
                              hash_len,
                              traffic_secret,
                              hash_len,
                              "finished",
                              8,
                              NULL,
                              0,
                              use_sha384);
}

SFUNC void fio_tls13_compute_finished(void *restrict verify_data,
                                      const void *restrict finished_key,
                                      const void *restrict transcript_hash,
                                      int use_sha384) {
  /* verify_data = HMAC(finished_key, Transcript-Hash) */
  if (use_sha384) {
    fio_u512 hmac = fio_sha512_hmac(finished_key, 48, transcript_hash, 48);
    FIO_MEMCPY(verify_data, hmac.u8, 48);
  } else {
    fio_u256 hmac = fio_sha256_hmac(finished_key, 32, transcript_hash, 32);
    FIO_MEMCPY(verify_data, hmac.u8, 32);
  }
}

SFUNC void fio_tls13_update_traffic_secret(void *restrict new_secret,
                                           const void *restrict current_secret,
                                           int use_sha384) {
  const size_t hash_len = use_sha384 ? 48 : 32;

  /* new_secret = HKDF-Expand-Label(current, "traffic upd", "", Hash.length) */
  fio_tls13_hkdf_expand_label(new_secret,
                              hash_len,
                              current_secret,
                              hash_len,
                              "traffic upd",
                              11,
                              NULL,
                              0,
                              use_sha384);
}

/* *****************************************************************************
TLS 1.3 Record Layer Implementation (RFC 8446 Section 5)
***************************************************************************** */

/* Build per-record nonce: sequence_number XOR iv */
FIO_IFUNC void fio_tls13_build_nonce(uint8_t nonce[12],
                                     const uint8_t iv[12],
                                     uint64_t seq) {
  /* Copy IV to nonce */
  FIO_MEMCPY(nonce, iv, 12);

  /* XOR sequence number into rightmost 8 bytes (big-endian)
   * Sequence number is padded to 12 bytes with leading zeros,
   * so we only XOR the last 8 bytes */
  nonce[4] ^= (uint8_t)(seq >> 56);
  nonce[5] ^= (uint8_t)(seq >> 48);
  nonce[6] ^= (uint8_t)(seq >> 40);
  nonce[7] ^= (uint8_t)(seq >> 32);
  nonce[8] ^= (uint8_t)(seq >> 24);
  nonce[9] ^= (uint8_t)(seq >> 16);
  nonce[10] ^= (uint8_t)(seq >> 8);
  nonce[11] ^= (uint8_t)(seq);
}

/* Parse record header */
SFUNC const uint8_t *fio_tls13_record_parse_header(
    const uint8_t *data,
    size_t data_len,
    fio_tls13_content_type_e *content_type,
    size_t *payload_len) {
  /* Need at least header */
  if (!data || data_len < FIO_TLS13_RECORD_HEADER_LEN)
    return NULL;

  /* Extract content type */
  uint8_t ct = data[0];

  /* Validate content type */
  if (ct != FIO_TLS13_CONTENT_CHANGE_CIPHER_SPEC &&
      ct != FIO_TLS13_CONTENT_ALERT && ct != FIO_TLS13_CONTENT_HANDSHAKE &&
      ct != FIO_TLS13_CONTENT_APPLICATION_DATA) {
    return NULL;
  }

  /* Extract length (big-endian) */
  uint16_t len = fio_buf2u16_be(data + 3);

  /* Validate length */
  if (len > FIO_TLS13_MAX_CIPHERTEXT_LEN)
    return NULL;

  /* Check if we have complete record */
  if (data_len < (size_t)(FIO_TLS13_RECORD_HEADER_LEN + len))
    return NULL;

  if (content_type)
    *content_type = (fio_tls13_content_type_e)ct;
  if (payload_len)
    *payload_len = len;

  return data + FIO_TLS13_RECORD_HEADER_LEN;
}

/* Initialize record keys */
SFUNC void fio_tls13_record_keys_init(fio_tls13_record_keys_s *keys,
                                      const uint8_t *key,
                                      uint8_t key_len,
                                      const uint8_t iv[12],
                                      fio_tls13_cipher_type_e cipher_type) {
  if (!keys)
    return;

  FIO_MEMSET(keys, 0, sizeof(*keys));

  /* Validate and copy key */
  if (key && key_len > 0) {
    uint8_t copy_len = (key_len > 32) ? 32 : key_len;
    FIO_MEMCPY(keys->key, key, copy_len);
    keys->key_len = copy_len;
  }

  /* Copy IV */
  if (iv)
    FIO_MEMCPY(keys->iv, iv, FIO_TLS13_IV_LEN);

  keys->cipher_type = (uint8_t)cipher_type;
  keys->sequence_number = 0;
}

/* Clear sensitive key material */
FIO_IFUNC void fio_tls13_record_keys_clear(fio_tls13_record_keys_s *keys) {
  if (keys)
    fio_secure_zero(keys, sizeof(*keys));
}

/* Internal: AEAD encrypt using appropriate cipher */
FIO_SFUNC int fio___tls13_aead_encrypt(uint8_t *ciphertext,
                                       uint8_t *tag,
                                       const uint8_t *plaintext,
                                       size_t plaintext_len,
                                       const uint8_t *aad,
                                       size_t aad_len,
                                       const uint8_t *key,
                                       uint8_t key_len,
                                       const uint8_t *nonce,
                                       fio_tls13_cipher_type_e cipher_type) {
  /* Copy plaintext to ciphertext buffer (in-place encryption) */
  if (plaintext != ciphertext && plaintext_len > 0)
    FIO_MEMCPY(ciphertext, plaintext, plaintext_len);

  switch (cipher_type) {
  case FIO_TLS13_CIPHER_AES_128_GCM:
    fio_aes128_gcm_enc(tag,
                       ciphertext,
                       plaintext_len,
                       aad,
                       aad_len,
                       key,
                       nonce);
    return 0;

  case FIO_TLS13_CIPHER_AES_256_GCM:
    fio_aes256_gcm_enc(tag,
                       ciphertext,
                       plaintext_len,
                       aad,
                       aad_len,
                       key,
                       nonce);
    return 0;

  case FIO_TLS13_CIPHER_CHACHA20_POLY1305:
    fio_chacha20_poly1305_enc(tag,
                              ciphertext,
                              plaintext_len,
                              aad,
                              aad_len,
                              key,
                              nonce);
    return 0;

  default: return -1;
  }
  (void)key_len; /* Used for validation in debug builds */
}

/* Internal: AEAD decrypt using appropriate cipher */
FIO_SFUNC int fio___tls13_aead_decrypt(uint8_t *plaintext,
                                       const uint8_t *tag,
                                       const uint8_t *ciphertext,
                                       size_t ciphertext_len,
                                       const uint8_t *aad,
                                       size_t aad_len,
                                       const uint8_t *key,
                                       uint8_t key_len,
                                       const uint8_t *nonce,
                                       fio_tls13_cipher_type_e cipher_type) {
  /* Copy ciphertext to plaintext buffer (in-place decryption) */
  if (ciphertext != plaintext && ciphertext_len > 0)
    FIO_MEMCPY(plaintext, ciphertext, ciphertext_len);

  /* Need mutable tag for the decrypt functions */
  uint8_t tag_copy[FIO_TLS13_TAG_LEN];
  FIO_MEMCPY(tag_copy, tag, FIO_TLS13_TAG_LEN);

  int ret = -1;
  switch (cipher_type) {
  case FIO_TLS13_CIPHER_AES_128_GCM:
    ret = fio_aes128_gcm_dec(tag_copy,
                             plaintext,
                             ciphertext_len,
                             aad,
                             aad_len,
                             key,
                             nonce);
    break;

  case FIO_TLS13_CIPHER_AES_256_GCM:
    ret = fio_aes256_gcm_dec(tag_copy,
                             plaintext,
                             ciphertext_len,
                             aad,
                             aad_len,
                             key,
                             nonce);
    break;

  case FIO_TLS13_CIPHER_CHACHA20_POLY1305:
    ret = fio_chacha20_poly1305_dec(tag_copy,
                                    plaintext,
                                    ciphertext_len,
                                    aad,
                                    aad_len,
                                    key,
                                    nonce);
    break;

  default: ret = -1; break;
  }

  fio_secure_zero(tag_copy, sizeof(tag_copy));
  (void)key_len;
  return ret;
}

/* Encrypt a TLS 1.3 record */
SFUNC int fio_tls13_record_encrypt(uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *plaintext,
                                   size_t plaintext_len,
                                   fio_tls13_content_type_e content_type,
                                   fio_tls13_record_keys_s *keys) {
  if (!out || !keys)
    return -1;

  /* Validate plaintext length */
  if (plaintext_len > FIO_TLS13_MAX_PLAINTEXT_LEN)
    return -1;

  /* Calculate output size:
   * header(5) + plaintext + content_type(1) + tag(16) */
  size_t inner_len = plaintext_len + 1; /* plaintext + content_type byte */
  size_t total_len =
      FIO_TLS13_RECORD_HEADER_LEN + inner_len + FIO_TLS13_TAG_LEN;

  if (out_capacity < total_len)
    return -1;

  /* Build record header (this becomes the AAD) */
  uint8_t *header = out;
  header[0] = FIO_TLS13_CONTENT_APPLICATION_DATA; /* opaque_type always 23 */
  header[1] = FIO_TLS13_LEGACY_VERSION_MAJOR;
  header[2] = FIO_TLS13_LEGACY_VERSION_MINOR;
  fio_u2buf16_be(header + 3, (uint16_t)(inner_len + FIO_TLS13_TAG_LEN));

  /* Prepare inner plaintext: plaintext || content_type */
  uint8_t *ct_out = out + FIO_TLS13_RECORD_HEADER_LEN;

  /* Copy plaintext if provided */
  if (plaintext && plaintext_len > 0)
    FIO_MEMCPY(ct_out, plaintext, plaintext_len);

  /* Append content type */
  ct_out[plaintext_len] = (uint8_t)content_type;

  /* Build nonce */
  uint8_t nonce[FIO_TLS13_IV_LEN];
  fio_tls13_build_nonce(nonce, keys->iv, keys->sequence_number);

  /* Tag goes after ciphertext */
  uint8_t *tag = ct_out + inner_len;

  /* Encrypt with AAD = record header */
  int ret =
      fio___tls13_aead_encrypt(ct_out,
                               tag,
                               ct_out,
                               inner_len,
                               header,
                               FIO_TLS13_RECORD_HEADER_LEN,
                               keys->key,
                               keys->key_len,
                               nonce,
                               (fio_tls13_cipher_type_e)keys->cipher_type);

  /* Note: nonce is not secret (derived from IV and sequence number which
   * remain in memory), so no need to zero it for security. */

  if (ret != 0)
    return -1;

  /* Increment sequence number */
  ++keys->sequence_number;

  return (int)total_len;
}

/* Decrypt a TLS 1.3 record */
SFUNC int fio_tls13_record_decrypt(uint8_t *out,
                                   size_t out_capacity,
                                   fio_tls13_content_type_e *content_type,
                                   const uint8_t *ciphertext,
                                   size_t ciphertext_len,
                                   fio_tls13_record_keys_s *keys) {
  if (!out || !ciphertext || !keys || !content_type)
    return -1;

  /* Parse header */
  fio_tls13_content_type_e outer_type;
  size_t payload_len;
  const uint8_t *payload = fio_tls13_record_parse_header(ciphertext,
                                                         ciphertext_len,
                                                         &outer_type,
                                                         &payload_len);
  if (!payload)
    return -1;

  /* For encrypted records, outer type must be application_data */
  if (outer_type != FIO_TLS13_CONTENT_APPLICATION_DATA)
    return -1;

  /* Payload must include at least tag + 1 byte (content type) */
  if (payload_len < FIO_TLS13_TAG_LEN + 1)
    return -1;

  /* Calculate inner ciphertext length (excluding tag) */
  size_t inner_ct_len = payload_len - FIO_TLS13_TAG_LEN;

  /* Check output capacity */
  if (out_capacity < inner_ct_len)
    return -1;

  /* Extract tag (last 16 bytes of payload) */
  const uint8_t *tag = payload + inner_ct_len;

  /* Build nonce */
  uint8_t nonce[FIO_TLS13_IV_LEN];
  fio_tls13_build_nonce(nonce, keys->iv, keys->sequence_number);

  /* AAD is the 5-byte record header */
  const uint8_t *aad = ciphertext;

  /* Decrypt */
  int ret =
      fio___tls13_aead_decrypt(out,
                               tag,
                               payload,
                               inner_ct_len,
                               aad,
                               FIO_TLS13_RECORD_HEADER_LEN,
                               keys->key,
                               keys->key_len,
                               nonce,
                               (fio_tls13_cipher_type_e)keys->cipher_type);

  /* Note: nonce is not secret (derived from IV and sequence number which
   * remain in memory), so no need to zero it for security. */

  if (ret != 0)
    return -1;

  /* Scan backwards to find real content type (skip zero padding)
   * Per RFC 8446: zeros are optional padding, real content type is
   * the last non-zero byte */
  size_t pt_len = inner_ct_len;
  while (pt_len > 0 && out[pt_len - 1] == 0)
    --pt_len;

  /* Must have at least the content type byte */
  if (pt_len == 0)
    return -1;

  /* Last non-zero byte is the content type */
  uint8_t inner_type = out[pt_len - 1];
  --pt_len; /* Exclude content type from plaintext length */

  /* Validate content type */
  if (inner_type != FIO_TLS13_CONTENT_ALERT &&
      inner_type != FIO_TLS13_CONTENT_HANDSHAKE &&
      inner_type != FIO_TLS13_CONTENT_APPLICATION_DATA) {
    /* Zero out decrypted data on invalid content type */
    fio_secure_zero(out, inner_ct_len);
    return -1;
  }

  *content_type = (fio_tls13_content_type_e)inner_type;

  /* Increment sequence number */
  ++keys->sequence_number;

  return (int)pt_len;
}

/* *****************************************************************************
TLS 1.3 Handshake Message Implementation (RFC 8446 Section 4)
***************************************************************************** */

/* Internal: Write uint16 big-endian */
FIO_SFUNC void fio___tls13_write_u16(uint8_t *out, uint16_t val) {
  out[0] = (uint8_t)(val >> 8);
  out[1] = (uint8_t)(val & 0xFF);
}

/* Internal: Read uint16 big-endian */
FIO_SFUNC uint16_t fio___tls13_read_u16(const uint8_t *data) {
  return (uint16_t)((data[0] << 8) | data[1]);
}

/* Internal: Write uint24 big-endian */
FIO_SFUNC void fio___tls13_write_u24(uint8_t *out, uint32_t val) {
  out[0] = (uint8_t)((val >> 16) & 0xFF);
  out[1] = (uint8_t)((val >> 8) & 0xFF);
  out[2] = (uint8_t)(val & 0xFF);
}

/* Internal: Read uint24 big-endian */
FIO_SFUNC uint32_t fio___tls13_read_u24(const uint8_t *data) {
  return ((uint32_t)data[0] << 16) | ((uint32_t)data[1] << 8) |
         (uint32_t)data[2];
}

/* Parse handshake header */
SFUNC const uint8_t *fio_tls13_parse_handshake_header(
    const uint8_t *data,
    size_t data_len,
    fio_tls13_handshake_type_e *msg_type,
    size_t *body_len) {
  /* Handshake header is 4 bytes: type(1) + length(3) */
  if (!data || data_len < 4)
    return NULL;

  uint8_t type = data[0];
  uint32_t len = fio___tls13_read_u24(data + 1);

  /* Validate we have complete message */
  if (data_len < 4 + len)
    return NULL;

  if (msg_type)
    *msg_type = (fio_tls13_handshake_type_e)type;
  if (body_len)
    *body_len = len;

  return data + 4;
}

/* Write handshake header */
SFUNC void fio_tls13_write_handshake_header(uint8_t *out,
                                            fio_tls13_handshake_type_e msg_type,
                                            size_t body_len) {
  if (!out)
    return;
  out[0] = (uint8_t)msg_type;
  fio___tls13_write_u24(out + 1, (uint32_t)body_len);
}

/* *****************************************************************************
ClientHello Building Implementation
***************************************************************************** */

/* Internal: Write SNI extension */
FIO_SFUNC size_t fio___tls13_write_ext_sni(uint8_t *out,
                                           const char *server_name) {
  if (!server_name)
    return 0;

  size_t name_len = 0;
  while (server_name[name_len] && name_len < 255)
    ++name_len;
  if (name_len == 0)
    return 0;

  uint8_t *p = out;

  /* Extension type: server_name (0) */
  fio___tls13_write_u16(p, FIO_TLS13_EXT_SERVER_NAME);
  p += 2;

  /* Extension data length: list_len(2) + entry_type(1) + name_len(2) + name */
  uint16_t ext_len = (uint16_t)(2 + 1 + 2 + name_len);
  fio___tls13_write_u16(p, ext_len);
  p += 2;

  /* Server name list length */
  fio___tls13_write_u16(p, (uint16_t)(1 + 2 + name_len));
  p += 2;

  /* Name type: host_name (0) */
  *p++ = 0;

  /* Host name length */
  fio___tls13_write_u16(p, (uint16_t)name_len);
  p += 2;

  /* Host name */
  FIO_MEMCPY(p, server_name, name_len);
  p += name_len;

  return (size_t)(p - out);
}

/* Internal: Write supported_versions extension (client) */
FIO_SFUNC size_t fio___tls13_write_ext_supported_versions(uint8_t *out) {
  uint8_t *p = out;

  /* Extension type: supported_versions (43) */
  fio___tls13_write_u16(p, FIO_TLS13_EXT_SUPPORTED_VERSIONS);
  p += 2;

  /* Extension data length: versions_len(1) + version(2) */
  fio___tls13_write_u16(p, 3);
  p += 2;

  /* Versions length (1 version = 2 bytes) */
  *p++ = 2;

  /* TLS 1.3 (0x0304) */
  fio___tls13_write_u16(p, FIO_TLS13_VERSION_TLS13);
  p += 2;

  return (size_t)(p - out);
}

/* Internal: Write supported_groups extension */
FIO_SFUNC size_t fio___tls13_write_ext_supported_groups(uint8_t *out) {
  uint8_t *p = out;

  /* Extension type: supported_groups (10) */
  fio___tls13_write_u16(p, FIO_TLS13_EXT_SUPPORTED_GROUPS);
  p += 2;

  /* Extension data length: groups_len(2) + groups(2 each) */
  /* We support: x25519, secp256r1 */
  fio___tls13_write_u16(p, 2 + 4); /* 2 groups * 2 bytes each */
  p += 2;

  /* Groups length */
  fio___tls13_write_u16(p, 4);
  p += 2;

  /* x25519 (preferred) */
  fio___tls13_write_u16(p, FIO_TLS13_GROUP_X25519);
  p += 2;

  /* secp256r1 (fallback) */
  fio___tls13_write_u16(p, FIO_TLS13_GROUP_SECP256R1);
  p += 2;

  return (size_t)(p - out);
}

/* Internal: Write signature_algorithms extension */
FIO_SFUNC size_t fio___tls13_write_ext_signature_algorithms(uint8_t *out) {
  uint8_t *p = out;

  /* Extension type: signature_algorithms (13) */
  fio___tls13_write_u16(p, FIO_TLS13_EXT_SIGNATURE_ALGORITHMS);
  p += 2;

  /* We support: ed25519, ecdsa_secp256r1_sha256, rsa_pss_rsae_sha256,
   * rsa_pkcs1_sha256 */
  uint16_t algos[] = {FIO_TLS13_SIG_ED25519,
                      FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256,
                      FIO_TLS13_SIG_RSA_PSS_RSAE_SHA256,
                      FIO_TLS13_SIG_RSA_PKCS1_SHA256,
                      FIO_TLS13_SIG_RSA_PSS_RSAE_SHA384,
                      FIO_TLS13_SIG_RSA_PKCS1_SHA384};
  size_t algo_count = sizeof(algos) / sizeof(algos[0]);

  /* Extension data length: algos_len(2) + algos */
  fio___tls13_write_u16(p, (uint16_t)(2 + algo_count * 2));
  p += 2;

  /* Algorithms length */
  fio___tls13_write_u16(p, (uint16_t)(algo_count * 2));
  p += 2;

  /* Write algorithms */
  for (size_t i = 0; i < algo_count; ++i) {
    fio___tls13_write_u16(p, algos[i]);
    p += 2;
  }

  return (size_t)(p - out);
}

/* Internal: Write key_share extension (client) */
FIO_SFUNC size_t fio___tls13_write_ext_key_share(uint8_t *out,
                                                 const uint8_t *x25519_pubkey) {
  if (!x25519_pubkey)
    return 0;

  uint8_t *p = out;

  /* Extension type: key_share (51) */
  fio___tls13_write_u16(p, FIO_TLS13_EXT_KEY_SHARE);
  p += 2;

  /* Extension data length: entries_len(2) + entry */
  /* Entry: group(2) + key_len(2) + key(32) = 36 bytes */
  fio___tls13_write_u16(p, 2 + 36);
  p += 2;

  /* Client key share entries length */
  fio___tls13_write_u16(p, 36);
  p += 2;

  /* Key share entry: x25519 */
  fio___tls13_write_u16(p, FIO_TLS13_GROUP_X25519);
  p += 2;

  /* Key length (32 for x25519) */
  fio___tls13_write_u16(p, 32);
  p += 2;

  /* Public key */
  FIO_MEMCPY(p, x25519_pubkey, 32);
  p += 32;

  return (size_t)(p - out);
}

/* Build ClientHello message */
SFUNC int fio_tls13_build_client_hello(uint8_t *out,
                                       size_t out_capacity,
                                       const uint8_t random[32],
                                       const char *server_name,
                                       const uint8_t *x25519_pubkey,
                                       const uint16_t *cipher_suites,
                                       size_t cipher_suite_count) {
  if (!out || !random || out_capacity < 256)
    return -1;

  /* Default cipher suites if none provided */
  uint16_t default_suites[] = {FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256,
                               FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256,
                               FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384};
  if (!cipher_suites || cipher_suite_count == 0) {
    cipher_suites = default_suites;
    cipher_suite_count = 3;
  }

  uint8_t *p = out + 4; /* Skip handshake header for now */
  uint8_t *start = p;

  /* Legacy version: TLS 1.2 (0x0303) */
  fio___tls13_write_u16(p, FIO_TLS13_VERSION_TLS12);
  p += 2;

  /* Random (32 bytes) */
  FIO_MEMCPY(p, random, 32);
  p += 32;

  /* Legacy session ID (empty for TLS 1.3) */
  *p++ = 0;

  /* Cipher suites */
  fio___tls13_write_u16(p, (uint16_t)(cipher_suite_count * 2));
  p += 2;
  for (size_t i = 0; i < cipher_suite_count; ++i) {
    fio___tls13_write_u16(p, cipher_suites[i]);
    p += 2;
  }

  /* Legacy compression methods (only null) */
  *p++ = 1; /* Length */
  *p++ = 0; /* null compression */

  /* Extensions */
  uint8_t *ext_len_ptr = p;
  p += 2; /* Skip extensions length for now */
  uint8_t *ext_start = p;

  /* SNI extension */
  p += fio___tls13_write_ext_sni(p, server_name);

  /* supported_versions extension (REQUIRED for TLS 1.3) */
  p += fio___tls13_write_ext_supported_versions(p);

  /* supported_groups extension */
  p += fio___tls13_write_ext_supported_groups(p);

  /* signature_algorithms extension */
  p += fio___tls13_write_ext_signature_algorithms(p);

  /* key_share extension */
  if (x25519_pubkey)
    p += fio___tls13_write_ext_key_share(p, x25519_pubkey);

  /* Write extensions length */
  fio___tls13_write_u16(ext_len_ptr, (uint16_t)(p - ext_start));

  /* Calculate body length and write handshake header */
  size_t body_len = (size_t)(p - start);
  fio_tls13_write_handshake_header(out, FIO_TLS13_HS_CLIENT_HELLO, body_len);

  return (int)(4 + body_len);
}

/* *****************************************************************************
ServerHello Parsing Implementation
***************************************************************************** */

/* HelloRetryRequest random value */
static const uint8_t fio___tls13_hrr_random[32] = {
    0xCF, 0x21, 0xAD, 0x74, 0xE5, 0x9A, 0x61, 0x11, 0xBE, 0x1D, 0x8C,
    0x02, 0x1E, 0x65, 0xB8, 0x91, 0xC2, 0xA2, 0x11, 0x16, 0x7A, 0xBB,
    0x8C, 0x5E, 0x07, 0x9E, 0x09, 0xE2, 0xC8, 0xA8, 0x33, 0x9C};

/* Parse ServerHello message */
SFUNC int fio_tls13_parse_server_hello(fio_tls13_server_hello_s *out,
                                       const uint8_t *data,
                                       size_t data_len) {
  if (!out || !data)
    return -1;

  FIO_MEMSET(out, 0, sizeof(*out));

  const uint8_t *p = data;
  const uint8_t *end = data + data_len;

  /* Minimum ServerHello: version(2) + random(32) + session_id_len(1) +
   * cipher_suite(2) + compression(1) = 38 bytes */
  if (data_len < 38)
    return -1;

  /* Legacy version (should be 0x0303) */
  uint16_t version = fio___tls13_read_u16(p);
  p += 2;
  if (version != FIO_TLS13_VERSION_TLS12)
    return -1;

  /* Random (32 bytes) */
  FIO_MEMCPY(out->random, p, 32);
  p += 32;

  /* Check for HelloRetryRequest */
  out->is_hello_retry_request =
      (FIO_MEMCMP(out->random, fio___tls13_hrr_random, 32) == 0);

  /* Legacy session ID (echo of client's, skip it) */
  uint8_t session_id_len = *p++;
  if (p + session_id_len > end)
    return -1;
  p += session_id_len;

  /* Cipher suite */
  if (p + 2 > end)
    return -1;
  out->cipher_suite = fio___tls13_read_u16(p);
  p += 2;

  /* Legacy compression method (must be 0) */
  if (p + 1 > end)
    return -1;
  if (*p++ != 0)
    return -1;

  /* Extensions (optional but expected for TLS 1.3) */
  if (p + 2 > end)
    return 0; /* No extensions, but valid */

  uint16_t ext_len = fio___tls13_read_u16(p);
  p += 2;

  if (p + ext_len > end)
    return -1;

  const uint8_t *ext_end = p + ext_len;

  /* Parse extensions */
  while (p + 4 <= ext_end) {
    uint16_t ext_type = fio___tls13_read_u16(p);
    p += 2;
    uint16_t ext_data_len = fio___tls13_read_u16(p);
    p += 2;

    if (p + ext_data_len > ext_end)
      return -1;

    switch (ext_type) {
    case FIO_TLS13_EXT_KEY_SHARE:
      /* In ServerHello: group(2) + key_len(2) + key
       * In HelloRetryRequest: just group(2) per RFC 8446 Section 4.2.8 */
      if (ext_data_len >= 2) {
        out->key_share_group = fio___tls13_read_u16(p);
        if (ext_data_len >= 4) {
          /* Normal ServerHello with full key share */
          uint16_t key_len = fio___tls13_read_u16(p + 2);
          if (key_len <= sizeof(out->key_share) &&
              ext_data_len >= 4 + key_len) {
            FIO_MEMCPY(out->key_share, p + 4, key_len);
            out->key_share_len = (uint8_t)key_len;
          }
        }
        /* If ext_data_len == 2, it's HRR with just the group */
      }
      break;

    case FIO_TLS13_EXT_SUPPORTED_VERSIONS:
      /* supported_versions in ServerHello: just the selected version (2 bytes)
       */
      if (ext_data_len >= 2) {
        uint16_t selected = fio___tls13_read_u16(p);
        if (selected != FIO_TLS13_VERSION_TLS13)
          return -1; /* Must be TLS 1.3 */
      }
      break;

    default:
      /* Ignore unknown extensions */
      break;
    }

    p += ext_data_len;
  }

  return 0;
}

/* *****************************************************************************
EncryptedExtensions Parsing Implementation
***************************************************************************** */

SFUNC int fio_tls13_parse_encrypted_extensions(
    fio_tls13_encrypted_extensions_s *out,
    const uint8_t *data,
    size_t data_len) {
  if (!out || !data)
    return -1;

  FIO_MEMSET(out, 0, sizeof(*out));

  const uint8_t *p = data;
  const uint8_t *end = data + data_len;

  /* Extensions length */
  if (p + 2 > end)
    return -1;

  uint16_t ext_len = fio___tls13_read_u16(p);
  p += 2;

  if (p + ext_len > end)
    return -1;

  const uint8_t *ext_end = p + ext_len;

  /* Parse extensions */
  while (p + 4 <= ext_end) {
    uint16_t ext_type = fio___tls13_read_u16(p);
    p += 2;
    uint16_t ext_data_len = fio___tls13_read_u16(p);
    p += 2;

    if (p + ext_data_len > ext_end)
      return -1;

    switch (ext_type) {
    case FIO_TLS13_EXT_SERVER_NAME:
      /* Server acknowledged SNI (empty extension) */
      out->has_server_name = 1;
      break;

    default:
      /* Ignore other extensions */
      break;
    }

    p += ext_data_len;
  }

  return 0;
}

/* *****************************************************************************
Certificate Parsing Implementation
***************************************************************************** */

SFUNC int fio_tls13_parse_certificate(fio_tls13_certificate_s *out,
                                      const uint8_t *data,
                                      size_t data_len) {
  if (!out || !data)
    return -1;

  FIO_MEMSET(out, 0, sizeof(*out));

  const uint8_t *p = data;
  const uint8_t *end = data + data_len;

  /* Certificate request context length (should be 0 for server cert) */
  if (p + 1 > end)
    return -1;
  uint8_t ctx_len = *p++;
  if (p + ctx_len > end)
    return -1;
  p += ctx_len;

  /* Certificate list length (3 bytes) */
  if (p + 3 > end)
    return -1;
  uint32_t list_len = fio___tls13_read_u24(p);
  p += 3;

  if (p + list_len > end)
    return -1;

  /* Parse first certificate entry */
  if (list_len < 3)
    return -1;

  /* Certificate data length (3 bytes) */
  uint32_t cert_len = fio___tls13_read_u24(p);
  p += 3;

  if (p + cert_len > end)
    return -1;

  /* Store pointer to first certificate */
  out->cert_data = p;
  out->cert_len = cert_len;

  return 0;
}

/* *****************************************************************************
CertificateVerify Parsing Implementation
***************************************************************************** */

SFUNC int fio_tls13_parse_certificate_verify(
    fio_tls13_certificate_verify_s *out,
    const uint8_t *data,
    size_t data_len) {
  if (!out || !data)
    return -1;

  FIO_MEMSET(out, 0, sizeof(*out));

  const uint8_t *p = data;
  const uint8_t *end = data + data_len;

  /* Signature algorithm (2 bytes) */
  if (p + 2 > end)
    return -1;
  out->signature_scheme = fio___tls13_read_u16(p);
  p += 2;

  /* Signature length (2 bytes) */
  if (p + 2 > end)
    return -1;
  uint16_t sig_len = fio___tls13_read_u16(p);
  p += 2;

  /* Signature data */
  if (p + sig_len > end)
    return -1;
  out->signature = p;
  out->signature_len = sig_len;

  return 0;
}

/* *****************************************************************************
Finished Message Implementation
***************************************************************************** */

SFUNC int fio_tls13_build_finished(uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *verify_data,
                                   size_t verify_data_len) {
  if (!out || !verify_data)
    return -1;

  /* Finished message: handshake header (4) + verify_data */
  size_t total_len = 4 + verify_data_len;
  if (out_capacity < total_len)
    return -1;

  /* Write handshake header */
  fio_tls13_write_handshake_header(out, FIO_TLS13_HS_FINISHED, verify_data_len);

  /* Write verify_data */
  FIO_MEMCPY(out + 4, verify_data, verify_data_len);

  return (int)total_len;
}

SFUNC int fio_tls13_parse_finished(const uint8_t *data,
                                   size_t data_len,
                                   const uint8_t *expected_verify_data,
                                   size_t verify_data_len) {
  if (!data || !expected_verify_data)
    return -1;

  /* Data should be exactly verify_data_len bytes */
  if (data_len != verify_data_len)
    return -1;

  /* Constant-time comparison */
  uint8_t diff = 0;
  for (size_t i = 0; i < verify_data_len; ++i)
    diff |= data[i] ^ expected_verify_data[i];

  return (diff == 0) ? 0 : -1;
}

/* *****************************************************************************




                        TLS 1.3 Client Handshake State Machine
                              (RFC 8446 Section 4)




***************************************************************************** */

/* *****************************************************************************
TLS 1.3 Alert Codes (RFC 8446 Section 6)
***************************************************************************** */

/** TLS 1.3 Alert Levels */
typedef enum {
  FIO_TLS13_ALERT_LEVEL_WARNING = 1,
  FIO_TLS13_ALERT_LEVEL_FATAL = 2,
} fio_tls13_alert_level_e;

/** TLS 1.3 Alert Descriptions */
typedef enum {
  FIO_TLS13_ALERT_CLOSE_NOTIFY = 0,
  FIO_TLS13_ALERT_UNEXPECTED_MESSAGE = 10,
  FIO_TLS13_ALERT_BAD_RECORD_MAC = 20,
  FIO_TLS13_ALERT_RECORD_OVERFLOW = 22,
  FIO_TLS13_ALERT_HANDSHAKE_FAILURE = 40,
  FIO_TLS13_ALERT_BAD_CERTIFICATE = 42,
  FIO_TLS13_ALERT_CERTIFICATE_REVOKED = 44,
  FIO_TLS13_ALERT_CERTIFICATE_EXPIRED = 45,
  FIO_TLS13_ALERT_CERTIFICATE_UNKNOWN = 46,
  FIO_TLS13_ALERT_ILLEGAL_PARAMETER = 47,
  FIO_TLS13_ALERT_UNKNOWN_CA = 48,
  FIO_TLS13_ALERT_DECODE_ERROR = 50,
  FIO_TLS13_ALERT_DECRYPT_ERROR = 51,
  FIO_TLS13_ALERT_PROTOCOL_VERSION = 70,
  FIO_TLS13_ALERT_INTERNAL_ERROR = 80,
  FIO_TLS13_ALERT_MISSING_EXTENSION = 109,
  FIO_TLS13_ALERT_UNSUPPORTED_EXTENSION = 110,
  FIO_TLS13_ALERT_UNRECOGNIZED_NAME = 112,
  FIO_TLS13_ALERT_BAD_CERTIFICATE_STATUS_RESPONSE = 113,
  FIO_TLS13_ALERT_UNKNOWN_PSK_IDENTITY = 115,
  FIO_TLS13_ALERT_CERTIFICATE_REQUIRED = 116,
  FIO_TLS13_ALERT_NO_APPLICATION_PROTOCOL = 120,
} fio_tls13_alert_description_e;

/* *****************************************************************************
TLS 1.3 Client State Machine
***************************************************************************** */

/** TLS 1.3 Client Handshake States */
typedef enum {
  FIO_TLS13_STATE_START = 0, /* Initial state */
  FIO_TLS13_STATE_WAIT_SH,   /* Sent ClientHello, waiting for ServerHello */
  FIO_TLS13_STATE_WAIT_SH2,  /* Sent ClientHello2 after HRR, waiting for SH */
  FIO_TLS13_STATE_WAIT_EE,   /* Received ServerHello, waiting for EE */
  FIO_TLS13_STATE_WAIT_CERT_CR,  /* Waiting for Certificate or CertRequest */
  FIO_TLS13_STATE_WAIT_CERT,     /* Waiting for Certificate */
  FIO_TLS13_STATE_WAIT_CV,       /* Waiting for CertificateVerify */
  FIO_TLS13_STATE_WAIT_FINISHED, /* Waiting for server Finished */
  FIO_TLS13_STATE_CONNECTED,     /* Handshake complete */
  FIO_TLS13_STATE_ERROR,         /* Error state */
} fio_tls13_client_state_e;

/** TLS 1.3 Client Context */
typedef struct {
  /* State */
  fio_tls13_client_state_e state;

  /* Negotiated parameters */
  uint16_t cipher_suite; /* Selected cipher suite */
  int use_sha384;        /* 0 = SHA-256, 1 = SHA-384 */

  /* Key material */
  uint8_t client_random[32];
  uint8_t x25519_private_key[32];
  uint8_t x25519_public_key[32];
  uint8_t shared_secret[32]; /* ECDHE shared secret */

  /* Secrets (derived during handshake) - up to SHA-384 size */
  uint8_t early_secret[48];
  uint8_t handshake_secret[48];
  uint8_t master_secret[48];
  uint8_t client_handshake_traffic_secret[48];
  uint8_t server_handshake_traffic_secret[48];
  uint8_t client_app_traffic_secret[48];
  uint8_t server_app_traffic_secret[48];

  /* Traffic keys */
  fio_tls13_record_keys_s client_handshake_keys;
  fio_tls13_record_keys_s server_handshake_keys;
  fio_tls13_record_keys_s client_app_keys;
  fio_tls13_record_keys_s server_app_keys;

  /* Transcript hash (running hash of all handshake messages) */
  fio_sha256_s transcript_sha256; /* For SHA-256 cipher suites */
  fio_sha512_s transcript_sha384; /* For SHA-384 cipher suites */

  /* Server certificate (pointer to received data, not owned) */
  const uint8_t *server_cert;
  size_t server_cert_len;

  /* CertificateVerify signature (pointer to received data, not owned) */
  const uint8_t *server_signature;
  size_t server_signature_len;
  uint16_t server_signature_scheme;

  /* Error info */
  uint8_t alert_level;
  uint8_t alert_description;

  /* Configuration */
  const char *server_name; /* SNI hostname */

  /* Certificate verification configuration */
  void *trust_store;        /* fio_x509_trust_store_s* - NULL to skip chain */
  uint8_t skip_cert_verify; /* 1 to skip all certificate verification */
  uint8_t cert_verified;    /* 1 if CertificateVerify was validated */
  uint8_t chain_verified;   /* 1 if certificate chain was validated */
  int16_t cert_error;       /* Certificate error code (fio_x509_error_e) */

  /* Certificate chain from server (raw pointers into cert_data_buf) */
  const uint8_t *cert_chain[10]; /* Up to 10 certificates in chain */
  size_t cert_chain_lens[10];    /* Length of each certificate */
  size_t cert_chain_count;       /* Number of certificates received */

  /* Buffer to store certificate data (copied from decrypted records) */
  uint8_t *cert_data_buf;   /* Allocated buffer for certificate data */
  size_t cert_data_buf_len; /* Total length of certificate data */
  size_t cert_data_buf_cap; /* Capacity of certificate data buffer */

  /* HelloRetryRequest handling (RFC 8446 Section 4.1.4) */
  uint8_t hrr_received;         /* 1 if HRR was received (to detect second) */
  uint16_t hrr_selected_group;  /* Group selected by server in HRR */
  uint8_t *hrr_cookie;          /* Cookie from HRR (if any) */
  size_t hrr_cookie_len;        /* Length of cookie */
  uint8_t p256_private_key[32]; /* P-256 private key (for HRR fallback) */
  uint8_t p256_public_key[65];  /* P-256 public key (uncompressed) */

  /* Internal flags */
  uint8_t encrypted_read;     /* 1 if reading encrypted records */
  uint8_t encrypted_write;    /* 1 if writing encrypted records */
  uint8_t key_update_pending; /* 1 if KeyUpdate response needed (RFC 8446 4.6.3)
                               */
} fio_tls13_client_s;

/* *****************************************************************************
TLS 1.3 Client API
***************************************************************************** */

/**
 * Initialize client context.
 *
 * @param client      Client context to initialize
 * @param server_name SNI hostname (can be NULL)
 */
SFUNC void fio_tls13_client_init(fio_tls13_client_s *client,
                                 const char *server_name);

/**
 * Clean up client context (zeroes secrets).
 *
 * @param client Client context to destroy
 */
SFUNC void fio_tls13_client_destroy(fio_tls13_client_s *client);

/**
 * Set trust store for certificate chain verification.
 *
 * When set, the client will verify the server's certificate chain against
 * the provided trust store. If NULL (default), chain verification is skipped.
 *
 * Note: Requires FIO_X509 module. The trust_store pointer must point to a
 * valid fio_x509_trust_store_s structure.
 *
 * @param client      Client context
 * @param trust_store Trust store for root CAs (NULL to skip chain verification)
 */
FIO_IFUNC void fio_tls13_client_set_trust_store(fio_tls13_client_s *client,
                                                void *trust_store);

/**
 * Skip all certificate verification (insecure).
 *
 * When enabled, the client will NOT verify:
 * - CertificateVerify signature
 * - Certificate chain
 * - Hostname matching
 *
 * WARNING: This is insecure and should only be used for testing or when
 * certificate verification is handled externally.
 *
 * @param client Client context
 * @param skip   1 to skip verification, 0 to enable (default)
 */
FIO_IFUNC void fio_tls13_client_skip_verification(fio_tls13_client_s *client,
                                                  int skip);

/**
 * Get the last certificate verification error.
 *
 * @param client Client context
 * @return Error code (0 = OK, negative = error)
 */
FIO_IFUNC int fio_tls13_client_get_cert_error(fio_tls13_client_s *client);

/**
 * Check if certificate verification was successful.
 *
 * @param client Client context
 * @return 1 if verified, 0 if not verified or skipped
 */
FIO_IFUNC int fio_tls13_client_is_cert_verified(fio_tls13_client_s *client);

/**
 * Generate ClientHello message and start handshake.
 *
 * @param client       Client context
 * @param out          Output buffer for ClientHello record
 * @param out_capacity Capacity of output buffer
 * @return Message length on success, -1 on error
 */
SFUNC int fio_tls13_client_start(fio_tls13_client_s *client,
                                 uint8_t *out,
                                 size_t out_capacity);

/**
 * Process incoming TLS record(s).
 *
 * May generate response data in out buffer.
 *
 * @param client       Client context
 * @param in           Input buffer containing TLS record(s)
 * @param in_len       Length of input data
 * @param out          Output buffer for response
 * @param out_capacity Capacity of output buffer
 * @param out_len      Output: response length (0 if no response needed)
 * @return Number of bytes consumed, or -1 on error
 */
SFUNC int fio_tls13_client_process(fio_tls13_client_s *client,
                                   const uint8_t *in,
                                   size_t in_len,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   size_t *out_len);

/**
 * Encrypt application data for sending.
 *
 * @param client       Client context
 * @param out          Output buffer for encrypted record
 * @param out_capacity Capacity of output buffer
 * @param plaintext    Plaintext data to encrypt
 * @param plaintext_len Length of plaintext
 * @return Encrypted record length, or -1 on error
 */
SFUNC int fio_tls13_client_encrypt(fio_tls13_client_s *client,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *plaintext,
                                   size_t plaintext_len);

/**
 * Decrypt received application data.
 *
 * @param client         Client context
 * @param out            Output buffer for decrypted data
 * @param out_capacity   Capacity of output buffer
 * @param ciphertext     Encrypted record (including header)
 * @param ciphertext_len Length of encrypted record
 * @return Plaintext length, or -1 on error
 */
SFUNC int fio_tls13_client_decrypt(fio_tls13_client_s *client,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *ciphertext,
                                   size_t ciphertext_len);

/**
 * Check if handshake is complete.
 */
FIO_IFUNC int fio_tls13_client_is_connected(fio_tls13_client_s *client) {
  return client && client->state == FIO_TLS13_STATE_CONNECTED;
}

/**
 * Check if in error state.
 */
FIO_IFUNC int fio_tls13_client_is_error(fio_tls13_client_s *client) {
  return client && client->state == FIO_TLS13_STATE_ERROR;
}

/**
 * Get current state name (for debugging).
 */
FIO_IFUNC const char *fio_tls13_client_state_name(fio_tls13_client_s *client) {
  if (!client)
    return "NULL";
  switch (client->state) {
  case FIO_TLS13_STATE_START: return "START";
  case FIO_TLS13_STATE_WAIT_SH: return "WAIT_SH";
  case FIO_TLS13_STATE_WAIT_SH2: return "WAIT_SH2";
  case FIO_TLS13_STATE_WAIT_EE: return "WAIT_EE";
  case FIO_TLS13_STATE_WAIT_CERT_CR: return "WAIT_CERT_CR";
  case FIO_TLS13_STATE_WAIT_CERT: return "WAIT_CERT";
  case FIO_TLS13_STATE_WAIT_CV: return "WAIT_CV";
  case FIO_TLS13_STATE_WAIT_FINISHED: return "WAIT_FINISHED";
  case FIO_TLS13_STATE_CONNECTED: return "CONNECTED";
  case FIO_TLS13_STATE_ERROR: return "ERROR";
  default: return "UNKNOWN";
  }
}

/**
 * Set trust store for certificate chain verification.
 */
FIO_IFUNC void fio_tls13_client_set_trust_store(fio_tls13_client_s *client,
                                                void *trust_store) {
  if (client)
    client->trust_store = trust_store;
}

/**
 * Skip all certificate verification (insecure).
 */
FIO_IFUNC void fio_tls13_client_skip_verification(fio_tls13_client_s *client,
                                                  int skip) {
  if (client)
    client->skip_cert_verify = (uint8_t)(skip != 0);
}

/**
 * Get the last certificate verification error.
 */
FIO_IFUNC int fio_tls13_client_get_cert_error(fio_tls13_client_s *client) {
  return client ? (int)client->cert_error : -1;
}

/**
 * Check if certificate verification was successful.
 */
FIO_IFUNC int fio_tls13_client_is_cert_verified(fio_tls13_client_s *client) {
  return client ? (client->cert_verified && client->chain_verified) : 0;
}

/* *****************************************************************************
TLS 1.3 Client Implementation
***************************************************************************** */

/* Internal: Update transcript hash with handshake message */
FIO_SFUNC void fio___tls13_transcript_update(fio_tls13_client_s *client,
                                             const uint8_t *data,
                                             size_t len) {
  if (client->use_sha384)
    fio_sha512_consume(&client->transcript_sha384, data, len);
  else
    fio_sha256_consume(&client->transcript_sha256, data, len);
}

/* Internal: Get current transcript hash (non-destructive copy) */
FIO_SFUNC void fio___tls13_transcript_hash(fio_tls13_client_s *client,
                                           uint8_t *out) {
  if (client->use_sha384) {
    fio_sha512_s copy = client->transcript_sha384;
    fio_u512 h = fio_sha512_finalize(&copy);
    FIO_MEMCPY(out, h.u8, 48);
  } else {
    fio_sha256_s copy = client->transcript_sha256;
    fio_u256 h = fio_sha256_finalize(&copy);
    FIO_MEMCPY(out, h.u8, 32);
  }
}

/**
 * Internal: Replace transcript with message_hash for HelloRetryRequest.
 *
 * Per RFC 8446 Section 4.4.1:
 * When the server responds with HelloRetryRequest, the transcript hash
 * is replaced with a special construct:
 *
 *   Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
 *     Hash(message_hash ||        // special message
 *          HelloRetryRequest ||   // the HRR message
 *          ... Mn)
 *
 * Where message_hash is:
 *   struct {
 *     HandshakeType msg_type = message_hash (254);
 *     uint24 length = Hash.length;
 *     opaque hash[Hash.length];  // Hash(ClientHello1)
 *   }
 *
 * This function:
 * 1. Gets the current transcript hash (Hash(ClientHello1))
 * 2. Reinitializes the transcript hash
 * 3. Updates it with the message_hash construct
 */
FIO_SFUNC void fio___tls13_transcript_replace_with_message_hash(
    fio_tls13_client_s *client) {
  size_t hash_len = client->use_sha384 ? 48 : 32;

  /* Get Hash(ClientHello1) */
  uint8_t ch1_hash[48];
  fio___tls13_transcript_hash(client, ch1_hash);

  /* Build message_hash construct:
   * msg_type (1 byte) = 254 (message_hash)
   * length (3 bytes) = hash_len
   * hash (hash_len bytes) */
  uint8_t message_hash[4 + 48];
  message_hash[0] = FIO_TLS13_HS_MESSAGE_HASH; /* 254 */
  message_hash[1] = 0;
  message_hash[2] = 0;
  message_hash[3] = (uint8_t)hash_len;
  FIO_MEMCPY(message_hash + 4, ch1_hash, hash_len);

  /* Reinitialize transcript hash and update with message_hash */
  if (client->use_sha384) {
    client->transcript_sha384 = fio_sha512_init();
    fio_sha512_consume(&client->transcript_sha384, message_hash, 4 + hash_len);
  } else {
    client->transcript_sha256 = fio_sha256_init();
    fio_sha256_consume(&client->transcript_sha256, message_hash, 4 + hash_len);
  }

  FIO_LOG_DEBUG2("TLS 1.3: Replaced transcript with message_hash for HRR");
}

/* Internal: Get hash length for current cipher suite */
FIO_SFUNC size_t fio___tls13_hash_len(fio_tls13_client_s *client) {
  return client->use_sha384 ? 48 : 32;
}

/* Internal: Get key length for current cipher suite */
FIO_SFUNC size_t fio___tls13_key_len(fio_tls13_client_s *client) {
  switch (client->cipher_suite) {
  case FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256: return 16;
  case FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384: return 32;
  case FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256: return 32;
  default: return 16;
  }
}

/* Internal: Get cipher type for current cipher suite */
FIO_SFUNC fio_tls13_cipher_type_e
fio___tls13_cipher_type(fio_tls13_client_s *client) {
  switch (client->cipher_suite) {
  case FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256:
    return FIO_TLS13_CIPHER_AES_128_GCM;
  case FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384:
    return FIO_TLS13_CIPHER_AES_256_GCM;
  case FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256:
    return FIO_TLS13_CIPHER_CHACHA20_POLY1305;
  default: return FIO_TLS13_CIPHER_AES_128_GCM;
  }
}

/* Internal: Set error state with alert */
FIO_SFUNC void fio___tls13_set_error(fio_tls13_client_s *client,
                                     uint8_t alert_level,
                                     uint8_t alert_description) {
  client->state = FIO_TLS13_STATE_ERROR;
  client->alert_level = alert_level;
  client->alert_description = alert_description;
}

/* Internal: Build TLSPlaintext record header */
FIO_SFUNC void fio___tls13_write_record_header(uint8_t *out,
                                               fio_tls13_content_type_e type,
                                               uint16_t length) {
  out[0] = (uint8_t)type;
  out[1] = FIO_TLS13_LEGACY_VERSION_MAJOR;
  out[2] = FIO_TLS13_LEGACY_VERSION_MINOR;
  out[3] = (uint8_t)(length >> 8);
  out[4] = (uint8_t)(length & 0xFF);
}

/* Internal: Derive handshake keys after ServerHello */
FIO_SFUNC int fio___tls13_derive_handshake_keys(fio_tls13_client_s *client) {
  int use_sha384 = client->use_sha384;
  size_t hash_len = fio___tls13_hash_len(client);
  size_t key_len = fio___tls13_key_len(client);
  fio_tls13_cipher_type_e cipher_type = fio___tls13_cipher_type(client);

  /* Get transcript hash at ServerHello */
  uint8_t transcript_hash[48];
  fio___tls13_transcript_hash(client, transcript_hash);

  /* Derive early secret (no PSK) */
  fio_tls13_derive_early_secret(client->early_secret, NULL, 0, use_sha384);

  /* Derive handshake secret */
  fio_tls13_derive_handshake_secret(client->handshake_secret,
                                    client->early_secret,
                                    client->shared_secret,
                                    32, /* X25519 shared secret is 32 bytes */
                                    use_sha384);

  /* Derive client handshake traffic secret */
  fio_tls13_derive_secret(client->client_handshake_traffic_secret,
                          client->handshake_secret,
                          hash_len,
                          "c hs traffic",
                          12,
                          transcript_hash,
                          hash_len,
                          use_sha384);

  /* Derive server handshake traffic secret */
  fio_tls13_derive_secret(client->server_handshake_traffic_secret,
                          client->handshake_secret,
                          hash_len,
                          "s hs traffic",
                          12,
                          transcript_hash,
                          hash_len,
                          use_sha384);

  /* Derive client handshake keys */
  uint8_t key[32], iv[12];
  fio_tls13_derive_traffic_keys(key,
                                key_len,
                                iv,
                                client->client_handshake_traffic_secret,
                                use_sha384);
  fio_tls13_record_keys_init(&client->client_handshake_keys,
                             key,
                             (uint8_t)key_len,
                             iv,
                             cipher_type);

  /* Derive server handshake keys */
  fio_tls13_derive_traffic_keys(key,
                                key_len,
                                iv,
                                client->server_handshake_traffic_secret,
                                use_sha384);
  fio_tls13_record_keys_init(&client->server_handshake_keys,
                             key,
                             (uint8_t)key_len,
                             iv,
                             cipher_type);

  /* Clear temporary key material */
  fio_secure_zero(key, sizeof(key));
  fio_secure_zero(iv, sizeof(iv));

  return 0;
}

/* Internal: Derive application keys after server Finished */
FIO_SFUNC int fio___tls13_derive_app_keys(fio_tls13_client_s *client) {
  int use_sha384 = client->use_sha384;
  size_t hash_len = fio___tls13_hash_len(client);
  size_t key_len = fio___tls13_key_len(client);
  fio_tls13_cipher_type_e cipher_type = fio___tls13_cipher_type(client);

  /* Get transcript hash at server Finished */
  uint8_t transcript_hash[48];
  fio___tls13_transcript_hash(client, transcript_hash);

  /* Derive master secret */
  fio_tls13_derive_master_secret(client->master_secret,
                                 client->handshake_secret,
                                 use_sha384);

  /* Derive client application traffic secret */
  fio_tls13_derive_secret(client->client_app_traffic_secret,
                          client->master_secret,
                          hash_len,
                          "c ap traffic",
                          12,
                          transcript_hash,
                          hash_len,
                          use_sha384);

  /* Derive server application traffic secret */
  fio_tls13_derive_secret(client->server_app_traffic_secret,
                          client->master_secret,
                          hash_len,
                          "s ap traffic",
                          12,
                          transcript_hash,
                          hash_len,
                          use_sha384);

  /* Derive client application keys */
  uint8_t key[32], iv[12];
  fio_tls13_derive_traffic_keys(key,
                                key_len,
                                iv,
                                client->client_app_traffic_secret,
                                use_sha384);
  fio_tls13_record_keys_init(&client->client_app_keys,
                             key,
                             (uint8_t)key_len,
                             iv,
                             cipher_type);

  /* Derive server application keys */
  fio_tls13_derive_traffic_keys(key,
                                key_len,
                                iv,
                                client->server_app_traffic_secret,
                                use_sha384);
  fio_tls13_record_keys_init(&client->server_app_keys,
                             key,
                             (uint8_t)key_len,
                             iv,
                             cipher_type);

  /* Clear temporary key material */
  fio_secure_zero(key, sizeof(key));
  fio_secure_zero(iv, sizeof(iv));

  return 0;
}

/* Internal: Build client Finished message */
FIO_SFUNC int fio___tls13_build_client_finished(fio_tls13_client_s *client,
                                                uint8_t *out,
                                                size_t out_capacity) {
  int use_sha384 = client->use_sha384;
  size_t hash_len = fio___tls13_hash_len(client);

  /* Need space for handshake header (4) + verify_data */
  if (out_capacity < 4 + hash_len)
    return -1;

  /* Get transcript hash */
  uint8_t transcript_hash[48];
  fio___tls13_transcript_hash(client, transcript_hash);

  /* Derive finished key from client handshake traffic secret */
  uint8_t finished_key[48];
  fio_tls13_derive_finished_key(finished_key,
                                client->client_handshake_traffic_secret,
                                use_sha384);

  /* Compute verify_data */
  uint8_t verify_data[48];
  fio_tls13_compute_finished(verify_data,
                             finished_key,
                             transcript_hash,
                             use_sha384);

  /* Build Finished message */
  int len = fio_tls13_build_finished(out, out_capacity, verify_data, hash_len);

  /* Clear sensitive data */
  fio_secure_zero(finished_key, sizeof(finished_key));

  return len;
}

/* Internal: Verify server Finished message */
FIO_SFUNC int fio___tls13_verify_server_finished(fio_tls13_client_s *client,
                                                 const uint8_t *verify_data,
                                                 size_t verify_data_len) {
  int use_sha384 = client->use_sha384;
  size_t hash_len = fio___tls13_hash_len(client);

  if (verify_data_len != hash_len)
    return -1;

  /* Get transcript hash (before Finished message) */
  uint8_t transcript_hash[48];
  fio___tls13_transcript_hash(client, transcript_hash);

  /* Derive finished key from server handshake traffic secret */
  uint8_t finished_key[48];
  fio_tls13_derive_finished_key(finished_key,
                                client->server_handshake_traffic_secret,
                                use_sha384);

  /* Compute expected verify_data */
  uint8_t expected[48];
  fio_tls13_compute_finished(expected,
                             finished_key,
                             transcript_hash,
                             use_sha384);

  /* Constant-time comparison */
  uint8_t diff = 0;
  for (size_t i = 0; i < hash_len; ++i)
    diff |= verify_data[i] ^ expected[i];

  /* Clear sensitive data */
  fio_secure_zero(finished_key, sizeof(finished_key));
  fio_secure_zero(expected, sizeof(expected));

  return diff ? -1 : 0;
}

/**
 * Internal: Handle HelloRetryRequest (RFC 8446 Section 4.1.4)
 *
 * Returns: 1 if HRR was handled and ClientHello2 should be sent,
 *          0 if not HRR (normal ServerHello),
 *         -1 on error
 *
 * When HRR is received:
 * 1. Verify this is the first HRR (second HRR is an error)
 * 2. Verify the selected group is one we offered
 * 3. Verify this would change our ClientHello (else illegal_parameter)
 * 4. Store cookie if present
 * 5. Update transcript hash with special message_hash format
 * 6. Generate new key share for selected group
 * 7. Set state to indicate retry needed
 */
FIO_SFUNC int fio___tls13_handle_hello_retry_request(
    fio_tls13_client_s *client,
    const fio_tls13_server_hello_s *sh,
    const uint8_t *hrr_msg,
    size_t hrr_msg_len) {
  /* RFC 8446 Section 4.1.4: Client MUST abort with unexpected_message
   * if it receives a second HelloRetryRequest */
  if (client->hrr_received) {
    FIO_LOG_DEBUG2("TLS 1.3: Received second HelloRetryRequest - aborting");
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
    return -1;
  }

  /* Validate cipher suite (same logic as normal ServerHello) */
  client->cipher_suite = sh->cipher_suite;
  switch (sh->cipher_suite) {
  case FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256: client->use_sha384 = 0; break;
  case FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256:
    client->use_sha384 = 0;
    break;
  case FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384: client->use_sha384 = 1; break;
  default:
    FIO_LOG_DEBUG2("TLS 1.3 HRR: Unsupported cipher suite 0x%04x",
                   sh->cipher_suite);
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_HANDSHAKE_FAILURE);
    return -1;
  }

  /* Check if server selected a group we support */
  uint16_t selected_group = sh->key_share_group;
  int group_supported = 0;
  int would_change = 0;

  /* We offer X25519 and P-256 */
  if (selected_group == FIO_TLS13_GROUP_X25519) {
    group_supported = 1;
    /* If we already offered X25519, this wouldn't change anything */
    /* (We always offer X25519 first, so this is an error) */
    would_change = 0;
  } else if (selected_group == FIO_TLS13_GROUP_SECP256R1) {
    group_supported = 1;
    /* We offered X25519 first, so switching to P-256 is a change */
    would_change = 1;
  }

  if (!group_supported) {
    FIO_LOG_DEBUG2("TLS 1.3 HRR: Server selected unsupported group 0x%04x",
                   selected_group);
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_ILLEGAL_PARAMETER);
    return -1;
  }

  /* RFC 8446 Section 4.1.4: Client MUST abort with illegal_parameter if
   * the HelloRetryRequest would not result in any change in the ClientHello */
  if (!would_change) {
    FIO_LOG_DEBUG2("TLS 1.3 HRR: Would not change ClientHello - aborting");
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_ILLEGAL_PARAMETER);
    return -1;
  }

  /* Store selected group for retry */
  client->hrr_selected_group = selected_group;
  client->hrr_received = 1;

  /* Parse HRR extensions to extract cookie if present */
  /* The HRR message format is same as ServerHello, parse extensions */
  {
    const uint8_t *p = hrr_msg + 4; /* Skip handshake header */
    const uint8_t *end = hrr_msg + hrr_msg_len;
    uint8_t session_id_len = 0;
    uint16_t ext_len = 0;
    const uint8_t *ext_end = NULL;

    /* Skip: version(2) + random(32) + session_id_len(1) + session_id +
     * cipher_suite(2) + compression(1) */
    if (p + 35 > end)
      goto skip_cookie;
    p += 2 + 32; /* version + random */
    session_id_len = *p++;
    if (p + session_id_len > end)
      goto skip_cookie;
    p += session_id_len;
    if (p + 3 > end)
      goto skip_cookie;
    p += 2 + 1; /* cipher_suite + compression */

    /* Extensions */
    if (p + 2 > end)
      goto skip_cookie;
    ext_len = fio___tls13_read_u16(p);
    p += 2;
    if (p + ext_len > end)
      goto skip_cookie;

    ext_end = p + ext_len;
    while (p + 4 <= ext_end) {
      uint16_t ext_type = fio___tls13_read_u16(p);
      uint16_t ext_data_len;
      p += 2;
      ext_data_len = fio___tls13_read_u16(p);
      p += 2;
      if (p + ext_data_len > ext_end)
        break;

      if (ext_type == FIO_TLS13_EXT_COOKIE && ext_data_len >= 2) {
        /* Cookie extension: length(2) + cookie_data */
        uint16_t cookie_len = fio___tls13_read_u16(p);
        if (cookie_len > 0 && cookie_len <= ext_data_len - 2) {
          /* Free old cookie if any */
          if (client->hrr_cookie) {
            FIO_MEM_FREE(client->hrr_cookie, client->hrr_cookie_len);
          }
          /* Allocate and copy cookie */
          client->hrr_cookie =
              (uint8_t *)FIO_MEM_REALLOC(NULL, 0, cookie_len, 0);
          if (client->hrr_cookie) {
            FIO_MEMCPY(client->hrr_cookie, p + 2, cookie_len);
            client->hrr_cookie_len = cookie_len;
            FIO_LOG_DEBUG2("TLS 1.3 HRR: Stored cookie (%zu bytes)",
                           (size_t)cookie_len);
          }
        }
      }
      p += ext_data_len;
    }

  skip_cookie:
    (void)0; /* Empty statement after label */
  }
  /* Update transcript hash with special message_hash format
   * Per RFC 8446 Section 4.4.1 */
  fio___tls13_transcript_replace_with_message_hash(client);

  /* Now update transcript with the HRR message */
  fio___tls13_transcript_update(client, hrr_msg, hrr_msg_len);

  /* Generate new key share for selected group */
  if (selected_group == FIO_TLS13_GROUP_SECP256R1) {
#if defined(H___FIO_P256___H)
    /* Generate P-256 keypair */
    fio_p256_keypair(client->p256_private_key, client->p256_public_key);
    FIO_LOG_DEBUG2("TLS 1.3 HRR: Generated P-256 key share");
#else
    FIO_LOG_DEBUG2("TLS 1.3 HRR: P-256 not available");
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_HANDSHAKE_FAILURE);
    return -1;
#endif
  }

  FIO_LOG_DEBUG2("TLS 1.3: HelloRetryRequest handled, will send ClientHello2");
  return 1; /* Indicate HRR was handled, need to send ClientHello2 */
}

/* Internal: Process ServerHello */
FIO_SFUNC int fio___tls13_process_server_hello(fio_tls13_client_s *client,
                                               const uint8_t *data,
                                               size_t data_len) {
  fio_tls13_server_hello_s sh;
  if (fio_tls13_parse_server_hello(&sh, data, data_len) != 0) {
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_DECODE_ERROR);
    return -1;
  }

  /* Check for HelloRetryRequest */
  if (sh.is_hello_retry_request) {
    /* Return special value to indicate HRR handling needed */
    return 2; /* Will be handled by caller with full message */
  }

  /* Validate cipher suite */
  client->cipher_suite = sh.cipher_suite;
  switch (sh.cipher_suite) {
  case FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256: client->use_sha384 = 0; break;
  case FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256:
    client->use_sha384 = 0;
    break;
  case FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384: client->use_sha384 = 1; break;
  default:
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_HANDSHAKE_FAILURE);
    return -1;
  }

  /* Validate key share - support both X25519 and P-256 */
  if (sh.key_share_group == FIO_TLS13_GROUP_X25519 && sh.key_share_len == 32) {
    /* X25519 - compute shared secret */
    if (fio_x25519_shared_secret(client->shared_secret,
                                 client->x25519_private_key,
                                 sh.key_share) != 0) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_ILLEGAL_PARAMETER);
      return -1;
    }
  } else if (sh.key_share_group == FIO_TLS13_GROUP_SECP256R1 &&
             sh.key_share_len == 65) {
#if defined(H___FIO_P256___H)
    /* P-256 - compute shared secret (after HRR) */
    if (fio_p256_shared_secret(client->shared_secret,
                               client->p256_private_key,
                               sh.key_share,
                               sh.key_share_len) != 0) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_ILLEGAL_PARAMETER);
      return -1;
    }
#else
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_ILLEGAL_PARAMETER);
    return -1;
#endif
  } else {
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_ILLEGAL_PARAMETER);
    return -1;
  }

  /* Derive handshake keys */
  if (fio___tls13_derive_handshake_keys(client) != 0) {
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_INTERNAL_ERROR);
    return -1;
  }

  /* Switch to encrypted mode for reading */
  client->encrypted_read = 1;

  return 0;
}

/* Internal: Process EncryptedExtensions */
FIO_SFUNC int fio___tls13_process_encrypted_extensions(
    fio_tls13_client_s *client,
    const uint8_t *data,
    size_t data_len) {
  fio_tls13_encrypted_extensions_s ee;
  if (fio_tls13_parse_encrypted_extensions(&ee, data, data_len) != 0) {
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_DECODE_ERROR);
    return -1;
  }
  /* EE parsed successfully - no action needed for basic implementation */
  return 0;
}

/* Internal: Process Certificate
 * Copies certificate data to a persistent buffer so pointers remain valid
 * after the decryption buffer is reused for subsequent records. */
FIO_SFUNC int fio___tls13_process_certificate(fio_tls13_client_s *client,
                                              const uint8_t *data,
                                              size_t data_len) {
  fio_tls13_certificate_s cert;
  if (fio_tls13_parse_certificate(&cert, data, data_len) != 0) {
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_DECODE_ERROR);
    return -1;
  }

  /* Reset certificate chain */
  client->cert_chain_count = 0;
  client->cert_data_buf_len = 0;

  /* Parse certificate chain structure */
  const uint8_t *p = data;
  const uint8_t *end = data + data_len;

  /* Skip certificate_request_context */
  if (p >= end)
    return 0;
  uint8_t ctx_len = *p++;
  if (p + ctx_len > end)
    return 0;
  p += ctx_len;

  /* Parse certificate_list length (3 bytes) */
  if (p + 3 > end)
    return 0;
  size_t list_len = ((size_t)p[0] << 16) | ((size_t)p[1] << 8) | p[2];
  p += 3;
  if (p + list_len > end)
    return 0;

  const uint8_t *list_end = p + list_len;

  /* First pass: calculate total certificate data size needed */
  size_t total_cert_size = 0;
  size_t cert_count = 0;
  const uint8_t *scan = p;
  while (scan < list_end && cert_count < 10) {
    if (scan + 3 > list_end)
      break;
    size_t cert_len =
        ((size_t)scan[0] << 16) | ((size_t)scan[1] << 8) | scan[2];
    scan += 3;
    if (cert_len == 0 || scan + cert_len > list_end)
      break;
    total_cert_size += cert_len;
    ++cert_count;
    scan += cert_len;
    /* Skip extensions */
    if (scan + 2 > list_end)
      break;
    size_t ext_len = ((size_t)scan[0] << 8) | scan[1];
    scan += 2;
    if (scan + ext_len > list_end)
      break;
    scan += ext_len;
  }

  if (total_cert_size == 0 || cert_count == 0)
    return 0;

  /* Allocate or reallocate buffer if needed */
  if (total_cert_size > client->cert_data_buf_cap) {
    if (client->cert_data_buf)
      FIO_MEM_FREE(client->cert_data_buf, client->cert_data_buf_cap);
    client->cert_data_buf =
        (uint8_t *)FIO_MEM_REALLOC(NULL, 0, total_cert_size, 0);
    if (!client->cert_data_buf) {
      client->cert_data_buf_cap = 0;
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_INTERNAL_ERROR);
      return -1;
    }
    client->cert_data_buf_cap = total_cert_size;
  }

  /* Second pass: copy certificate data to persistent buffer */
  uint8_t *buf_ptr = client->cert_data_buf;
  while (p < list_end && client->cert_chain_count < 10) {
    if (p + 3 > list_end)
      break;
    size_t cert_len = ((size_t)p[0] << 16) | ((size_t)p[1] << 8) | p[2];
    p += 3;
    if (cert_len == 0 || p + cert_len > list_end)
      break;

    /* Copy certificate data to persistent buffer */
    FIO_MEMCPY(buf_ptr, p, cert_len);
    client->cert_chain[client->cert_chain_count] = buf_ptr;
    client->cert_chain_lens[client->cert_chain_count] = cert_len;
    ++client->cert_chain_count;
    buf_ptr += cert_len;
    p += cert_len;

    /* Skip extensions */
    if (p + 2 > list_end)
      break;
    size_t ext_len = ((size_t)p[0] << 8) | p[1];
    p += 2;
    if (p + ext_len > list_end)
      break;
    p += ext_len;
  }

  client->cert_data_buf_len = (size_t)(buf_ptr - client->cert_data_buf);

  /* Update server_cert to point to first certificate in persistent buffer */
  if (client->cert_chain_count > 0) {
    client->server_cert = client->cert_chain[0];
    client->server_cert_len = client->cert_chain_lens[0];
  }

  FIO_LOG_DEBUG2("TLS 1.3: Received %zu certificates in chain (%zu bytes)",
                 client->cert_chain_count,
                 client->cert_data_buf_len);
  return 0;
}

#if defined(H___FIO_X509___H) && defined(H___FIO_RSA___H)
/* Internal: Verify CertificateVerify signature per RFC 8446 Section 4.4.3
 * NOTE: Requires FIO_X509 and FIO_RSA modules to be included. */
FIO_SFUNC int fio___tls13_verify_cv_signature(fio_tls13_client_s *client,
                                              const fio_x509_cert_s *cert,
                                              uint16_t sig_scheme,
                                              const uint8_t *signature,
                                              size_t sig_len) {
  /* Build signed content: 64 spaces + context string + 0x00 + transcript hash
   * Per RFC 8446 Section 4.4.3:
   *   "The content that is covered ... is the hash output ...
   *    Specifically, the content consists of:
   *    - A string of 64 0x20 (space) bytes
   *    - The context string
   *    - A single 0 byte
   *    - The content to be signed"
   */
  static const char context_server[] = "TLS 1.3, server CertificateVerify";
  const size_t context_len = sizeof(context_server) - 1; /* 33 bytes */
  size_t hash_len = fio___tls13_hash_len(client);

  /* Total: 64 + 33 + 1 + hash_len = 98 or 114 bytes */
  uint8_t signed_content[64 + 33 + 1 + FIO_TLS13_MAX_HASH_LEN];
  size_t signed_content_len = 64 + context_len + 1 + hash_len;

  /* 64 spaces */
  FIO_MEMSET(signed_content, 0x20, 64);
  /* Context string */
  FIO_MEMCPY(signed_content + 64, context_server, context_len);
  /* Zero byte separator */
  signed_content[64 + context_len] = 0x00;
  /* Transcript hash (current state before CertificateVerify is added) */
  fio___tls13_transcript_hash(client, signed_content + 64 + context_len + 1);

  /* Hash the signed content for signature verification */
  uint8_t content_hash[FIO_TLS13_MAX_HASH_LEN];
  fio_rsa_hash_e rsa_hash_alg;
  size_t expected_hash_len;

  /* Determine hash algorithm from signature scheme */
  switch (sig_scheme) {
  case FIO_TLS13_SIG_RSA_PSS_RSAE_SHA256:
  case FIO_TLS13_SIG_RSA_PKCS1_SHA256:
  case FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256: {
    fio_sha256_s sha = fio_sha256_init();
    fio_sha256_consume(&sha, signed_content, signed_content_len);
    fio_u256 h = fio_sha256_finalize(&sha);
    FIO_MEMCPY(content_hash, h.u8, 32);
    expected_hash_len = 32;
    rsa_hash_alg = FIO_RSA_HASH_SHA256;
    break;
  }
  case FIO_TLS13_SIG_RSA_PSS_RSAE_SHA384:
  case FIO_TLS13_SIG_RSA_PKCS1_SHA384:
  case FIO_TLS13_SIG_ECDSA_SECP384R1_SHA384: {
    /* SHA-384 uses SHA-512 internals, truncated to 48 bytes */
    fio_sha512_s sha = fio_sha512_init();
    fio_sha512_consume(&sha, signed_content, signed_content_len);
    fio_u512 h = fio_sha512_finalize(&sha);
    FIO_MEMCPY(content_hash, h.u8, 48); /* Use first 48 bytes (SHA-384) */
    expected_hash_len = 48;
    rsa_hash_alg = FIO_RSA_HASH_SHA384;
    break;
  }
  case FIO_TLS13_SIG_ED25519:
    /* Ed25519 does not pre-hash the message */
    expected_hash_len = 0;
    rsa_hash_alg = FIO_RSA_HASH_SHA256; /* unused */
    break;
  default:
    FIO_LOG_DEBUG2("TLS 1.3: Unsupported signature scheme: 0x%04X", sig_scheme);
    return -1;
  }

  /* Verify signature based on algorithm and key type */
  switch (sig_scheme) {
  case FIO_TLS13_SIG_RSA_PSS_RSAE_SHA256:
  case FIO_TLS13_SIG_RSA_PSS_RSAE_SHA384: {
    /* RSA-PSS verification - required for TLS 1.3 */
    if (cert->key_type != FIO_X509_KEY_RSA) {
      FIO_LOG_DEBUG2("TLS 1.3: Certificate key type mismatch for RSA-PSS");
      return -1;
    }
    /* Build RSA public key structure */
    fio_rsa_pubkey_s pubkey;
    FIO_MEMSET(&pubkey, 0, sizeof(pubkey));
    pubkey.n = cert->pubkey.rsa.n;
    pubkey.n_len = cert->pubkey.rsa.n_len;
    pubkey.e = cert->pubkey.rsa.e;
    pubkey.e_len = cert->pubkey.rsa.e_len;

    if (fio_rsa_verify_pss(signature,
                           sig_len,
                           content_hash,
                           expected_hash_len,
                           rsa_hash_alg,
                           &pubkey) != 0) {
      FIO_LOG_DEBUG2("TLS 1.3: RSA-PSS signature verification failed");
      return -1;
    }
    break;
  }
  case FIO_TLS13_SIG_RSA_PKCS1_SHA256:
  case FIO_TLS13_SIG_RSA_PKCS1_SHA384: {
    /* RSA PKCS#1 v1.5 - legacy, but some servers still use it */
    if (cert->key_type != FIO_X509_KEY_RSA) {
      FIO_LOG_DEBUG2("TLS 1.3: Certificate key type mismatch for RSA-PKCS1");
      return -1;
    }
    fio_rsa_pubkey_s pubkey;
    FIO_MEMSET(&pubkey, 0, sizeof(pubkey));
    pubkey.n = cert->pubkey.rsa.n;
    pubkey.n_len = cert->pubkey.rsa.n_len;
    pubkey.e = cert->pubkey.rsa.e;
    pubkey.e_len = cert->pubkey.rsa.e_len;

    if (fio_rsa_verify_pkcs1(signature,
                             sig_len,
                             content_hash,
                             expected_hash_len,
                             rsa_hash_alg,
                             &pubkey) != 0) {
      FIO_LOG_DEBUG2("TLS 1.3: RSA-PKCS1 signature verification failed");
      return -1;
    }
    break;
  }
  case FIO_TLS13_SIG_ED25519: {
    /* Ed25519 - sign directly over the content (no pre-hashing) */
    if (cert->key_type != FIO_X509_KEY_ED25519) {
      FIO_LOG_DEBUG2("TLS 1.3: Certificate key type mismatch for Ed25519");
      return -1;
    }
    if (sig_len != 64) {
      FIO_LOG_DEBUG2("TLS 1.3: Invalid Ed25519 signature length: %zu", sig_len);
      return -1;
    }
    if (fio_ed25519_verify(signature,
                           signed_content,
                           signed_content_len,
                           cert->pubkey.ed25519.key) != 0) {
      FIO_LOG_DEBUG2("TLS 1.3: Ed25519 signature verification failed");
      return -1;
    }
    break;
  }
  case FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256: {
#if defined(H___FIO_P256___H)
    /* ECDSA P-256 with SHA-256 */
    if (cert->key_type != FIO_X509_KEY_ECDSA_P256) {
      FIO_LOG_DEBUG2("TLS 1.3: Certificate key type mismatch for ECDSA P-256");
      return -1;
    }
    if (!cert->pubkey.ecdsa.point || cert->pubkey.ecdsa.point_len != 65) {
      FIO_LOG_DEBUG2("TLS 1.3: Invalid ECDSA P-256 public key");
      return -1;
    }
    if (fio_ecdsa_p256_verify(signature,
                              sig_len,
                              content_hash,
                              cert->pubkey.ecdsa.point,
                              cert->pubkey.ecdsa.point_len) != 0) {
      FIO_LOG_DEBUG2("TLS 1.3: ECDSA P-256 signature verification failed");
      return -1;
    }
    break;
#else
    FIO_LOG_DEBUG2("TLS 1.3: ECDSA P-256 not available (FIO_P256 not defined)");
    return -1;
#endif
  }
  case FIO_TLS13_SIG_ECDSA_SECP384R1_SHA384: {
#if defined(H___FIO_P384___H)
    /* ECDSA P-384 with SHA-384 */
    if (cert->key_type != FIO_X509_KEY_ECDSA_P384) {
      FIO_LOG_DEBUG2("TLS 1.3: Certificate key type mismatch for ECDSA P-384");
      return -1;
    }
    if (!cert->pubkey.ecdsa.point || cert->pubkey.ecdsa.point_len != 97) {
      FIO_LOG_DEBUG2("TLS 1.3: Invalid ECDSA P-384 public key");
      return -1;
    }
    if (fio_ecdsa_p384_verify(signature,
                              sig_len,
                              content_hash,
                              cert->pubkey.ecdsa.point,
                              cert->pubkey.ecdsa.point_len) != 0) {
      FIO_LOG_DEBUG2("TLS 1.3: ECDSA P-384 signature verification failed");
      return -1;
    }
    break;
#else
    FIO_LOG_DEBUG2("TLS 1.3: ECDSA P-384 not available (FIO_P384 not defined)");
    return -1;
#endif
  }
  default: return -1;
  }

  FIO_LOG_DEBUG2("TLS 1.3: CertificateVerify signature verified successfully");
  return 0;
}
#endif /* H___FIO_X509___H && H___FIO_RSA___H */

/* Internal: Process CertificateVerify */
FIO_SFUNC int fio___tls13_process_certificate_verify(fio_tls13_client_s *client,
                                                     const uint8_t *data,
                                                     size_t data_len) {
  fio_tls13_certificate_verify_s cv;
  if (fio_tls13_parse_certificate_verify(&cv, data, data_len) != 0) {
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_DECODE_ERROR);
    return -1;
  }

  /* Store signature info */
  client->server_signature = cv.signature;
  client->server_signature_len = cv.signature_len;
  client->server_signature_scheme = cv.signature_scheme;

  /* Skip verification if explicitly disabled */
  if (client->skip_cert_verify) {
    FIO_LOG_DEBUG2("TLS 1.3: Skipping CertificateVerify (insecure mode)");
    client->cert_verified = 1;
    return 0;
  }

#if defined(H___FIO_X509___H) && defined(H___FIO_RSA___H)
  /* Must have at least one certificate to verify against */
  if (client->cert_chain_count == 0) {
    FIO_LOG_DEBUG2("TLS 1.3: No certificates received for CV verification");
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_CERTIFICATE_REQUIRED);
    return -1;
  }

  /* Parse the end-entity certificate to get the public key */
  fio_x509_cert_s cert;
  if (fio_x509_parse(&cert,
                     client->cert_chain[0],
                     client->cert_chain_lens[0]) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3: Failed to parse server certificate for CV");
    client->cert_error = FIO_X509_ERR_PARSE;
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_BAD_CERTIFICATE);
    return -1;
  }

  /* Verify the CertificateVerify signature */
  if (fio___tls13_verify_cv_signature(client,
                                      &cert,
                                      cv.signature_scheme,
                                      cv.signature,
                                      cv.signature_len) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3: CertificateVerify signature invalid");
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_DECRYPT_ERROR);
    return -1;
  }

  client->cert_verified = 1;
#else
  /* X509/RSA modules not available - skip signature verification */
  FIO_LOG_DEBUG2("TLS 1.3: X509/RSA modules unavailable, skipping CV verify");
  client->cert_verified = 1;
#endif /* H___FIO_X509___H && H___FIO_RSA___H */
  return 0;
}

#if defined(H___FIO_X509___H)
/* Internal: Verify certificate chain (call after CertificateVerify succeeds)
 * NOTE: Requires FIO_X509 module to be included. */
FIO_SFUNC int fio___tls13_verify_certificate_chain(fio_tls13_client_s *client) {
  /* Skip if no chain or verification disabled */
  if (client->skip_cert_verify) {
    FIO_LOG_DEBUG2("TLS 1.3: Skipping chain verification (insecure mode)");
    client->chain_verified = 1;
    return 0;
  }

  /* Must have at least one certificate */
  if (client->cert_chain_count == 0) {
    FIO_LOG_DEBUG2("TLS 1.3: No certificates to verify");
    client->cert_error = FIO_X509_ERR_EMPTY_CHAIN;
    return -1;
  }

  /* Get current timestamp for validity checking */
  int64_t current_time = (int64_t)fio_time_real().tv_sec;

  /* Use x509 chain verification if trust store is provided */
  if (client->trust_store != NULL) {
    int result =
        fio_x509_verify_chain(client->cert_chain,
                              client->cert_chain_lens,
                              client->cert_chain_count,
                              client->server_name,
                              current_time,
                              (fio_x509_trust_store_s *)client->trust_store);
    if (result != FIO_X509_OK) {
      FIO_LOG_DEBUG2("TLS 1.3: Chain verification failed: %s",
                     fio_x509_error_str(result));
      client->cert_error = (int16_t)result;
      return -1;
    }
    client->chain_verified = 1;
    FIO_LOG_DEBUG2("TLS 1.3: Certificate chain verified successfully");
    return 0;
  }

  /* No trust store: perform minimal validation (hostname + validity only) */
  fio_x509_cert_s cert;
  if (fio_x509_parse(&cert,
                     client->cert_chain[0],
                     client->cert_chain_lens[0]) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3: Failed to parse end-entity certificate");
    client->cert_error = FIO_X509_ERR_PARSE;
    return -1;
  }

  /* Check validity period */
  if (fio_x509_check_validity(&cert, current_time) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3: Certificate expired or not yet valid");
    client->cert_error = (current_time < cert.not_before)
                             ? FIO_X509_ERR_NOT_YET_VALID
                             : FIO_X509_ERR_EXPIRED;
    return -1;
  }

  /* Check hostname if SNI was provided */
  if (client->server_name != NULL) {
    size_t name_len = strlen(client->server_name);
    if (fio_x509_match_hostname(&cert, client->server_name, name_len) != 0) {
      FIO_LOG_DEBUG2("TLS 1.3: Hostname mismatch (expected: %s)",
                     client->server_name);
      client->cert_error = FIO_X509_ERR_HOSTNAME_MISMATCH;
      return -1;
    }
  }

  /* Without trust store, we can't verify the chain, but we did basic checks */
  FIO_LOG_DEBUG2("TLS 1.3: Basic certificate checks passed (no trust store)");
  client->chain_verified = 1;
  return 0;
}
#else
/* X509 module not available - stub function */
FIO_SFUNC int fio___tls13_verify_certificate_chain(fio_tls13_client_s *client) {
  /* No X509 module - skip chain verification */
  FIO_LOG_DEBUG2("TLS 1.3: X509 module unavailable, skipping chain verify");
  client->chain_verified = 1;
  (void)client;
  return 0;
}
#endif /* H___FIO_X509___H */

/* Internal: Process Finished */
FIO_SFUNC int fio___tls13_process_finished(fio_tls13_client_s *client,
                                           const uint8_t *data,
                                           size_t data_len) {
  /* Verify server Finished */
  if (fio___tls13_verify_server_finished(client, data, data_len) != 0) {
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_DECRYPT_ERROR);
    return -1;
  }

  return 0;
}

/* Internal: Process a single handshake message */
FIO_SFUNC int fio___tls13_process_handshake_message(fio_tls13_client_s *client,
                                                    const uint8_t *msg,
                                                    size_t msg_len,
                                                    uint8_t *out,
                                                    size_t out_capacity,
                                                    size_t *out_len) {
  fio_tls13_handshake_type_e msg_type;
  size_t body_len;
  const uint8_t *body =
      fio_tls13_parse_handshake_header(msg, msg_len, &msg_type, &body_len);

  if (!body) {
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_DECODE_ERROR);
    return -1;
  }

  *out_len = 0;

  switch (client->state) {
  case FIO_TLS13_STATE_WAIT_SH:
  case FIO_TLS13_STATE_WAIT_SH2: {
    fio_tls13_server_hello_s sh;
    if (msg_type != FIO_TLS13_HS_SERVER_HELLO) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }

    /* Parse ServerHello to check if it's an HRR */
    if (fio_tls13_parse_server_hello(&sh, body, body_len) != 0) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_DECODE_ERROR);
      return -1;
    }

    if (sh.is_hello_retry_request) {
      /* HelloRetryRequest - handle specially (updates transcript internally) */
      if (fio___tls13_handle_hello_retry_request(client,
                                                 &sh,
                                                 msg,
                                                 4 + body_len) != 1) {
        return -1; /* Error already set */
      }
      /* Need to send ClientHello2 - return special value */
      return 2;
    }

    /* Normal ServerHello - update transcript FIRST, then process */
    fio___tls13_transcript_update(client, msg, 4 + body_len);
    if (fio___tls13_process_server_hello(client, body, body_len) != 0)
      return -1;
    client->state = FIO_TLS13_STATE_WAIT_EE;
    break;
  }

  case FIO_TLS13_STATE_WAIT_EE:
    if (msg_type != FIO_TLS13_HS_ENCRYPTED_EXTENSIONS) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }
    fio___tls13_transcript_update(client, msg, 4 + body_len);
    if (fio___tls13_process_encrypted_extensions(client, body, body_len) != 0)
      return -1;
    client->state = FIO_TLS13_STATE_WAIT_CERT_CR;
    break;

  case FIO_TLS13_STATE_WAIT_CERT_CR:
    if (msg_type == FIO_TLS13_HS_CERTIFICATE_REQUEST) {
      /* CertificateRequest - skip for now, go to WAIT_CERT */
      fio___tls13_transcript_update(client, msg, 4 + body_len);
      client->state = FIO_TLS13_STATE_WAIT_CERT;
    } else if (msg_type == FIO_TLS13_HS_CERTIFICATE) {
      fio___tls13_transcript_update(client, msg, 4 + body_len);
      if (fio___tls13_process_certificate(client, body, body_len) != 0)
        return -1;
      client->state = FIO_TLS13_STATE_WAIT_CV;
    } else {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }
    break;

  case FIO_TLS13_STATE_WAIT_CERT:
    if (msg_type != FIO_TLS13_HS_CERTIFICATE) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }
    fio___tls13_transcript_update(client, msg, 4 + body_len);
    if (fio___tls13_process_certificate(client, body, body_len) != 0)
      return -1;
    client->state = FIO_TLS13_STATE_WAIT_CV;
    break;

  case FIO_TLS13_STATE_WAIT_CV:
    if (msg_type != FIO_TLS13_HS_CERTIFICATE_VERIFY) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }
    /* Process CertificateVerify BEFORE updating transcript (signature covers
     * transcript up to but not including CertificateVerify) */
    if (fio___tls13_process_certificate_verify(client, body, body_len) != 0)
      return -1;
    /* Now update transcript with CertificateVerify */
    fio___tls13_transcript_update(client, msg, 4 + body_len);
    /* Verify certificate chain after CertificateVerify signature is valid */
    if (fio___tls13_verify_certificate_chain(client) != 0) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_BAD_CERTIFICATE);
      return -1;
    }
    client->state = FIO_TLS13_STATE_WAIT_FINISHED;
    break;

  case FIO_TLS13_STATE_WAIT_FINISHED:
    if (msg_type != FIO_TLS13_HS_FINISHED) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }
    /* Verify server Finished BEFORE updating transcript */
    if (fio___tls13_process_finished(client, body, body_len) != 0)
      return -1;
    /* Now update transcript with server Finished */
    fio___tls13_transcript_update(client, msg, 4 + body_len);

    /* Derive application keys */
    if (fio___tls13_derive_app_keys(client) != 0) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_INTERNAL_ERROR);
      return -1;
    }

    /* Build client Finished */
    {
      uint8_t finished_msg[64];
      int finished_len =
          fio___tls13_build_client_finished(client,
                                            finished_msg,
                                            sizeof(finished_msg));
      if (finished_len < 0) {
        fio___tls13_set_error(client,
                              FIO_TLS13_ALERT_LEVEL_FATAL,
                              FIO_TLS13_ALERT_INTERNAL_ERROR);
        return -1;
      }

      /* Update transcript with client Finished */
      fio___tls13_transcript_update(client, finished_msg, (size_t)finished_len);

      /* Encrypt client Finished */
      int enc_len = fio_tls13_record_encrypt(out,
                                             out_capacity,
                                             finished_msg,
                                             (size_t)finished_len,
                                             FIO_TLS13_CONTENT_HANDSHAKE,
                                             &client->client_handshake_keys);
      if (enc_len < 0) {
        fio___tls13_set_error(client,
                              FIO_TLS13_ALERT_LEVEL_FATAL,
                              FIO_TLS13_ALERT_INTERNAL_ERROR);
        return -1;
      }
      *out_len = (size_t)enc_len;
    }

    /* Switch to encrypted mode for writing */
    client->encrypted_write = 1;
    client->state = FIO_TLS13_STATE_CONNECTED;
    break;

  default:
    fio___tls13_set_error(client,
                          FIO_TLS13_ALERT_LEVEL_FATAL,
                          FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
    return -1;
  }

  return 0;
}

/* *****************************************************************************
TLS 1.3 Client HelloRetryRequest - ClientHello2 Building
***************************************************************************** */

/**
 * Internal: Build ClientHello2 after HelloRetryRequest.
 *
 * Per RFC 8446 Section 4.1.4, ClientHello2 MUST:
 * - Use the same random value as the original ClientHello
 * - Replace key_share with a single KeyShareEntry for the server-selected group
 * - Include cookie extension if provided in HRR
 * - Update pre_shared_key if present (we don't use PSK)
 *
 * Returns: Total record length on success, -1 on error
 */
FIO_SFUNC int fio___tls13_build_client_hello2(fio_tls13_client_s *client,
                                              uint8_t *out,
                                              size_t out_capacity) {
  if (!client || !out || out_capacity < 512)
    return -1;

  /* Build ClientHello2 handshake message */
  uint8_t ch_msg[1024];
  uint8_t *p = ch_msg + 4; /* Skip handshake header */
  uint8_t *start = p;

  /* Legacy version: TLS 1.2 (0x0303) */
  fio___tls13_write_u16(p, FIO_TLS13_VERSION_TLS12);
  p += 2;

  /* Random - MUST be same as original ClientHello */
  FIO_MEMCPY(p, client->client_random, 32);
  p += 32;

  /* Legacy session ID (empty for TLS 1.3) */
  *p++ = 0;

  /* Cipher suites - same as original */
  uint16_t cipher_suites[] = {FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256,
                              FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256,
                              FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384};
  fio___tls13_write_u16(p, 6); /* 3 suites * 2 bytes */
  p += 2;
  for (int i = 0; i < 3; ++i) {
    fio___tls13_write_u16(p, cipher_suites[i]);
    p += 2;
  }

  /* Legacy compression methods (only null) */
  *p++ = 1; /* Length */
  *p++ = 0; /* null compression */

  /* Extensions */
  uint8_t *ext_len_ptr = p;
  p += 2; /* Skip extensions length for now */
  uint8_t *ext_start = p;

  /* SNI extension (if we have server name) */
  if (client->server_name) {
    p += fio___tls13_write_ext_sni(p, client->server_name);
  }

  /* supported_versions extension (REQUIRED for TLS 1.3) */
  p += fio___tls13_write_ext_supported_versions(p);

  /* supported_groups extension */
  p += fio___tls13_write_ext_supported_groups(p);

  /* signature_algorithms extension */
  p += fio___tls13_write_ext_signature_algorithms(p);

  /* Cookie extension (if provided in HRR) */
  if (client->hrr_cookie && client->hrr_cookie_len > 0) {
    /* Extension type: cookie (44) */
    fio___tls13_write_u16(p, FIO_TLS13_EXT_COOKIE);
    p += 2;
    /* Extension data length: cookie_len(2) + cookie */
    fio___tls13_write_u16(p, (uint16_t)(2 + client->hrr_cookie_len));
    p += 2;
    /* Cookie length */
    fio___tls13_write_u16(p, (uint16_t)client->hrr_cookie_len);
    p += 2;
    /* Cookie data */
    FIO_MEMCPY(p, client->hrr_cookie, client->hrr_cookie_len);
    p += client->hrr_cookie_len;
    FIO_LOG_DEBUG2("TLS 1.3 CH2: Included cookie (%zu bytes)",
                   client->hrr_cookie_len);
  }

  /* key_share extension - SINGLE entry for server-selected group */
  fio___tls13_write_u16(p, FIO_TLS13_EXT_KEY_SHARE);
  p += 2;

  if (client->hrr_selected_group == FIO_TLS13_GROUP_X25519) {
    /* X25519: entries_len(2) + group(2) + key_len(2) + key(32) = 38 bytes */
    fio___tls13_write_u16(p, 2 + 36); /* Extension data length */
    p += 2;
    fio___tls13_write_u16(p, 36); /* Client key share entries length */
    p += 2;
    fio___tls13_write_u16(p, FIO_TLS13_GROUP_X25519);
    p += 2;
    fio___tls13_write_u16(p, 32); /* Key length */
    p += 2;
    FIO_MEMCPY(p, client->x25519_public_key, 32);
    p += 32;
  } else if (client->hrr_selected_group == FIO_TLS13_GROUP_SECP256R1) {
#if defined(H___FIO_P256___H)
    /* P-256: entries_len(2) + group(2) + key_len(2) + key(65) = 71 bytes */
    fio___tls13_write_u16(p, 2 + 69); /* Extension data length */
    p += 2;
    fio___tls13_write_u16(p, 69); /* Client key share entries length */
    p += 2;
    fio___tls13_write_u16(p, FIO_TLS13_GROUP_SECP256R1);
    p += 2;
    fio___tls13_write_u16(p, 65); /* Key length (uncompressed point) */
    p += 2;
    FIO_MEMCPY(p, client->p256_public_key, 65);
    p += 65;
#else
    FIO_LOG_DEBUG2("TLS 1.3 CH2: P-256 not available");
    return -1;
#endif
  } else {
    FIO_LOG_DEBUG2("TLS 1.3 CH2: Unsupported group 0x%04x",
                   client->hrr_selected_group);
    return -1;
  }

  /* Write extensions length */
  fio___tls13_write_u16(ext_len_ptr, (uint16_t)(p - ext_start));

  /* Calculate body length and write handshake header */
  size_t body_len = (size_t)(p - start);
  fio_tls13_write_handshake_header(ch_msg, FIO_TLS13_HS_CLIENT_HELLO, body_len);

  size_t ch_len = 4 + body_len;

  /* Update transcript with ClientHello2 */
  fio___tls13_transcript_update(client, ch_msg, ch_len);

  /* Check output capacity for record header + message */
  size_t total_len = FIO_TLS13_RECORD_HEADER_LEN + ch_len;
  if (out_capacity < total_len)
    return -1;

  /* Write record header */
  fio___tls13_write_record_header(out,
                                  FIO_TLS13_CONTENT_HANDSHAKE,
                                  (uint16_t)ch_len);

  /* Copy handshake message */
  FIO_MEMCPY(out + FIO_TLS13_RECORD_HEADER_LEN, ch_msg, ch_len);

  FIO_LOG_DEBUG2("TLS 1.3: Built ClientHello2 (%zu bytes) for group 0x%04x",
                 total_len,
                 client->hrr_selected_group);

  return (int)total_len;
}

/* *****************************************************************************
TLS 1.3 Client Public API Implementation
***************************************************************************** */

SFUNC void fio_tls13_client_init(fio_tls13_client_s *client,
                                 const char *server_name) {
  if (!client)
    return;

  FIO_MEMSET(client, 0, sizeof(*client));
  client->state = FIO_TLS13_STATE_START;
  client->server_name = server_name;

  /* Initialize transcript hashes */
  client->transcript_sha256 = fio_sha256_init();
  client->transcript_sha384 = fio_sha512_init();

  /* Generate random and X25519 keypair */
  fio_rand_bytes(client->client_random, 32);
  fio_x25519_keypair(client->x25519_private_key, client->x25519_public_key);
}

SFUNC void fio_tls13_client_destroy(fio_tls13_client_s *client) {
  if (!client)
    return;

  /* Free certificate data buffer */
  if (client->cert_data_buf) {
    FIO_MEM_FREE(client->cert_data_buf, client->cert_data_buf_cap);
    client->cert_data_buf = NULL;
    client->cert_data_buf_len = 0;
    client->cert_data_buf_cap = 0;
  }

  /* Free HRR cookie if allocated */
  if (client->hrr_cookie) {
    FIO_MEM_FREE(client->hrr_cookie, client->hrr_cookie_len);
    client->hrr_cookie = NULL;
    client->hrr_cookie_len = 0;
  }

  /* Clear all sensitive data */
  fio_secure_zero(client->x25519_private_key, 32);
  fio_secure_zero(client->p256_private_key, 32);
  fio_secure_zero(client->shared_secret, 32);
  fio_secure_zero(client->early_secret, 48);
  fio_secure_zero(client->handshake_secret, 48);
  fio_secure_zero(client->master_secret, 48);
  fio_secure_zero(client->client_handshake_traffic_secret, 48);
  fio_secure_zero(client->server_handshake_traffic_secret, 48);
  fio_secure_zero(client->client_app_traffic_secret, 48);
  fio_secure_zero(client->server_app_traffic_secret, 48);

  fio_tls13_record_keys_clear(&client->client_handshake_keys);
  fio_tls13_record_keys_clear(&client->server_handshake_keys);
  fio_tls13_record_keys_clear(&client->client_app_keys);
  fio_tls13_record_keys_clear(&client->server_app_keys);

  FIO_MEMSET(client, 0, sizeof(*client));
}

SFUNC int fio_tls13_client_start(fio_tls13_client_s *client,
                                 uint8_t *out,
                                 size_t out_capacity) {
  if (!client || !out || client->state != FIO_TLS13_STATE_START)
    return -1;

  /* Build ClientHello */
  uint16_t cipher_suites[] = {FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256,
                              FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256,
                              FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384};

  /* Build handshake message first (without record header) */
  uint8_t ch_msg[512];
  int ch_len = fio_tls13_build_client_hello(ch_msg,
                                            sizeof(ch_msg),
                                            client->client_random,
                                            client->server_name,
                                            client->x25519_public_key,
                                            cipher_suites,
                                            3);
  if (ch_len < 0)
    return -1;

  /* Update transcript with ClientHello (handshake message only) */
  fio___tls13_transcript_update(client, ch_msg, (size_t)ch_len);

  /* Check output capacity for record header + message */
  size_t total_len = FIO_TLS13_RECORD_HEADER_LEN + (size_t)ch_len;
  if (out_capacity < total_len)
    return -1;

  /* Write record header */
  fio___tls13_write_record_header(out,
                                  FIO_TLS13_CONTENT_HANDSHAKE,
                                  (uint16_t)ch_len);

  /* Copy handshake message */
  FIO_MEMCPY(out + FIO_TLS13_RECORD_HEADER_LEN, ch_msg, (size_t)ch_len);

  client->state = FIO_TLS13_STATE_WAIT_SH;
  return (int)total_len;
}

SFUNC int fio_tls13_client_process(fio_tls13_client_s *client,
                                   const uint8_t *in,
                                   size_t in_len,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   size_t *out_len) {
  if (!client || !in || !out || !out_len)
    return -1;

  if (client->state == FIO_TLS13_STATE_ERROR ||
      client->state == FIO_TLS13_STATE_CONNECTED)
    return -1;

  *out_len = 0;

  /* Parse record header */
  fio_tls13_content_type_e content_type;
  size_t payload_len;
  const uint8_t *payload =
      fio_tls13_record_parse_header(in, in_len, &content_type, &payload_len);

  if (!payload)
    return 0; /* Need more data */

  size_t record_len = FIO_TLS13_RECORD_HEADER_LEN + payload_len;

  /* Handle Change Cipher Spec (ignore in TLS 1.3) */
  if (content_type == FIO_TLS13_CONTENT_CHANGE_CIPHER_SPEC) {
    return (int)record_len;
  }

  /* Decrypt if in encrypted mode */
  uint8_t decrypted[FIO_TLS13_MAX_PLAINTEXT_LEN + 256];
  const uint8_t *hs_data = payload;
  size_t hs_len = payload_len;

  if (client->encrypted_read) {
    if (content_type != FIO_TLS13_CONTENT_APPLICATION_DATA) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }

    fio_tls13_content_type_e inner_type;
    int dec_len = fio_tls13_record_decrypt(decrypted,
                                           sizeof(decrypted),
                                           &inner_type,
                                           in,
                                           record_len,
                                           &client->server_handshake_keys);
    if (dec_len < 0) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_BAD_RECORD_MAC);
      return -1;
    }

    if (inner_type != FIO_TLS13_CONTENT_HANDSHAKE) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }

    hs_data = decrypted;
    hs_len = (size_t)dec_len;
  } else {
    if (content_type != FIO_TLS13_CONTENT_HANDSHAKE) {
      fio___tls13_set_error(client,
                            FIO_TLS13_ALERT_LEVEL_FATAL,
                            FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }
  }

  /* Process handshake messages (may be multiple in one record) */
  size_t offset = 0;
  while (offset < hs_len) {
    /* Parse handshake header to get message length */
    if (hs_len - offset < 4)
      break; /* Need more data */

    uint32_t msg_body_len = ((uint32_t)hs_data[offset + 1] << 16) |
                            ((uint32_t)hs_data[offset + 2] << 8) |
                            (uint32_t)hs_data[offset + 3];
    size_t msg_total_len = 4 + msg_body_len;

    if (offset + msg_total_len > hs_len)
      break; /* Need more data */

    /* Process this handshake message */
    size_t msg_out_len = 0;
    int process_result =
        fio___tls13_process_handshake_message(client,
                                              hs_data + offset,
                                              msg_total_len,
                                              out + *out_len,
                                              out_capacity - *out_len,
                                              &msg_out_len);

    if (process_result == 2) {
      /* HelloRetryRequest received - need to send ClientHello2 */
      int ch2_len = fio___tls13_build_client_hello2(client,
                                                    out + *out_len,
                                                    out_capacity - *out_len);
      if (ch2_len < 0) {
        fio___tls13_set_error(client,
                              FIO_TLS13_ALERT_LEVEL_FATAL,
                              FIO_TLS13_ALERT_INTERNAL_ERROR);
        return -1;
      }
      *out_len += (size_t)ch2_len;
      client->state = FIO_TLS13_STATE_WAIT_SH2;
      offset += msg_total_len;
      continue;
    } else if (process_result != 0) {
      return -1;
    }
    *out_len += msg_out_len;
    offset += msg_total_len;
  }

  return (int)record_len;
}

SFUNC int fio_tls13_client_encrypt(fio_tls13_client_s *client,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *plaintext,
                                   size_t plaintext_len) {
  if (!client || !out)
    return -1;

  if (client->state != FIO_TLS13_STATE_CONNECTED)
    return -1;

  return fio_tls13_record_encrypt(out,
                                  out_capacity,
                                  plaintext,
                                  plaintext_len,
                                  FIO_TLS13_CONTENT_APPLICATION_DATA,
                                  &client->client_app_keys);
}

SFUNC int fio_tls13_client_decrypt(fio_tls13_client_s *client,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *ciphertext,
                                   size_t ciphertext_len) {
  if (!client || !out || !ciphertext)
    return -1;

  if (client->state != FIO_TLS13_STATE_CONNECTED)
    return -1;

  fio_tls13_content_type_e content_type;
  int dec_len = fio_tls13_record_decrypt(out,
                                         out_capacity,
                                         &content_type,
                                         ciphertext,
                                         ciphertext_len,
                                         &client->server_app_keys);

  if (dec_len < 0)
    return -1;

  /* Handle post-handshake messages (e.g., NewSessionTicket)
   * Per RFC 8446 Section 4.6.1, servers may send NewSessionTicket messages
   * after the handshake completes. These are encrypted with application
   * traffic keys but have handshake content type.
   * Return 0 to indicate "no application data, try next record". */
  if (content_type == FIO_TLS13_CONTENT_HANDSHAKE) {
    FIO_LOG_DEBUG2("TLS 1.3: Received post-handshake message (ignored)");
    return 0;
  }

  /* Handle alerts */
  if (content_type == FIO_TLS13_CONTENT_ALERT) {
    if (dec_len >= 2) {
      FIO_LOG_DEBUG2("TLS 1.3: Received alert: level=%d, desc=%d",
                     out[0],
                     out[1]);
    }
    return -1;
  }

  /* Only return application data */
  if (content_type != FIO_TLS13_CONTENT_APPLICATION_DATA)
    return -1;

  return dec_len;
}

/* *****************************************************************************




                        TLS 1.3 Server Handshake State Machine
                              (RFC 8446 Section 4)




***************************************************************************** */

/* *****************************************************************************
TLS 1.3 Server State Machine
***************************************************************************** */

/** TLS 1.3 Server Handshake States (RFC 8446 Section 2) */
typedef enum {
  FIO_TLS13_SERVER_STATE_START = 0,     /* Initial state, waiting for CH */
  FIO_TLS13_SERVER_STATE_RECVD_CH,      /* Received ClientHello, parsing */
  FIO_TLS13_SERVER_STATE_NEGOTIATED,    /* Negotiated params, building SH */
  FIO_TLS13_SERVER_STATE_WAIT_FLIGHT2,  /* Sent SH..Fin, waiting for client */
  FIO_TLS13_SERVER_STATE_WAIT_FINISHED, /* Waiting for client Finished */
  FIO_TLS13_SERVER_STATE_CONNECTED,     /* Handshake complete */
  FIO_TLS13_SERVER_STATE_ERROR,         /* Error state */
} fio_tls13_server_state_e;

/** Parsed ClientHello message */
typedef struct {
  uint8_t random[32];                /* Client random */
  uint8_t legacy_session_id[32];     /* Legacy session ID (for middlebox) */
  uint8_t legacy_session_id_len;     /* Length of legacy session ID */
  uint16_t cipher_suites[16];        /* Offered cipher suites */
  size_t cipher_suite_count;         /* Number of cipher suites */
  uint16_t supported_groups[8];      /* Offered key exchange groups */
  size_t supported_group_count;      /* Number of groups */
  uint16_t signature_algorithms[16]; /* Offered signature algorithms */
  size_t signature_algorithm_count;  /* Number of signature algorithms */
  uint8_t key_shares[256];           /* Key share data */
  size_t key_share_len;              /* Total key share data length */
  uint16_t key_share_groups[4];      /* Groups for key shares */
  uint8_t key_share_offsets[4];      /* Offsets into key_shares */
  uint8_t key_share_lens[4];         /* Lengths of each key share */
  size_t key_share_count;            /* Number of key shares */
  const char *server_name;           /* SNI hostname (pointer into data) */
  size_t server_name_len;            /* SNI hostname length */
  int has_supported_versions;        /* 1 if TLS 1.3 supported */
  /* ALPN (Application-Layer Protocol Negotiation) */
  const char *alpn_protocols[8]; /* ALPN protocol names (pointers into data) */
  size_t alpn_protocol_lens[8];  /* ALPN protocol name lengths */
  size_t alpn_protocol_count;    /* Number of ALPN protocols */
} fio_tls13_client_hello_s;

/** TLS 1.3 Server Context */
typedef struct {
  /* State */
  fio_tls13_server_state_e state;

  /* Negotiated parameters */
  uint16_t cipher_suite;     /* Selected cipher suite */
  uint16_t key_share_group;  /* Selected key exchange group */
  uint16_t signature_scheme; /* Selected signature algorithm */
  int use_sha384;            /* 0 = SHA-256, 1 = SHA-384 */

  /* Key material */
  uint8_t server_random[32];
  uint8_t x25519_private_key[32];
  uint8_t x25519_public_key[32];
  uint8_t shared_secret[32]; /* ECDHE shared secret */

  /* Secrets (derived during handshake) - up to SHA-384 size */
  uint8_t early_secret[48];
  uint8_t handshake_secret[48];
  uint8_t master_secret[48];
  uint8_t client_handshake_traffic_secret[48];
  uint8_t server_handshake_traffic_secret[48];
  uint8_t client_app_traffic_secret[48];
  uint8_t server_app_traffic_secret[48];

  /* Traffic keys */
  fio_tls13_record_keys_s client_handshake_keys;
  fio_tls13_record_keys_s server_handshake_keys;
  fio_tls13_record_keys_s client_app_keys;
  fio_tls13_record_keys_s server_app_keys;

  /* Transcript hash (running hash of all handshake messages) */
  fio_sha256_s transcript_sha256; /* For SHA-256 cipher suites */
  fio_sha512_s transcript_sha384; /* For SHA-384 cipher suites */

  /* Certificate chain (DER-encoded certificates) */
  const uint8_t **cert_chain;    /* Array of certificate pointers */
  const size_t *cert_chain_lens; /* Array of certificate lengths */
  size_t cert_chain_count;       /* Number of certificates */

  /* Private key for signing (Ed25519, P-256, or RSA) */
  const uint8_t *private_key; /* Private key data */
  size_t private_key_len;     /* Private key length */
  uint16_t private_key_type;  /* Key type (signature scheme) */
  /* Public key for P-256 signing (65 bytes: 0x04 || x || y) */
  uint8_t public_key[65];

  /* Client info (from ClientHello) */
  char client_sni[256];          /* Client's SNI hostname */
  size_t client_sni_len;         /* SNI length */
  uint8_t legacy_session_id[32]; /* Client's legacy session ID (to echo) */
  uint8_t legacy_session_id_len; /* Length of legacy session ID */

  /* ALPN (Application-Layer Protocol Negotiation) */
  char selected_alpn[256];          /* Selected ALPN protocol name */
  size_t selected_alpn_len;         /* Selected ALPN protocol length */
  const char **alpn_protocols;      /* Server's supported ALPN protocols */
  const size_t *alpn_protocol_lens; /* Server's ALPN protocol lengths */
  size_t alpn_protocol_count;       /* Number of server's ALPN protocols */

  /* Error info */
  uint8_t alert_level;
  uint8_t alert_description;

  /* Internal flags */
  uint8_t encrypted_read;     /* 1 if reading encrypted records */
  uint8_t encrypted_write;    /* 1 if writing encrypted records */
  uint8_t client_auth;        /* 1 if requesting client certificate */
  uint8_t key_update_pending; /* 1 if KeyUpdate response needed (RFC 8446 4.6.3)
                               */
} fio_tls13_server_s;

/* *****************************************************************************
TLS 1.3 Server API
***************************************************************************** */

/**
 * Initialize server context.
 *
 * @param server Server context to initialize
 */
SFUNC void fio_tls13_server_init(fio_tls13_server_s *server);

/**
 * Clean up server context (zeroes secrets).
 *
 * @param server Server context to destroy
 */
SFUNC void fio_tls13_server_destroy(fio_tls13_server_s *server);

/**
 * Set certificate chain for server authentication.
 *
 * @param server     Server context
 * @param certs      Array of DER-encoded certificate pointers
 * @param cert_lens  Array of certificate lengths
 * @param cert_count Number of certificates (first is end-entity)
 */
SFUNC void fio_tls13_server_set_cert_chain(fio_tls13_server_s *server,
                                           const uint8_t **certs,
                                           const size_t *cert_lens,
                                           size_t cert_count);

/**
 * Set private key for server authentication.
 *
 * @param server      Server context
 * @param private_key Private key data (Ed25519: 32 bytes seed)
 * @param key_len     Private key length
 * @param key_type    Key type (FIO_TLS13_SIG_ED25519, etc.)
 */
SFUNC void fio_tls13_server_set_private_key(fio_tls13_server_s *server,
                                            const uint8_t *private_key,
                                            size_t key_len,
                                            uint16_t key_type);

/**
 * Process incoming TLS record(s).
 *
 * May generate response data in out buffer.
 *
 * @param server       Server context
 * @param in           Input buffer containing TLS record(s)
 * @param in_len       Length of input data
 * @param out          Output buffer for response
 * @param out_capacity Capacity of output buffer
 * @param out_len      Output: response length (0 if no response needed)
 * @return Number of bytes consumed, or -1 on error
 */
SFUNC int fio_tls13_server_process(fio_tls13_server_s *server,
                                   const uint8_t *in,
                                   size_t in_len,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   size_t *out_len);

/**
 * Encrypt application data for sending.
 *
 * @param server       Server context
 * @param out          Output buffer for encrypted record
 * @param out_capacity Capacity of output buffer
 * @param plaintext    Plaintext data to encrypt
 * @param plaintext_len Length of plaintext
 * @return Encrypted record length, or -1 on error
 */
SFUNC int fio_tls13_server_encrypt(fio_tls13_server_s *server,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *plaintext,
                                   size_t plaintext_len);

/**
 * Decrypt received application data.
 *
 * @param server         Server context
 * @param out            Output buffer for decrypted data
 * @param out_capacity   Capacity of output buffer
 * @param ciphertext     Encrypted record (including header)
 * @param ciphertext_len Length of encrypted record
 * @return Plaintext length, or -1 on error
 */
SFUNC int fio_tls13_server_decrypt(fio_tls13_server_s *server,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *ciphertext,
                                   size_t ciphertext_len);

/**
 * Check if handshake is complete.
 */
FIO_IFUNC int fio_tls13_server_is_connected(fio_tls13_server_s *server) {
  return server && server->state == FIO_TLS13_SERVER_STATE_CONNECTED;
}

/**
 * Check if in error state.
 */
FIO_IFUNC int fio_tls13_server_is_error(fio_tls13_server_s *server) {
  return server && server->state == FIO_TLS13_SERVER_STATE_ERROR;
}

/**
 * Get current state name (for debugging).
 */
FIO_IFUNC const char *fio_tls13_server_state_name(fio_tls13_server_s *server) {
  if (!server)
    return "NULL";
  switch (server->state) {
  case FIO_TLS13_SERVER_STATE_START: return "START";
  case FIO_TLS13_SERVER_STATE_RECVD_CH: return "RECVD_CH";
  case FIO_TLS13_SERVER_STATE_NEGOTIATED: return "NEGOTIATED";
  case FIO_TLS13_SERVER_STATE_WAIT_FLIGHT2: return "WAIT_FLIGHT2";
  case FIO_TLS13_SERVER_STATE_WAIT_FINISHED: return "WAIT_FINISHED";
  case FIO_TLS13_SERVER_STATE_CONNECTED: return "CONNECTED";
  case FIO_TLS13_SERVER_STATE_ERROR: return "ERROR";
  default: return "UNKNOWN";
  }
}

/**
 * Get client's SNI hostname.
 */
FIO_IFUNC const char *fio_tls13_server_get_sni(fio_tls13_server_s *server) {
  return (server && server->client_sni_len > 0) ? server->client_sni : NULL;
}

/* *****************************************************************************
TLS 1.3 Server Implementation - Internal Helpers
***************************************************************************** */

/* Internal: Update transcript hash with handshake message */
FIO_SFUNC void fio___tls13_server_transcript_update(fio_tls13_server_s *server,
                                                    const uint8_t *data,
                                                    size_t len) {
  if (server->use_sha384)
    fio_sha512_consume(&server->transcript_sha384, data, len);
  else
    fio_sha256_consume(&server->transcript_sha256, data, len);
}

/* Internal: Get current transcript hash (non-destructive copy) */
FIO_SFUNC void fio___tls13_server_transcript_hash(fio_tls13_server_s *server,
                                                  uint8_t *out) {
  if (server->use_sha384) {
    fio_sha512_s copy = server->transcript_sha384;
    fio_u512 h = fio_sha512_finalize(&copy);
    FIO_MEMCPY(out, h.u8, 48);
  } else {
    fio_sha256_s copy = server->transcript_sha256;
    fio_u256 h = fio_sha256_finalize(&copy);
    FIO_MEMCPY(out, h.u8, 32);
  }
}

/* Internal: Get hash length for current cipher suite */
FIO_SFUNC size_t fio___tls13_server_hash_len(fio_tls13_server_s *server) {
  return server->use_sha384 ? 48 : 32;
}

/* Internal: Get key length for current cipher suite */
FIO_SFUNC size_t fio___tls13_server_key_len(fio_tls13_server_s *server) {
  switch (server->cipher_suite) {
  case FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256: return 16;
  case FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384: return 32;
  case FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256: return 32;
  default: return 16;
  }
}

/* Internal: Get cipher type for current cipher suite */
FIO_SFUNC fio_tls13_cipher_type_e
fio___tls13_server_cipher_type(fio_tls13_server_s *server) {
  switch (server->cipher_suite) {
  case FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256:
    return FIO_TLS13_CIPHER_AES_128_GCM;
  case FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384:
    return FIO_TLS13_CIPHER_AES_256_GCM;
  case FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256:
    return FIO_TLS13_CIPHER_CHACHA20_POLY1305;
  default: return FIO_TLS13_CIPHER_AES_128_GCM;
  }
}

/* Internal: Set error state with alert */
FIO_SFUNC void fio___tls13_server_set_error(fio_tls13_server_s *server,
                                            uint8_t alert_level,
                                            uint8_t alert_description) {
  server->state = FIO_TLS13_SERVER_STATE_ERROR;
  server->alert_level = alert_level;
  server->alert_description = alert_description;
}

/* *****************************************************************************
TLS 1.3 Server Implementation - ClientHello Parsing
***************************************************************************** */

/* Internal: Parse ClientHello extensions */
FIO_SFUNC int fio___tls13_parse_ch_extensions(fio_tls13_client_hello_s *ch,
                                              const uint8_t *data,
                                              size_t data_len) {
  const uint8_t *p = data;
  const uint8_t *end = data + data_len;

  while (p + 4 <= end) {
    uint16_t ext_type = fio___tls13_read_u16(p);
    p += 2;
    uint16_t ext_len = fio___tls13_read_u16(p);
    p += 2;

    if (p + ext_len > end)
      return -1;

    const uint8_t *ext_data = p;
    p += ext_len;

    switch (ext_type) {
    case FIO_TLS13_EXT_SERVER_NAME: {
      /* SNI extension */
      if (ext_len < 5)
        break;
      uint16_t list_len = fio___tls13_read_u16(ext_data);
      if (list_len + 2 > ext_len)
        break;
      const uint8_t *list = ext_data + 2;
      const uint8_t *list_end = list + list_len;
      while (list + 3 <= list_end) {
        uint8_t name_type = list[0];
        uint16_t name_len = fio___tls13_read_u16(list + 1);
        list += 3;
        if (list + name_len > list_end)
          break;
        if (name_type == 0) { /* host_name */
          ch->server_name = (const char *)list;
          ch->server_name_len = name_len;
          break;
        }
        list += name_len;
      }
      break;
    }

    case FIO_TLS13_EXT_SUPPORTED_GROUPS: {
      /* Supported groups extension */
      if (ext_len < 2)
        break;
      uint16_t groups_len = fio___tls13_read_u16(ext_data);
      if (groups_len + 2 > ext_len || groups_len % 2 != 0)
        break;
      const uint8_t *groups = ext_data + 2;
      size_t count = groups_len / 2;
      if (count > 8)
        count = 8;
      for (size_t i = 0; i < count; ++i)
        ch->supported_groups[i] = fio___tls13_read_u16(groups + i * 2);
      ch->supported_group_count = count;
      break;
    }

    case FIO_TLS13_EXT_SIGNATURE_ALGORITHMS: {
      /* Signature algorithms extension */
      if (ext_len < 2)
        break;
      uint16_t algos_len = fio___tls13_read_u16(ext_data);
      if (algos_len + 2 > ext_len || algos_len % 2 != 0)
        break;
      const uint8_t *algos = ext_data + 2;
      size_t count = algos_len / 2;
      if (count > 16)
        count = 16;
      for (size_t i = 0; i < count; ++i)
        ch->signature_algorithms[i] = fio___tls13_read_u16(algos + i * 2);
      ch->signature_algorithm_count = count;
      break;
    }

    case FIO_TLS13_EXT_SUPPORTED_VERSIONS: {
      /* Supported versions extension (client format) */
      if (ext_len < 1)
        break;
      uint8_t versions_len = ext_data[0];
      if (versions_len + 1 > ext_len || versions_len % 2 != 0)
        break;
      const uint8_t *versions = ext_data + 1;
      for (size_t i = 0; i < versions_len / 2; ++i) {
        uint16_t ver = fio___tls13_read_u16(versions + i * 2);
        if (ver == FIO_TLS13_VERSION_TLS13) {
          ch->has_supported_versions = 1;
          break;
        }
      }
      break;
    }

    case FIO_TLS13_EXT_KEY_SHARE: {
      /* Key share extension (client format) */
      if (ext_len < 2)
        break;
      uint16_t shares_len = fio___tls13_read_u16(ext_data);
      if (shares_len + 2 > ext_len)
        break;
      const uint8_t *shares = ext_data + 2;
      const uint8_t *shares_end = shares + shares_len;
      size_t offset = 0;
      while (shares + 4 <= shares_end && ch->key_share_count < 4) {
        uint16_t group = fio___tls13_read_u16(shares);
        uint16_t key_len = fio___tls13_read_u16(shares + 2);
        shares += 4;
        if (shares + key_len > shares_end)
          break;
        if (offset + key_len <= sizeof(ch->key_shares)) {
          ch->key_share_groups[ch->key_share_count] = group;
          ch->key_share_offsets[ch->key_share_count] = (uint8_t)offset;
          ch->key_share_lens[ch->key_share_count] = (uint8_t)key_len;
          FIO_MEMCPY(ch->key_shares + offset, shares, key_len);
          offset += key_len;
          ++ch->key_share_count;
        }
        shares += key_len;
      }
      ch->key_share_len = offset;
      break;
    }

    default:
      /* Ignore unknown extensions */
      break;
    }
  }

  return 0;
}

/* Internal: Parse ClientHello message */
FIO_SFUNC int fio___tls13_parse_client_hello(fio_tls13_client_hello_s *ch,
                                             const uint8_t *data,
                                             size_t data_len) {
  if (!ch || !data)
    return -1;

  FIO_MEMSET(ch, 0, sizeof(*ch));

  const uint8_t *p = data;
  const uint8_t *end = data + data_len;

  /* Minimum ClientHello: version(2) + random(32) + session_id_len(1) +
   * cipher_suites_len(2) + cipher_suite(2) + compression_len(1) +
   * compression(1) = 41 bytes */
  if (data_len < 41)
    return -1;

  /* Legacy version (should be 0x0303 for TLS 1.3) */
  uint16_t version = fio___tls13_read_u16(p);
  p += 2;
  if (version != FIO_TLS13_VERSION_TLS12)
    return -1;

  /* Random (32 bytes) */
  FIO_MEMCPY(ch->random, p, 32);
  p += 32;

  /* Legacy session ID (must be echoed in ServerHello for middlebox compat) */
  uint8_t session_id_len = *p++;
  if (p + session_id_len > end || session_id_len > 32)
    return -1;
  ch->legacy_session_id_len = session_id_len;
  if (session_id_len > 0)
    FIO_MEMCPY(ch->legacy_session_id, p, session_id_len);
  p += session_id_len;

  /* Cipher suites */
  if (p + 2 > end)
    return -1;
  uint16_t cs_len = fio___tls13_read_u16(p);
  p += 2;
  if (p + cs_len > end || cs_len % 2 != 0)
    return -1;
  size_t cs_count = cs_len / 2;
  if (cs_count > 16)
    cs_count = 16;
  for (size_t i = 0; i < cs_count; ++i)
    ch->cipher_suites[i] = fio___tls13_read_u16(p + i * 2);
  ch->cipher_suite_count = cs_count;
  p += cs_len;

  /* Legacy compression methods */
  if (p + 1 > end)
    return -1;
  uint8_t comp_len = *p++;
  if (p + comp_len > end)
    return -1;
  p += comp_len;

  /* Extensions */
  if (p + 2 > end)
    return 0; /* No extensions, but valid */

  uint16_t ext_len = fio___tls13_read_u16(p);
  p += 2;
  if (p + ext_len > end)
    return -1;

  return fio___tls13_parse_ch_extensions(ch, p, ext_len);
}

/* *****************************************************************************
TLS 1.3 Server Implementation - Negotiation
***************************************************************************** */

/* Internal: Select cipher suite from client's offer */
FIO_SFUNC int fio___tls13_server_select_cipher(
    fio_tls13_server_s *server,
    const fio_tls13_client_hello_s *ch) {
  /* Server preference order */
  static const uint16_t preferred[] = {
      FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256,
      FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256,
      FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384,
  };

  for (size_t i = 0; i < sizeof(preferred) / sizeof(preferred[0]); ++i) {
    for (size_t j = 0; j < ch->cipher_suite_count; ++j) {
      if (ch->cipher_suites[j] == preferred[i]) {
        server->cipher_suite = preferred[i];
        server->use_sha384 =
            (preferred[i] == FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384);
        return 0;
      }
    }
  }

  return -1; /* No common cipher suite */
}

/* Internal: Select key share group from client's offer */
FIO_SFUNC int fio___tls13_server_select_key_share(
    fio_tls13_server_s *server,
    const fio_tls13_client_hello_s *ch,
    const uint8_t **client_key_share,
    size_t *client_key_share_len) {
  /* We only support X25519 for now */
  for (size_t i = 0; i < ch->key_share_count; ++i) {
    if (ch->key_share_groups[i] == FIO_TLS13_GROUP_X25519 &&
        ch->key_share_lens[i] == 32) {
      server->key_share_group = FIO_TLS13_GROUP_X25519;
      *client_key_share = ch->key_shares + ch->key_share_offsets[i];
      *client_key_share_len = 32;
      return 0;
    }
  }

  return -1; /* No supported key share */
}

/* Internal: Select signature algorithm based on server's key type */
FIO_SFUNC int fio___tls13_server_select_signature(
    fio_tls13_server_s *server,
    const fio_tls13_client_hello_s *ch) {
  /* Check if client supports our key type */
  for (size_t i = 0; i < ch->signature_algorithm_count; ++i) {
    if (ch->signature_algorithms[i] == server->private_key_type) {
      server->signature_scheme = server->private_key_type;
      return 0;
    }
  }

  return -1; /* Client doesn't support our signature algorithm */
}

/* *****************************************************************************
TLS 1.3 Server Implementation - Message Building
***************************************************************************** */

/* Internal: Build ServerHello message */
FIO_SFUNC int fio___tls13_build_server_hello(fio_tls13_server_s *server,
                                             uint8_t *out,
                                             size_t out_capacity) {
  if (out_capacity < 256)
    return -1;

  uint8_t *p = out + 4; /* Skip handshake header */
  uint8_t *start = p;

  /* Legacy version: TLS 1.2 (0x0303) */
  fio___tls13_write_u16(p, FIO_TLS13_VERSION_TLS12);
  p += 2;

  /* Server random (32 bytes) */
  FIO_MEMCPY(p, server->server_random, 32);
  p += 32;

  /* Legacy session ID (echo client's for middlebox compatibility) */
  *p++ = server->legacy_session_id_len;
  if (server->legacy_session_id_len > 0) {
    FIO_MEMCPY(p, server->legacy_session_id, server->legacy_session_id_len);
    p += server->legacy_session_id_len;
  }

  /* Cipher suite */
  fio___tls13_write_u16(p, server->cipher_suite);
  p += 2;

  /* Legacy compression method: null */
  *p++ = 0;

  /* Extensions */
  uint8_t *ext_len_ptr = p;
  p += 2;
  uint8_t *ext_start = p;

  /* supported_versions extension (required for TLS 1.3) */
  fio___tls13_write_u16(p, FIO_TLS13_EXT_SUPPORTED_VERSIONS);
  p += 2;
  fio___tls13_write_u16(p, 2); /* Extension length */
  p += 2;
  fio___tls13_write_u16(p, FIO_TLS13_VERSION_TLS13);
  p += 2;

  /* key_share extension */
  fio___tls13_write_u16(p, FIO_TLS13_EXT_KEY_SHARE);
  p += 2;
  fio___tls13_write_u16(p,
                        36); /* Extension length: group(2) + len(2) + key(32) */
  p += 2;
  fio___tls13_write_u16(p, server->key_share_group);
  p += 2;
  fio___tls13_write_u16(p, 32); /* X25519 key length */
  p += 2;
  FIO_MEMCPY(p, server->x25519_public_key, 32);
  p += 32;

  /* Write extensions length */
  fio___tls13_write_u16(ext_len_ptr, (uint16_t)(p - ext_start));

  /* Write handshake header */
  size_t body_len = (size_t)(p - start);
  fio_tls13_write_handshake_header(out, FIO_TLS13_HS_SERVER_HELLO, body_len);

  return (int)(4 + body_len);
}

/* Internal: Build EncryptedExtensions message */
FIO_SFUNC int fio___tls13_build_encrypted_extensions(fio_tls13_server_s *server,
                                                     uint8_t *out,
                                                     size_t out_capacity) {
  if (out_capacity < 8)
    return -1;

  /* Empty extensions for now */
  out[0] = FIO_TLS13_HS_ENCRYPTED_EXTENSIONS;
  out[1] = 0;
  out[2] = 0;
  out[3] = 2; /* Body length: 2 bytes for empty extensions list */
  out[4] = 0;
  out[5] = 0; /* Extensions length: 0 */

  (void)server;
  return 6;
}

/* Internal: Build Certificate message */
FIO_SFUNC int fio___tls13_build_certificate(fio_tls13_server_s *server,
                                            uint8_t *out,
                                            size_t out_capacity) {
  if (!server->cert_chain || server->cert_chain_count == 0)
    return -1;

  /* Calculate total size needed */
  size_t total_cert_size = 0;
  for (size_t i = 0; i < server->cert_chain_count; ++i)
    total_cert_size +=
        3 + server->cert_chain_lens[i] + 2; /* len(3) + cert + ext_len(2) */

  size_t body_len =
      1 + 3 + total_cert_size; /* ctx_len(1) + list_len(3) + certs */
  if (out_capacity < 4 + body_len)
    return -1;

  uint8_t *p = out;

  /* Handshake header */
  fio_tls13_write_handshake_header(p, FIO_TLS13_HS_CERTIFICATE, body_len);
  p += 4;

  /* Certificate request context (empty for server) */
  *p++ = 0;

  /* Certificate list length */
  fio___tls13_write_u24(p, (uint32_t)total_cert_size);
  p += 3;

  /* Certificate entries */
  for (size_t i = 0; i < server->cert_chain_count; ++i) {
    /* Certificate data length */
    fio___tls13_write_u24(p, (uint32_t)server->cert_chain_lens[i]);
    p += 3;

    /* Certificate data */
    FIO_MEMCPY(p, server->cert_chain[i], server->cert_chain_lens[i]);
    p += server->cert_chain_lens[i];

    /* Extensions (empty) */
    *p++ = 0;
    *p++ = 0;
  }

  return (int)(4 + body_len);
}

/* Internal: Build CertificateVerify message */
FIO_SFUNC int fio___tls13_build_certificate_verify(fio_tls13_server_s *server,
                                                   uint8_t *out,
                                                   size_t out_capacity) {
  if (!server->private_key || server->private_key_len == 0)
    return -1;

  /* Build signed content per RFC 8446 Section 4.4.3 */
  static const char context_server[] = "TLS 1.3, server CertificateVerify";
  const size_t context_len = sizeof(context_server) - 1;
  size_t hash_len = fio___tls13_server_hash_len(server);

  uint8_t signed_content[64 + 33 + 1 + FIO_TLS13_MAX_HASH_LEN];
  size_t signed_content_len = 64 + context_len + 1 + hash_len;

  /* 64 spaces */
  FIO_MEMSET(signed_content, 0x20, 64);
  /* Context string */
  FIO_MEMCPY(signed_content + 64, context_server, context_len);
  /* Zero byte separator */
  signed_content[64 + context_len] = 0x00;
  /* Transcript hash */
  fio___tls13_server_transcript_hash(server,
                                     signed_content + 64 + context_len + 1);

  /* Sign based on key type */
  uint8_t signature[512];
  size_t sig_len = 0;

  switch (server->private_key_type) {
  case FIO_TLS13_SIG_ED25519: {
    if (server->private_key_len != 32)
      return -1;
    /* Ed25519 signs directly over the content */
    uint8_t ed_public_key[32];
    fio_ed25519_public_key(ed_public_key, server->private_key);
    fio_ed25519_sign(signature,
                     signed_content,
                     signed_content_len,
                     server->private_key,
                     ed_public_key);
    sig_len = 64;
    break;
  }
  case FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256: {
    if (server->private_key_len != 32)
      return -1;
    /* P-256 ECDSA: hash the signed content with SHA-256, then sign */
    fio_u256 msg_hash = fio_sha256(signed_content, signed_content_len);
    if (fio_ecdsa_p256_sign(signature,
                            &sig_len,
                            sizeof(signature),
                            msg_hash.u8,
                            server->private_key) != 0)
      return -1;
    break;
  }
  default:
    /* Unsupported signature algorithm */
    return -1;
  }

  /* Build CertificateVerify message */
  size_t body_len = 2 + 2 + sig_len; /* scheme(2) + sig_len(2) + sig */
  if (out_capacity < 4 + body_len)
    return -1;

  uint8_t *p = out;

  /* Handshake header */
  fio_tls13_write_handshake_header(p,
                                   FIO_TLS13_HS_CERTIFICATE_VERIFY,
                                   body_len);
  p += 4;

  /* Signature algorithm */
  fio___tls13_write_u16(p, server->signature_scheme);
  p += 2;

  /* Signature length */
  fio___tls13_write_u16(p, (uint16_t)sig_len);
  p += 2;

  /* Signature */
  FIO_MEMCPY(p, signature, sig_len);

  FIO_LOG_DDEBUG("TLS 1.3 Server: CertificateVerify scheme=0x%04x sig_len=%zu",
                 server->signature_scheme,
                 sig_len);

  return (int)(4 + body_len);
}

/* Internal: Build server Finished message */
FIO_SFUNC int fio___tls13_build_server_finished(fio_tls13_server_s *server,
                                                uint8_t *out,
                                                size_t out_capacity) {
  int use_sha384 = server->use_sha384;
  size_t hash_len = fio___tls13_server_hash_len(server);

  if (out_capacity < 4 + hash_len)
    return -1;

  /* Get transcript hash */
  uint8_t transcript_hash[48];
  fio___tls13_server_transcript_hash(server, transcript_hash);

  /* Derive finished key from server handshake traffic secret */
  uint8_t finished_key[48];
  fio_tls13_derive_finished_key(finished_key,
                                server->server_handshake_traffic_secret,
                                use_sha384);

  /* Compute verify_data */
  uint8_t verify_data[48];
  fio_tls13_compute_finished(verify_data,
                             finished_key,
                             transcript_hash,
                             use_sha384);

  /* Build Finished message */
  int len = fio_tls13_build_finished(out, out_capacity, verify_data, hash_len);

  /* Clear sensitive data */
  fio_secure_zero(finished_key, sizeof(finished_key));

  return len;
}

/* *****************************************************************************
TLS 1.3 Server Implementation - Key Derivation
***************************************************************************** */

/* Internal: Derive handshake keys after ServerHello */
FIO_SFUNC int fio___tls13_server_derive_handshake_keys(
    fio_tls13_server_s *server) {
  int use_sha384 = server->use_sha384;
  size_t hash_len = fio___tls13_server_hash_len(server);
  size_t key_len = fio___tls13_server_key_len(server);
  fio_tls13_cipher_type_e cipher_type = fio___tls13_server_cipher_type(server);

  /* Get transcript hash at ServerHello */
  uint8_t transcript_hash[48];
  fio___tls13_server_transcript_hash(server, transcript_hash);

  /* Derive early secret (no PSK) */
  fio_tls13_derive_early_secret(server->early_secret, NULL, 0, use_sha384);

  /* Derive handshake secret */
  fio_tls13_derive_handshake_secret(server->handshake_secret,
                                    server->early_secret,
                                    server->shared_secret,
                                    32, /* X25519 shared secret is 32 bytes */
                                    use_sha384);

  /* Derive client handshake traffic secret */
  fio_tls13_derive_secret(server->client_handshake_traffic_secret,
                          server->handshake_secret,
                          hash_len,
                          "c hs traffic",
                          12,
                          transcript_hash,
                          hash_len,
                          use_sha384);

  /* Derive server handshake traffic secret */
  fio_tls13_derive_secret(server->server_handshake_traffic_secret,
                          server->handshake_secret,
                          hash_len,
                          "s hs traffic",
                          12,
                          transcript_hash,
                          hash_len,
                          use_sha384);

  /* Derive client handshake keys */
  uint8_t key[32], iv[12];
  fio_tls13_derive_traffic_keys(key,
                                key_len,
                                iv,
                                server->client_handshake_traffic_secret,
                                use_sha384);
  fio_tls13_record_keys_init(&server->client_handshake_keys,
                             key,
                             (uint8_t)key_len,
                             iv,
                             cipher_type);

  /* Derive server handshake keys */
  fio_tls13_derive_traffic_keys(key,
                                key_len,
                                iv,
                                server->server_handshake_traffic_secret,
                                use_sha384);
  fio_tls13_record_keys_init(&server->server_handshake_keys,
                             key,
                             (uint8_t)key_len,
                             iv,
                             cipher_type);

  /* Clear temporary key material */
  fio_secure_zero(key, sizeof(key));
  fio_secure_zero(iv, sizeof(iv));

  return 0;
}

/* Internal: Derive application keys after server Finished */
FIO_SFUNC int fio___tls13_server_derive_app_keys(fio_tls13_server_s *server) {
  int use_sha384 = server->use_sha384;
  size_t hash_len = fio___tls13_server_hash_len(server);
  size_t key_len = fio___tls13_server_key_len(server);
  fio_tls13_cipher_type_e cipher_type = fio___tls13_server_cipher_type(server);

  /* Get transcript hash at server Finished */
  uint8_t transcript_hash[48];
  fio___tls13_server_transcript_hash(server, transcript_hash);

  /* Derive master secret */
  fio_tls13_derive_master_secret(server->master_secret,
                                 server->handshake_secret,
                                 use_sha384);

  /* Derive client application traffic secret */
  fio_tls13_derive_secret(server->client_app_traffic_secret,
                          server->master_secret,
                          hash_len,
                          "c ap traffic",
                          12,
                          transcript_hash,
                          hash_len,
                          use_sha384);

  /* Derive server application traffic secret */
  fio_tls13_derive_secret(server->server_app_traffic_secret,
                          server->master_secret,
                          hash_len,
                          "s ap traffic",
                          12,
                          transcript_hash,
                          hash_len,
                          use_sha384);

  /* Derive client application keys */
  uint8_t key[32], iv[12];
  fio_tls13_derive_traffic_keys(key,
                                key_len,
                                iv,
                                server->client_app_traffic_secret,
                                use_sha384);
  fio_tls13_record_keys_init(&server->client_app_keys,
                             key,
                             (uint8_t)key_len,
                             iv,
                             cipher_type);

  /* Derive server application keys */
  fio_tls13_derive_traffic_keys(key,
                                key_len,
                                iv,
                                server->server_app_traffic_secret,
                                use_sha384);
  fio_tls13_record_keys_init(&server->server_app_keys,
                             key,
                             (uint8_t)key_len,
                             iv,
                             cipher_type);

  /* Clear temporary key material */
  fio_secure_zero(key, sizeof(key));
  fio_secure_zero(iv, sizeof(iv));

  return 0;
}

/* *****************************************************************************
TLS 1.3 Server Implementation - Handshake Processing
***************************************************************************** */

/* Internal: Verify client Finished message */
FIO_SFUNC int fio___tls13_server_verify_client_finished(
    fio_tls13_server_s *server,
    const uint8_t *verify_data,
    size_t verify_data_len) {
  int use_sha384 = server->use_sha384;
  size_t hash_len = fio___tls13_server_hash_len(server);

  if (verify_data_len != hash_len)
    return -1;

  /* Get transcript hash (before Finished message) */
  uint8_t transcript_hash[48];
  fio___tls13_server_transcript_hash(server, transcript_hash);

  /* Derive finished key from client handshake traffic secret */
  uint8_t finished_key[48];
  fio_tls13_derive_finished_key(finished_key,
                                server->client_handshake_traffic_secret,
                                use_sha384);

  /* Compute expected verify_data */
  uint8_t expected[48];
  fio_tls13_compute_finished(expected,
                             finished_key,
                             transcript_hash,
                             use_sha384);

  /* Constant-time comparison */
  uint8_t diff = 0;
  for (size_t i = 0; i < hash_len; ++i)
    diff |= verify_data[i] ^ expected[i];

  /* Clear sensitive data */
  fio_secure_zero(finished_key, sizeof(finished_key));
  fio_secure_zero(expected, sizeof(expected));

  return diff ? -1 : 0;
}

/* Internal: Process ClientHello and generate server flight */
FIO_SFUNC int fio___tls13_server_process_client_hello(
    fio_tls13_server_s *server,
    const uint8_t *ch_msg,
    size_t ch_msg_len,
    uint8_t *out,
    size_t out_capacity,
    size_t *out_len) {
  /* Parse ClientHello */
  fio_tls13_client_hello_s ch;
  if (fio___tls13_parse_client_hello(&ch, ch_msg + 4, ch_msg_len - 4) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: ClientHello parse failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_DECODE_ERROR);
    return -1;
  }

  FIO_LOG_DDEBUG("TLS 1.3 Server: ClientHello ciphers=%zu sigs=%zu keys=%zu",
                 ch.cipher_suite_count,
                 ch.signature_algorithm_count,
                 ch.key_share_count);

  /* Verify TLS 1.3 is supported */
  if (!ch.has_supported_versions) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: client does not support TLS 1.3");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_PROTOCOL_VERSION);
    return -1;
  }

  /* Store SNI */
  if (ch.server_name && ch.server_name_len > 0) {
    size_t copy_len = ch.server_name_len;
    if (copy_len >= sizeof(server->client_sni))
      copy_len = sizeof(server->client_sni) - 1;
    FIO_MEMCPY(server->client_sni, ch.server_name, copy_len);
    server->client_sni[copy_len] = '\0';
    server->client_sni_len = copy_len;
  }

  /* Store legacy session ID (must echo in ServerHello for middlebox compat) */
  server->legacy_session_id_len = ch.legacy_session_id_len;
  if (ch.legacy_session_id_len > 0) {
    FIO_MEMCPY(server->legacy_session_id,
               ch.legacy_session_id,
               ch.legacy_session_id_len);
  }

  /* Select cipher suite */
  if (fio___tls13_server_select_cipher(server, &ch) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: no common cipher suite");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_HANDSHAKE_FAILURE);
    return -1;
  }

  /* Select key share */
  const uint8_t *client_key_share;
  size_t client_key_share_len;
  if (fio___tls13_server_select_key_share(server,
                                          &ch,
                                          &client_key_share,
                                          &client_key_share_len) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: no common key share group");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_HANDSHAKE_FAILURE);
    return -1;
  }

  /* Select signature algorithm */
  if (fio___tls13_server_select_signature(server, &ch) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: sig algorithm mismatch (key=0x%04x)",
                   server->private_key_type);
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_HANDSHAKE_FAILURE);
    return -1;
  }

  /* Generate server random and X25519 keypair */
  fio_rand_bytes(server->server_random, 32);
  fio_x25519_keypair(server->x25519_private_key, server->x25519_public_key);

  /* Compute shared secret */
  if (fio_x25519_shared_secret(server->shared_secret,
                               server->x25519_private_key,
                               client_key_share) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: ECDHE shared secret failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_ILLEGAL_PARAMETER);
    return -1;
  }

  /* Update transcript with ClientHello */
  fio___tls13_server_transcript_update(server, ch_msg, ch_msg_len);

  /* Build ServerHello */
  uint8_t sh_msg[256];
  int sh_len = fio___tls13_build_server_hello(server, sh_msg, sizeof(sh_msg));
  if (sh_len < 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: ServerHello build failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_INTERNAL_ERROR);
    return -1;
  }

  /* Update transcript with ServerHello */
  fio___tls13_server_transcript_update(server, sh_msg, (size_t)sh_len);

  /* Derive handshake keys */
  if (fio___tls13_server_derive_handshake_keys(server) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: handshake key derivation failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_INTERNAL_ERROR);
    return -1;
  }

  /* Build encrypted handshake messages */
  uint8_t hs_msgs[4096];
  size_t hs_msgs_len = 0;

  /* EncryptedExtensions */
  int ee_len =
      fio___tls13_build_encrypted_extensions(server,
                                             hs_msgs + hs_msgs_len,
                                             sizeof(hs_msgs) - hs_msgs_len);
  if (ee_len < 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: EncryptedExtensions build failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_INTERNAL_ERROR);
    return -1;
  }
  fio___tls13_server_transcript_update(server,
                                       hs_msgs + hs_msgs_len,
                                       (size_t)ee_len);
  hs_msgs_len += (size_t)ee_len;

  /* Certificate */
  int cert_len = fio___tls13_build_certificate(server,
                                               hs_msgs + hs_msgs_len,
                                               sizeof(hs_msgs) - hs_msgs_len);
  if (cert_len < 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: Certificate build failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_INTERNAL_ERROR);
    return -1;
  }
  fio___tls13_server_transcript_update(server,
                                       hs_msgs + hs_msgs_len,
                                       (size_t)cert_len);
  hs_msgs_len += (size_t)cert_len;

  /* CertificateVerify */
  int cv_len =
      fio___tls13_build_certificate_verify(server,
                                           hs_msgs + hs_msgs_len,
                                           sizeof(hs_msgs) - hs_msgs_len);
  if (cv_len < 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: CertificateVerify build failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_INTERNAL_ERROR);
    return -1;
  }
  fio___tls13_server_transcript_update(server,
                                       hs_msgs + hs_msgs_len,
                                       (size_t)cv_len);
  hs_msgs_len += (size_t)cv_len;

  /* Server Finished */
  int fin_len =
      fio___tls13_build_server_finished(server,
                                        hs_msgs + hs_msgs_len,
                                        sizeof(hs_msgs) - hs_msgs_len);
  if (fin_len < 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: Finished build failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_INTERNAL_ERROR);
    return -1;
  }
  fio___tls13_server_transcript_update(server,
                                       hs_msgs + hs_msgs_len,
                                       (size_t)fin_len);
  hs_msgs_len += (size_t)fin_len;

  /* Derive application keys (after server Finished is in transcript) */
  if (fio___tls13_server_derive_app_keys(server) != 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: app key derivation failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_INTERNAL_ERROR);
    return -1;
  }

  /* Build output: ServerHello record + CCS + encrypted handshake record */
  size_t offset = 0;

  /* ServerHello record (plaintext) */
  if (offset + 5 + (size_t)sh_len > out_capacity)
    return -1;
  fio___tls13_write_record_header(out + offset,
                                  FIO_TLS13_CONTENT_HANDSHAKE,
                                  (uint16_t)sh_len);
  offset += 5;
  FIO_MEMCPY(out + offset, sh_msg, (size_t)sh_len);
  offset += (size_t)sh_len;

  /* Change Cipher Spec (for middlebox compatibility, RFC 8446 Section 5) */
  if (offset + 6 > out_capacity)
    return -1;
  out[offset++] = FIO_TLS13_CONTENT_CHANGE_CIPHER_SPEC;
  out[offset++] = 0x03;
  out[offset++] = 0x03; /* Legacy version TLS 1.2 */
  out[offset++] = 0x00;
  out[offset++] = 0x01; /* Length: 1 byte */
  out[offset++] = 0x01; /* CCS message: 1 */

  /* Encrypted handshake messages */
  int enc_len = fio_tls13_record_encrypt(out + offset,
                                         out_capacity - offset,
                                         hs_msgs,
                                         hs_msgs_len,
                                         FIO_TLS13_CONTENT_HANDSHAKE,
                                         &server->server_handshake_keys);
  if (enc_len < 0) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: handshake encryption failed");
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_INTERNAL_ERROR);
    return -1;
  }
  offset += (size_t)enc_len;

  *out_len = offset;
  server->encrypted_read = 1;
  server->encrypted_write = 1;
  server->state = FIO_TLS13_SERVER_STATE_WAIT_FINISHED;

  return 0;
}

/* Internal: Process client Finished message */
FIO_SFUNC int fio___tls13_server_process_client_finished(
    fio_tls13_server_s *server,
    const uint8_t *fin_msg,
    size_t fin_msg_len) {
  /* Parse Finished message */
  fio_tls13_handshake_type_e msg_type;
  size_t body_len;
  const uint8_t *body = fio_tls13_parse_handshake_header(fin_msg,
                                                         fin_msg_len,
                                                         &msg_type,
                                                         &body_len);

  if (!body || msg_type != FIO_TLS13_HS_FINISHED) {
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
    return -1;
  }

  /* Verify client Finished */
  if (fio___tls13_server_verify_client_finished(server, body, body_len) != 0) {
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_DECRYPT_ERROR);
    return -1;
  }

  /* Update transcript with client Finished */
  fio___tls13_server_transcript_update(server, fin_msg, fin_msg_len);

  server->state = FIO_TLS13_SERVER_STATE_CONNECTED;
  return 0;
}

/* *****************************************************************************
TLS 1.3 Server Public API Implementation
***************************************************************************** */

SFUNC void fio_tls13_server_init(fio_tls13_server_s *server) {
  if (!server)
    return;

  FIO_MEMSET(server, 0, sizeof(*server));
  server->state = FIO_TLS13_SERVER_STATE_START;

  /* Initialize transcript hashes */
  server->transcript_sha256 = fio_sha256_init();
  server->transcript_sha384 = fio_sha512_init();

  /* Default to Ed25519 if no key type set */
  server->private_key_type = FIO_TLS13_SIG_ED25519;
}

SFUNC void fio_tls13_server_destroy(fio_tls13_server_s *server) {
  if (!server)
    return;

  /* Clear all sensitive data */
  fio_secure_zero(server->x25519_private_key, 32);
  fio_secure_zero(server->shared_secret, 32);
  fio_secure_zero(server->early_secret, 48);
  fio_secure_zero(server->handshake_secret, 48);
  fio_secure_zero(server->master_secret, 48);
  fio_secure_zero(server->client_handshake_traffic_secret, 48);
  fio_secure_zero(server->server_handshake_traffic_secret, 48);
  fio_secure_zero(server->client_app_traffic_secret, 48);
  fio_secure_zero(server->server_app_traffic_secret, 48);

  fio_tls13_record_keys_clear(&server->client_handshake_keys);
  fio_tls13_record_keys_clear(&server->server_handshake_keys);
  fio_tls13_record_keys_clear(&server->client_app_keys);
  fio_tls13_record_keys_clear(&server->server_app_keys);

  FIO_MEMSET(server, 0, sizeof(*server));
}

SFUNC void fio_tls13_server_set_cert_chain(fio_tls13_server_s *server,
                                           const uint8_t **certs,
                                           const size_t *cert_lens,
                                           size_t cert_count) {
  if (!server)
    return;
  server->cert_chain = certs;
  server->cert_chain_lens = cert_lens;
  server->cert_chain_count = cert_count;
}

SFUNC void fio_tls13_server_set_private_key(fio_tls13_server_s *server,
                                            const uint8_t *private_key,
                                            size_t key_len,
                                            uint16_t key_type) {
  if (!server)
    return;
  server->private_key = private_key;
  server->private_key_len = key_len;
  server->private_key_type = key_type;
}

SFUNC int fio_tls13_server_process(fio_tls13_server_s *server,
                                   const uint8_t *in,
                                   size_t in_len,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   size_t *out_len) {
  if (!server || !in || !out || !out_len)
    return -1;

  if (server->state == FIO_TLS13_SERVER_STATE_ERROR ||
      server->state == FIO_TLS13_SERVER_STATE_CONNECTED)
    return -1;

  *out_len = 0;

  /* Parse record header */
  fio_tls13_content_type_e content_type;
  size_t payload_len;
  const uint8_t *payload =
      fio_tls13_record_parse_header(in, in_len, &content_type, &payload_len);

  if (!payload)
    return 0; /* Need more data */

  size_t record_len = FIO_TLS13_RECORD_HEADER_LEN + payload_len;

  /* Handle Change Cipher Spec (ignore in TLS 1.3) */
  if (content_type == FIO_TLS13_CONTENT_CHANGE_CIPHER_SPEC)
    return (int)record_len;

  /* Process based on state */
  switch (server->state) {
  case FIO_TLS13_SERVER_STATE_START: {
    /* Expecting ClientHello */
    if (content_type != FIO_TLS13_CONTENT_HANDSHAKE) {
      fio___tls13_server_set_error(server,
                                   FIO_TLS13_ALERT_LEVEL_FATAL,
                                   FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }

    /* Parse handshake header */
    fio_tls13_handshake_type_e msg_type;
    size_t body_len;
    const uint8_t *body = fio_tls13_parse_handshake_header(payload,
                                                           payload_len,
                                                           &msg_type,
                                                           &body_len);

    if (!body || msg_type != FIO_TLS13_HS_CLIENT_HELLO) {
      fio___tls13_server_set_error(server,
                                   FIO_TLS13_ALERT_LEVEL_FATAL,
                                   FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }

    /* Process ClientHello and generate server flight */
    if (fio___tls13_server_process_client_hello(server,
                                                payload,
                                                payload_len,
                                                out,
                                                out_capacity,
                                                out_len) != 0) {
      return -1;
    }
    FIO_LOG_DEBUG2("TLS 1.3 Server: ClientHello processed, sent ServerHello");
    break;
  }

  case FIO_TLS13_SERVER_STATE_WAIT_FINISHED: {
    /* Expecting encrypted client Finished */
    if (content_type != FIO_TLS13_CONTENT_APPLICATION_DATA) {
      fio___tls13_server_set_error(server,
                                   FIO_TLS13_ALERT_LEVEL_FATAL,
                                   FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }

    /* Decrypt */
    uint8_t decrypted[FIO_TLS13_MAX_PLAINTEXT_LEN + 256];
    fio_tls13_content_type_e inner_type;
    int dec_len = fio_tls13_record_decrypt(decrypted,
                                           sizeof(decrypted),
                                           &inner_type,
                                           in,
                                           record_len,
                                           &server->client_handshake_keys);
    if (dec_len < 0) {
      FIO_LOG_DEBUG2("TLS 1.3 Server: client Finished decryption failed");
      fio___tls13_server_set_error(server,
                                   FIO_TLS13_ALERT_LEVEL_FATAL,
                                   FIO_TLS13_ALERT_BAD_RECORD_MAC);
      return -1;
    }

    if (inner_type == FIO_TLS13_CONTENT_ALERT && dec_len >= 2) {
      FIO_LOG_DEBUG2("TLS 1.3 Server: alert level=%d desc=%d",
                     decrypted[0],
                     decrypted[1]);
      fio___tls13_server_set_error(server,
                                   FIO_TLS13_ALERT_LEVEL_FATAL,
                                   decrypted[1]);
      return -1;
    }
    if (inner_type != FIO_TLS13_CONTENT_HANDSHAKE) {
      fio___tls13_server_set_error(server,
                                   FIO_TLS13_ALERT_LEVEL_FATAL,
                                   FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
      return -1;
    }

    /* Process client Finished */
    if (fio___tls13_server_process_client_finished(server,
                                                   decrypted,
                                                   (size_t)dec_len) != 0) {
      return -1;
    }
    FIO_LOG_DEBUG2("TLS 1.3 Server: handshake complete");
    break;
  }

  default:
    fio___tls13_server_set_error(server,
                                 FIO_TLS13_ALERT_LEVEL_FATAL,
                                 FIO_TLS13_ALERT_UNEXPECTED_MESSAGE);
    return -1;
  }

  return (int)record_len;
}

SFUNC int fio_tls13_server_encrypt(fio_tls13_server_s *server,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *plaintext,
                                   size_t plaintext_len) {
  if (!server || !out)
    return -1;

  if (server->state != FIO_TLS13_SERVER_STATE_CONNECTED)
    return -1;

  return fio_tls13_record_encrypt(out,
                                  out_capacity,
                                  plaintext,
                                  plaintext_len,
                                  FIO_TLS13_CONTENT_APPLICATION_DATA,
                                  &server->server_app_keys);
}

SFUNC int fio_tls13_server_decrypt(fio_tls13_server_s *server,
                                   uint8_t *out,
                                   size_t out_capacity,
                                   const uint8_t *ciphertext,
                                   size_t ciphertext_len) {
  if (!server || !out || !ciphertext)
    return -1;

  if (server->state != FIO_TLS13_SERVER_STATE_CONNECTED)
    return -1;

  fio_tls13_content_type_e content_type;
  int dec_len = fio_tls13_record_decrypt(out,
                                         out_capacity,
                                         &content_type,
                                         ciphertext,
                                         ciphertext_len,
                                         &server->client_app_keys);

  if (dec_len < 0)
    return -1;

  /* Handle post-handshake messages */
  if (content_type == FIO_TLS13_CONTENT_HANDSHAKE) {
    FIO_LOG_DEBUG2("TLS 1.3 Server: Received post-handshake message (ignored)");
    return 0;
  }

  /* Handle alerts */
  if (content_type == FIO_TLS13_CONTENT_ALERT) {
    if (dec_len >= 2) {
      uint8_t level = out[0];
      uint8_t desc = out[1];
      FIO_LOG_DEBUG2("TLS 1.3 Server: Received alert: level=%d, desc=%d",
                     level,
                     desc);
      /* close_notify (0) is a graceful shutdown, return 0 (EOF) */
      if (desc == 0)
        return 0;
    }
    return -1;
  }

  /* Only return application data */
  if (content_type != FIO_TLS13_CONTENT_APPLICATION_DATA)
    return -1;

  return dec_len;
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_TLS13 */
#undef FIO_TLS13
/* ************************************************************************** */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_STR_NAME fio       /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                        Dynamic Strings (binary safe)



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#ifdef FIO_STR_SMALL
#ifndef FIO_STR_NAME
#define FIO_STR_NAME FIO_STR_SMALL
#endif
#ifndef FIO_STR_OPTIMIZE4IMMUTABILITY
#define FIO_STR_OPTIMIZE4IMMUTABILITY 1
#endif
#endif /* FIO_STR_SMALL */

#if defined(FIO_STR_NAME)

#ifndef FIO_STR_OPTIMIZE_EMBEDDED
/**
 * For each unit (0 by default), adds `sizeof(char *)` bytes to the type size,
 * increasing the amount of strings that could be embedded within the type
 * without additional memory allocation.
 *
 * For example, when using a reference counter wrapper on a 64bit system, it
 * would make sense to set this value to 1 - allowing the type size to fully
 * utilize a 16 byte memory allocation alignment.
 */
#define FIO_STR_OPTIMIZE_EMBEDDED 0
#endif

#ifndef FIO_STR_OPTIMIZE4IMMUTABILITY
/**
 * Minimizes the struct size, storing only string length and pointer.
 *
 * By avoiding extra (mutable related) data, such as the allocated memory's
 * capacity, strings require less memory. However, this does introduce a
 * performance penalty when editing the string data.
 */
#define FIO_STR_OPTIMIZE4IMMUTABILITY 0
#endif

#if FIO_STR_OPTIMIZE4IMMUTABILITY
/* enforce limit after which FIO_STR_OPTIMIZE4IMMUTABILITY makes no sense */
#if FIO_STR_OPTIMIZE_EMBEDDED > 1
#undef FIO_STR_OPTIMIZE_EMBEDDED
#define FIO_STR_OPTIMIZE_EMBEDDED 1
#endif
#else
/* enforce limit due to 6 bit embedded string length limit (assumes 64 bit) */
#if FIO_STR_OPTIMIZE_EMBEDDED > 4
#undef FIO_STR_OPTIMIZE_EMBEDDED
#define FIO_STR_OPTIMIZE_EMBEDDED 4
#endif
#endif /* FIO_STR_OPTIMIZE4IMMUTABILITY*/

/* *****************************************************************************
String API - Initialization and Destruction
***************************************************************************** */

/**
 * The `fio_str_s` type should be considered opaque.
 *
 * The type's attributes should be accessed ONLY through the accessor
 * functions: `fio_str2cstr`, `fio_str_len`, `fio_str2ptr`, `fio_str_capa`,
 * etc'.
 *
 * Note: when the `small` flag is present, the structure is ignored and used
 * as raw memory for a small String (no additional allocation). This changes
 * the String's behavior drastically and requires that the accessor functions
 * be used.
 */
typedef struct {
  /* String flags:
   *
   * bit 1: small string.
   * bit 2: frozen string.
   * bit 3: static (non allocated) string (big strings only).
   * bit 3-8: small string length (up to 64 bytes).
   */
  uint8_t special;
  uint8_t reserved[(sizeof(void *) * (1 + FIO_STR_OPTIMIZE_EMBEDDED)) -
                   (sizeof(uint8_t))]; /* padding length */
#if !FIO_STR_OPTIMIZE4IMMUTABILITY
  size_t capa; /* known capacity for longer Strings */
  size_t len;  /* String length for longer Strings */
#endif         /* FIO_STR_OPTIMIZE4IMMUTABILITY */
  char *buf;   /* pointer for longer Strings */
} FIO_NAME(FIO_STR_NAME, s);

#ifdef FIO_PTR_TAG_TYPE
#define FIO_STR_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_STR_PTR FIO_NAME(FIO_STR_NAME, s) *
#endif

#ifndef FIO_STR_INIT
/**
 * This value should be used for initialization. For example:
 *
 *      // on the stack
 *      fio_str_s str = FIO_STR_INIT;
 *
 *      // or on the heap
 *      fio_str_s *str = malloc(sizeof(*str));
 *      *str = FIO_STR_INIT;
 *
 * Remember to cleanup:
 *
 *      // on the stack
 *      fio_str_destroy(&str);
 *
 *      // or on the heap
 *      fio_str_free(str);
 *      free(str);
 */
#define FIO_STR_INIT                                                           \
  { .special = 0 }

/**
 * This macro allows the container to be initialized with existing data, as long
 * as it's memory was allocated with the same allocator (`malloc` /
 * `fio_malloc`).
 *
 * The `capacity` value should exclude the NUL character (if exists).
 *
 * NOTE: This macro isn't valid for FIO_STR_SMALL (or strings with the
 * FIO_STR_OPTIMIZE4IMMUTABILITY optimization)
 */
#define FIO_STR_INIT_EXISTING(buffer, length, capacity)                        \
  { .capa = (capacity), .len = (length), .buf = (buffer) }

/**
 * This macro allows the container to be initialized with existing static data,
 * that shouldn't be freed.
 *
 * NOTE: This macro isn't valid for FIO_STR_SMALL (or strings with the
 * FIO_STR_OPTIMIZE4IMMUTABILITY optimization)
 */
#define FIO_STR_INIT_STATIC(buffer)                                            \
  {                                                                            \
    .special = 4, .capa = FIO_STRLEN((buffer)), .len = FIO_STRLEN((buffer)),   \
    .buf = (char *)(buffer)                                                    \
  }

/**
 * This macro allows the container to be initialized with existing static data,
 * that shouldn't be freed.
 *
 * NOTE: This macro isn't valid for FIO_STR_SMALL (or strings with the
 * FIO_STR_OPTIMIZE4IMMUTABILITY optimization)
 */
#define FIO_STR_INIT_STATIC2(buffer, length)                                   \
  { .special = 4, .capa = (length), .len = (length), .buf = (char *)(buffer) }

#endif /* FIO_STR_INIT */

#ifndef FIO_REF_CONSTRUCTOR_ONLY
/** Allocates a new String object on the heap. */
FIO_IFUNC FIO_STR_PTR FIO_NAME(FIO_STR_NAME, new)(void);

/**
 * Destroys the string and frees the container (if allocated with `new`).
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, free)(FIO_STR_PTR s);
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/**
 * Initializes the container with the provided static / constant string.
 *
 * The string will be copied to the container **only** if it will fit in the
 * container itself. Otherwise, the supplied pointer will be used as is and it
 * should remain valid until the string is destroyed.
 *
 * The final string can be safely be destroyed (using the `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_const)(FIO_STR_PTR s,
                                                            const char *str,
                                                            size_t len);

/**
 * Initializes the container with a copy of the provided dynamic string.
 *
 * The string is always copied and the final string must be destroyed (using the
 * `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_copy)(FIO_STR_PTR s,
                                                           const char *str,
                                                           size_t len);

/**
 * Initializes the container with a copy of an existing String object.
 *
 * The string is always copied and the final string must be destroyed (using the
 * `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_copy2)(FIO_STR_PTR dest,
                                                            FIO_STR_PTR src);

/**
 * Frees the String's resources and re-initializes the container.
 *
 * Note: if the container isn't allocated on the stack, it should be freed
 * separately using the appropriate `free` function.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, destroy)(FIO_STR_PTR s);

/**
 * Returns a C string with the existing data, re-initializing the String.
 *
 * Note: the String data is removed from the container, but the container
 * isn't freed.
 *
 * Returns NULL if there's no String data.
 *
 * NOTE: Returned string is ALWAYS dynamically allocated. Remember to free.
 */
FIO_IFUNC char *FIO_NAME(FIO_STR_NAME, detach)(FIO_STR_PTR s);

/** Frees the pointer returned by `detach`. */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, dealloc)(void *ptr);

/* *****************************************************************************
String API - String state (data pointers, length, capacity, etc')
***************************************************************************** */

/** Returns the String's complete state (capacity, length and pointer).  */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, info)(const FIO_STR_PTR s);

/** Returns the String's partial state (length and pointer).  */
FIO_IFUNC fio_buf_info_s FIO_NAME(FIO_STR_NAME, buf)(const FIO_STR_PTR s);

/** Returns a pointer (`char *`) to the String's content. */
FIO_IFUNC char *FIO_NAME(FIO_STR_NAME, ptr)(FIO_STR_PTR s);

/** Returns the String's length in bytes. */
FIO_IFUNC size_t FIO_NAME(FIO_STR_NAME, len)(FIO_STR_PTR s);

/** Returns the String's existing capacity (total used & available memory). */
FIO_IFUNC size_t FIO_NAME(FIO_STR_NAME, capa)(FIO_STR_PTR s);

/** Prevents further manipulations to the String's content. */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, freeze)(FIO_STR_PTR s);

/** Returns true if the string is frozen. */
FIO_IFUNC uint8_t FIO_NAME_BL(FIO_STR_NAME, frozen)(FIO_STR_PTR s);

/** Returns 1 if memory was allocated (and the String must be destroyed). */
FIO_IFUNC int FIO_NAME_BL(FIO_STR_NAME, allocated)(const FIO_STR_PTR s);

/** Binary comparison returns `1` if both strings are equal and `0` if not. */
FIO_IFUNC int FIO_NAME_BL(FIO_STR_NAME, eq)(const FIO_STR_PTR str1,
                                            const FIO_STR_PTR str2);

/**
 * Returns the string's Risky Hash value.
 *
 * Note: Hash algorithm might change without notice.
 */
FIO_IFUNC uint64_t FIO_NAME(FIO_STR_NAME, hash)(const FIO_STR_PTR s,
                                                uint64_t seed);

/* *****************************************************************************
String API - Memory management
***************************************************************************** */

/**
 * Sets the new String size without reallocating any memory (limited by
 * existing capacity).
 *
 * Returns the updated state of the String.
 *
 * Note: When shrinking, any existing data beyond the new size may be
 * corrupted.
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, resize)(FIO_STR_PTR s,
                                                        size_t size);

/**
 * Performs a best attempt at minimizing memory consumption.
 *
 * Actual effects depend on the underlying memory allocator and it's
 * implementation. Not all allocators will free any memory.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, compact)(FIO_STR_PTR s);

#if !FIO_STR_OPTIMIZE4IMMUTABILITY
/**
 * Reserves (at least) `amount` of bytes for the string's data.
 *
 * `amount` is in addition to existing String length.
 *
 * Make sure to call `resize` with the updated information once the editing is
 * done.
 *
 * Returns the updated state of the String.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, reserve)(FIO_STR_PTR s,
                                                     size_t amount);
#define FIO_STR_RESERVE_NAME reserve
#else
/** INTERNAL - DO NOT USE! */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, __reserve)(FIO_STR_PTR s,
                                                       size_t amount);
#define FIO_STR_RESERVE_NAME __reserve
#endif
/* *****************************************************************************
String API - UTF-8 State
***************************************************************************** */

/** Returns 1 if the String is UTF-8 valid and 0 if not. */
SFUNC size_t FIO_NAME(FIO_STR_NAME, utf8_valid)(FIO_STR_PTR s);

/** Returns the String's length in UTF-8 characters. */
SFUNC size_t FIO_NAME(FIO_STR_NAME, utf8_len)(FIO_STR_PTR s);

/**
 * Takes a UTF-8 character selection information (UTF-8 position and length)
 * and updates the same variables so they reference the raw byte slice
 * information.
 *
 * If the String isn't UTF-8 valid up to the requested selection, than `pos`
 * will be updated to `-1` otherwise values are always positive.
 *
 * The returned `len` value may be shorter than the original if there wasn't
 * enough data left to accommodate the requested length. When a `len` value of
 * `0` is returned, this means that `pos` marks the end of the String.
 *
 * Returns -1 on error and 0 on success.
 */
SFUNC int FIO_NAME(FIO_STR_NAME,
                   utf8_select)(FIO_STR_PTR s, intptr_t *pos, size_t *len);

/* *****************************************************************************
String API - Content Manipulation and Review
***************************************************************************** */

/** Writes data at the end of the String. */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write)(FIO_STR_PTR s,
                                                       const void *src,
                                                       size_t src_len);

/**
 * Appends the `src` String to the end of the `dest` String.
 *
 * If `dest` is empty, the resulting Strings will be equal.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, concat)(FIO_STR_PTR dest,
                                                    FIO_STR_PTR const src);

/** Alias for fio_str_concat */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, join)(FIO_STR_PTR dest,
                                                      FIO_STR_PTR const src) {
  return FIO_NAME(FIO_STR_NAME, concat)(dest, src);
}

/**
 * Replaces the data in the String - replacing `old_len` bytes starting at
 * `start_pos`, with the data at `src` (`src_len` bytes long).
 *
 * Negative `start_pos` values are calculated backwards, `-1` == end of
 * String.
 *
 * When `old_len` is zero, the function will insert the data at `start_pos`.
 *
 * If `src_len == 0` than `src` will be ignored and the data marked for
 * replacement will be erased.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, replace)(FIO_STR_PTR s,
                                                     intptr_t start_pos,
                                                     size_t old_len,
                                                     const void *src,
                                                     size_t src_len);

/** Writes data at the end of the String. See `fio_string_write2`. */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              __write2)(FIO_STR_PTR s,
                                        const fio_string_write_s srcs[]);

#ifndef FIO_STR_WRITE2
#define FIO_STR_WRITE2(str_name, dest, ...)                                    \
  FIO_NAME(str_name, __write2)(dest, (fio_string_write_s[]){__VA_ARGS__, {0}})
#endif
/* *****************************************************************************
String API - Numerals
***************************************************************************** */

/** Writes a number at the end of the String using normal base 10 notation. */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_i)(FIO_STR_PTR s,
                                                     int64_t num);

/** Writes a number at the end of the String using Hex (base 16) notation. */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_hex)(FIO_STR_PTR s,
                                                       int64_t num);

/* Writes a binary representation of `i` to the String */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_bin)(FIO_STR_PTR s,
                                                       int64_t num);

/* *****************************************************************************
String API - printf style support
***************************************************************************** */

/**
 * Writes to the String using a vprintf like interface.
 *
 * Data is written to the end of the String.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, vprintf)(FIO_STR_PTR s,
                                                     const char *format,
                                                     va_list argv);

/**
 * Writes to the String using a printf like interface.
 *
 * Data is written to the end of the String.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              printf)(FIO_STR_PTR s, const char *format, ...);

/* *****************************************************************************
String API - C / JSON escaping
***************************************************************************** */

/**
 * Writes data at the end of the String, escaping the data using JSON semantics.
 *
 * The JSON semantic are common to many programming languages, promising a UTF-8
 * String while making it easy to read and copy the string during debugging.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_escape)(FIO_STR_PTR s,
                                                          const void *data,
                                                          size_t data_len);

/**
 * Writes an escaped data into the string after unescaping the data.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_unescape)(FIO_STR_PTR s,
                                                            const void *escaped,
                                                            size_t len);

/* *****************************************************************************
String API - Base64 support
***************************************************************************** */

/**
 * Writes data at the end of the String, encoding the data as Base64 encoded
 * data.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_base64enc)(FIO_STR_PTR s,
                                               const void *data,
                                               size_t data_len,
                                               uint8_t url_encoded);

/**
 * Writes decoded base64 data to the end of the String.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_base64dec)(FIO_STR_PTR s,
                                               const void *encoded,
                                               size_t encoded_len);

/* *****************************************************************************
String API - HTML escaping support
***************************************************************************** */

/** Writes HTML escaped data to a String. */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_html_escape)(FIO_STR_PTR s,
                                                               const void *raw,
                                                               size_t len);

/** Writes HTML un-escaped data to a String - incomplete and minimal. */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_html_unescape)(FIO_STR_PTR s,
                                                   const void *escaped,
                                                   size_t len);

/* *****************************************************************************
String API - writing data from files to the String
***************************************************************************** */

/**
 * Reads data from a file descriptor `fd` at offset `start_at` and pastes it's
 * contents (or a slice of it) at the end of the String. If `limit == 0`, than
 * the data will be read until EOF.
 *
 * The file should be a regular file or the operation might fail (can't be used
 * for sockets).
 *
 * The file descriptor will remain open and should be closed manually.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, readfd)(FIO_STR_PTR s,
                                                    int fd,
                                                    intptr_t start_at,
                                                    intptr_t limit);
/**
 * Opens the file `filename` and pastes it's contents (or a slice ot it) at
 * the end of the String. If `limit == 0`, than the data will be read until
 * EOF.
 *
 * If the file can't be located, opened or read, or if `start_at` is beyond
 * the EOF position, NULL is returned in the state's `data` field.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, readfile)(FIO_STR_PTR s,
                                                      const char *filename,
                                                      intptr_t start_at,
                                                      intptr_t limit);
/* *****************************************************************************
String API - Testing
***************************************************************************** */
#ifdef FIO_STR_WRITE_TEST_FUNC
/**
 * Tests the fio_str functionality.
 */
SFUNC void FIO_NAME_TEST(stl, FIO_STR_NAME)(void);
#endif
/* *****************************************************************************


                             String Implementation

                           IMPLEMENTATION - INLINED


***************************************************************************** */

/* used here, but declared later (reference counter is static / global). */

SFUNC FIO_NAME(FIO_STR_NAME, s) * FIO_NAME(FIO_STR_NAME, __object_new)(void);
SFUNC void FIO_NAME(FIO_STR_NAME, __object_free)(FIO_NAME(FIO_STR_NAME, s) * s);
SFUNC int FIO_NAME(FIO_STR_NAME, __default_reallocate)(fio_str_info_s *dest,
                                                       size_t new_capa);
SFUNC int FIO_NAME(FIO_STR_NAME,
                   __default_copy_and_reallocate)(fio_str_info_s *dest,
                                                  size_t new_capa);
SFUNC void FIO_NAME(FIO_STR_NAME, __default_free)(void *ptr, size_t capa);

/* *****************************************************************************
String Macro Helpers
***************************************************************************** */

#define FIO_STR_IS_SMALL(s)  ((((s)->special & 1) | !(s)->buf))
#define FIO_STR_SMALL_LEN(s) ((size_t)((s)->special >> 2))
#define FIO_STR_SMALL_LEN_SET(s, l)                                            \
  ((s)->special = (((s)->special & 2) | ((uint8_t)(l) << 2) | 1))
#define FIO_STR_SMALL_CAPA(s) ((sizeof(*(s)) - 2) & 63)
#define FIO_STR_SMALL_DATA(s) ((char *)((s)->reserved))

#define FIO_STR_BIG_DATA(s)       ((s)->buf)
#define FIO_STR_BIG_IS_DYNAMIC(s) (!((s)->special & 4))
#define FIO_STR_BIG_SET_STATIC(s) ((s)->special |= 4)
#define FIO_STR_BIG_FREE_BUF(s)                                                \
  (FIO_NAME(FIO_STR_NAME, __default_free)((s)->buf, FIO_STR_BIG_CAPA((s))))

#define FIO_STR_IS_FROZEN(s) ((s)->special & 2)
#define FIO_STR_FREEZE_(s)   ((s)->special |= 2)
#define FIO_STR_THAW_(s)     ((s)->special ^= (uint8_t)2)

#if FIO_STR_OPTIMIZE4IMMUTABILITY

#define FIO_STR_BIG_LEN(s)                                                     \
  ((sizeof(void *) == 4)                                                       \
       ? (((uint32_t)(s)->reserved[0]) | ((uint32_t)(s)->reserved[1] << 8) |   \
          ((uint32_t)(s)->reserved[2] << 16))                                  \
       : (((uint64_t)(s)->reserved[0]) | ((uint64_t)(s)->reserved[1] << 8) |   \
          ((uint64_t)(s)->reserved[2] << 16) |                                 \
          ((uint64_t)(s)->reserved[3] << 24) |                                 \
          ((uint64_t)(s)->reserved[4] << 32) |                                 \
          ((uint64_t)(s)->reserved[5] << 40) |                                 \
          ((uint64_t)(s)->reserved[6] << 48)))
#define FIO_STR_BIG_LEN_SET(s, l)                                              \
  do {                                                                         \
    if (sizeof(void *) == 4) {                                                 \
      if (!((l) & ((~(uint32_t)0) << 24))) {                                   \
        (s)->reserved[0] = (l)&0xFF;                                           \
        (s)->reserved[1] = ((uint32_t)(l) >> 8) & 0xFF;                        \
        (s)->reserved[2] = ((uint32_t)(l) >> 16) & 0xFF;                       \
      } else {                                                                 \
        FIO_LOG_ERROR("facil.io small string length error - too long");        \
        (s)->reserved[0] = 0xFF;                                               \
        (s)->reserved[1] = 0xFF;                                               \
        (s)->reserved[2] = 0xFF;                                               \
      }                                                                        \
    } else {                                                                   \
      if (!((l) & ((~(uint64_t)0) << 56))) {                                   \
        (s)->reserved[0] = (l)&0xFF;                                           \
        (s)->reserved[1] = ((uint64_t)(l) >> 8) & 0xFF;                        \
        (s)->reserved[2] = ((uint64_t)(l) >> 16) & 0xFF;                       \
        (s)->reserved[3] = ((uint64_t)(l) >> 24) & 0xFF;                       \
        (s)->reserved[4] = ((uint64_t)(l) >> 32) & 0xFF;                       \
        (s)->reserved[5] = ((uint64_t)(l) >> 40) & 0xFF;                       \
        (s)->reserved[6] = ((uint64_t)(l) >> 48) & 0xFF;                       \
      } else {                                                                 \
        FIO_LOG_ERROR("facil.io small string length error - too long");        \
        (s)->reserved[0] = 0xFF;                                               \
        (s)->reserved[1] = 0xFF;                                               \
        (s)->reserved[2] = 0xFF;                                               \
        (s)->reserved[3] = 0xFF;                                               \
        (s)->reserved[4] = 0xFF;                                               \
        (s)->reserved[5] = 0xFF;                                               \
        (s)->reserved[6] = 0xFF;                                               \
      }                                                                        \
    }                                                                          \
  } while (0)
#define FIO_STR_BIG_CAPA(s) fio_string_capa4len(FIO_STR_BIG_LEN((s)))
#define FIO_STR_BIG_CAPA_SET(s, capa)
#else
#define FIO_STR_BIG_LEN(s)            ((s)->len)
#define FIO_STR_BIG_LEN_SET(s, l)     ((s)->len = (l))
#define FIO_STR_BIG_CAPA(s)           ((s)->capa)
#define FIO_STR_BIG_CAPA_SET(s, capa) (FIO_STR_BIG_CAPA(s) = (capa))
#endif

/* *****************************************************************************
String Information Round-tripping
***************************************************************************** */

/** Returns the String's complete state (capacity, length and pointer).  */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, info)(const FIO_STR_PTR s_) {
  fio_str_info_s r = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, r);
  FIO_NAME(FIO_STR_NAME, s) *s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (FIO_STR_IS_SMALL(s))
    r = FIO_STR_INFO3(FIO_STR_SMALL_DATA(s),
                      FIO_STR_SMALL_LEN(s),
                      FIO_STR_SMALL_CAPA(s));
  else
    r = FIO_STR_INFO3(FIO_STR_BIG_DATA(s),
                      FIO_STR_BIG_LEN(s),
                      FIO_STR_BIG_CAPA(s));
  r.capa &= ((size_t)0ULL - (!FIO_STR_IS_FROZEN(s)));
  return r;
}

/** Returns the String's partial state (length and pointer).  */
FIO_IFUNC fio_buf_info_s FIO_NAME(FIO_STR_NAME, buf)(const FIO_STR_PTR s_) {
  fio_buf_info_s r = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, r);
  FIO_NAME(FIO_STR_NAME, s) *s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (FIO_STR_IS_SMALL(s))
    r = FIO_BUF_INFO2(FIO_STR_SMALL_DATA(s), FIO_STR_SMALL_LEN(s));
  else
    r = FIO_BUF_INFO2(FIO_STR_BIG_DATA(s), FIO_STR_BIG_LEN(s));
  return r;
}

/* Internal(!): updated String data according to `info`.  */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, __info_update)(const FIO_STR_PTR s_,
                                                     fio_str_info_s info) {
  /* internally used function, tagging already validated. */
  FIO_NAME(FIO_STR_NAME, s) *s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (info.buf == FIO_STR_SMALL_DATA(s)) {
    s->special |= 1;
    FIO_STR_SMALL_LEN_SET(s, info.len);
    return;
  }
  s->special = 0;
  FIO_STR_BIG_LEN_SET(s, info.len);
  FIO_STR_BIG_CAPA_SET(s, info.capa);
  s->buf = info.buf;
}

/* Internal(!): updated String data according to `info`.  */
FIO_IFUNC fio_string_realloc_fn FIO_NAME(FIO_STR_NAME,
                                         __realloc_func)(const FIO_STR_PTR s_) {
  fio_string_realloc_fn options[] = {
      FIO_NAME(FIO_STR_NAME, __default_reallocate),
      FIO_NAME(FIO_STR_NAME, __default_copy_and_reallocate),
  };
  /* internally used function, tagging already validated. */
  FIO_NAME(FIO_STR_NAME, s) *s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  return options[FIO_STR_IS_SMALL(s) | !FIO_STR_BIG_IS_DYNAMIC(s)];
}

/* *****************************************************************************
String Constructors (inline)
***************************************************************************** */
#ifndef FIO_REF_CONSTRUCTOR_ONLY

/** Allocates a new String object on the heap. */
FIO_IFUNC FIO_STR_PTR FIO_NAME(FIO_STR_NAME, new)(void) {
  FIO_NAME(FIO_STR_NAME, s) *const s = FIO_NAME(FIO_STR_NAME, __object_new)();
  if (!FIO_MEM_REALLOC_IS_SAFE_ && s) {
    *s = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT;
  }
#ifdef DEBUG
  {
    FIO_NAME(FIO_STR_NAME, s) tmp = {0};
    FIO_ASSERT(!FIO_MEMCMP(&tmp, s, sizeof(tmp)),
               "new " FIO_MACRO2STR(
                   FIO_NAME(FIO_STR_NAME, s)) " object not initialized!");
  }
#endif
  return (FIO_STR_PTR)FIO_PTR_TAG(s);
}

/** Destroys the string and frees the container (if allocated with `new`). */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, free)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(s_);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (!FIO_STR_IS_SMALL(s) && FIO_STR_BIG_IS_DYNAMIC(s)) {
    FIO_STR_BIG_FREE_BUF(s);
  }
  FIO_NAME(FIO_STR_NAME, __object_free)(s);
}

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/**
 * Frees the String's resources and reinitializes the container.
 *
 * Note: if the container isn't allocated on the stack, it should be freed
 * separately using the appropriate `free` function.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, destroy)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(s_);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (!FIO_STR_IS_SMALL(s) && FIO_STR_BIG_IS_DYNAMIC(s)) {
    FIO_STR_BIG_FREE_BUF(s);
  }
  *s = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT;
}

/**
 * Returns a C string with the existing data, re-initializing the String.
 *
 * Note: the String data is removed from the container, but the container
 * isn't freed.
 *
 * Returns NULL if there's no String data.
 */
FIO_IFUNC char *FIO_NAME(FIO_STR_NAME, detach)(FIO_STR_PTR s_) {
  char *data = NULL;
  FIO_PTR_TAG_VALID_OR_RETURN(s_, data);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);

  if (FIO_STR_IS_SMALL(s)) {
    if (FIO_STR_SMALL_LEN(s)) { /* keep these ifs apart */
      fio_str_info_s cpy =
          FIO_STR_INFO2(FIO_STR_SMALL_DATA(s), FIO_STR_SMALL_LEN(s));
      FIO_NAME(FIO_STR_NAME, __default_copy_and_reallocate)(&cpy, cpy.len);
      data = cpy.buf;
    }
  } else {
    if (FIO_STR_BIG_IS_DYNAMIC(s)) {
      data = FIO_STR_BIG_DATA(s);
    } else if (FIO_STR_BIG_LEN(s)) {
      fio_str_info_s cpy =
          FIO_STR_INFO2(FIO_STR_BIG_DATA(s), FIO_STR_BIG_LEN(s));
      FIO_NAME(FIO_STR_NAME, __default_copy_and_reallocate)(&cpy, cpy.len);
      data = cpy.buf;
    }
  }
  *s = (FIO_NAME(FIO_STR_NAME, s)){0};
  return data;
}

/**
 * Performs a best attempt at minimizing memory consumption.
 *
 * Actual effects depend on the underlying memory allocator and it's
 * implementation. Not all allocators will free any memory.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, compact)(FIO_STR_PTR s_) {
#if FIO_STR_OPTIMIZE4IMMUTABILITY
  (void)s_;
#else
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(s_);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (FIO_STR_IS_SMALL(s) || !FIO_STR_BIG_IS_DYNAMIC(s) ||
      fio_string_capa4len(FIO_NAME(FIO_STR_NAME, len)(s_)) >=
          FIO_NAME(FIO_STR_NAME, capa)(s_))
    return;
  FIO_NAME(FIO_STR_NAME, s) tmp = FIO_STR_INIT;
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  FIO_NAME(FIO_STR_NAME, init_copy)
  ((FIO_STR_PTR)FIO_PTR_TAG(&tmp), i.buf, i.len);
  FIO_NAME(FIO_STR_NAME, destroy)(s_);
  *s = tmp;
#endif
}

/* *****************************************************************************
String Initialization (inline)
***************************************************************************** */

/**
 * Initializes the container with the provided static / constant string.
 *
 * The string will be copied to the container **only** if it will fit in the
 * container itself. Otherwise, the supplied pointer will be used as is and it
 * should remain valid until the string is destroyed.
 *
 * The final string can be safely be destroyed (using the `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_const)(FIO_STR_PTR s_,
                                                            const char *str,
                                                            size_t len) {
  fio_str_info_s i = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, i);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  *s = (FIO_NAME(FIO_STR_NAME, s)){0};
  if (len < FIO_STR_SMALL_CAPA(s)) {
    FIO_STR_SMALL_LEN_SET(s, len);
    if (len && str)
      FIO_MEMCPY(FIO_STR_SMALL_DATA(s), str, len);
    FIO_STR_SMALL_DATA(s)[len] = 0;

    i = FIO_STR_INFO3(FIO_STR_SMALL_DATA(s), len, FIO_STR_SMALL_CAPA(s));
    return i;
  }
  FIO_STR_BIG_DATA(s) = (char *)str;
  FIO_STR_BIG_LEN_SET(s, len);
  FIO_STR_BIG_CAPA_SET(s, len);
  FIO_STR_BIG_SET_STATIC(s);
  i = FIO_STR_INFO3(FIO_STR_BIG_DATA(s), len, 0);
  return i;
}

/**
 * Initializes the container with the provided dynamic string.
 *
 * The string is always copied and the final string must be destroyed (using the
 * `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_copy)(FIO_STR_PTR s_,
                                                           const char *str,
                                                           size_t len) {
  fio_str_info_s i = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, i);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  *s = (FIO_NAME(FIO_STR_NAME, s)){0};
  if (len < FIO_STR_SMALL_CAPA(s)) {
    FIO_STR_SMALL_LEN_SET(s, len);
    if (len && str)
      FIO_MEMCPY(FIO_STR_SMALL_DATA(s), str, len);
    FIO_STR_SMALL_DATA(s)[len] = 0;

    i = FIO_STR_INFO3(FIO_STR_SMALL_DATA(s), len, FIO_STR_SMALL_CAPA(s));
    return i;
  }
  i = FIO_STR_INFO2((char *)str, len);
  FIO_NAME(FIO_STR_NAME, __default_copy_and_reallocate)(&i, len);
  FIO_STR_BIG_CAPA_SET(s, i.capa);
  FIO_STR_BIG_DATA(s) = i.buf;
  FIO_STR_BIG_LEN_SET(s, len);
  return i;
}

/**
 * Initializes the container with a copy of an existing String object.
 *
 * The string is always copied and the final string must be destroyed (using the
 * `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_copy2)(FIO_STR_PTR dest,
                                                            FIO_STR_PTR src) {
  fio_str_info_s i;
  i = FIO_NAME(FIO_STR_NAME, info)(src);
  i = FIO_NAME(FIO_STR_NAME, init_copy)(dest, i.buf, i.len);
  return i;
}

/* *****************************************************************************
String Information (inline)
***************************************************************************** */

/** Returns a pointer (`char *`) to the String's content. */
FIO_IFUNC char *FIO_NAME(FIO_STR_NAME, ptr)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, NULL);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  char *results[] = {(FIO_STR_BIG_DATA(s)), (FIO_STR_SMALL_DATA(s))};
  return results[FIO_STR_IS_SMALL(s)];
}

/** Returns the String's length in bytes. */
FIO_IFUNC size_t FIO_NAME(FIO_STR_NAME, len)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 0);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  size_t results[] = {(FIO_STR_BIG_LEN(s)), (FIO_STR_SMALL_LEN(s))};
  return results[FIO_STR_IS_SMALL(s)];
}

/** Returns the String's existing capacity (total used & available memory). */
FIO_IFUNC size_t FIO_NAME(FIO_STR_NAME, capa)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 0);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (FIO_STR_IS_SMALL(s))
    return FIO_STR_SMALL_CAPA(s);
  if (FIO_STR_BIG_IS_DYNAMIC(s))
    return FIO_STR_BIG_CAPA(s);
  return 0;
}

/**
 * Sets the new String size without reallocating any memory (limited by
 * existing capacity).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, resize)(FIO_STR_PTR s_,
                                                        size_t size) {
  fio_str_info_s i = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, i);
  i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa) {
    return i;
  }
  /* resize may be used to reserve memory in advance while setting size  */
  if (i.capa > size) {
    i.len = size;
    i.buf[i.len] = 0;
  } else {
    fio_string_write(&i,
                     FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                     NULL,
                     size - i.len);
  }
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);

  return i;
}

/**
 * Prevents further manipulations to the String's content.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, freeze)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(s_);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  FIO_STR_FREEZE_(s);
}

/**
 * Returns true if the string is frozen.
 */
FIO_IFUNC uint8_t FIO_NAME_BL(FIO_STR_NAME, frozen)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 1);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  return FIO_STR_IS_FROZEN(s);
}

/** Returns 1 if memory was allocated and (the String must be destroyed). */
FIO_IFUNC int FIO_NAME_BL(FIO_STR_NAME, allocated)(const FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 0);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  return (!FIO_STR_IS_SMALL(s) & FIO_STR_BIG_IS_DYNAMIC(s));
}

/**
 * Binary comparison returns `1` if both strings are equal and `0` if not.
 */
FIO_IFUNC int FIO_NAME_BL(FIO_STR_NAME, eq)(const FIO_STR_PTR str1_,
                                            const FIO_STR_PTR str2_) {
  if (str1_ == str2_)
    return 1;
  FIO_PTR_TAG_VALID_OR_RETURN(str1_, 0);
  FIO_PTR_TAG_VALID_OR_RETURN(str2_, 0);
  fio_buf_info_s s1 = FIO_NAME(FIO_STR_NAME, buf)(str1_);
  fio_buf_info_s s2 = FIO_NAME(FIO_STR_NAME, buf)(str2_);
  return FIO_BUF_INFO_IS_EQ(s1, s2);
}

/**
 * Returns the string's Risky Hash value.
 *
 * Note: Hash algorithm might change without notice.
 */
FIO_IFUNC uint64_t FIO_NAME(FIO_STR_NAME, hash)(const FIO_STR_PTR s_,
                                                uint64_t seed) {
  fio_buf_info_s i = FIO_NAME(FIO_STR_NAME, buf)(s_);
  return fio_risky_hash((void *)i.buf, i.len, seed);
}

/* *****************************************************************************
String API - Content Manipulation and Review (inline)
***************************************************************************** */

/** Writes data at the end of the String. */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write)(FIO_STR_PTR s_,
                                                       const void *src,
                                                       size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write(&i, FIO_NAME(FIO_STR_NAME, __realloc_func)(s_), src, len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/* *****************************************************************************


                             String Implementation

                               IMPLEMENTATION


***************************************************************************** */

/* *****************************************************************************
External functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_STR_NAME, s))
FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_STR_NAME, destroy))

/* *****************************************************************************
String Core Callbacks - Memory management
***************************************************************************** */
SFUNC FIO_NAME(FIO_STR_NAME, s) * FIO_NAME(FIO_STR_NAME, __object_new)(void) {
  FIO_NAME(FIO_STR_NAME, s) *r =
      (FIO_NAME(FIO_STR_NAME, s) *)FIO_MEM_REALLOC_(NULL, 0, (sizeof(*r)), 0);
  if (r)
    FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_STR_NAME, s));
  return r;
}
SFUNC void FIO_NAME(FIO_STR_NAME,
                    __object_free)(FIO_NAME(FIO_STR_NAME, s) * s) {
  if (!s)
    return;
  FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_STR_NAME, s));
  FIO_MEM_FREE_(s, sizeof(*s));
}

SFUNC int FIO_NAME(FIO_STR_NAME, __default_reallocate)(fio_str_info_s *dest,
                                                       size_t new_capa) {
  new_capa = fio_string_capa4len(new_capa);
  void *tmp = FIO_MEM_REALLOC_(dest->buf, dest->capa, new_capa, dest->len);
  if (!tmp)
    return -1;
  if (!dest->buf)
    FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_STR_NAME, destroy));
  dest->capa = new_capa;
  dest->buf = (char *)tmp;
  return 0;
}
SFUNC int FIO_NAME(FIO_STR_NAME,
                   __default_copy_and_reallocate)(fio_str_info_s *dest,
                                                  size_t new_capa) {
  if (dest->len && new_capa < dest->len)
    new_capa = dest->len;
  new_capa = fio_string_capa4len(new_capa);
  void *tmp = FIO_MEM_REALLOC_(NULL, 0, new_capa, 0);
  if (!tmp)
    return -1;
  FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_STR_NAME, destroy));
  if (dest->len)
    FIO_MEMCPY(tmp, dest->buf, dest->len);
  ((char *)tmp)[dest->len] = 0;
  dest->capa = new_capa;
  dest->buf = (char *)tmp;
  return 0;
}
SFUNC void FIO_NAME(FIO_STR_NAME, __default_free)(void *ptr, size_t capa) {
  if (!ptr)
    return;
  FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_STR_NAME, destroy));
  FIO_MEM_FREE_(ptr, capa);
  (void)capa; /* if unused */
}
SFUNC void FIO_NAME(FIO_STR_NAME, __default_free_noop)(void *str) { (void)str; }
SFUNC void FIO_NAME(FIO_STR_NAME, __default_free_noop2)(fio_str_info_s str) {
  (void)str;
}

/* *****************************************************************************
String Implementation - Memory management
***************************************************************************** */

/** Frees the pointer returned by `detach`. */
SFUNC void FIO_NAME(FIO_STR_NAME, dealloc)(void *ptr) {
  if (!ptr)
    return;
  FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_STR_NAME, destroy));
  FIO_MEM_FREE_(ptr, -1);
}

/**
 * Reserves at least `amount` of bytes for the string's data.
 *
 * Returns the current state of the String.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              FIO_STR_RESERVE_NAME)(FIO_STR_PTR s_,
                                                    size_t amount) {
  fio_str_info_s state = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, state);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  state = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (FIO_STR_IS_FROZEN(s))
    return state;
  amount += state.len;
  if (state.capa <= amount) {
    FIO_NAME(FIO_STR_NAME, __realloc_func)(s_)(&state, amount);
    state.buf[state.len] = 0;
    FIO_NAME(FIO_STR_NAME, __info_update)(s_, state);
  } else if (state.capa > FIO_STR_SMALL_CAPA(s) &&
             amount <= FIO_STR_SMALL_CAPA(s) &&
             state.len <= FIO_STR_SMALL_CAPA(s)) {
    FIO_NAME(FIO_STR_NAME, s) tmp;
    state = FIO_NAME(FIO_STR_NAME, init_copy)((FIO_STR_PTR)FIO_PTR_TAG(&tmp),
                                              state.buf,
                                              state.len);
    FIO_NAME(FIO_STR_NAME, destroy)(s_);
    *s = tmp;
  }
  return state;
}

/* *****************************************************************************
String Implementation - UTF-8 State
***************************************************************************** */

/** Returns 1 if the String is UTF-8 valid and 0 if not. */
SFUNC size_t FIO_NAME(FIO_STR_NAME, utf8_valid)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 0);
  fio_str_info_s state = FIO_NAME(FIO_STR_NAME, info)(s_);
  return fio_string_utf8_len(state);
}

/** Returns the String's length in UTF-8 characters. */
SFUNC size_t FIO_NAME(FIO_STR_NAME, utf8_len)(FIO_STR_PTR s_) {
  fio_str_info_s state = FIO_NAME(FIO_STR_NAME, info)(s_);
  return fio_string_utf8_len(state);
}

/**
 * Takes a UTF-8 character selection information (UTF-8 position and length)
 * and updates the same variables so they reference the raw byte slice
 * information.
 *
 * If the String isn't UTF-8 valid up to the requested selection, than `pos`
 * will be updated to `-1` otherwise values are always positive.
 *
 * The returned `len` value may be shorter than the original if there wasn't
 * enough data left to accommodate the requested length. When a `len` value of
 * `0` is returned, this means that `pos` marks the end of the String.
 *
 * Returns -1 on error and 0 on success.
 */
SFUNC int FIO_NAME(FIO_STR_NAME,
                   utf8_select)(FIO_STR_PTR s_, intptr_t *pos, size_t *len) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, -1);
  fio_str_info_s state = FIO_NAME(FIO_STR_NAME, info)(s_);
  return fio_string_utf8_select(state, pos, len);
}

/* *****************************************************************************
String Implementation - Content Manipulation and Review
***************************************************************************** */

/**
 * Writes a number at the end of the String using normal base 10 notation.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_i)(FIO_STR_PTR s_,
                                                     int64_t num) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_i(&i, FIO_NAME(FIO_STR_NAME, __realloc_func)(s_), num);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes a number at the end of the String using Hex (base 16) notation.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_hex)(FIO_STR_PTR s_,
                                                       int64_t num) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_hex(&i, FIO_NAME(FIO_STR_NAME, __realloc_func)(s_), num);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes a number at the end of the String using binary notation.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_bin)(FIO_STR_PTR s_,
                                                       int64_t num) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_bin(&i, FIO_NAME(FIO_STR_NAME, __realloc_func)(s_), num);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Appends the `src` String to the end of the `dest` String.
 *
 * If `dest` is empty, the resulting Strings will be equal.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, concat)(FIO_STR_PTR dest_,
                                                    FIO_STR_PTR const src_) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(dest_);
  if (!i.capa)
    return i;
  FIO_PTR_TAG_VALID_OR_RETURN(src_, i);
  fio_str_info_s src = FIO_NAME(FIO_STR_NAME, info)(src_);
  if (!src.len)
    return i;
  fio_string_write(&i,
                   FIO_NAME(FIO_STR_NAME, __realloc_func)(dest_),
                   src.buf,
                   src.len);
  FIO_NAME(FIO_STR_NAME, __info_update)(dest_, i);
  return i;
}

/**
 * Replaces the data in the String - replacing `old_len` bytes starting at
 * `start_pos`, with the data at `src` (`src_len` bytes long).
 *
 * Negative `start_pos` values are calculated backwards, `-1` == end of
 * String.
 *
 * When `old_len` is zero, the function will insert the data at `start_pos`.
 *
 * If `src_len == 0` than `src` will be ignored and the data marked for
 * replacement will be erased.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, replace)(FIO_STR_PTR s_,
                                                     intptr_t start_pos,
                                                     size_t old_len,
                                                     const void *src,
                                                     size_t src_len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_replace(&i,
                     FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                     start_pos,
                     old_len,
                     src,
                     src_len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes a number at the end of the String using binary notation.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              __write2)(FIO_STR_PTR s_,
                                        const fio_string_write_s srcs[]) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write2 FIO_NOOP(&i,
                             FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                             srcs);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes to the String using a vprintf like interface.
 *
 * Data is written to the end of the String.
 */
SFUNC fio_str_info_s FIO___PRINTF_STYLE(2, 0)
    FIO_NAME(FIO_STR_NAME,
             vprintf)(FIO_STR_PTR s_, const char *format, va_list argv) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_vprintf(&i,
                     FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                     format,
                     argv);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes to the String using a printf like interface.
 *
 * Data is written to the end of the String.
 */
SFUNC fio_str_info_s FIO___PRINTF_STYLE(2, 3)
    FIO_NAME(FIO_STR_NAME, printf)(FIO_STR_PTR s_, const char *format, ...) {
  va_list argv;
  va_start(argv, format);
  fio_str_info_s state = FIO_NAME(FIO_STR_NAME, vprintf)(s_, format, argv);
  va_end(argv);
  return state;
}

/* *****************************************************************************
String API - C / JSON escaping
***************************************************************************** */

/**
 * Writes data at the end of the String, escaping the data using JSON semantics.
 *
 * The JSON semantic are common to many programming languages, promising a UTF-8
 * String while making it easy to read and copy the string during debugging.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_escape)(FIO_STR_PTR s_,
                                                          const void *src,
                                                          size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_escape(&i,
                          FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                          src,
                          len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes an escaped data into the string after unescaping the data.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_unescape)(FIO_STR_PTR s_,
                                                            const void *src,
                                                            size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_unescape(&i,
                            FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                            src,
                            len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/* *****************************************************************************
String - Base64 support
***************************************************************************** */

/**
 * Writes data at the end of the String, encoding the data as Base64 encoded
 * data.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_base64enc)(FIO_STR_PTR s_,
                                               const void *data,
                                               size_t len,
                                               uint8_t url_encoded) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_base64enc(&i,
                             FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                             data,
                             len,
                             url_encoded);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes decoded base64 data to the end of the String.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_base64dec)(FIO_STR_PTR s_,
                                               const void *encoded_,
                                               size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_base64dec(&i,
                             FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                             encoded_,
                             len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/* *****************************************************************************
String API - HTML escaping support
***************************************************************************** */

/** Writes HTML escaped data to a String. */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_html_escape)(FIO_STR_PTR s_,
                                                               const void *data,
                                                               size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_html_escape(&i,
                               FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                               data,
                               len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/** Writes HTML un-escaped data to a String - incomplete and minimal. */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_html_unescape)(FIO_STR_PTR s_,
                                                   const void *data,
                                                   size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_html_unescape(&i,
                                 FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                                 data,
                                 len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/* *****************************************************************************
String - read file
***************************************************************************** */

/**
 * Reads data from a file descriptor `fd` at offset `start_at` and pastes it's
 * contents (or a slice of it) at the end of the String. If `limit == 0`, than
 * the data will be read until EOF.
 *
 * The file should be a regular file or the operation might fail (can't be used
 * for sockets).
 *
 * The file descriptor will remain open and should be closed manually.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, readfd)(FIO_STR_PTR s_,
                                                    int fd,
                                                    intptr_t start_at,
                                                    intptr_t limit) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_readfd(&i,
                    FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                    fd,
                    start_at,
                    limit);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Opens the file `filename` and pastes it's contents (or a slice ot it) at
 * the end of the String. If `limit == 0`, than the data will be read until
 * EOF.
 *
 * If the file can't be located, opened or read, or if `start_at` is beyond
 * the EOF position, NULL is returned in the state's `data` field.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, readfile)(FIO_STR_PTR s_,
                                                      const char *filename,
                                                      intptr_t start_at,
                                                      intptr_t limit) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_readfile(&i,
                      FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                      filename,
                      start_at,
                      limit);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/* *****************************************************************************


                                    String Test


***************************************************************************** */
#ifdef FIO_STR_WRITE_TEST_FUNC

/**
 * Tests the fio_str functionality.
 */
SFUNC void FIO_NAME_TEST(stl, FIO_STR_NAME)(void) {
  FIO_NAME(FIO_STR_NAME, s) str = {0}; /* test zeroed out memory */
#define FIO__STR_SMALL_CAPA FIO_STR_SMALL_CAPA(&str)
  FIO_STR_PTR pstr = FIO_PTR_TAG((&str));
  fprintf(stderr,
          "\t* Testing core string features for " FIO_MACRO2STR(
              FIO_STR_NAME) ".\n");
  fprintf(stderr,
          "\t* String container size (without wrapper): %zu\n",
          sizeof(FIO_NAME(FIO_STR_NAME, s)));
  fprintf(stderr,
          "\t* Self-contained capacity (FIO_STR_SMALL_CAPA): %zu\n",
          FIO__STR_SMALL_CAPA);
  FIO_ASSERT(!FIO_NAME_BL(FIO_STR_NAME, frozen)(pstr), "new string is frozen");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(pstr) == FIO__STR_SMALL_CAPA,
             "small string capacity returned %zu",
             FIO_NAME(FIO_STR_NAME, capa)(pstr));
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(pstr) == 0,
             "small string length reporting error!");
  FIO_ASSERT(
      FIO_NAME(FIO_STR_NAME, ptr)(pstr) == ((char *)(&str) + 1),
      "small string pointer reporting error (%zd offset)!",
      (ssize_t)(((char *)(&str) + 1) - FIO_NAME(FIO_STR_NAME, ptr)(pstr)));
  FIO_NAME(FIO_STR_NAME, write)(pstr, "World", 4);
  FIO_ASSERT(FIO_STR_IS_SMALL(&str),
             "small string writing error - not small on small write!");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(pstr) == FIO__STR_SMALL_CAPA,
             "Small string capacity reporting error after write!");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(pstr) == 4,
             "small string length reporting error after write!");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, ptr)(pstr) == (char *)&str + 1,
             "small string pointer reporting error after write!");
  FIO_ASSERT(!FIO_NAME(FIO_STR_NAME, ptr)(pstr)[4] &&
                 FIO_STRLEN(FIO_NAME(FIO_STR_NAME, ptr)(pstr)) == 4,
             "small string NUL missing after write (%zu)!",
             FIO_STRLEN(FIO_NAME(FIO_STR_NAME, ptr)(pstr)));
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(pstr), "Worl"),
             "small string write error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(pstr));
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, ptr)(pstr) ==
                 FIO_NAME(FIO_STR_NAME, info)(pstr).buf,
             "small string `data` != `info.buf` (%p != %p)",
             (void *)FIO_NAME(FIO_STR_NAME, ptr)(pstr),
             (void *)FIO_NAME(FIO_STR_NAME, info)(pstr).buf);

  FIO_NAME(FIO_STR_NAME, FIO_STR_RESERVE_NAME)
  (pstr, sizeof(FIO_NAME(FIO_STR_NAME, s)));
  FIO_ASSERT(!FIO_STR_IS_SMALL(&str),
             "Long String reporting as small after capacity update!");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(pstr) >=
                 sizeof(FIO_NAME(FIO_STR_NAME, s)) - 1,
             "Long String capacity update error (%zu != %zu)!",
             FIO_NAME(FIO_STR_NAME, capa)(pstr),
             FIO_STR_SMALL_CAPA(&str));

  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, ptr)(pstr) ==
                 FIO_NAME(FIO_STR_NAME, info)(pstr).buf,
             "Long String `ptr` !>= "
             "`cstr(s).buf` (%p != %p)",
             (void *)FIO_NAME(FIO_STR_NAME, ptr)(pstr),
             (void *)FIO_NAME(FIO_STR_NAME, info)(pstr).buf);

#if FIO_STR_OPTIMIZE4IMMUTABILITY
  /* immutable string length is updated after `reserve` to reflect new capa */
  FIO_NAME(FIO_STR_NAME, resize)(pstr, 4);
#endif
  FIO_ASSERT(
      FIO_NAME(FIO_STR_NAME, len)(pstr) == 4,
      "Long String length changed during conversion from small string (%zu)!",
      FIO_NAME(FIO_STR_NAME, len)(pstr));
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, ptr)(pstr) == str.buf,
             "Long String pointer reporting error after capacity update!");
  FIO_ASSERT(FIO_STRLEN(FIO_NAME(FIO_STR_NAME, ptr)(pstr)) == 4,
             "Long String NUL missing after capacity update (%zu)!",
             FIO_STRLEN(FIO_NAME(FIO_STR_NAME, ptr)(pstr)));
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(pstr), "Worl"),
             "Long String value changed after capacity update (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(pstr));

  FIO_NAME(FIO_STR_NAME, write)(pstr, "d!", 2);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(pstr), "World!"),
             "Long String `write` error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(pstr));

  FIO_NAME(FIO_STR_NAME, replace)(pstr, 0, 0, "Hello ", 6);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(pstr), "Hello World!"),
             "Long String `insert` error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(pstr));

  FIO_NAME(FIO_STR_NAME, resize)(pstr, 6);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(pstr), "Hello "),
             "Long String `resize` clipping error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(pstr));

  FIO_NAME(FIO_STR_NAME, replace)(pstr, 6, 0, "My World!", 9);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(pstr), "Hello My World!"),
             "Long String `replace` error when testing overflow (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(pstr));

  FIO_NAME(FIO_STR_NAME, FIO_STR_RESERVE_NAME)
  (pstr, FIO_NAME(FIO_STR_NAME, len)(pstr)); /* may truncate */

  FIO_NAME(FIO_STR_NAME, replace)(pstr, -10, 2, "Big", 3);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(pstr), "Hello Big World!"),
             "Long String `replace` error when testing splicing (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(pstr));

  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(pstr) ==
                     fio_string_capa4len(FIO_STRLEN("Hello Big World!")) ||
                 !FIO_NAME_BL(FIO_STR_NAME, allocated)(pstr),
             "Long String `replace` capacity update error "
             "(%zu >=? %zu)!",
             FIO_NAME(FIO_STR_NAME, capa)(pstr),
             fio_string_capa4len(FIO_STRLEN("Hello Big World!")));

  if (FIO_NAME(FIO_STR_NAME, len)(pstr) < (sizeof(str) - 2)) {
    FIO_NAME(FIO_STR_NAME, compact)(pstr);
    FIO_ASSERT(FIO_STR_IS_SMALL(&str),
               "Compacting didn't change String to small!");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(pstr) ==
                   FIO_STRLEN("Hello Big World!"),
               "Compacting altered String length! (%zu != %zu)!",
               FIO_NAME(FIO_STR_NAME, len)(pstr),
               FIO_STRLEN("Hello Big World!"));
    FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(pstr), "Hello Big World!"),
               "Compact data error (%s)!",
               FIO_NAME(FIO_STR_NAME, ptr)(pstr));
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(pstr) == sizeof(str) - 2,
               "Compacted String capacity reporting error!");
  } else {
    FIO_LOG_DEBUG2("\t* Skipped `compact` test (irrelevant for type).");
  }

  {
    FIO_NAME(FIO_STR_NAME, freeze)(pstr);
    FIO_ASSERT(FIO_NAME_BL(FIO_STR_NAME, frozen)(pstr),
               "Frozen String not flagged as frozen.");
    fio_str_info_s old_state = FIO_NAME(FIO_STR_NAME, info)(pstr);
    FIO_NAME(FIO_STR_NAME, write)(pstr, "more data to be written here", 28);
    FIO_NAME(FIO_STR_NAME, replace)
    (pstr, 2, 1, "more data to be written here", 28);
    fio_str_info_s new_state = FIO_NAME(FIO_STR_NAME, info)(pstr);
    FIO_ASSERT(old_state.len == new_state.len, "Frozen String length changed!");
    FIO_ASSERT(old_state.buf == new_state.buf,
               "Frozen String pointer changed!");
    FIO_ASSERT(
        old_state.capa == new_state.capa,
        "Frozen String capacity changed (allowed, but shouldn't happen)!");
    FIO_STR_THAW_(&str);
  }
  FIO_NAME(FIO_STR_NAME, printf)(pstr, " %u", 42);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(pstr), "Hello Big World! 42"),
             "`printf` data error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(pstr));

  {
    FIO_NAME(FIO_STR_NAME, s) str2 = FIO_STR_INIT;
    FIO_STR_PTR pstr2 = FIO_PTR_TAG(&str2);
    FIO_NAME(FIO_STR_NAME, concat)(pstr2, pstr);
    FIO_ASSERT(FIO_NAME_BL(FIO_STR_NAME, eq)(pstr, pstr2),
               "`concat` error, strings not equal (%s != %s)!",
               FIO_NAME(FIO_STR_NAME, ptr)(pstr),
               FIO_NAME(FIO_STR_NAME, ptr)(pstr2));
    FIO_NAME(FIO_STR_NAME, write)(pstr2, ":extra data", 11);
    FIO_ASSERT(!FIO_NAME_BL(FIO_STR_NAME, eq)(pstr, pstr2),
               "`write` error after copy, strings equal "
               "((%zu)%s == (%zu)%s)!",
               FIO_NAME(FIO_STR_NAME, len)(pstr),
               FIO_NAME(FIO_STR_NAME, ptr)(pstr),
               FIO_NAME(FIO_STR_NAME, len)(pstr2),
               FIO_NAME(FIO_STR_NAME, ptr)(pstr2));

    FIO_NAME(FIO_STR_NAME, destroy)(pstr2);
  }

  FIO_NAME(FIO_STR_NAME, destroy)(pstr);

  FIO_NAME(FIO_STR_NAME, write_i)(pstr, -42);
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(pstr) == 3 &&
                 !memcmp("-42", FIO_NAME(FIO_STR_NAME, ptr)(pstr), 3),
             "write_i output error ((%zu) %s != -42)",
             FIO_NAME(FIO_STR_NAME, len)(pstr),
             FIO_NAME(FIO_STR_NAME, ptr)(pstr));
  FIO_NAME(FIO_STR_NAME, destroy)(pstr);
  {
    fprintf(stderr, "\t* Testing string `readfile`.\n");
    FIO_NAME(FIO_STR_NAME, s) *s = FIO_NAME(FIO_STR_NAME, new)();
    FIO_ASSERT(FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s),
               "error, string not allocated (%p)!",
               (void *)s);
    fio_str_info_s state = FIO_NAME(FIO_STR_NAME, readfile)(s, __FILE__, 0, 0);

    FIO_ASSERT(state.len && state.buf,
               "error, no data was read for file %s!",
               __FILE__);
#if defined(H___FIO_CSTL_COMBINED___H)
    FIO_ASSERT(!memcmp(state.buf,
                       "/* "
                       "******************************************************"
                       "***********************",
                       80),
               "content error, header mismatch!\n %s",
               state.buf);
#endif /* H___FIO_CSTL_COMBINED___H */
    fprintf(stderr, "\t* Testing UTF-8 validation and length.\n");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, utf8_valid)(s),
               "`utf8_valid` error, code in this file "
               "should be valid!");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, utf8_len)(s) &&
                   (FIO_NAME(FIO_STR_NAME, utf8_len)(s) <=
                    FIO_NAME(FIO_STR_NAME, len)(s)) &&
                   (FIO_NAME(FIO_STR_NAME, utf8_len)(s) >=
                    (FIO_NAME(FIO_STR_NAME, len)(s)) >> 1),
               "`utf8_len` error, invalid value (%zu / %zu!",
               FIO_NAME(FIO_STR_NAME, utf8_len)(s),
               FIO_NAME(FIO_STR_NAME, len)(s));

    if (1) {
      /* String content == whole file (this file) */
      intptr_t pos = -10;
      size_t len = 20;
      fprintf(stderr, "\t* Testing UTF-8 positioning.\n");

      FIO_ASSERT(FIO_NAME(FIO_STR_NAME, utf8_select)(s, &pos, &len) == 0,
                 "`select` returned error for negative "
                 "pos! (%zd, %zu)",
                 (ssize_t)pos,
                 len);
      FIO_ASSERT(pos ==
                     (intptr_t)state.len - 10, /* no UTF-8 bytes in this file */
                 "`utf8_select` error, negative position "
                 "invalid! (%zd)",
                 (ssize_t)pos);
      FIO_ASSERT(len == 10,
                 "`utf8_select` error, trancated length "
                 "invalid! (%zd)",
                 (ssize_t)len);
      pos = 10;
      len = 20;
      FIO_ASSERT(FIO_NAME(FIO_STR_NAME, utf8_select)(s, &pos, &len) == 0,
                 "`utf8_select` returned error! (%zd, %zu)",
                 (ssize_t)pos,
                 len);
      FIO_ASSERT(pos == 10,
                 "`utf8_select` error, position invalid! (%zd)",
                 (ssize_t)pos);
      FIO_ASSERT(len == 20,
                 "`utf8_select` error, length invalid! (%zd)",
                 (ssize_t)len);
    }
    FIO_NAME(FIO_STR_NAME, free)(s);
  }
  FIO_NAME(FIO_STR_NAME, destroy)(pstr);
  if (1) {
    /* Testing Static initialization and writing */
#if FIO_STR_OPTIMIZE4IMMUTABILITY
    FIO_NAME(FIO_STR_NAME, init_const)(pstr, "Welcome", 7);
#else
    str = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT_STATIC("Welcome");
#endif
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(pstr) == 0 ||
                   FIO_STR_IS_SMALL(&str),
               "Static string capacity non-zero.");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(pstr) > 0,
               "Static string length should be automatically calculated.");
    FIO_ASSERT(!FIO_NAME_BL(FIO_STR_NAME, allocated)(pstr),
               "Static strings shouldn't be dynamic.");
    FIO_NAME(FIO_STR_NAME, destroy)(pstr);

#if FIO_STR_OPTIMIZE4IMMUTABILITY
    FIO_NAME(FIO_STR_NAME, init_const)
    (pstr,
     "Welcome to a very long static string that should not fit within a "
     "containing struct... hopefuly",
     95);
#else
    str = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT_STATIC(
        "Welcome to a very long static string that should not fit within a "
        "containing struct... hopefuly");
#endif
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(pstr) == 0 ||
                   FIO_STR_IS_SMALL(&str),
               "Static string capacity non-zero.");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(pstr) > 0,
               "Static string length should be automatically calculated.");
    FIO_ASSERT(!FIO_NAME_BL(FIO_STR_NAME, allocated)(pstr),
               "Static strings shouldn't be dynamic.");
    FIO_NAME(FIO_STR_NAME, destroy)(pstr);

#if FIO_STR_OPTIMIZE4IMMUTABILITY
    FIO_NAME(FIO_STR_NAME, init_const)(pstr, "Welcome", 7);
#else
    str = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT_STATIC("Welcome");
#endif
    fio_str_info_s state = FIO_NAME(FIO_STR_NAME, write)(pstr, " Home", 5);
    FIO_ASSERT(state.capa > 0, "Static string not converted to non-static.");
    FIO_ASSERT(FIO_NAME_BL(FIO_STR_NAME, allocated)(pstr) ||
                   FIO_STR_IS_SMALL(&str),
               "String should be dynamic after `write`.");

    char *cstr = FIO_NAME(FIO_STR_NAME, detach)(pstr);
    FIO_ASSERT(cstr, "`detach` returned NULL");
    FIO_ASSERT(!memcmp(cstr, "Welcome Home\0", 13),
               "`detach` string error: %s",
               cstr);
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(pstr) == 0,
               "`detach` data wasn't cleared.");
    FIO_NAME(FIO_STR_NAME, destroy)(pstr); /*not really needed... detached... */
    FIO_NAME(FIO_STR_NAME, dealloc)(cstr);
  }
  {
    fprintf(stderr, "\t* Testing Base64 encoding / decoding.\n");
    FIO_NAME(FIO_STR_NAME, destroy)(pstr); /* does nothing, but why not... */

    FIO_NAME(FIO_STR_NAME, s) b64message = FIO_STR_INIT;
    fio_str_info_s b64i = FIO_NAME(FIO_STR_NAME, write)(
        FIO_PTR_TAG(&b64message),
        "Hello World, this is the voice of peace:)",
        41);
    for (size_t i = 0; i < 256; ++i) {
      uint8_t c = i;
      b64i = FIO_NAME(FIO_STR_NAME, write)(FIO_PTR_TAG(&b64message), &c, 1);
      FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(FIO_PTR_TAG(&b64message)) ==
                     (size_t)(42 + i),
                 "Base64 message length error (%zu != %zu)",
                 FIO_NAME(FIO_STR_NAME, len)(FIO_PTR_TAG(&b64message)),
                 (size_t)(42 + i));
      FIO_ASSERT(FIO_NAME(FIO_STR_NAME,
                          ptr)(FIO_PTR_TAG(&b64message))[41 + i] == (char)c,
                 "Base64 message data error");
    }
    fio_str_info_s encoded =
        FIO_NAME(FIO_STR_NAME, write_base64enc)(pstr, b64i.buf, b64i.len, 1);
    /* prevent encoded data from being deallocated during unencoding */
    encoded = FIO_NAME(FIO_STR_NAME, FIO_STR_RESERVE_NAME)(
        pstr,
        encoded.len + ((encoded.len >> 2) * 3) + 8);
    fio_str_info_s decoded;
    {
      FIO_NAME(FIO_STR_NAME, s) tmps;
      FIO_NAME(FIO_STR_NAME, init_copy2)(FIO_PTR_TAG(&tmps), pstr);
      decoded = FIO_NAME(FIO_STR_NAME, write_base64dec)(
          pstr,
          FIO_NAME(FIO_STR_NAME, ptr)(FIO_PTR_TAG(&tmps)),
          FIO_NAME(FIO_STR_NAME, len)(FIO_PTR_TAG(&tmps)));
      FIO_NAME(FIO_STR_NAME, destroy)(FIO_PTR_TAG(&tmps));
      encoded.buf = decoded.buf;
    }
    FIO_ASSERT(encoded.len, "Base64 encoding failed");
    FIO_ASSERT(decoded.len > encoded.len,
               "Base64 decoding failed:\n%s",
               encoded.buf);
    FIO_ASSERT(b64i.len == decoded.len - encoded.len,
               "Base 64 roundtrip length error, %zu != %zu (%zu - %zu):\n %s",
               b64i.len,
               decoded.len - encoded.len,
               decoded.len,
               encoded.len,
               decoded.buf);

    FIO_ASSERT(!memcmp(b64i.buf, decoded.buf + encoded.len, b64i.len),
               "Base 64 roundtrip failed:\n %s",
               decoded.buf);
    FIO_NAME(FIO_STR_NAME, destroy)(FIO_PTR_TAG(&b64message));
    FIO_NAME(FIO_STR_NAME, destroy)(pstr);
  }
  {
    fprintf(stderr,
            "\t* Testing JSON style character escaping / unescaping.\n");
    FIO_NAME(FIO_STR_NAME, s) unescaped = FIO_STR_INIT;
    fio_str_info_s ue;
    const char *utf8_sample = /* three hearts, small-big-small*/
        "\xf0\x9f\x92\x95\xe2\x9d\xa4\xef\xb8\x8f\xf0\x9f\x92\x95";
    FIO_NAME(FIO_STR_NAME, write)
    (FIO_PTR_TAG(&unescaped), utf8_sample, FIO_STRLEN(utf8_sample));
    for (size_t i = 0; i < 256; ++i) {
      uint8_t c = i;
      ue = FIO_NAME(FIO_STR_NAME, write)(FIO_PTR_TAG(&unescaped), &c, 1);
    }
    fio_str_info_s encoded =
        FIO_NAME(FIO_STR_NAME, write_escape)(pstr, ue.buf, ue.len);
    // fprintf(stderr, "* %s\n", encoded.buf);
    fio_str_info_s decoded;
    {
      FIO_NAME(FIO_STR_NAME, s) tmps;
      FIO_NAME(FIO_STR_NAME, init_copy2)(&tmps, pstr);
      decoded = FIO_NAME(FIO_STR_NAME,
                         write_unescape)(pstr,
                                         FIO_NAME(FIO_STR_NAME, ptr)(&tmps),
                                         FIO_NAME(FIO_STR_NAME, len)(&tmps));
      FIO_NAME(FIO_STR_NAME, destroy)(&tmps);
      encoded.buf = decoded.buf;
    }
    FIO_ASSERT(!memcmp(encoded.buf, utf8_sample, FIO_STRLEN(utf8_sample)),
               "valid UTF-8 data shouldn't be escaped:\n%.*s\n%s",
               (int)encoded.len,
               encoded.buf,
               decoded.buf);
    FIO_ASSERT(encoded.len, "JSON encoding failed");
    FIO_ASSERT(decoded.len > encoded.len,
               "JSON decoding failed:\n%s",
               encoded.buf);
    FIO_ASSERT(ue.len == decoded.len - encoded.len,
               "JSON roundtrip length error, %zu != %zu (%zu - %zu):\n %s",
               ue.len,
               decoded.len - encoded.len,
               decoded.len,
               encoded.len,
               decoded.buf);

    FIO_ASSERT(!memcmp(ue.buf, decoded.buf + encoded.len, ue.len),
               "JSON roundtrip failed:\n %s",
               decoded.buf);
    FIO_NAME(FIO_STR_NAME, destroy)(FIO_PTR_TAG(&unescaped));
    FIO_NAME(FIO_STR_NAME, destroy)(pstr);
  }
}
#undef FIO__STR_SMALL_CAPA
#undef FIO_STR_WRITE_TEST_FUNC
#endif /* FIO_STR_WRITE_TEST_FUNC */

/* *****************************************************************************
String Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */

#undef FIO_STR_SMALL
#undef FIO_STR_SMALL_CAPA
#undef FIO_STR_SMALL_DATA
#undef FIO_STR_SMALL_LEN
#undef FIO_STR_SMALL_LEN_SET

#undef FIO_STR_BIG_CAPA
#undef FIO_STR_BIG_CAPA_SET
#undef FIO_STR_BIG_DATA
#undef FIO_STR_BIG_FREE_BUF
#undef FIO_STR_BIG_IS_DYNAMIC
#undef FIO_STR_BIG_LEN
#undef FIO_STR_BIG_LEN_SET
#undef FIO_STR_BIG_SET_STATIC

#undef FIO_STR_FREEZE_

#undef FIO_STR_IS_FROZEN
#undef FIO_STR_IS_SMALL
#undef FIO_STR_NAME

#undef FIO_STR_OPTIMIZE4IMMUTABILITY
#undef FIO_STR_OPTIMIZE_EMBEDDED
#undef FIO_STR_PTR
#undef FIO_STR_THAW_
#undef FIO_STR_RESERVE_NAME

#endif /* FIO_STR_NAME */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_ARRAY_NAME ary     /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                            Dynamic Arrays



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#ifdef FIO_ARRAY_NAME

#ifndef FIO_ARRAY_NOT_FOUND
#define FIO_ARRAY_NOT_FOUND ((uint32_t)-1)
#endif

#ifdef FIO_ARRAY_TYPE_STR
#ifndef FIO_ARRAY_TYPE
#define FIO_ARRAY_TYPE fio_keystr_s
#endif
#ifndef FIO_ARRAY_TYPE_COPY
#define FIO_ARRAY_TYPE_COPY(dest, src) ((dest) = fio_keystr_init((src)))
#endif
#ifndef FIO_ARRAY_TYPE_DESTROY
#define FIO_ARRAY_TYPE_DESTROY(obj) fio_keystr_destroy(&(obj));
#endif
#ifndef FIO_ARRAY_TYPE_CMP
#define FIO_ARRAY_TYPE_CMP(a, b) fio_keystr_is_eq((a), (b))
#endif
#undef FIO_ARRAY_DESTROY_AFTER_COPY
#define FIO_ARRAY_DESTROY_AFTER_COPY 1
#endif

#ifndef FIO_ARRAY_TYPE
/** The type for array elements (an array of FIO_ARRAY_TYPE) */
#define FIO_ARRAY_TYPE void *
/** An invalid value for that type (if any). */
#define FIO_ARRAY_TYPE_INVALID        NULL
#define FIO_ARRAY_TYPE_INVALID_SIMPLE 1
#else
#ifndef FIO_ARRAY_TYPE_INVALID
/** An invalid value for that type (if any). */
#define FIO_ARRAY_TYPE_INVALID        ((FIO_ARRAY_TYPE){0})
/* internal flag - do not set */
#define FIO_ARRAY_TYPE_INVALID_SIMPLE 1
#endif
#endif

#ifndef FIO_ARRAY_TYPE_INVALID_SIMPLE
/** Is the FIO_ARRAY_TYPE_INVALID object memory is all zero? (yes = 1) */
#define FIO_ARRAY_TYPE_INVALID_SIMPLE 0
#endif

#ifndef FIO_ARRAY_TYPE_COPY
/** Handles a copy operation for an array's element. */
#define FIO_ARRAY_TYPE_COPY(dest, src) (dest) = (src)
/* internal flag - do not set */
#define FIO_ARRAY_TYPE_COPY_SIMPLE 1
#endif

#ifndef FIO_ARRAY_TYPE_DESTROY
/** Handles a destroy / free operation for an array's element. */
#define FIO_ARRAY_TYPE_DESTROY(obj)
/* internal flag - do not set */
#define FIO_ARRAY_TYPE_DESTROY_SIMPLE 1
#endif

#ifndef FIO_ARRAY_TYPE_CMP
/** Handles a comparison operation for an array's element. */
#define FIO_ARRAY_TYPE_CMP(a, b) (a) == (b)
/* internal flag - do not set */
#define FIO_ARRAY_TYPE_CMP_SIMPLE 1
#endif

#ifndef FIO_ARRAY_TYPE_CONCAT_COPY
#define FIO_ARRAY_TYPE_CONCAT_COPY        FIO_ARRAY_TYPE_COPY
#define FIO_ARRAY_TYPE_CONCAT_COPY_SIMPLE FIO_ARRAY_TYPE_COPY_SIMPLE
#endif
/**
 * The FIO_ARRAY_DESTROY_AFTER_COPY macro should be set if
 * FIO_ARRAY_TYPE_DESTROY should be called after FIO_ARRAY_TYPE_COPY when an
 * object is removed from the array after being copied to an external container
 * (an `old` pointer)
 */
#ifndef FIO_ARRAY_DESTROY_AFTER_COPY
#if !FIO_ARRAY_TYPE_DESTROY_SIMPLE && !FIO_ARRAY_TYPE_COPY_SIMPLE
#define FIO_ARRAY_DESTROY_AFTER_COPY 1
#else
#define FIO_ARRAY_DESTROY_AFTER_COPY 0
#endif
#endif

/* Extra empty slots when allocating memory. */
#ifndef FIO_ARRAY_PADDING
#define FIO_ARRAY_PADDING 4
#endif

/*
 * Uses the array structure to embed object, if there's space for them.
 *
 * This optimizes small arrays and specifically touplets. For `void *` type
 * arrays this allows for 2 objects to be embedded, resulting in faster access
 * due to cache locality and reduced pointer redirection.
 *
 * For large arrays, it is better to disable this feature.
 *
 * Note: values larger than 1 add a memory allocation cost to the array
 * container, adding enough room for at least `FIO_ARRAY_ENABLE_EMBEDDED - 1`
 * items.
 */
#ifndef FIO_ARRAY_ENABLE_EMBEDDED
#define FIO_ARRAY_ENABLE_EMBEDDED 1
#endif

/* Sets memory growth to exponentially increase. Consumes more memory. */
#ifndef FIO_ARRAY_EXPONENTIAL
#define FIO_ARRAY_EXPONENTIAL 0
#endif

#undef FIO_ARRAY_SIZE2WORDS
#define FIO_ARRAY_SIZE2WORDS(size)                                             \
  ((sizeof(FIO_ARRAY_TYPE) & 1)   ? (((size) & (~15)) + 16)                    \
   : (sizeof(FIO_ARRAY_TYPE) & 2) ? (((size) & (~7)) + 8)                      \
   : (sizeof(FIO_ARRAY_TYPE) & 4) ? (((size) & (~3)) + 4)                      \
   : (sizeof(FIO_ARRAY_TYPE) & 8) ? (((size) & (~1)) + 2)                      \
                                  : (size))

/* *****************************************************************************
Dynamic Arrays - type
***************************************************************************** */

/** an Array type. */
typedef struct FIO_NAME(FIO_ARRAY_NAME, s) {
  /* start common header (with embedded array type) */
  /** the offset to the first item. */
  uint32_t start;
  /** The offset to the first empty location the array. */
  uint32_t end;
  /* end common header (with embedded array type) */
  /** The array's capacity - limited to 32bits, but we use the extra padding. */
  uint32_t capa;
  /** a pointer to the array's memory (if not embedded) */
  FIO_ARRAY_TYPE *ary;
#if FIO_ARRAY_ENABLE_EMBEDDED > 1
  /** Do we wanted larger small-array optimizations? */
  FIO_ARRAY_TYPE
  extra_memory_for_embedded_arrays[(FIO_ARRAY_ENABLE_EMBEDDED - 1)]
#endif
} FIO_NAME(FIO_ARRAY_NAME, s);

#ifdef FIO_PTR_TAG_TYPE
#define FIO_ARRAY_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, s) *
#endif

/* *****************************************************************************
Dynamic Arrays - API
***************************************************************************** */

#ifndef FIO_ARRAY_INIT
/* Initialization macro. */
#define FIO_ARRAY_INIT                                                         \
  { 0 }
#endif

#ifndef FIO_REF_CONSTRUCTOR_ONLY

/* Allocates a new array object on the heap and initializes it's memory. */
SFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, new)(void);

/* Frees an array's internal data AND it's container! */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, free)(FIO_ARRAY_PTR ary);

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/* Destroys any objects stored in the array and frees the internal state. */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, destroy)(FIO_ARRAY_PTR ary);

/** Returns the number of elements in the Array. */
FIO_IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, count)(FIO_ARRAY_PTR ary);

/** Returns the current, temporary, array capacity (it's dynamic). */
FIO_IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, capa)(FIO_ARRAY_PTR ary);

/**
 * Returns 1 if the array is embedded, 0 if it has memory allocated and -1 on an
 * error.
 */
FIO_IFUNC int FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(FIO_ARRAY_PTR ary);

/**
 * Returns a pointer to the C array containing the objects.
 */
FIO_IFUNC FIO_ARRAY_TYPE *FIO_NAME2(FIO_ARRAY_NAME, ptr)(FIO_ARRAY_PTR ary);

/**
 * Reserves a minimal capacity for additional elements to be added to the array.
 *
 * If `capa` is negative, new memory will be allocated at the beginning of the
 * array rather then it's end.
 *
 * Returns the array's new capacity.
 */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, reserve)(FIO_ARRAY_PTR ary,
                                                 int64_t capa);

/**
 * Adds all the items in the `src` Array to the end of the `dest` Array.
 *
 * The `src` Array remain untouched.
 *
 * Always returns the destination array (`dest`).
 */
SFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, concat)(FIO_ARRAY_PTR dest,
                                                     FIO_ARRAY_PTR src);

/**
 * Sets `index` to the value in `data`.
 *
 * If `index` is negative, it will be counted from the end of the Array (-1 ==
 * last element).
 *
 * If `old` isn't NULL, the existing data will be copied to the location pointed
 * to by `old` before the copy in the Array is destroyed.
 *
 * Returns a pointer to the new object, or NULL on error.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, set)(FIO_ARRAY_PTR ary,
                                                    int64_t index,
                                                    FIO_ARRAY_TYPE data,
                                                    FIO_ARRAY_TYPE *old);

/**
 * Returns the value located at `index` (no copying is performed).
 *
 * If `index` is negative, it will be counted from the end of the Array (-1 ==
 * last element).
 */
FIO_IFUNC FIO_ARRAY_TYPE FIO_NAME(FIO_ARRAY_NAME, get)(FIO_ARRAY_PTR ary,
                                                       int64_t index);

/**
 * Returns the index of the object or (uint32_t)-1 if the object wasn't found.
 *
 * If `start_at` is negative (i.e., -1), than seeking will be performed in
 * reverse, where -1 == last index (-2 == second to last, etc').
 */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, find)(FIO_ARRAY_PTR ary,
                                              FIO_ARRAY_TYPE data,
                                              int64_t start_at);

/**
 * Removes an object from the array, MOVING all the other objects to prevent
 * "holes" in the data.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns 0 on success and -1 on error.
 *
 * This action is O(n) where n in the length of the array.
 * It could get expensive.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, remove)(FIO_ARRAY_PTR ary,
                                           int64_t index,
                                           FIO_ARRAY_TYPE *old);

/**
 * Removes all occurrences of an object from the array (if any), MOVING all the
 * existing objects to prevent "holes" in the data.
 *
 * Returns the number of items removed.
 *
 * This action is O(n) where n in the length of the array.
 * It could get expensive.
 */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, remove2)(FIO_ARRAY_PTR ary,
                                                 FIO_ARRAY_TYPE data);

/** Attempts to lower the array's memory consumption. */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, compact)(FIO_ARRAY_PTR ary);

/**
 * Pushes an object to the end of the Array. Returns a pointer to the new object
 * or NULL on error.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, push)(FIO_ARRAY_PTR ary,
                                                     FIO_ARRAY_TYPE data);

/**
 * Removes an object from the end of the Array.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns -1 on error (Array is empty) and 0 on success.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, pop)(FIO_ARRAY_PTR ary, FIO_ARRAY_TYPE *old);

/**
 * Unshifts an object to the beginning of the Array. Returns a pointer to the
 * new object or NULL on error.
 *
 * This could be expensive, causing `memmove`.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, unshift)(FIO_ARRAY_PTR ary,
                                                        FIO_ARRAY_TYPE data);

/**
 * Removes an object from the beginning of the Array.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns -1 on error (Array is empty) and 0 on success.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, shift)(FIO_ARRAY_PTR ary,
                                          FIO_ARRAY_TYPE *old);

/** Iteration information structure passed to the callback. */
typedef struct FIO_NAME(FIO_ARRAY_NAME, each_s) {
  /** The array iterated. Once set, cannot be safely changed. */
  FIO_ARRAY_PTR const parent;
  /** The current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct FIO_NAME(FIO_ARRAY_NAME, each_s) * info);
  /** Opaque user data. */
  void *udata;
  /** The object / value at the current index. */
  FIO_ARRAY_TYPE value;
  /* memory padding used for FIOBJ */
  uint64_t padding;
} FIO_NAME(FIO_ARRAY_NAME, each_s);

/**
 * Iteration using a callback for each entry in the array.
 *
 * The callback task function must accept an each_s pointer, see above.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME,
                        each)(FIO_ARRAY_PTR ary,
                              int (*task)(FIO_NAME(FIO_ARRAY_NAME, each_s) *
                                          info),
                              void *udata,
                              int64_t start_at);

#ifndef FIO_ARRAY_EACH
/**
 * Iterates through the array using a `for` loop.
 *
 * Access the object with the pointer `pos`. The `pos` variable can be named
 * however you please.
 *
 * Avoid editing the array during a FOR loop, although I hope it's possible, I
 * wouldn't count on it.
 *
 * **Note**: this variant supports automatic pointer tagging / untagging.
 */
#define FIO_ARRAY_EACH(array_name, array, pos)                                 \
  for (FIO_NAME(array_name, ____type_t)                                        \
           *first___ai = NULL,                                                 \
           *pos = FIO_NAME(array_name, each_next)((array), &first___ai, NULL); \
       pos;                                                                    \
       pos = FIO_NAME(array_name, each_next)((array), &first___ai, pos))
#endif

/**
 * Returns a pointer to the (next) object in the array.
 *
 * Returns a pointer to the first object if `pos == NULL` and there are objects
 * in the array.
 *
 * The first pointer is automatically set and it allows object insertions and
 * memory effecting functions to be called from within the loop.
 *
 * If the object in `pos` (or an object before it) were removed, consider
 * passing `pos-1` to the function, to avoid skipping any elements while
 * looping.
 *
 * Returns the next object if both `first` and `pos` are valid.
 *
 * Returns NULL if `pos` was the last object or no object exist.
 *
 * Returns the first object if either `first` or `pos` are invalid.
 *
 */
FIO_IFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME,
                                   each_next)(FIO_ARRAY_PTR ary,
                                              FIO_ARRAY_TYPE **first,
                                              FIO_ARRAY_TYPE *pos);

/* *****************************************************************************
Dynamic Arrays - embedded arrays
***************************************************************************** */
typedef struct {
  /* start common header */
  /** the offset to the first item. */
  uint32_t start;
  /** The offset to the first empty location the array. */
  uint32_t end;
  /* end common header */
  FIO_ARRAY_TYPE embedded[];
} FIO_NAME(FIO_ARRAY_NAME, ___embedded_s);

#define FIO_ARRAY2EMBEDDED(a) ((FIO_NAME(FIO_ARRAY_NAME, ___embedded_s) *)(a))

#if FIO_ARRAY_ENABLE_EMBEDDED
#define FIO_ARRAY_IS_EMBEDDED(a)                                               \
  ((sizeof(FIO_ARRAY_TYPE) +                                                   \
    sizeof(FIO_NAME(FIO_ARRAY_NAME, ___embedded_s))) <=                        \
       sizeof(FIO_NAME(FIO_ARRAY_NAME, s)) &&                                  \
   (((a)->start > (a)->end) || !(a)->ary))
#define FIO_ARRAY_IS_EMBEDDED_PTR(ary, ptr)                                    \
  ((sizeof(FIO_ARRAY_TYPE) +                                                   \
    sizeof(FIO_NAME(FIO_ARRAY_NAME, ___embedded_s))) <=                        \
       sizeof(FIO_NAME(FIO_ARRAY_NAME, s)) &&                                  \
   (uintptr_t)(ptr) > (uintptr_t)(ary) &&                                      \
   (uintptr_t)(ptr) < (uintptr_t)((ary) + 1))
#define FIO_ARRAY_EMBEDDED_CAPA                                                \
  ((sizeof(FIO_ARRAY_TYPE) +                                                   \
    sizeof(FIO_NAME(FIO_ARRAY_NAME, ___embedded_s))) >                         \
           sizeof(FIO_NAME(FIO_ARRAY_NAME, s))                                 \
       ? 0                                                                     \
       : ((sizeof(FIO_NAME(FIO_ARRAY_NAME, s)) -                               \
           sizeof(FIO_NAME(FIO_ARRAY_NAME, ___embedded_s))) /                  \
          sizeof(FIO_ARRAY_TYPE)))

#else
#define FIO_ARRAY_IS_EMBEDDED(a)            0
#define FIO_ARRAY_IS_EMBEDDED_PTR(ary, ptr) 0
#define FIO_ARRAY_EMBEDDED_CAPA             0

#endif /* FIO_ARRAY_ENABLE_EMBEDDED */
/* *****************************************************************************
Inlined functions
***************************************************************************** */
/** Returns the number of elements in the Array. */
FIO_IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, count)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN(ary_, 0);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0: return ary->end - ary->start;
  case 1: return ary->start;
  }
  return 0;
}

/** Returns the current, temporary, array capacity (it's dynamic). */
FIO_IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, capa)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN(ary_, 0);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0: return (uint32_t)ary->capa;
  case 1: return FIO_ARRAY_EMBEDDED_CAPA;
  }
  return 0;
}

/**
 * Returns a pointer to the C array containing the objects.
 */
FIO_IFUNC FIO_ARRAY_TYPE *FIO_NAME2(FIO_ARRAY_NAME, ptr)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN(ary_, NULL);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0: return ary->ary + ary->start;
  case 1: return FIO_ARRAY2EMBEDDED(ary)->embedded;
  }
  return NULL;
}

/**
 * Returns 1 if the array is embedded, 0 if it has memory allocated and -1 on an
 * error.
 */
FIO_IFUNC int FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN(ary_, -1);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  return FIO_ARRAY_IS_EMBEDDED(ary);
  (void)ary; /* if unused (never embedded) */
}

/**
 * Returns the value located at `index` (no copying is performed).
 *
 * If `index` is negative, it will be counted from the end of the Array (-1 ==
 * last element).
 */
FIO_IFUNC FIO_ARRAY_TYPE FIO_NAME(FIO_ARRAY_NAME, get)(FIO_ARRAY_PTR ary_,
                                                       int64_t index) {
  FIO_PTR_TAG_VALID_OR_RETURN(ary_, FIO_ARRAY_TYPE_INVALID);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  FIO_ARRAY_TYPE *a;
  size_t count;
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    a = ary->ary + ary->start;
    count = ary->end - ary->start;
    break;
  case 1:
    a = FIO_ARRAY2EMBEDDED(ary)->embedded;
    count = ary->start;
    break;
  default: return FIO_ARRAY_TYPE_INVALID;
  }

  if (index < 0) {
    index += count;
    if (index < 0)
      return FIO_ARRAY_TYPE_INVALID;
  }
  if ((uint32_t)index >= count)
    return FIO_ARRAY_TYPE_INVALID;
  return a[index];
}

/* Returns a pointer to the (next) object in the array. */
FIO_IFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME,
                                   each_next)(FIO_ARRAY_PTR ary_,
                                              FIO_ARRAY_TYPE **first,
                                              FIO_ARRAY_TYPE *pos) {
  FIO_PTR_TAG_VALID_OR_RETURN(ary_, NULL);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  int64_t count;
  FIO_ARRAY_TYPE *a;
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    count = ary->end - ary->start;
    a = ary->ary + ary->start;
    break;
  case 1:
    count = ary->start;
    a = FIO_ARRAY2EMBEDDED(ary)->embedded;
    break;
  default: return NULL;
  }
  intptr_t i;
  if (!count || !first)
    return NULL;
  if (!pos || !(*first) || (*first) > pos) {
    i = -1;
  } else {
    i = (intptr_t)(pos - (*first));
  }
  *first = a;
  ++i;
  if (i >= count)
    return NULL;
  return i + a;
}

/** Used internally for the EACH macro */
typedef FIO_ARRAY_TYPE FIO_NAME(FIO_ARRAY_NAME, ____type_t);

/* *****************************************************************************
Exported functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
/* *****************************************************************************
Helper macros
***************************************************************************** */
#if FIO_ARRAY_EXPONENTIAL
#define FIO_ARRAY_ADD2CAPA(capa) (((capa) << 1) + FIO_ARRAY_PADDING)
#else
#define FIO_ARRAY_ADD2CAPA(capa) ((capa) + FIO_ARRAY_PADDING)
#endif

/* *****************************************************************************
Dynamic Arrays - internal helpers
***************************************************************************** */

#define FIO_ARRAY_POS2ABS(ary, pos)                                            \
  (pos >= 0 ? (ary->start + pos) : (ary->end - pos))

#define FIO_ARRAY_AB_CT(cond, a, b) ((b) ^ ((0 - ((cond)&1)) & ((a) ^ (b))))

FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_ARRAY_NAME, s))
FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_ARRAY_NAME, destroy))
/* *****************************************************************************
Dynamic Arrays - implementation
***************************************************************************** */

#ifndef FIO_REF_CONSTRUCTOR_ONLY
/* Allocates a new array object on the heap and initializes it's memory. */
SFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, new)(void) {
  FIO_NAME(FIO_ARRAY_NAME, s) *a =
      (FIO_NAME(FIO_ARRAY_NAME, s) *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*a), 0);
  if (!FIO_MEM_REALLOC_IS_SAFE_ && a) {
    *a = (FIO_NAME(FIO_ARRAY_NAME, s))FIO_ARRAY_INIT;
  }
  FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_ARRAY_NAME, s));
  return (FIO_ARRAY_PTR)FIO_PTR_TAG(a);
}

/* Frees an array's internal data AND it's container! */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, free)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(ary_);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  FIO_NAME(FIO_ARRAY_NAME, destroy)(ary_);
  FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_ARRAY_NAME, s));
  FIO_MEM_FREE_(ary, sizeof(*ary));
}
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/* Destroys any objects stored in the array and frees the internal state. */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, destroy)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(ary_);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  union {
    FIO_NAME(FIO_ARRAY_NAME, s) a;
    FIO_NAME(FIO_ARRAY_NAME, ___embedded_s) e;
  } tmp = {.a = *ary};
  *ary = (FIO_NAME(FIO_ARRAY_NAME, s))FIO_ARRAY_INIT;

  switch (
      FIO_NAME_BL(FIO_ARRAY_NAME, embedded)((FIO_ARRAY_PTR)FIO_PTR_TAG(&tmp))) {
  case 0:
    if (tmp.a.ary) {
#if !FIO_ARRAY_TYPE_DESTROY_SIMPLE
      for (size_t i = tmp.a.start; i < tmp.a.end; ++i) {
        FIO_ARRAY_TYPE_DESTROY(tmp.a.ary[i]);
      }
#endif
      FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_ARRAY_NAME, destroy));
      FIO_MEM_FREE_(tmp.a.ary, tmp.a.capa * sizeof(*tmp.a.ary));
    }
    return;
  case 1:
#if !FIO_ARRAY_TYPE_DESTROY_SIMPLE
    while (tmp.e.start--) {
      FIO_ARRAY_TYPE_DESTROY((tmp.e.embedded[tmp.e.start]));
    }
#endif
    return;
  }
  return;
}

/** Reserves a minimal capacity for the array. */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, reserve)(FIO_ARRAY_PTR ary_,
                                                 int64_t capa_) {
  FIO_PTR_TAG_VALID_OR_RETURN(ary_, 0);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  if (capa_ > UINT32_MAX || capa_ < ((int64_t)0LL - UINT32_MAX))
    return ary->capa;
  uint32_t abs_capa = ((capa_ >= 0) ? (uint32_t)capa_ : (uint32_t)(0 - capa_));
  uint32_t capa;
  FIO_ARRAY_TYPE *tmp;
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    abs_capa += ary->end - ary->start;
    capa = FIO_ARRAY_SIZE2WORDS((abs_capa));
    if (abs_capa <= ary->capa)
      return (uint32_t)ary->capa;
    /* objects don't move, use only realloc */
    if ((capa_ >= 0) || (capa_ < 0 && ary->start > 0)) {
      tmp = (FIO_ARRAY_TYPE *)FIO_MEM_REALLOC_(ary->ary,
                                               0,
                                               sizeof(*tmp) * capa,
                                               sizeof(*tmp) * ary->end);
      if (!tmp)
        return (uint32_t)ary->capa;
      if (!ary->ary)
        FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_ARRAY_NAME, destroy));
      ary->capa = capa;
      ary->ary = tmp;
      return capa;
    } else { /* moving objects, starting with a fresh piece of memory */
      tmp = (FIO_ARRAY_TYPE *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*tmp) * capa, 0);
      const uint32_t count = ary->end - ary->start;
      if (!tmp)
        return (uint32_t)ary->capa;
      if (!ary->ary)
        FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_ARRAY_NAME, destroy));
      if (capa_ >= 0) { /* copy items at beginning of memory stack */
        if (count) {
          FIO_MEMCPY(tmp, ary->ary + ary->start, count * sizeof(*tmp));
        }
        FIO_MEM_FREE_(ary->ary, sizeof(*ary->ary) * ary->capa);
        *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
            .start = 0,
            .end = count,
            .capa = capa,
            .ary = tmp,
        };
        return capa;
      } else { /* copy items at ending of memory stack */
        if (count) {
          FIO_MEMCPY(tmp + (capa - count),
                     ary->ary + ary->start,
                     count * sizeof(*tmp));
        }
        FIO_MEM_FREE_(ary->ary, sizeof(*ary->ary) * ary->capa);
        *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
            .start = (capa - count),
            .end = capa,
            .capa = capa,
            .ary = tmp,
        };
      }
    }
    return capa;
  case 1:
    abs_capa += ary->start;
    capa = FIO_ARRAY_SIZE2WORDS((abs_capa));
    if (abs_capa <= FIO_ARRAY_EMBEDDED_CAPA)
      return FIO_ARRAY_EMBEDDED_CAPA;
    tmp = (FIO_ARRAY_TYPE *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*tmp) * capa, 0);
    if (!tmp)
      return FIO_ARRAY_EMBEDDED_CAPA;
    FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_ARRAY_NAME, destroy));
    if (capa_ >= 0) {
      /* copy items at beginning of memory stack */
      if (ary->start) {
        FIO_MEMCPY(tmp,
                   FIO_ARRAY2EMBEDDED(ary)->embedded,
                   ary->start * sizeof(*tmp));
      }
      *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
          .start = 0,
          .end = ary->start,
          .capa = capa,
          .ary = tmp,
      };
      return capa;
    }
    /* copy items at ending of memory stack */
    if (ary->start) {
      FIO_MEMCPY(tmp + (capa - ary->start),
                 FIO_ARRAY2EMBEDDED(ary)->embedded,
                 ary->start * sizeof(*tmp));
    }
    *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
        .start = (capa - ary->start),
        .end = capa,
        .capa = capa,
        .ary = tmp,
    };
    return capa;
  default: return 0;
  }
}

/**
 * Adds all the items in the `src` Array to the end of the `dest` Array.
 *
 * The `src` Array remain untouched.
 *
 * Returns `dest` on success or NULL on error (i.e., no memory).
 */
SFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, concat)(FIO_ARRAY_PTR dest_,
                                                     FIO_ARRAY_PTR src_) {
  FIO_PTR_TAG_VALID_OR_RETURN(dest_, (FIO_ARRAY_PTR)NULL);
  FIO_PTR_TAG_VALID_OR_RETURN(src_, (FIO_ARRAY_PTR)NULL);
  FIO_NAME(FIO_ARRAY_NAME, s) *dest =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), dest_);
  FIO_NAME(FIO_ARRAY_NAME, s) *src =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), src_);
  if (!dest || !src)
    return dest_;
  const uint32_t offset = FIO_NAME(FIO_ARRAY_NAME, count)(dest_);
  const uint32_t added = FIO_NAME(FIO_ARRAY_NAME, count)(src_);
  const uint32_t total = offset + added;
  if (!added)
    return dest_;

  if (total < offset || total + offset < total)
    return NULL; /* item count overflow */

  const uint32_t capa = FIO_NAME(FIO_ARRAY_NAME, reserve)(dest_, added);

  if (!FIO_ARRAY_IS_EMBEDDED(dest) && dest->start + total > capa) {
    /* we need to move the existing items due to the offset */
    FIO_MEMMOVE(dest->ary,
                dest->ary + dest->start,
                (dest->end - dest->start) * sizeof(*dest->ary));
    dest->start = 0;
    dest->end = offset;
  }
#if FIO_ARRAY_TYPE_CONCAT_COPY_SIMPLE
  /* copy data */
  FIO_MEMCPY(FIO_NAME2(FIO_ARRAY_NAME, ptr)(dest_) + offset,
             FIO_NAME2(FIO_ARRAY_NAME, ptr)(src_),
             added);
#else
  {
    FIO_ARRAY_TYPE *const a1 = FIO_NAME2(FIO_ARRAY_NAME, ptr)(dest_);
    FIO_ARRAY_TYPE *const a2 = FIO_NAME2(FIO_ARRAY_NAME, ptr)(src_);
    for (uint32_t i = 0; i < added; ++i) {
      FIO_ARRAY_TYPE_CONCAT_COPY(a1[i + offset], a2[i]);
    }
  }
#endif /* FIO_ARRAY_TYPE_CONCAT_COPY_SIMPLE */
  /* update dest */
  if (!FIO_ARRAY_IS_EMBEDDED(dest)) {
    dest->end += added;
    return dest_;
  } else
    dest->start = total;
  return dest_;
}

/**
 * Sets `index` to the value in `data`.
 *
 * If `index` is negative, it will be counted from the end of the Array (-1 ==
 * last element).
 *
 * If `old` isn't NULL, the existing data will be copied to the location pointed
 * to by `old` before the copy in the Array is destroyed.
 *
 * Returns a pointer to the new object, or NULL on error.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, set)(FIO_ARRAY_PTR ary_,
                                                    int64_t index,
                                                    FIO_ARRAY_TYPE data,
                                                    FIO_ARRAY_TYPE *old) {
  FIO_ARRAY_TYPE *a = NULL;
  FIO_NAME(FIO_ARRAY_NAME, s) * ary;
  uint32_t count;
  uint8_t pre_existing = 1;

  FIO_PTR_TAG_VALID_OR_GOTO(ary_, invalid);

  ary = FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);

  if (index < 0) {
    index += count;
    if (index < 0)
      goto negative_expansion;
  }

  if ((size_t)index > 0xFFFFFFFFULL)
    goto invalid;

  if ((uint32_t)index >= count) {
    if ((uint32_t)index == count)
      FIO_NAME(FIO_ARRAY_NAME, reserve)(ary_, FIO_ARRAY_ADD2CAPA(index));
    else
      FIO_NAME(FIO_ARRAY_NAME, reserve)(ary_, (uint32_t)index + 1);
    if (FIO_ARRAY_IS_EMBEDDED(ary))
      goto expand_embedded;
    goto expansion;
  }

  a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);

done:

  /* copy / clear object */
  if (pre_existing) {
    if (old) {
      FIO_ARRAY_TYPE_COPY(old[0], a[index]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(a[index]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(a[index]);
    }
  } else if (old) {
    FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY_TYPE_INVALID);
  }
  FIO_ARRAY_TYPE_COPY(a[index], FIO_ARRAY_TYPE_INVALID);
  FIO_ARRAY_TYPE_COPY(a[index], data);
  return a + index;

expansion:

  pre_existing = 0;
  a = ary->ary;
  {
    uint8_t was_moved = 0;
    /* test if we need to move objects to make room at the end */
    if (ary->start + (uint32_t)index >= ary->capa) {
      FIO_MEMMOVE(ary->ary, ary->ary + ary->start, (count) * sizeof(*ary->ary));
      ary->start = 0;
      ary->end = (uint32_t)index + 1;
      was_moved = 1;
    }
    /* initialize memory in between objects */
    if (was_moved || !FIO_MEM_REALLOC_IS_SAFE_ ||
        !FIO_ARRAY_TYPE_INVALID_SIMPLE) {
#if FIO_ARRAY_TYPE_INVALID_SIMPLE
      FIO_MEMSET(a + count, 0, ((uint32_t)index - count) * sizeof(*ary->ary));
#else
      for (size_t i = count; i <= (size_t)index; ++i) {
        FIO_ARRAY_TYPE_COPY(a[i], FIO_ARRAY_TYPE_INVALID);
      }
#endif
    }
    ary->end = (uint32_t)index + 1;
  }
  goto done;

expand_embedded:
  pre_existing = 0;
  ary->start = (uint32_t)index + 1;
  a = FIO_ARRAY2EMBEDDED(ary)->embedded;
  goto done;

negative_expansion:
  pre_existing = 0;
  FIO_NAME(FIO_ARRAY_NAME, reserve)(ary_, (index - count));
  index = 0 - index;
  if (index > ary->capa)
    goto invalid;
  if ((FIO_ARRAY_IS_EMBEDDED(ary)))
    goto negative_expansion_embedded;
  a = ary->ary;
  if (index > (int32_t)ary->start) {
    FIO_MEMMOVE(a + index, a + ary->start, count * sizeof(*a));
    ary->end = (uint32_t)index + count;
    ary->start = (uint32_t)index;
  }
  index = ary->start - (uint32_t)index;
  if ((uint32_t)(index + 1) < ary->start) {
#if FIO_ARRAY_TYPE_INVALID_SIMPLE
    FIO_MEMSET(a + index, 0, (ary->start - index) * (sizeof(*a)));
#else
    for (size_t i = index; i < (size_t)ary->start; ++i) {
      FIO_ARRAY_TYPE_COPY(a[i], FIO_ARRAY_TYPE_INVALID);
    }
#endif
  }
  ary->start = (uint32_t)index;
  goto done;

negative_expansion_embedded:
  a = FIO_ARRAY2EMBEDDED(ary)->embedded;
  FIO_MEMMOVE(a + index, a, count * count * sizeof(*a));
#if FIO_ARRAY_TYPE_INVALID_SIMPLE
  FIO_MEMSET(a, 0, index * (sizeof(a)));
#else
  for (size_t i = 0; i < (size_t)index; ++i) {
    FIO_ARRAY_TYPE_COPY(a[i], FIO_ARRAY_TYPE_INVALID);
  }
#endif
  index = 0;
  goto done;

invalid:
  FIO_ARRAY_TYPE_DESTROY(data);
  if (old) {
    FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY_TYPE_INVALID);
  }

  return a;
}

/**
 * Returns the index of the object or (uint32_t)-1 if the object wasn't found.
 *
 * If `start_at` is negative (i.e., -1), than seeking will be performed in
 * reverse, where -1 == last index (-2 == second to last, etc').
 */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, find)(FIO_ARRAY_PTR ary_,
                                              FIO_ARRAY_TYPE data,
                                              int64_t start_at) {
  FIO_ARRAY_TYPE *a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
  if (!a)
    return -1;
  size_t count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);
  if (start_at >= 0) {
    /* seek forwards */
    if ((uint32_t)start_at >= count)
      start_at = (int32_t)count;
    while ((uint32_t)start_at < count) {
      if (FIO_ARRAY_TYPE_CMP(a[start_at], data))
        return (uint32_t)start_at;
      ++start_at;
    }
  } else {
    /* seek backwards */
    if (start_at + (int32_t)count < 0)
      return -1;
    count += start_at;
    count += 1;
    while (count--) {
      if (FIO_ARRAY_TYPE_CMP(a[count], data))
        return (uint32_t)count;
    }
  }
  return -1;
}

/**
 * Removes an object from the array, MOVING all the other objects to prevent
 * "holes" in the data.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns 0 on success and -1 on error.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, remove)(FIO_ARRAY_PTR ary_,
                                           int64_t index,
                                           FIO_ARRAY_TYPE *old) {
  FIO_ARRAY_TYPE *a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  size_t count;
  if (!a)
    goto invalid;
  count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);

  if (index < 0) {
    index += count;
    if (index < 0) {
      FIO_LOG_WARNING(
          FIO_MACRO2STR(FIO_NAME(FIO_ARRAY_NAME,
                                 remove)) " called with a negative index lower "
                                          "than the element count.");
      goto invalid;
    }
  }
  if ((uint32_t)index >= count)
    goto invalid;
  if (!index) {
    FIO_NAME(FIO_ARRAY_NAME, shift)(ary_, old);
    return 0;
  }
  if ((uint32_t)index + 1 == count) {
    FIO_NAME(FIO_ARRAY_NAME, pop)(ary_, old);
    return 0;
  }

  if (old) {
    FIO_ARRAY_TYPE_COPY(*old, a[index]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
    FIO_ARRAY_TYPE_DESTROY(a[index]);
#endif
  } else {
    FIO_ARRAY_TYPE_DESTROY(a[index]);
  }

  if ((uint32_t)(index + 1) < count) {
    FIO_MEMMOVE(a + index, a + index + 1, (count - (index + 1)) * sizeof(*a));
  }
  FIO_ARRAY_TYPE_COPY((a + (count - 1))[0], FIO_ARRAY_TYPE_INVALID);

  if (FIO_ARRAY_IS_EMBEDDED(ary))
    goto embedded;
  --ary->end;
  return 0;

embedded:
  --ary->start;
  return 0;

invalid:
  if (old) {
    FIO_ARRAY_TYPE_COPY(*old, FIO_ARRAY_TYPE_INVALID);
  }
  return -1;
}

/**
 * Removes all occurrences of an object from the array (if any), MOVING all the
 * existing objects to prevent "holes" in the data.
 *
 * Returns the number of items removed.
 */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, remove2)(FIO_ARRAY_PTR ary_,
                                                 FIO_ARRAY_TYPE data) {
  size_t c = 0;
  FIO_ARRAY_TYPE *a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  size_t count;
  if (!a)
    return (uint32_t)c;
  count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);

  size_t i = 0;
  while ((i + c) < count) {
    if (!(FIO_ARRAY_TYPE_CMP(a[i + c], data))) {
      a[i] = a[i + c];
      ++i;
      continue;
    }
    FIO_ARRAY_TYPE_DESTROY(a[i + c]);
    ++c;
  }
  if (c && FIO_MEM_REALLOC_IS_SAFE_) {
    /* keep memory zeroed out */
    FIO_MEMSET(a + i, 0, sizeof(*a) * c);
  }
  if (!FIO_ARRAY_IS_EMBEDDED_PTR(ary, a)) {
    ary->end = (uint32_t)(ary->start + i);
    return (uint32_t)c;
  }
  ary->start = (uint32_t)i;
  return (uint32_t)c;
}

/** Attempts to lower the array's memory consumption. */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, compact)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(ary_);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  size_t count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);
  FIO_ARRAY_TYPE *tmp = NULL;

  if (count <= FIO_ARRAY_EMBEDDED_CAPA)
    goto re_embed;

  tmp = (FIO_ARRAY_TYPE *)
      FIO_MEM_REALLOC_(NULL, 0, (ary->end - ary->start) * sizeof(*tmp), 0);
  if (!tmp)
    return;
  FIO_MEMCPY(tmp, ary->ary + ary->start, count * sizeof(*ary->ary));
  FIO_MEM_FREE_(ary->ary, ary->capa * sizeof(*ary->ary));
  *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
      .start = 0,
      .end = (ary->end - ary->start),
      .capa = (ary->end - ary->start),
      .ary = tmp,
  };
  return;

re_embed:
  if (!FIO_ARRAY_IS_EMBEDDED(ary)) {
    tmp = ary->ary;
    uint32_t offset = ary->start;
    size_t old_capa = ary->capa;
    *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
        .start = (uint32_t)count,
    };
    if (count) {
      FIO_MEMCPY(FIO_ARRAY2EMBEDDED(ary)->embedded,
                 tmp + offset,
                 count * sizeof(*tmp));
    }
    if (tmp) {
      FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_ARRAY_NAME, destroy));
      FIO_MEM_FREE_(tmp, sizeof(*tmp) * old_capa);
      (void)old_capa; /* if unused */
    }
  }
  return;
}
/**
 * Pushes an object to the end of the Array. Returns NULL on error.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, push)(FIO_ARRAY_PTR ary_,
                                                     FIO_ARRAY_TYPE data) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    if (ary->end == ary->capa) {
      if (!ary->start) {
        if (FIO_NAME(FIO_ARRAY_NAME,
                     reserve)(ary_, (uint32_t)FIO_ARRAY_ADD2CAPA(ary->capa)) ==
            ary->end)
          goto invalid;
      } else {
        const uint32_t new_start = (ary->start >> 2);
        const uint32_t count = ary->end - ary->start;
        if (count)
          FIO_MEMMOVE(ary->ary + new_start,
                      ary->ary + ary->start,
                      count * sizeof(*ary->ary));
        ary->end = count + new_start;
        ary->start = new_start;
      }
    }
    FIO_ARRAY_TYPE_COPY(ary->ary[ary->end], data);
    return ary->ary + (ary->end++);

  case 1:
    if (ary->start == FIO_ARRAY_EMBEDDED_CAPA)
      goto needs_memory_embedded;
    FIO_ARRAY_TYPE_COPY(FIO_ARRAY2EMBEDDED(ary)->embedded[ary->start], data);
    return FIO_ARRAY2EMBEDDED(ary)->embedded + (ary->start++);
  }
invalid:
  FIO_ARRAY_TYPE_DESTROY(data);
  return NULL;

needs_memory_embedded:
  if (FIO_NAME(FIO_ARRAY_NAME,
               reserve)(ary_, FIO_ARRAY_ADD2CAPA(FIO_ARRAY_EMBEDDED_CAPA)) ==
      FIO_ARRAY_EMBEDDED_CAPA)
    goto invalid;
  FIO_ARRAY_TYPE_COPY(ary->ary[ary->end], data);
  return ary->ary + (ary->end++);
}

/**
 * Removes an object from the end of the Array.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns -1 on error (Array is empty) and 0 on success.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, pop)(FIO_ARRAY_PTR ary_,
                                        FIO_ARRAY_TYPE *old) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    if (ary->end == ary->start)
      return -1;
    --ary->end;
    if (old) {
      FIO_ARRAY_TYPE_COPY(*old, ary->ary[ary->end]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(ary->ary[ary->end]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(ary->ary[ary->end]);
    }
    return 0;
  case 1:
    if (!ary->start)
      return -1;
    --ary->start;
    if (old) {
      FIO_ARRAY_TYPE_COPY(*old, FIO_ARRAY2EMBEDDED(ary)->embedded[ary->start]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(FIO_ARRAY2EMBEDDED(ary)->embedded[ary->start]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(FIO_ARRAY2EMBEDDED(ary)->embedded[ary->start]);
    }
    FIO_MEMSET(FIO_ARRAY2EMBEDDED(ary)->embedded + ary->start,
               0,
               sizeof(*ary->ary));
    return 0;
  }
  if (old)
    FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY_TYPE_INVALID);
  return -1;
}

/**
 * Unshifts an object to the beginning of the Array. Returns -1 on error.
 *
 * This could be expensive, causing `memmove`.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, unshift)(FIO_ARRAY_PTR ary_,
                                                        FIO_ARRAY_TYPE data) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    if (!ary->start) {
      if (ary->end == ary->capa) {
        FIO_NAME(FIO_ARRAY_NAME, reserve)
        (ary_, (-1 - (int32_t)FIO_ARRAY_ADD2CAPA(ary->capa)));
        if (!ary->start)
          goto invalid;
      } else {
        const uint32_t new_end =
            (uint32_t)(ary->capa - ((ary->capa - ary->end) >> 2));
        const uint32_t count = (uint32_t)(ary->end - ary->start);
        const uint32_t new_start = (uint32_t)(new_end - count);
        if (count)
          FIO_MEMMOVE(ary->ary + new_start,
                      ary->ary + ary->start,
                      count * sizeof(*ary->ary));
        ary->end = new_end;
        ary->start = new_start;
      }
    }
    FIO_ARRAY_TYPE_COPY(ary->ary[--ary->start], data);
    return ary->ary + ary->start;

  case 1:
    if (ary->start == FIO_ARRAY_EMBEDDED_CAPA)
      goto needs_memory_embed;
    if (ary->start)
      FIO_MEMMOVE(FIO_ARRAY2EMBEDDED(ary)->embedded + 1,
                  FIO_ARRAY2EMBEDDED(ary)->embedded,
                  sizeof(*ary->ary) * ary->start);
    ++ary->start;
    FIO_ARRAY_TYPE_COPY(FIO_ARRAY2EMBEDDED(ary)->embedded[0], data);
    return FIO_ARRAY2EMBEDDED(ary)->embedded;
  }
invalid:
  FIO_ARRAY_TYPE_DESTROY(data);
  return NULL;

needs_memory_embed:
  if (FIO_NAME(FIO_ARRAY_NAME, reserve)(
          ary_,
          (-1 - (int32_t)FIO_ARRAY_ADD2CAPA(FIO_ARRAY_EMBEDDED_CAPA))) ==
      FIO_ARRAY_EMBEDDED_CAPA)
    goto invalid;
  FIO_ARRAY_TYPE_COPY(ary->ary[--ary->start], data);
  return ary->ary + ary->start;
}

/**
 * Removes an object from the beginning of the Array.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns -1 on error (Array is empty) and 0 on success.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, shift)(FIO_ARRAY_PTR ary_,
                                          FIO_ARRAY_TYPE *old) {

  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);

  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    if (ary->end == ary->start)
      return -1;
    if (old) {
      FIO_ARRAY_TYPE_COPY(*old, ary->ary[ary->start]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(ary->ary[ary->start]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(ary->ary[ary->start]);
    }
    ++ary->start;
    return 0;
  case 1:
    if (!ary->start)
      return -1;
    if (old) {
      FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY2EMBEDDED(ary)->embedded[0]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(FIO_ARRAY2EMBEDDED(ary)->embedded[0]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(FIO_ARRAY2EMBEDDED(ary)->embedded[0]);
    }
    --ary->start;
    if (ary->start)
      FIO_MEMMOVE(FIO_ARRAY2EMBEDDED(ary)->embedded,
                  FIO_ARRAY2EMBEDDED(ary)->embedded +
                      FIO_ARRAY2EMBEDDED(ary)->start,
                  FIO_ARRAY2EMBEDDED(ary)->start *
                      sizeof(*FIO_ARRAY2EMBEDDED(ary)->embedded));
    FIO_MEMSET(FIO_ARRAY2EMBEDDED(ary)->embedded + ary->start,
               0,
               sizeof(*ary->ary));
    return 0;
  }
  if (old)
    FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY_TYPE_INVALID);
  return -1;
}

/**
 * Iteration using a callback for each entry in the array.
 *
 * The callback task function must accept an the entry data as well as an opaque
 * user pointer.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME,
                        each)(FIO_ARRAY_PTR ary_,
                              int (*task)(FIO_NAME(FIO_ARRAY_NAME, each_s) *
                                          info),
                              void *udata,
                              int64_t start_at) {
  FIO_ARRAY_TYPE *a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
  if (!a)
    return (uint32_t)-1;

  uint32_t count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);

  if (start_at < 0) {
    start_at = count - start_at;
    if (start_at < 0)
      start_at = 0;
  }

  if (!a || !task)
    return (uint32_t)-1;

  if ((uint32_t)start_at >= count)
    return (uint32_t)count;

  FIO_NAME(FIO_ARRAY_NAME, each_s)
  e = {
      .parent = ary_,
      .index = (uint64_t)start_at,
      .task = task,
      .udata = udata,
  };

  while ((uint32_t)e.index < FIO_NAME(FIO_ARRAY_NAME, count)(ary_)) {
    a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
    e.value = a[e.index];
    int r = e.task(&e);
    ++e.index;
    if (r == -1) {
      return (uint32_t)(e.index);
    }
  }
  return (uint32_t)e.index;
}

/* *****************************************************************************
Dynamic Arrays - test
***************************************************************************** */
#ifdef FIO_TEST_ALL

/* make suer the functions are defined for the testing */
#ifdef FIO_REF_CONSTRUCTOR_ONLY
IFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, new)(void);
IFUNC void FIO_NAME(FIO_ARRAY_NAME, free)(FIO_ARRAY_PTR ary);
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

#define FIO_ARRAY_TEST_OBJ_SET(dest, val)                                      \
  FIO_MEMSET(&(dest), (int)(val), sizeof(FIO_ARRAY_TYPE))
#define FIO_ARRAY_TEST_OBJ_IS(val)                                             \
  (!FIO_MEMCMP(&o,                                                             \
               FIO_MEMSET(&v, (int)(val), sizeof(v)),                          \
               sizeof(FIO_ARRAY_TYPE)))

FIO_SFUNC int FIO_NAME_TEST(stl, FIO_NAME(FIO_ARRAY_NAME, test_task))(
    FIO_NAME(FIO_ARRAY_NAME, each_s) * i) {
  struct data_s {
    int i;
    int va[];
  } *d = (struct data_s *)i->udata;
  FIO_ARRAY_TYPE v;

  FIO_ARRAY_TEST_OBJ_SET(v, d->va[d->i]);
  ++d->i;
  if (d->va[d->i + 1])
    return 0;
  return -1;
}

FIO_SFUNC void FIO_NAME_TEST(stl, FIO_ARRAY_NAME)(void) {
  FIO_ARRAY_TYPE o;
  FIO_ARRAY_TYPE v;
  FIO_NAME(FIO_ARRAY_NAME, s) a_on_stack = FIO_ARRAY_INIT;
  FIO_ARRAY_PTR a_array[2];
  a_array[0] = (FIO_ARRAY_PTR)FIO_PTR_TAG((&a_on_stack));
  a_array[1] = FIO_NAME(FIO_ARRAY_NAME, new)();
  FIO_ASSERT_ALLOC(a_array[1]);
  /* perform test twice, once for an array on the stack and once for allocate */
  for (size_t selector = 0; selector < 2; ++selector) {
    FIO_ARRAY_PTR a = a_array[selector];
    fprintf(stderr,
            "\t* Testing dynamic arrays on the %s (" FIO_MACRO2STR(
                FIO_NAME(FIO_ARRAY_NAME,
                         s)) ").\n\t"
                             "  This type supports %zu embedded items\n",
            (selector ? "heap" : "stack"),
            FIO_ARRAY_EMBEDDED_CAPA);
    /* Test start here */

    /* test push */
    for (size_t i = 0; i < (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3; ++i) {
      FIO_ARRAY_TEST_OBJ_SET(o, (i + 1));
      o = *FIO_NAME(FIO_ARRAY_NAME, push)(a, o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1), "push failed (%d)", i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, i);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1), "push-get cycle failed (%d)", i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, -1);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1),
                 "get with -1 returned wrong result (%d)",
                 i);
    }
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   FIO_ARRAY_EMBEDDED_CAPA + 3,
               "push didn't update count correctly (%d != %d)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a),
               (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3);

    /* test pop */
    for (size_t i = (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3; i--;) {
      FIO_NAME(FIO_ARRAY_NAME, pop)(a, &o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS((i + 1)),
                 "pop value error failed (%d)",
                 i);
    }
    FIO_ASSERT(!FIO_NAME(FIO_ARRAY_NAME, count)(a),
               "pop didn't pop all elements?");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, pop)(a, &o),
               "pop for empty array should return an error.");

    /* test compact with zero elements */
    FIO_NAME(FIO_ARRAY_NAME, compact)(a);
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) == FIO_ARRAY_EMBEDDED_CAPA,
               "compact zero elementes didn't make array embedded?");

    /* test unshift */
    for (size_t i = (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3; i--;) {
      FIO_ARRAY_TEST_OBJ_SET(o, (i + 1));
      o = *FIO_NAME(FIO_ARRAY_NAME, unshift)(a, o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1), "shift failed (%d)", i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, 0);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1),
                 "unshift-get cycle failed (%d)",
                 i);
      int64_t negative_index = 0 - (((int)(FIO_ARRAY_EMBEDDED_CAPA) + 3) - i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, negative_index);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1),
                 "get with %d returned wrong result.",
                 negative_index);
    }
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   FIO_ARRAY_EMBEDDED_CAPA + 3,
               "unshift didn't update count correctly (%d != %d)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a),
               (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3);

    /* test shift */
    for (size_t i = 0; i < (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3; ++i) {
      FIO_NAME(FIO_ARRAY_NAME, shift)(a, &o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS((i + 1)),
                 "shift value error failed (%d)",
                 i);
    }
    FIO_ASSERT(!FIO_NAME(FIO_ARRAY_NAME, count)(a),
               "shift didn't shift all elements?");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, shift)(a, &o),
               "shift for empty array should return an error.");

    /* test set from embedded? array */
    FIO_NAME(FIO_ARRAY_NAME, compact)(a);
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) == FIO_ARRAY_EMBEDDED_CAPA,
               "compact zero elementes didn't make array embedded (2)?");
    FIO_ARRAY_TEST_OBJ_SET(o, 1);
    FIO_NAME(FIO_ARRAY_NAME, push)(a, o);
    if (FIO_ARRAY_EMBEDDED_CAPA) {
      FIO_ARRAY_TEST_OBJ_SET(o, 1);
      FIO_NAME(FIO_ARRAY_NAME, set)(a, FIO_ARRAY_EMBEDDED_CAPA, o, &o);
      FIO_ASSERT(FIO_ARRAY_TYPE_CMP(o, FIO_ARRAY_TYPE_INVALID),
                 "set overflow from embedded array should reset `old`");
      FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                     FIO_ARRAY_EMBEDDED_CAPA + 1,
                 "set didn't update count correctly from embedded "
                 "array (%d != %d)",
                 FIO_NAME(FIO_ARRAY_NAME, count)(a),
                 (int)FIO_ARRAY_EMBEDDED_CAPA);
    }

    /* test set from bigger array */
    FIO_ARRAY_TEST_OBJ_SET(o, 1);
    FIO_NAME(FIO_ARRAY_NAME, set)
    (a, ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4), o, &o);
    FIO_ASSERT(FIO_ARRAY_TYPE_CMP(o, FIO_ARRAY_TYPE_INVALID),
               "set overflow should reset `old`");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "set didn't update count correctly (%d != %d)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a),
               (int)((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4));
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) >=
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4),
               "set capa should be above item count");
    if (FIO_ARRAY_EMBEDDED_CAPA) {
      FIO_ARRAY_TYPE_COPY(o, FIO_ARRAY_TYPE_INVALID);
      FIO_NAME(FIO_ARRAY_NAME, set)(a, FIO_ARRAY_EMBEDDED_CAPA, o, &o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(1),
                 "set overflow lost last item while growing.");
    }
    o = FIO_NAME(FIO_ARRAY_NAME, get)(a, (FIO_ARRAY_EMBEDDED_CAPA + 1) * 2);
    FIO_ASSERT(FIO_ARRAY_TYPE_CMP(o, FIO_ARRAY_TYPE_INVALID),
               "set overflow should have memory in the middle set to invalid "
               "objetcs.");
    FIO_ARRAY_TEST_OBJ_SET(o, 2);
    FIO_NAME(FIO_ARRAY_NAME, set)(a, 0, o, &o);
    FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(1),
               "set should set `old` to previous value");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "set item count error");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) >=
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "set capa should be above item count");

    /* test find TODO: test with uninitialized array */
    FIO_ARRAY_TEST_OBJ_SET(o, 99);
    if (FIO_ARRAY_TYPE_CMP(o, FIO_ARRAY_TYPE_INVALID)) {
      FIO_ARRAY_TEST_OBJ_SET(o, 100);
    }
    uint32_t found = FIO_NAME(FIO_ARRAY_NAME, find)(a, o, 0);
    FIO_ASSERT(found == (uint32_t)-1,
               "seeking for an object that doesn't exist should fail.");
    FIO_ARRAY_TEST_OBJ_SET(o, 1);
    found = FIO_NAME(FIO_ARRAY_NAME, find)(a, o, 1);
    FIO_ASSERT(found == ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4),
               "seeking for an object returned the wrong index.");
    FIO_ASSERT(found == FIO_NAME(FIO_ARRAY_NAME, find)(a, o, -1),
               "seeking for an object in reverse returned the wrong index.");
    FIO_ARRAY_TEST_OBJ_SET(o, 2);
    FIO_ASSERT(
        !FIO_NAME(FIO_ARRAY_NAME, find)(a, o, -2),
        "seeking for an object in reverse (2) returned the wrong index.");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "find should have side-effects - count error");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) >=
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "find should have side-effects - capa error");

    /* test remove */
    FIO_NAME(FIO_ARRAY_NAME, remove)(a, found, &o);
    FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(1), "remove didn't copy old data?");
    o = FIO_NAME(FIO_ARRAY_NAME, get)(a, 0);
    FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(2), "remove removed more?");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4),
               "remove with didn't update count correctly (%d != %s)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a),
               (int)((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4));
    o = FIO_NAME(FIO_ARRAY_NAME, get)(a, -1);

    /* test remove2 */
    FIO_ARRAY_TYPE_COPY(o, FIO_ARRAY_TYPE_INVALID);
    FIO_ASSERT((found = FIO_NAME(FIO_ARRAY_NAME, remove2)(a, o)) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) - 1,
               "remove2 result error, %d != %d items.",
               found,
               (int)((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) - 1);
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) == 1,
               "remove2 didn't update count correctly (%d != 1)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a));

    /* hopefuly these will end... or crash on error. */
    while (!FIO_NAME(FIO_ARRAY_NAME, pop)(a, NULL)) {
      ;
    }
    while (!FIO_NAME(FIO_ARRAY_NAME, shift)(a, NULL)) {
      ;
    }

    /* test push / unshift alternate */
    FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
    for (size_t i = 0; i < 4096; ++i) {
      FIO_ARRAY_TEST_OBJ_SET(o, (i + 1));
      FIO_NAME(FIO_ARRAY_NAME, push)(a, o);
      FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) + 1 ==
                     ((uint32_t)(i + 1) << 1),
                 "push-unshift[%d.5] cycle count arror (%d != %d)",
                 i,
                 FIO_NAME(FIO_ARRAY_NAME, count)(a),
                 (((uint32_t)(i + 1) << 1)) - 1);
      FIO_ARRAY_TEST_OBJ_SET(o, (i + 4097));
      FIO_NAME(FIO_ARRAY_NAME, unshift)(a, o);
      FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) == ((uint32_t)(i + 1) << 1),
                 "push-unshift[%d] cycle count arror (%d != %d)",
                 i,
                 FIO_NAME(FIO_ARRAY_NAME, count)(a),
                 ((uint32_t)(i + 1) << 1));
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, 0);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 4097),
                 "unshift-push cycle failed (%d)",
                 i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, -1);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1),
                 "push-shift cycle failed (%d)",
                 i);
    }
    for (size_t i = 0; i < 4096; ++i) {
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, i);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS((4096 * 2) - i),
                 "item value error at index %d",
                 i);
    }
    for (size_t i = 0; i < 4096; ++i) {
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, i + 4096);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS((1 + i)),
                 "item value error at index %d",
                 i + 4096);
    }
#if DEBUG
    for (size_t i = 0; i < 2; ++i) {
      FIO_LOG_DEBUG2(
          "\t- " FIO_MACRO2STR(
              FIO_NAME(FIO_ARRAY_NAME, s)) " after push/unshit cycle%s:\n"
                                           "\t\t- item count: %d items\n"
                                           "\t\t- capacity:   %d items\n"
                                           "\t\t- memory:     %d bytes\n",
          (i ? " after compact" : ""),
          FIO_NAME(FIO_ARRAY_NAME, count)(a),
          FIO_NAME(FIO_ARRAY_NAME, capa)(a),
          FIO_NAME(FIO_ARRAY_NAME, capa)(a) * sizeof(FIO_ARRAY_TYPE));
      FIO_NAME(FIO_ARRAY_NAME, compact)(a);
    }
#endif /* DEBUG */

    FIO_ARRAY_TYPE_COPY(o, FIO_ARRAY_TYPE_INVALID);
/* test set with NULL, hopefully a bug will cause a crash */
#if FIO_ARRAY_TYPE_DESTROY_SIMPLE
    for (size_t i = 0; i < 4096; ++i) {
      FIO_NAME(FIO_ARRAY_NAME, set)(a, i, o, NULL);
    }
#else
    /*
     * we need to clear the memory to make sure a cleanup actions don't get
     * unexpected values.
     */
    for (size_t i = 0; i < (4096 * 2); ++i) {
      FIO_ARRAY_TYPE_COPY((FIO_NAME2(FIO_ARRAY_NAME, ptr)(a)[i]),
                          FIO_ARRAY_TYPE_INVALID);
    }

#endif

    /* TODO: test concat */

    /* test each */
    {
      struct data_s {
        int i;
        int va[10];
      } d = {1, {1, 8, 2, 7, 3, 6, 4, 5}};
      FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
      for (size_t i = 0; d.va[i]; ++i) {
        FIO_ARRAY_TEST_OBJ_SET(o, d.va[i]);
        FIO_NAME(FIO_ARRAY_NAME, push)(a, o);
      }

      int index = FIO_NAME(FIO_ARRAY_NAME, each)(
          a,
          FIO_NAME_TEST(stl, FIO_NAME(FIO_ARRAY_NAME, test_task)),
          (void *)&d,
          d.i);
      FIO_ASSERT(index == d.i,
                 "index rerturned from each should match next object");
      FIO_ASSERT(*(char *)&d.va[d.i],
                 "array each error (didn't stop in time?).");
      FIO_ASSERT(!(*(char *)&d.va[d.i + 1]),
                 "array each error (didn't stop in time?).");
    }
#if FIO_ARRAY_TYPE_DESTROY_SIMPLE
    {
      FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
      size_t max_items = 63;
      FIO_ARRAY_TYPE tmp[64];
      for (size_t i = 0; i < max_items; ++i) {
        FIO_MEMSET(tmp + i, i + 1, sizeof(*tmp));
      }
      for (size_t items = 0; items <= max_items; items = ((items << 1) | 1)) {
        FIO_LOG_DEBUG2("\t* testing the FIO_ARRAY_EACH macro with %zu items.",
                       items);
        size_t i = 0;
        for (i = 0; i < items; ++i)
          FIO_NAME(FIO_ARRAY_NAME, push)(a, tmp[i]);
        i = 0;
        FIO_ARRAY_EACH(FIO_ARRAY_NAME, a, pos) {
          FIO_ASSERT(!memcmp(tmp + i, pos, sizeof(*pos)),
                     "FIO_ARRAY_EACH pos is at wrong index %zu != %zu",
                     (size_t)(pos - FIO_NAME2(FIO_ARRAY_NAME, ptr)(a)),
                     i);
          ++i;
        }
        FIO_ASSERT(i == items,
                   "FIO_ARRAY_EACH macro count error - didn't review all "
                   "items? %zu != %zu ",
                   i,
                   items);
        FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
      }
    }
#endif
    /* test destroy */
    FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
    FIO_ASSERT(!FIO_NAME(FIO_ARRAY_NAME, count)(a),
               "destroy didn't clear count.");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) == FIO_ARRAY_EMBEDDED_CAPA,
               "destroy capa error.");
    /* Test end here */
  }
  FIO_NAME(FIO_ARRAY_NAME, free)(a_array[1]);
}
#undef FIO_ARRAY_TEST_OBJ_SET
#undef FIO_ARRAY_TEST_OBJ_IS

#endif /* FIO_TEST_ALL */
/* *****************************************************************************
Dynamic Arrays - cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_ARRAY_NAME */

#undef FIO_ARRAY_NAME
#undef FIO_ARRAY_TYPE
#undef FIO_ARRAY_ENABLE_EMBEDDED
#undef FIO_ARRAY_TYPE_INVALID
#undef FIO_ARRAY_TYPE_INVALID_SIMPLE
#undef FIO_ARRAY_TYPE_COPY
#undef FIO_ARRAY_TYPE_COPY_SIMPLE
#undef FIO_ARRAY_TYPE_CONCAT_COPY
#undef FIO_ARRAY_TYPE_CONCAT_COPY_SIMPLE
#undef FIO_ARRAY_TYPE_DESTROY
#undef FIO_ARRAY_TYPE_DESTROY_SIMPLE
#undef FIO_ARRAY_DESTROY_AFTER_COPY
#undef FIO_ARRAY_TYPE_CMP
#undef FIO_ARRAY_TYPE_CMP_SIMPLE
#undef FIO_ARRAY_PADDING
#undef FIO_ARRAY_SIZE2WORDS
#undef FIO_ARRAY_POS2ABS
#undef FIO_ARRAY_AB_CT
#undef FIO_ARRAY_PTR
#undef FIO_ARRAY_EXPONENTIAL
#undef FIO_ARRAY_ADD2CAPA
#undef FIO_ARRAY_IS_EMBEDDED
#undef FIO_ARRAY_IS_EMBEDDED_PTR
#undef FIO_ARRAY_EMBEDDED_CAPA
#undef FIO_ARRAY2EMBEDDED
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_MAP_NAME map       /* Development inclusion - ignore line */
#define FIO_MAP_KEY  size_t    /* Development inclusion - ignore line */
// #define FIO_MAP_VALUE_BSTR     /* Development inclusion - ignore line */
// #define FIO_MAP_ORDERED        /* Development inclusion - ignore line */
#define FIO_MAP_TEST   /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                  Unordered/Ordered Map Implementation



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_MAP_NAME)
/* *****************************************************************************
Map Settings - Sets have only keys (value == key) - Hash Maps have values
***************************************************************************** */

/* if FIO_MAP_KEY_KSTR is defined, use fio_keystr_s keys */
#ifdef FIO_MAP_KEY_KSTR
#define FIO_MAP_KEY                  fio_str_info_s
#define FIO_MAP_KEY_INTERNAL         fio_keystr_s
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_keystr_info(&(k))
#define FIO_MAP_KEY_COPY(dest, src)                                            \
  (dest) = fio_keystr_init((src), FIO_NAME(FIO_MAP_NAME, __key_alloc))
#define FIO_MAP_KEY_CMP(a, b) fio_keystr_is_eq2((a), (b))
#define FIO_MAP_KEY_DESTROY(key)                                               \
  fio_keystr_destroy(&(key), FIO_NAME(FIO_MAP_NAME, __key_free))
#define FIO_MAP_KEY_DISCARD(key)
FIO_SFUNC void *FIO_NAME(FIO_MAP_NAME, __key_alloc)(size_t len) {
  return FIO_MEM_REALLOC_(NULL, 0, len, 0);
}
FIO_SFUNC void FIO_NAME(FIO_MAP_NAME, __key_free)(void *ptr, size_t len) {
  FIO_MEM_FREE_(ptr, len);
  (void)len; /* if unused */
}
#undef FIO_MAP_KEY_KSTR

/* if FIO_MAP_KEY is undefined, assume String keys (using `fio_bstr`). */
#elif !defined(FIO_MAP_KEY) || defined(FIO_MAP_KEY_BSTR)
#define FIO_MAP_KEY                  fio_str_info_s
#define FIO_MAP_KEY_INTERNAL         char *
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_bstr_info((k))
#define FIO_MAP_KEY_COPY(dest, src)                                            \
  (dest) = fio_bstr_write(NULL, (src).buf, (src).len)
#define FIO_MAP_KEY_CMP(a, b)    fio_bstr_is_eq2info((a), (b))
#define FIO_MAP_KEY_DESTROY(key) fio_bstr_free((key))
#define FIO_MAP_KEY_DISCARD(key)
#endif
#undef FIO_MAP_KEY_BSTR

#ifndef FIO_MAP_KEY_INTERNAL
#define FIO_MAP_KEY_INTERNAL FIO_MAP_KEY
#endif

#ifndef FIO_MAP_KEY_FROM_INTERNAL
#define FIO_MAP_KEY_FROM_INTERNAL(o) o
#endif

#ifndef FIO_MAP_KEY_COPY
#define FIO_MAP_KEY_COPY(dest, src) ((dest) = (src))
#endif

#ifndef FIO_MAP_KEY_CMP
#define FIO_MAP_KEY_CMP(a, b) ((a) == (b))
#endif

#ifndef FIO_MAP_KEY_DESTROY
#define FIO_MAP_KEY_DESTROY(o)
#define FIO_MAP_KEY_DESTROY_SIMPLE 1
#endif

#ifndef FIO_MAP_KEY_DISCARD
#define FIO_MAP_KEY_DISCARD(o)
#endif

/* FIO_MAP_HASH_FN(key) - used instead of providing a hash value. */
#ifndef FIO_MAP_HASH_FN
#undef FIO_MAP_RECALC_HASH
#endif

/* FIO_MAP_RECALC_HASH - if true, hash values won't be cached. */
#ifndef FIO_MAP_RECALC_HASH
#define FIO_MAP_RECALC_HASH 0
#endif

#ifdef FIO_MAP_VALUE_BSTR
#define FIO_MAP_VALUE                  fio_str_info_s
#define FIO_MAP_VALUE_INTERNAL         char *
#define FIO_MAP_VALUE_FROM_INTERNAL(v) fio_bstr_info((v))
#define FIO_MAP_VALUE_COPY(dest, src)                                          \
  (dest) = fio_bstr_write(NULL, (src).buf, (src).len)
#define FIO_MAP_VALUE_DESTROY(v) fio_bstr_free((v))
#define FIO_MAP_VALUE_DISCARD(v)
#endif

#ifdef FIO_MAP_VALUE
#define FIO_MAP_GET_T FIO_MAP_VALUE
#else
#define FIO_MAP_GET_T FIO_MAP_KEY
#endif

#ifndef FIO_MAP_VALUE_INTERNAL
#define FIO_MAP_VALUE_INTERNAL FIO_MAP_VALUE
#endif

#ifndef FIO_MAP_VALUE_FROM_INTERNAL
#ifdef FIO_MAP_VALUE
#define FIO_MAP_VALUE_FROM_INTERNAL(o) o
#else
#define FIO_MAP_VALUE_FROM_INTERNAL(o)
#endif
#endif

#ifndef FIO_MAP_VALUE_COPY
#ifdef FIO_MAP_VALUE
#define FIO_MAP_VALUE_COPY(dest, src) (dest) = (src)
#else
#define FIO_MAP_VALUE_COPY(dest, src)
#endif
#endif

#ifndef FIO_MAP_VALUE_DESTROY
#define FIO_MAP_VALUE_DESTROY(o)
#define FIO_MAP_VALUE_DESTROY_SIMPLE 1
#endif

#ifndef FIO_MAP_VALUE_DISCARD
#define FIO_MAP_VALUE_DISCARD(o)
#endif

#ifdef FIO_MAP_LRU
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 1 /* required for least recently used order */
#endif

/* test if FIO_MAP_ORDERED was defined as an empty macro */
#if defined(FIO_MAP_ORDERED) && ((0 - FIO_MAP_ORDERED - 1) == 1)
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 1 /* assume developer's intention */
#endif

#ifndef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 0
#endif

/* *****************************************************************************
Pointer Tagging Support
***************************************************************************** */

#ifdef FIO_PTR_TAG_TYPE
#define FIO_MAP_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_MAP_PTR FIO_NAME(FIO_MAP_NAME, s) *
#endif
#define FIO_MAP_T FIO_NAME(FIO_MAP_NAME, s)

/* *****************************************************************************
Map Types
***************************************************************************** */

#ifndef FIO_MAP_INIT
/* Initialization macro. */
#define FIO_MAP_INIT                                                           \
  { 0 }
#endif

/** internal object data representation */
typedef struct FIO_NAME(FIO_MAP_NAME, node_s) FIO_NAME(FIO_MAP_NAME, node_s);

/** A Hash Map / Set type */
typedef struct FIO_NAME(FIO_MAP_NAME, s) {
  uint32_t bits;
  uint32_t count;
  FIO_NAME(FIO_MAP_NAME, node_s) * map;
#if FIO_MAP_ORDERED
  FIO_INDEXED_LIST32_HEAD head;
#endif
} FIO_NAME(FIO_MAP_NAME, s);

/** internal object data representation */
struct FIO_NAME(FIO_MAP_NAME, node_s) {
#if !FIO_MAP_RECALC_HASH
  uint64_t hash;
#endif
  FIO_MAP_KEY_INTERNAL key;
#ifdef FIO_MAP_VALUE
  FIO_MAP_VALUE_INTERNAL value;
#endif
#if FIO_MAP_ORDERED
  FIO_INDEXED_LIST32_NODE node;
#endif
};

/** Map iterator type */
typedef struct {
  /** the node in the internal map */
  FIO_NAME(FIO_MAP_NAME, node_s) * node;
  /** the key in the current position */
  FIO_MAP_KEY key;
#ifdef FIO_MAP_VALUE
  /** the value in the current position */
  FIO_MAP_VALUE value;
#endif
#if !FIO_MAP_RECALC_HASH
  /** the hash for the current position */
  uint64_t hash;
#endif
  struct {                   /* internal usage, do not access */
    uint32_t index;          /* the index in the internal map */
    uint32_t pos;            /* the position in the ordering scheme */
    uintptr_t map_validator; /* map mutation guard */
  } private_;
} FIO_NAME(FIO_MAP_NAME, iterator_s);

/* *****************************************************************************
Construction / Deconstruction
***************************************************************************** */

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY

/* Allocates a new object on the heap and initializes it's memory. */
SFUNC FIO_MAP_PTR FIO_NAME(FIO_MAP_NAME, new)(void);

/* Frees any internal data AND the object's container! */
SFUNC void FIO_NAME(FIO_MAP_NAME, free)(FIO_MAP_PTR map);

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/** Destroys the object, re-initializing its container. */
SFUNC void FIO_NAME(FIO_MAP_NAME, destroy)(FIO_MAP_PTR map);

/* *****************************************************************************
Map State
***************************************************************************** */

/** Theoretical map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME, capa)(FIO_MAP_PTR map);

/** The number of objects in the map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME, count)(FIO_MAP_PTR map);

/** Reserves at minimum the capacity requested. */
SFUNC void FIO_NAME(FIO_MAP_NAME, reserve)(FIO_MAP_PTR map, size_t capa);

/** Returns the key value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP_KEY FIO_NAME(FIO_MAP_NAME,
                               node2key)(FIO_NAME(FIO_MAP_NAME, node_s) * node);

/** Returns the hash value associated with the node's pointer (see set_ptr). */
FIO_IFUNC uint64_t FIO_NAME(FIO_MAP_NAME,
                            node2hash)(FIO_NAME(FIO_MAP_NAME, node_s) * node);

#ifdef FIO_MAP_VALUE
/** Returns the value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP_VALUE FIO_NAME(FIO_MAP_NAME,
                                 node2val)(FIO_NAME(FIO_MAP_NAME, node_s) *
                                           node);
#endif

/** Returns the key value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP_KEY_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2key_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node);

#ifdef FIO_MAP_VALUE
/** Returns the value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP_VALUE_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2val_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node);
#endif

/* *****************************************************************************
Adding / Removing Elements from the Map
***************************************************************************** */

/** Removes an object in the map, returning a pointer to the map data. */
SFUNC int FIO_NAME(FIO_MAP_NAME, remove)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                         uint64_t hash,
#endif
                                         FIO_MAP_KEY key,
#if defined(FIO_MAP_VALUE)
                                         FIO_MAP_VALUE_INTERNAL *old
#else
                                         FIO_MAP_KEY_INTERNAL *old
#endif
);

/** Evicts elements in order least recently used (LRU), FIFO or undefined. */
SFUNC void FIO_NAME(FIO_MAP_NAME, evict)(FIO_MAP_PTR map,
                                         size_t number_of_elements);

/** Removes all objects from the map, without releasing the map's resources. */
SFUNC void FIO_NAME(FIO_MAP_NAME, clear)(FIO_MAP_PTR map);

/** Attempts to minimize memory use. */
SFUNC void FIO_NAME(FIO_MAP_NAME, compact)(FIO_MAP_PTR map);

/** Gets a value from the map, if exists. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, get)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                    uint64_t hash,
#endif
                                                    FIO_MAP_KEY key);

/** Sets a value in the map, hash maps will overwrite existing data if any. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, set)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                    uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                                                    FIO_MAP_KEY key,
                                                    FIO_MAP_VALUE obj,
                                                    FIO_MAP_VALUE_INTERNAL *old
#else
                                                    FIO_MAP_KEY key
#endif
);

/** Sets a value in the map if not set previously. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, set_if_missing)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                               uint64_t hash,
#endif
                                                               FIO_MAP_KEY key
#ifdef FIO_MAP_VALUE
                                                               ,
                                                               FIO_MAP_VALUE obj
#endif
);

/**
 * The core set function.
 *
 * This function returns `NULL` on error (errors are logged).
 *
 * If the map is a hash map, overwriting the value (while keeping the key) is
 * possible. In this case the `old` pointer is optional, and if set than the old
 * data will be copied to over during an overwrite.
 *
 * NOTE: the function returns a pointer to the map's internal storage.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME, set_ptr)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                    uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                                    FIO_MAP_KEY key,
                                    FIO_MAP_VALUE val,
                                    FIO_MAP_VALUE_INTERNAL *old,
                                    int overwrite
#else
                                    FIO_MAP_KEY key
#endif
    );

/**
 * The core get function. This function returns NULL if item is missing.
 *
 * NOTE: the function returns a pointer to the map's internal storage.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME, get_ptr)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                    uint64_t hash,
#endif
                                    FIO_MAP_KEY key);
/* *****************************************************************************
Map Iteration and Traversal
***************************************************************************** */

/** Iteration information structure passed to the callback. */
typedef struct FIO_NAME(FIO_MAP_NAME, each_s) {
  /** The being iterated. Once set, cannot be safely changed. */
  FIO_MAP_PTR const parent;
  /** The current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct FIO_NAME(FIO_MAP_NAME, each_s) * info);
  /** Opaque user data. */
  void *udata;
#ifdef FIO_MAP_VALUE
  /** The object's value at the current index. */
  FIO_MAP_VALUE value;
#endif
  /** The object's key the current index. */
  FIO_MAP_KEY key;
} FIO_NAME(FIO_MAP_NAME, each_s);

/**
 * Iteration using a callback for each element in the map.
 *
 * The callback task function must accept an each_s pointer, see above.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
SFUNC uint32_t FIO_NAME(FIO_MAP_NAME,
                        each)(FIO_MAP_PTR map,
                              int (*task)(FIO_NAME(FIO_MAP_NAME, each_s) *),
                              void *udata,
                              ssize_t start_at);

/**
 * Returns the next iterator object after `current_pos` or the first if `NULL`.
 *
 * Note that adding objects to the map or rehashing between iterations could
 * incur performance penalties when re-setting and re-seeking the previous
 * iterator position.
 *
 * Adding objects to, or rehashing, an unordered maps could invalidate the
 * iterator object completely as the ordering may have changed and so the "next"
 * object might be any object in the map.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, iterator_s)
    FIO_NAME(FIO_MAP_NAME,
             get_next)(FIO_MAP_PTR map,
                       FIO_NAME(FIO_MAP_NAME, iterator_s) * current_pos);

/**
 * Returns the next iterator object after `current_pos` or the last if `NULL`.
 *
 * See notes in `get_next`.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, iterator_s)
    FIO_NAME(FIO_MAP_NAME,
             get_prev)(FIO_MAP_PTR map,
                       FIO_NAME(FIO_MAP_NAME, iterator_s) * current_pos);

/** Returns 1 if the iterator is out of bounds, otherwise returns 0. */
FIO_IFUNC int FIO_NAME(FIO_MAP_NAME,
                       iterator_is_valid)(FIO_NAME(FIO_MAP_NAME, iterator_s) *
                                          iterator);

/** Returns a pointer to the node object in the internal map. */
FIO_IFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME,
             iterator2node)(FIO_MAP_PTR map,
                            FIO_NAME(FIO_MAP_NAME, iterator_s) * iterator);

#ifndef FIO_MAP_EACH

/** Iterates through the map using an iterator object. */
#define FIO_MAP_EACH(map_name, map_ptr, i)                                     \
  for (FIO_NAME(map_name, iterator_s)                                          \
           i = FIO_NAME(map_name, get_next)(map_ptr, NULL);                    \
       FIO_NAME(map_name, iterator_is_valid)(&i);                              \
       i = FIO_NAME(map_name, get_next)(map_ptr, &i))

/** Iterates through the map using an iterator object. */
#define FIO_MAP_EACH_REVERSED(map_name, map_ptr, i)                            \
  for (FIO_NAME(map_name, iterator_s)                                          \
           i = FIO_NAME(map_name, get_prev)(map_ptr, NULL);                    \
       FIO_NAME(map_name, iterator_is_valid)(&i);                              \
       i = FIO_NAME(map_name, get_prev)(map_ptr, &i))

#endif /* FIO_MAP_EACH */

/* *****************************************************************************
Optional Sorting Support - TODO? (convert to array, sort, rehash)
***************************************************************************** */

#if defined(FIO_MAP_KEY_IS_GREATER_THAN) && !defined(FIO_SORT_TYPE) &&         \
    FIO_MAP_ORDERED
#undef FIO_SORT_NAME
#endif

/* *****************************************************************************
Map Implementation - inlined static functions
***************************************************************************** */

#ifndef FIO_MAP_CAPA_BITS_LIMIT
/* Note: cannot be more than 31 bits unless some of the code is rewritten. */
#define FIO_MAP_CAPA_BITS_LIMIT 31
#endif

/* Theoretical map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME, capa)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, 0);
  FIO_MAP_T *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (o->map)
    return (uint32_t)((size_t)1ULL << o->bits);
  return 0;
}

/* The number of objects in the map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME, count)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, 0);
  return FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map)->count;
}

/** Returns 1 if the iterator points to a valid object, otherwise returns 0. */
FIO_IFUNC int FIO_NAME(FIO_MAP_NAME,
                       iterator_is_valid)(FIO_NAME(FIO_MAP_NAME, iterator_s) *
                                          iterator) {
  return (iterator && iterator->private_.map_validator);
}

/** Returns the key value associated with the node's pointer. */
FIO_IFUNC FIO_MAP_KEY FIO_NAME(FIO_MAP_NAME,
                               node2key)(FIO_NAME(FIO_MAP_NAME, node_s) *
                                         node) {
  FIO_MAP_KEY r = (FIO_MAP_KEY){0};
  if (!node)
    return r;
  return FIO_MAP_KEY_FROM_INTERNAL(node->key);
}

/** Returns the hash value associated with the node's pointer. */
FIO_IFUNC uint64_t FIO_NAME(FIO_MAP_NAME,
                            node2hash)(FIO_NAME(FIO_MAP_NAME, node_s) * node) {
  uint32_t r = (uint32_t){0};
  if (!node)
    return r;
#if FIO_MAP_RECALC_HASH
  FIO_MAP_KEY k = FIO_MAP_KEY_FROM_INTERNAL(node->key);
  uint64_t hash = FIO_MAP_HASH_FN(k);
  hash += !hash;
  return hash;
#else
  return node->hash;
#endif
}

#ifdef FIO_MAP_VALUE
/** Returns the value associated with the node's pointer. */
FIO_IFUNC FIO_MAP_VALUE FIO_NAME(FIO_MAP_NAME,
                                 node2val)(FIO_NAME(FIO_MAP_NAME, node_s) *
                                           node) {
  FIO_MAP_VALUE r = (FIO_MAP_VALUE){0};
  if (!node)
    return r;
  return FIO_MAP_VALUE_FROM_INTERNAL(node->value);
}
#else
/* If called for a node without a
 * value, returns the key (simplifies
 * stuff). */
FIO_IFUNC FIO_MAP_KEY FIO_NAME(FIO_MAP_NAME,
                               node2val)(FIO_NAME(FIO_MAP_NAME, node_s) *
                                         node) {
  return FIO_NAME(FIO_MAP_NAME, node2key)(node);
}
#endif

/** Returns the key value associated with the node's pointer. */
FIO_IFUNC FIO_MAP_KEY_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2key_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node) {
  if (!node)
    return NULL;
  return &(node->key);
}

#ifdef FIO_MAP_VALUE
/** Returns the value associated with the node's pointer. */
FIO_IFUNC FIO_MAP_VALUE_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2val_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node) {
  if (!node)
    return NULL;
  return &(node->value);
}
#else
/* If called for a node without a
 * value, returns the key (simplifies
 * stuff). */
FIO_IFUNC FIO_MAP_KEY_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2val_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node) {
  return FIO_NAME(FIO_MAP_NAME, node2key_ptr)(node);
}
#endif

/** Gets a value from the map, if exists. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, get)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                    uint64_t hash,
#endif
                                                    FIO_MAP_KEY key) {
  return FIO_NAME(FIO_MAP_NAME, node2val)(FIO_NAME(FIO_MAP_NAME, get_ptr)(map,
#if !defined(FIO_MAP_HASH_FN)
                                                                          hash,
#endif
                                                                          key));
}

/** Sets a value in the map, hash maps will overwrite existing data if any. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, set)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                    uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                                                    FIO_MAP_KEY key,
                                                    FIO_MAP_VALUE obj,
                                                    FIO_MAP_VALUE_INTERNAL *old
#else
                                                    FIO_MAP_KEY key
#endif
) {
  return FIO_NAME(FIO_MAP_NAME, node2val)(FIO_NAME(FIO_MAP_NAME, set_ptr)(map,
#if !defined(FIO_MAP_HASH_FN)
                                                                          hash,
#endif
                                                                          key
#ifdef FIO_MAP_VALUE
                                                                          ,
                                                                          obj,
                                                                          old,
                                                                          1
#endif
                                                                          ));
}

/** Sets a value in the map if not set previously. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, set_if_missing)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                               uint64_t hash,
#endif
                                                               FIO_MAP_KEY key
#ifdef FIO_MAP_VALUE
                                                               ,
                                                               FIO_MAP_VALUE obj
#endif
) {
  return FIO_NAME(FIO_MAP_NAME, node2val)(FIO_NAME(FIO_MAP_NAME, set_ptr)(map,
#if !defined(FIO_MAP_HASH_FN)
                                                                          hash,
#endif
                                                                          key
#ifdef FIO_MAP_VALUE
                                                                          ,
                                                                          obj,
                                                                          NULL,
                                                                          0
#endif
                                                                          ));
}

/** Returns a pointer to the node object in the internal map. */
FIO_IFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME,
             iterator2node)(FIO_MAP_PTR map,
                            FIO_NAME(FIO_MAP_NAME, iterator_s) * iterator) {
  FIO_NAME(FIO_MAP_NAME, node_s) *node = NULL;
  if (!iterator || !iterator->private_.map_validator)
    return node;
  FIO_PTR_TAG_VALID_OR_RETURN(map, node);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  node = o->map + iterator->private_.index;
  return node;
}

/* *****************************************************************************
Map Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_MAP_NAME, destroy))
/* *****************************************************************************
Constructors
***************************************************************************** */

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY
FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_MAP_NAME, s))
/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC FIO_MAP_PTR FIO_NAME(FIO_MAP_NAME, new)(void) {
  FIO_NAME(FIO_MAP_NAME, s) *o =
      (FIO_NAME(FIO_MAP_NAME, s) *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*o), 0);
  if (!o)
    return (FIO_MAP_PTR)NULL;
  FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_MAP_NAME, s));
  *o = (FIO_NAME(FIO_MAP_NAME, s))FIO_MAP_INIT;
  return (FIO_MAP_PTR)FIO_PTR_TAG(o);
}
/* Frees any internal data AND the object's container! */
FIO_IFUNC void FIO_NAME(FIO_MAP_NAME, free)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, destroy)(map);
  FIO_NAME(FIO_MAP_NAME, s) *o =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_MAP_NAME, s), map);
  FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_MAP_NAME, s));
  FIO_MEM_FREE_(o, sizeof(*o));
}
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/* *****************************************************************************




Internal Helpers (Core)




***************************************************************************** */

/** internal object data representation */
struct FIO_NAME(FIO_MAP_NAME, __imap_s) {
  uint8_t h[64];
};

#ifndef FIO_MAP_ATTACK_LIMIT
#define FIO_MAP_ATTACK_LIMIT 16
#endif
#ifndef FIO_MAP_MINIMAL_BITS
#define FIO_MAP_MINIMAL_BITS 1
#endif
#ifndef FIO_MAP_CUCKOO_STEPS
/* Prime numbers are better */
#define FIO_MAP_CUCKOO_STEPS (0x43F82D0BUL) /* a big high prime */
#endif
#ifndef FIO_MAP_SEEK_LIMIT
#define FIO_MAP_SEEK_LIMIT 13U
#endif
#ifndef FIO_MAP_ARRAY_LOG_LIMIT
#define FIO_MAP_ARRAY_LOG_LIMIT 3
#endif
#ifndef FIO_MAP_CAPA
#define FIO_MAP_CAPA(bits) ((size_t)1ULL << (bits))
#endif

#ifndef FIO_MAP_IS_SPARSE
#define FIO_MAP_IS_SPARSE(map)                                                 \
  (o->bits > FIO_MAP_ARRAY_LOG_LIMIT && ((capa >> 2) > o->count))
#endif

/* Allocates resources for a new (clean) map. */
FIO_IFUNC int FIO_NAME(FIO_MAP_NAME,
                       __allocate_map)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                       uint32_t bits) {
  if (bits < FIO_MAP_MINIMAL_BITS)
    bits = FIO_MAP_MINIMAL_BITS;
  if (bits > FIO_MAP_CAPA_BITS_LIMIT)
    return -1;
  size_t s = (sizeof(o->map[0]) + 1) << bits;
  FIO_NAME(FIO_MAP_NAME, node_s) *n =
      (FIO_NAME(FIO_MAP_NAME, node_s) *)FIO_MEM_REALLOC_(NULL, 0, s, 0);
  if (!n)
    return -1;
  if (!FIO_MEM_REALLOC_IS_SAFE_) /* set only imap to zero */
    FIO_MEMSET((n + (1ULL << bits)), 0, (1ULL << bits));
  *o = (FIO_NAME(FIO_MAP_NAME, s)){.map = n, .bits = bits};
  FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_MAP_NAME, destroy));
  return 0;
}

/* The number of objects in the map capacity. */
FIO_IFUNC uint8_t *FIO_NAME(FIO_MAP_NAME,
                            __imap)(FIO_NAME(FIO_MAP_NAME, s) const *o) {
  return (uint8_t *)(o->map + FIO_MAP_CAPA(o->bits));
}

FIO_IFUNC uint64_t FIO_NAME(FIO_MAP_NAME, __byte_hash)(uint64_t hash) {
  hash = (hash >> 48) ^ (hash >> 56);
  hash &= 0xFF;
  hash += !(hash);
  hash -= (hash == 255);
  return hash;
}

FIO_IFUNC uint64_t FIO_NAME(FIO_MAP_NAME,
                            __is_eq_hash)(FIO_NAME(FIO_MAP_NAME, node_s) * o,
                                          uint64_t hash) {
#if FIO_MAP_RECALC_HASH && defined(FIO_MAP_HASH_FN)
  uint64_t khash = FIO_MAP_HASH_FN(FIO_MAP_KEY_FROM_INTERNAL(o->key));
  khash += !khash;
#else
  const uint64_t khash = o->hash;
#endif
  return (khash == hash);
}

typedef struct FIO_NAME(FIO_MAP_NAME, __each_node_s) {
  FIO_NAME(FIO_MAP_NAME, s) * map;
  FIO_NAME(FIO_MAP_NAME, node_s) * node;
  int (*fn)(struct FIO_NAME(FIO_MAP_NAME, __each_node_s) *);
  void *udata;
} FIO_NAME(FIO_MAP_NAME, __each_node_s);

void fio___map___each_node___(void); /* IDE Marker */
/* perform task for each node. */
FIO_IFUNC int FIO_NAME(FIO_MAP_NAME,
                       __each_node)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                    int (*fn)(FIO_NAME(FIO_MAP_NAME,
                                                       __each_node_s) *),
                                    void *udata) {
  FIO_NAME(FIO_MAP_NAME, __each_node_s)
  each = {.map = o, .fn = fn, .udata = udata};
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  size_t counter = o->count;
  if (!counter)
    return 0;
#if FIO_MAP_ORDERED
  FIO_INDEXED_LIST_EACH(o->map, node, o->head, pos) {
    each.node = o->map + pos;
    if (each.fn(&each))
      return -1;
    --counter;
    if (FIO_UNLIKELY(imap != FIO_NAME(FIO_MAP_NAME, __imap)(o)))
      return -1;
  }
#else
  const size_t len = FIO_MAP_CAPA(o->bits);
  if (FIO_UNLIKELY(o->bits > 5 && (FIO_MAP_CAPA(o->bits) >> 2) > o->count))
    goto sparse_map;
  for (size_t i = 0; counter; ++i) {
    if (!imap[i] || imap[i] == 255)
      continue;
    each.node = o->map + i;
    if (FIO_UNLIKELY(each.fn(&each)))
      return -1;
    --counter;
    if (FIO_UNLIKELY(imap != FIO_NAME(FIO_MAP_NAME, __imap)(o)))
      return -1;
  }
  FIO_ASSERT_DEBUG(
      !counter,
      "detected error while looping over all elements in map (%zu/%zu)",
      counter,
      (size_t)FIO_MAP_CAPA(o->bits));
  return 0;

sparse_map:
  for (size_t i = 0; counter && i < len; i += 64) {
    uint64_t bitmap = 0;
    for (size_t j = 0; j < 64; j += 8) {
      uint64_t tmp = *((uint64_t *)(imap + i + j));
      uint64_t inv = ~tmp;
      tmp = FIO_HAS_FULL_BYTE64(tmp);
      inv = FIO_HAS_FULL_BYTE64(inv);
      tmp |= inv;
      FIO_HAS_BYTE2BITMAP(tmp, 7);
      bitmap |= (tmp << j);
    }
    bitmap = ~bitmap; /* where 1 was a free slot, now it's an occupied one */
    for (size_t j = 0; bitmap; ++j) {
      if ((bitmap & 1)) {
        each.node = o->map + i + j;
        if (each.fn(&each))
          return -1;
        --counter;
        if (imap != FIO_NAME(FIO_MAP_NAME, __imap)(o))
          return -1;
      }
      bitmap >>= 1;
    }
  }
#endif
  FIO_ASSERT_DEBUG(
      !counter,
      "detected error while looping over all elements in map (%zu/%zu)",
      counter,
      (size_t)FIO_MAP_CAPA(o->bits));
  return 0;
}

#if !FIO_MAP_KEY_DESTROY_SIMPLE || !FIO_MAP_VALUE_DESTROY_SIMPLE
static int FIO_NAME(FIO_MAP_NAME,
                    __destroy_map_task)(FIO_NAME(FIO_MAP_NAME, __each_node_s) *
                                        e) {
  FIO_MAP_KEY_DESTROY(e->node->key);
  FIO_MAP_VALUE_DESTROY(e->node->value);
  return 0;
}
#endif

/* Destroys and exsiting map. */
FIO_IFUNC void FIO_NAME(FIO_MAP_NAME,
                        __destroy_map)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                       _Bool should_zero) {
#if !FIO_MAP_KEY_DESTROY_SIMPLE || !FIO_MAP_VALUE_DESTROY_SIMPLE
  FIO_NAME(FIO_MAP_NAME, __each_node)
  (o, FIO_NAME(FIO_MAP_NAME, __destroy_map_task), NULL);
#endif
  if (should_zero) /* set only imap to zero */
    FIO_MEMSET((o->map + (1ULL << o->bits)), 0, (1ULL << o->bits));
  o->count = 0;
}

/* Destroys and exsiting map. */
FIO_IFUNC void FIO_NAME(FIO_MAP_NAME, __free_map)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                                  _Bool should_destroy) {
  if (!o->map)
    return;
  if (should_destroy)
    FIO_NAME(FIO_MAP_NAME, __destroy_map)(o, 0);
  FIO_MEM_FREE_(o->map, ((sizeof(o->map[0]) + 1) << o->bits));
  FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_MAP_NAME, destroy));
  *o = (FIO_NAME(FIO_MAP_NAME, s)){0};
}

#ifndef H___FIO_MAP_INDEX_TYPE___H
#define H___FIO_MAP_INDEX_TYPE___H
typedef struct {
  uint32_t home;
  uint32_t act;
  uint32_t alt;
  uint32_t bhash;
} fio___map_node_info_s;
#endif

/** internal object data representation */
typedef struct FIO_NAME(FIO_MAP_NAME, __o_node_s) {
  uint64_t hash;
  FIO_MAP_KEY key;
#ifdef FIO_MAP_VALUE
  FIO_MAP_VALUE value;
#endif
} FIO_NAME(FIO_MAP_NAME, __o_node_s);

/* seek a node for very small collections 8 item capacity at most */
FIO_SFUNC fio___map_node_info_s FIO_NAME(FIO_MAP_NAME, __node_info_mini)(
    FIO_NAME(FIO_MAP_NAME, s) * o,
    FIO_NAME(FIO_MAP_NAME, __o_node_s) * node) {
  // FIO_LOG_INFO("seek as linear array for h %llu", node->hash);
  fio___map_node_info_s r = {
      (uint32_t)-1,
      (uint32_t)-1,
      (uint32_t)-1,
      (uint32_t)FIO_NAME(FIO_MAP_NAME, __byte_hash)(node->hash)};
  if (!o->bits)
    return r;
  const uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  const uint32_t capa = (uint32_t)FIO_MAP_CAPA(o->bits);
  const uint32_t mask = capa - 1;
  size_t pos = node->hash & 0xFF;
  for (uint32_t i = 0; i < capa; ++i) {
    pos = (pos + i) & mask;
    if (imap[pos] == r.bhash &&
        FIO_NAME(FIO_MAP_NAME, __is_eq_hash)(o->map + pos, node->hash) &&
        FIO_MAP_KEY_CMP(o->map[pos].key, node->key)) {
      r.act = (uint32_t)pos;
      return r;
    } else if (!imap[pos]) {
      r.alt = r.home = (uint32_t)pos;
      return r;
    } else if (imap[pos] == 255U) { /* "home" has been occupied before */
      r.alt = r.home = (uint32_t)pos;
    }
  }
  return r;
}

/* seek a node for medium sized collections, 16-512 item capacity. */
FIO_SFUNC fio___map_node_info_s FIO_NAME(FIO_MAP_NAME, __node_info_med)(
    FIO_NAME(FIO_MAP_NAME, s) * o,
    FIO_NAME(FIO_MAP_NAME, __o_node_s) * node) {
  // FIO_LOG_INFO("seek as linear array for h %llu", node->hash);
  static int guard_print = 0;
  fio___map_node_info_s r = {
      (uint32_t)-1,
      (uint32_t)-1,
      (uint32_t)-1,
      (uint32_t)FIO_NAME(FIO_MAP_NAME, __byte_hash)(node->hash)};
  const uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  const uint32_t mask = (uint32_t)(FIO_MAP_CAPA(o->bits) - 1);
  uint32_t guard = FIO_MAP_ATTACK_LIMIT;
  uint32_t pos = r.home = (node->hash & mask);
  uint32_t step = 2;
  uint32_t attempts = (mask < 511) ? ((mask >> 2) | 8) : 127;
  for (; r.alt == (uint32_t)-1 && attempts; --attempts) {
    if (!imap[pos]) {
      r.alt = pos;
      return r;
    } else if (imap[pos] == 255U) { /* "home" has been occupied before */
      r.alt = pos;
    } else if (imap[pos] == r.bhash &&
               FIO_NAME(FIO_MAP_NAME, __is_eq_hash)(o->map + pos, node->hash)) {
      if (FIO_MAP_KEY_CMP(o->map[pos].key, node->key)) {
        r.act = pos;
        return r;
      }
      if (!--guard) {
        r.act = pos;
        goto possible_attack;
      }
    }
    pos = ((pos + (step++)) & mask);
  }
  for (; attempts; --attempts) {
    if (imap[pos] == r.bhash &&
        FIO_NAME(FIO_MAP_NAME, __is_eq_hash)(o->map + pos, node->hash)) {
      if (FIO_MAP_KEY_CMP(o->map[pos].key, node->key)) {
        r.act = pos;
        return r;
      }
      if (!--guard) {
        r.act = pos;
        goto possible_attack;
      }
    }
    if (!imap[pos])
      return r;
    pos = ((pos + (step++)) & mask);
  }
  if (r.alt == (uint32_t)-1)
    r.home = r.alt;
  return r;

possible_attack:
  if (!guard_print) {
    guard_print = 1;
    FIO_LOG_SECURITY("hash map " FIO_MACRO2STR(
        FIO_NAME(FIO_MAP_NAME, s)) " under attack? (full collision guard)");
  }
  return r;
}

/* seek a node for larger collections, where 8 byte grouping is meaningless */
FIO_SFUNC fio___map_node_info_s FIO_NAME(FIO_MAP_NAME, __node_info_full)(
    FIO_NAME(FIO_MAP_NAME, s) * o,
    FIO_NAME(FIO_MAP_NAME, __o_node_s) * node) {
  // FIO_LOG_INFO("seek as linear array for h %llu", node->hash);
  static int guard_print = 0;
  fio___map_node_info_s r = {
      (uint32_t)-1,
      (uint32_t)-1,
      (uint32_t)-1,
      (uint32_t)FIO_NAME(FIO_MAP_NAME, __byte_hash)(node->hash)};
  const uint32_t mask = (FIO_MAP_CAPA(o->bits) - 1) & (~(uint32_t)7ULL);
  const uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  const size_t attempt_limit = o->bits + 7;
  const uint64_t mbyte64 = ~(UINT64_C(0x0101010101010101) * (uint64_t)r.bhash);
  uint32_t guard = FIO_MAP_ATTACK_LIMIT;
  uint32_t pos = r.home = (node->hash & mask);
  size_t attempt = 0;
  for (; r.alt == (uint32_t)-1 && attempt < attempt_limit; ++attempt) {
    uint64_t group = fio_buf2u64_le(imap + pos);
    group ^= mbyte64;
    group &= UINT64_C(0x7F7F7F7F7F7F7F7F);
    group += UINT64_C(0x0101010101010101);
    group &= UINT64_C(0x8080808080808080);
    while (group) {
      uint32_t offset = (uint32_t)fio_lsb_index_unsafe(group);
      group ^= (uint64_t)1ULL << offset;
      offset >>= 3;
      offset += pos;
      if (imap[offset] == r.bhash &&
          FIO_NAME(FIO_MAP_NAME, __is_eq_hash)(o->map + offset, node->hash)) {
        if (FIO_MAP_KEY_CMP(o->map[offset].key, node->key)) {
          r.act = offset;
          return r;
        }
        if (!--guard) {
          r.act = offset;
          goto possible_attack;
        }
      }
    }
    group = fio_buf2u64_le(imap + pos);
    group &= UINT64_C(0x7F7F7F7F7F7F7F7F);
    group += UINT64_C(0x0101010101010101);
    group &= UINT64_C(0x8080808080808080);
    while (group) {
      uint32_t offset = (uint32_t)fio_lsb_index_unsafe(group);
      group ^= (uint64_t)1ULL << offset;
      offset >>= 3;
      offset += pos;
      if (imap[offset] == 255U) {
        r.alt = offset;
        break;
      }
    }
    group = ~fio_buf2u64_le(imap + pos);
    group &= UINT64_C(0x7F7F7F7F7F7F7F7F);
    group += UINT64_C(0x0101010101010101);
    group &= UINT64_C(0x8080808080808080);
    while (group) {
      uint32_t offset = (uint32_t)fio_lsb_index_unsafe(group);
      group ^= (uint64_t)1ULL << offset;
      offset >>= 3;
      offset += pos;
      if (!imap[offset]) {
        r.alt = offset;
        return r;
      }
    }
    pos += (attempt + 2) << 3;
    pos &= mask;
  }
  for (; attempt < attempt_limit; ++attempt) {
    uint64_t group = fio_buf2u64_le(imap + pos);
    group ^= mbyte64;
    group &= UINT64_C(0x7F7F7F7F7F7F7F7F);
    group += UINT64_C(0x0101010101010101);
    group &= UINT64_C(0x8080808080808080);
    while (group) {
      uint32_t offset = (uint32_t)fio_lsb_index_unsafe(group);
      group ^= (uint64_t)1ULL << offset;
      offset >>= 3;
      offset += pos;
      if (imap[offset] == r.bhash &&
          FIO_NAME(FIO_MAP_NAME, __is_eq_hash)(o->map + offset, node->hash)) {
        if (FIO_MAP_KEY_CMP(o->map[offset].key, node->key)) {
          r.act = offset;
          return r;
        }
        if (!--guard) {
          r.act = offset;
          goto possible_attack;
        }
      }
    }
    group = ~fio_buf2u64_le(imap + pos);
    group &= UINT64_C(0x7F7F7F7F7F7F7F7F);
    group += UINT64_C(0x0101010101010101);
    group &= UINT64_C(0x8080808080808080);
    while (group) {
      uint32_t offset = (uint32_t)fio_lsb_index_unsafe(group);
      group ^= (uint64_t)1ULL << offset;
      offset >>= 3;
      offset += pos;
      if (!imap[offset]) {
        return r;
      }
    }
    pos += (attempt + 2) << 3;
    pos &= mask;
  }
  if (r.alt == (uint32_t)-1)
    r.home = r.alt;
  return r;
possible_attack:
  if (!guard_print) {
    guard_print = 1;
    FIO_LOG_SECURITY("hash map " FIO_MACRO2STR(
        FIO_NAME(FIO_MAP_NAME, s)) " under attack? (full collision guard)");
  }
  return r;
}

FIO_IFUNC fio___map_node_info_s
FIO_NAME(FIO_MAP_NAME, __node_info)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                    FIO_NAME(FIO_MAP_NAME, __o_node_s) * node) {
#if defined(FIO_MAP_HASH_FN)
  if (!node->hash)
    node->hash = FIO_MAP_HASH_FN(node->key);
#endif
  node->hash += !node->hash;
  if (o->bits < 4)
    return FIO_NAME(FIO_MAP_NAME, __node_info_mini)(o, node);
  else if (o->bits < 9)
    return FIO_NAME(FIO_MAP_NAME, __node_info_med)(o, node);
  else
    return FIO_NAME(FIO_MAP_NAME, __node_info_full)(o, node);
}

#if FIO_MAP_ORDERED
FIO_IFUNC void FIO_NAME(FIO_MAP_NAME,
                        __update_order)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                        uint32_t i) {
  if (o->count == 1) {
    o->head = i;
    o->map[i].node.next = o->map[i].node.prev = i;
  } else {
    FIO_INDEXED_LIST_PUSH(o->map, node, o->head, i);
  }
}
#define FIO___MAP_UPDATE_ORDER(map, at)                                        \
  FIO_NAME(FIO_MAP_NAME, __update_order)(map, at)
#else
#define FIO___MAP_UPDATE_ORDER(map, at)
#endif

static int FIO_NAME(FIO_MAP_NAME,
                    __move2map_task)(FIO_NAME(FIO_MAP_NAME, __each_node_s) *
                                     e) {
  FIO_NAME(FIO_MAP_NAME, s) *dest = (FIO_NAME(FIO_MAP_NAME, s) *)e->udata;
  FIO_NAME(FIO_MAP_NAME, __o_node_s)
  n = {
    .key = FIO_MAP_KEY_FROM_INTERNAL(e->node->key),
#if !FIO_MAP_RECALC_HASH
    .hash = e->node->hash,
#endif
  };
  fio___map_node_info_s i = FIO_NAME(FIO_MAP_NAME, __node_info)(dest, &n);
  if (i.home == (uint32_t)-1) {
    FIO_LOG_ERROR("move2map FAILED (%zu/%zu)!",
                  e->node - e->map->map,
                  FIO_MAP_CAPA(dest->bits));
    return -1;
  }
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(dest);
  ++dest->count;
  /* insert at best position */
  imap[i.alt] = i.bhash;
  dest->map[i.alt] = e->node[0];
  FIO___MAP_UPDATE_ORDER(dest, i.alt);
  return 0;
}

void fio___map___move2map___(void); /* IDE Marker */
FIO_IFUNC int FIO_NAME(FIO_MAP_NAME,
                       __move2map)(FIO_NAME(FIO_MAP_NAME, s) * dest,
                                   FIO_NAME(FIO_MAP_NAME, s) * src) {
  return FIO_NAME(
      FIO_MAP_NAME,
      __each_node)(src, FIO_NAME(FIO_MAP_NAME, __move2map_task), dest);
}

/* Inserts a node to the map. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME,
                            __node_insert)(FIO_NAME(FIO_MAP_NAME, s) * o,
#ifndef FIO_MAP_HASH_FN
                                           uint64_t hash,
#endif
                                           FIO_MAP_KEY key,
#ifdef FIO_MAP_VALUE
                                           FIO_MAP_VALUE value,
#endif
#ifdef FIO_MAP_VALUE
                                           FIO_MAP_VALUE_INTERNAL *old,
#else
                                           FIO_MAP_KEY_INTERNAL *old,
#endif
                                           _Bool overwrite) {
  static FIO_NAME(FIO_MAP_NAME, s) *last_collision = NULL;
  uint32_t r = -1;
  FIO_NAME(FIO_MAP_NAME, s) tmp;
  FIO_NAME(FIO_MAP_NAME, __o_node_s)
  node = {
      .key = key,
#ifdef FIO_MAP_VALUE
      .value = value,
#endif
#ifndef FIO_MAP_HASH_FN
      .hash = hash,
#endif
  };
  fio___map_node_info_s info;
  info = FIO_NAME(FIO_MAP_NAME, __node_info)(o, &node);
  if (info.act != r)
    goto perform_overwrite;
  if (info.home == r)
    goto reallocate_map;

insert:
  ++o->count;
  r = info.alt;
  FIO_NAME(FIO_MAP_NAME, __imap)(o)[r] = info.bhash;
#if !FIO_MAP_RECALC_HASH
  o->map[r].hash = node.hash,
#endif
  FIO_MAP_KEY_COPY(o->map[r].key, node.key);
  FIO_MAP_VALUE_COPY(o->map[r].value, node.value);
  FIO___MAP_UPDATE_ORDER(o, r);
  return r;

perform_overwrite:
  r = info.act;
  FIO_MAP_KEY_DISCARD(node.key);
  if (!overwrite) {
    FIO_MAP_VALUE_DISCARD(value);
    return r;
  }
#ifdef FIO_MAP_VALUE
  if (old)
    *old = o->map[r].value;
  else {
    FIO_MAP_VALUE_DESTROY(o->map[r].value);
  }
  FIO_MAP_VALUE_COPY(o->map[r].value, node.value);
#else
  (void)old;
#endif
#if FIO_MAP_ORDERED
  if (o->head == r)
    o->head = o->map[o->head].node.prev;
  FIO_INDEXED_LIST_REMOVE(o->map, node, r);
  FIO___MAP_UPDATE_ORDER(o, r);
#endif
  return r;

reallocate_map:
  /* reallocate map */
  for (size_t i = 1; i < 3; ++i) {
    if (FIO_NAME(FIO_MAP_NAME, __allocate_map)(&tmp, (uint32_t)(o->bits + i)))
      goto no_memory;
    if (FIO_NAME(FIO_MAP_NAME, __move2map)(&tmp, o)) {
      FIO_NAME(FIO_MAP_NAME, __free_map)(&tmp, 0);
      continue;
    }
    info = FIO_NAME(FIO_MAP_NAME, __node_info)(&tmp, &node);
    if (info.home != r) {
      FIO_NAME(FIO_MAP_NAME, __free_map)(o, 0);
      *o = tmp;
      goto insert;
    }
    FIO_NAME(FIO_MAP_NAME, __free_map)(&tmp, 0);
  }
  goto security_partial;

no_memory:
  FIO_MAP_KEY_DISCARD(key);
  FIO_MAP_VALUE_DISCARD(value);
  FIO_LOG_ERROR(
      "unknown error occurred trying to add an entry to the map (capa: %zu)",
      (size_t)FIO_MAP_CAPA(o->bits));
  FIO_ASSERT_DEBUG(0, "these errors shouldn't happen - no memory?");
  return r;

security_partial:
  if (last_collision != o) {
    FIO_LOG_SECURITY(
        "hash map " FIO_MACRO2STR(FIO_NAME(
            FIO_MAP_NAME,
            s)) " under attack? (partial/full collision guard) - capa: %zu.",
        (size_t)FIO_MAP_CAPA(o->bits));
    last_collision = o;
  }
  return r;
}

/* Inserts a node to the map. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME,
                            __node_find)(FIO_NAME(FIO_MAP_NAME, s) * o,
#ifndef FIO_MAP_HASH_FN
                                         uint64_t hash,
#endif
                                         FIO_MAP_KEY key) {
  uint32_t r = -1;
  fio___map_node_info_s info;
  FIO_NAME(FIO_MAP_NAME, __o_node_s)
  node = {
      .key = key,
#ifndef FIO_MAP_HASH_FN
      .hash = hash,
#endif
  };
  if (!o->map)
    return r;
  info = FIO_NAME(FIO_MAP_NAME, __node_info)(o, &node);
  return (r = info.act);
}

/* Deletes a known node from the map. */
FIO_IFUNC void FIO_NAME(FIO_MAP_NAME,
                        __node_delete_at)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                          uint32_t at,
#ifdef FIO_MAP_VALUE
                                          FIO_MAP_VALUE_INTERNAL *old
#else
                                          FIO_MAP_KEY_INTERNAL *old
#endif
) {
  --o->count;
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  imap[at] = 255U; /* mark as deleted */
  if (old) {
#ifdef FIO_MAP_VALUE
    FIO_MAP_KEY_DESTROY(o->map[at].key);
    *old = o->map[at].value;
#else
    *old = o->map[at].key;
#endif
  } else {
    FIO_MAP_KEY_DESTROY(o->map[at].key);
    FIO_MAP_VALUE_DESTROY(o->map[at].value);
  }

#if FIO_MAP_ORDERED
  if (o->head == at) {
    o->head = (o->count ? o->map[o->head].node.next : 0);
  }
  FIO_INDEXED_LIST_REMOVE(o->map, node, at);
#endif
}

/* Deletes a node from the map. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME,
                            __node_delete)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                           FIO_MAP_KEY key,
#ifndef FIO_MAP_HASH_FN
                                           uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                                           FIO_MAP_VALUE_INTERNAL *old
#else
                                           FIO_MAP_KEY_INTERNAL *old
#endif
) {
  uint32_t r = (uint32_t)-1;
  if (!o->map)
    return r;
  fio___map_node_info_s info;
  FIO_NAME(FIO_MAP_NAME, __o_node_s)
  node = {
      .key = key,
#ifndef FIO_MAP_HASH_FN
      .hash = hash,
#endif
  };
  info = FIO_NAME(FIO_MAP_NAME, __node_info)(o, &node);
  if (info.act == r)
    return r;
  r = 0;
  FIO_NAME(FIO_MAP_NAME, __node_delete_at)(o, info.act, old);
  return r;
}

/* *****************************************************************************






Map API






***************************************************************************** */

/** Destroys the object, re-initializing its container. */
SFUNC void FIO_NAME(FIO_MAP_NAME, destroy)(FIO_MAP_PTR map) {
  // FIO_PTR_TAG_VALID_OR_RETURN(map, 0);
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  FIO_NAME(FIO_MAP_NAME, __free_map)(m, 1);
  *m = (FIO_NAME(FIO_MAP_NAME, s)){0};
}

/** Reserves at minimum the capacity requested. */
SFUNC void FIO_NAME(FIO_MAP_NAME, reserve)(FIO_MAP_PTR map, size_t capa) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (capa <= FIO_MAP_CAPA(m->bits))
    return;
  uint32_t bits = m->bits;
  for (; capa > FIO_MAP_CAPA(bits); ++bits)
    ;
  FIO_NAME(FIO_MAP_NAME, s) tmp;
  if (FIO_NAME(FIO_MAP_NAME, __allocate_map)(&tmp, bits))
    goto no_memory;
  if (m->count && FIO_NAME(FIO_MAP_NAME, __move2map)(&tmp, m)) {
    FIO_NAME(FIO_MAP_NAME, __free_map)(&tmp, 0);
    goto no_memory;
  }
  FIO_NAME(FIO_MAP_NAME, __free_map)(m, 0);
  *m = tmp;
  return;
no_memory:
  FIO_LOG_ERROR("unknown error occurred trying to rehash the map");
  FIO_ASSERT_DEBUG(0, "these errors shouldn't happen - no memory?");
  return;
}

/** Removes an object in the map, returning a pointer to the map data. */
SFUNC int FIO_NAME(FIO_MAP_NAME, remove)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                         uint64_t hash,
#endif
                                         FIO_MAP_KEY key,
#if defined(FIO_MAP_VALUE)
                                         FIO_MAP_VALUE_INTERNAL *old
#else
                                         FIO_MAP_KEY_INTERNAL *old
#endif
) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, -1);
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (!m->count)
    return -1;
  return FIO_NAME(FIO_MAP_NAME, __node_delete)(m,
                                               key,
#if !defined(FIO_MAP_HASH_FN)
                                               hash,
#endif
                                               old);
}

FIO_SFUNC int FIO_NAME(FIO_MAP_NAME,
                       __evict_task)(FIO_NAME(FIO_MAP_NAME, __each_node_s) *
                                     e) {
  size_t *counter = (size_t *)e->udata;
  FIO_NAME(FIO_MAP_NAME, __node_delete_at)
  (e->map, (uint32_t)(e->node - e->map->map), NULL);
  if ((counter[0] -= 1))
    return 0;
  return -1;
}
/** Evicts elements in order least recently used (LRU), FIFO or undefined. */
SFUNC void FIO_NAME(FIO_MAP_NAME, evict)(FIO_MAP_PTR map,
                                         size_t number_of_elements) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  if (!number_of_elements)
    return;
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (m->count <= number_of_elements) {
    FIO_NAME(FIO_MAP_NAME, __destroy_map)(m, 1);
    return;
  }
  FIO_NAME(FIO_MAP_NAME, __each_node)
  (m, FIO_NAME(FIO_MAP_NAME, __evict_task), &number_of_elements);
}

/** Removes all objects from the map, without releasing the map's resources.
 */
SFUNC void FIO_NAME(FIO_MAP_NAME, clear)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (m->map)
    FIO_NAME(FIO_MAP_NAME, __destroy_map)(m, 1);
}

/** Attempts to minimize memory use. */
SFUNC void FIO_NAME(FIO_MAP_NAME, compact)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (!o->map || !o->count)
    return;
  FIO_NAME(FIO_MAP_NAME, s) cpy = {0};
  uint32_t bits = o->bits;
  while (FIO_MAP_CAPA(bits >> 1) > o->count)
    bits >>= 1;
  ++bits;
  if (bits >= o->bits)
    return;
  for (size_t i = 0; i < 2; ++i) {
    if (FIO_NAME(FIO_MAP_NAME, __allocate_map)(&cpy, bits))
      return;
    if (!FIO_NAME(FIO_MAP_NAME, __move2map)(&cpy, o))
      goto finish;
    FIO_NAME(FIO_MAP_NAME, __free_map)(&cpy, 0);
    ++bits;
  }
  return;

finish:
  FIO_NAME(FIO_MAP_NAME, __free_map)(o, 0);
  o[0] = cpy;
  return;
}

SFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME, set_ptr)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                    uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                                    FIO_MAP_KEY key,
                                    FIO_MAP_VALUE val,
                                    FIO_MAP_VALUE_INTERNAL *old,
                                    int overwrite
#else
                                    FIO_MAP_KEY key
#endif
    ) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, NULL);
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  uint32_t i = FIO_NAME(FIO_MAP_NAME, __node_insert)(m,
#ifndef FIO_MAP_HASH_FN
                                                     hash,
#endif
                                                     key,
#ifdef FIO_MAP_VALUE
                                                     val,
                                                     old,
                                                     overwrite
#else
                                                     NULL,
                                                     1
#endif
  );
  if (i == (uint32_t)-1)
    return NULL;
  return m->map + i;
}

/**
 * The core get function. This function returns NULL if item is missing.
 *
 * NOTE: the function returns a pointer to the map's internal storage.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME, get_ptr)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                    uint64_t hash,
#endif
                                    FIO_MAP_KEY key) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, NULL);
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  uint32_t i = FIO_NAME(FIO_MAP_NAME, __node_find)(m,
#ifndef FIO_MAP_HASH_FN
                                                   hash,
#endif
                                                   key);
  if (i == (uint32_t)-1)
    return NULL;
  return m->map + i;
}

/* *****************************************************************************



Map Iterators



***************************************************************************** */

SFUNC FIO_NAME(FIO_MAP_NAME, iterator_s)
    FIO_NAME(FIO_MAP_NAME,
             get_next)(FIO_MAP_PTR map,
                       FIO_NAME(FIO_MAP_NAME, iterator_s) * current_pos) {
  FIO_NAME(FIO_MAP_NAME, iterator_s) r = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(map, r);
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(m);
  if (!m->count)
    return r;
  if (!current_pos)
    goto empty;
  if (current_pos->private_.pos + 1 == m->count)
    return r;
  if (current_pos->private_.map_validator != (uintptr_t)(m->map))
    return r; /* mutation stops iteration */
#if FIO_MAP_ORDERED
  if (current_pos->node->node.next == m->head)
    return r;
  r.node = m->map + current_pos->node->node.next;
#else
  for (size_t i = current_pos->node - m->map + 1; i < FIO_MAP_CAPA(m->bits);
       ++i) {
    if (!imap[i] || imap[i] == 0xFFU)
      continue;
    r.node = m->map + i;
    break;
  }
  if (!r.node)
    return r;
#endif

  r = (FIO_NAME(FIO_MAP_NAME, iterator_s)) {
    .node = r.node, .key = FIO_MAP_KEY_FROM_INTERNAL(r.node->key),
#ifdef FIO_MAP_VALUE
    .value = FIO_MAP_VALUE_FROM_INTERNAL(r.node->value),
#endif
#if !FIO_MAP_RECALC_HASH
    .hash = r.node->hash,
#endif
    .private_ = {.index = (uint32_t)(r.node - m->map),
                 .pos = current_pos->private_.pos + 1,
                 .map_validator = (uintptr_t)m->map},
  };
  return r;
empty:

#if FIO_MAP_ORDERED
  r = (FIO_NAME(FIO_MAP_NAME, iterator_s)) {
    .node = m->map + m->head,
    .key = FIO_MAP_KEY_FROM_INTERNAL(m->map[m->head].key),
#ifdef FIO_MAP_VALUE
    .value = FIO_MAP_VALUE_FROM_INTERNAL(m->map[m->head].value),
#endif
#if !FIO_MAP_RECALC_HASH
    .hash = m->map[m->head].hash,
#endif
    .private_ = {.index = m->head,
                 .pos = 0,
                 .map_validator = (uintptr_t)m->map},
  };
#else
  for (size_t i = 0; i < FIO_MAP_CAPA(m->bits); ++i) {
    if (!imap[i] || imap[i] == 0xFFU)
      continue;
    r.node = m->map + i;
    break;
  }

  r = (FIO_NAME(FIO_MAP_NAME, iterator_s)) {
    .node = r.node, .key = FIO_MAP_KEY_FROM_INTERNAL(r.node->key),
#ifdef FIO_MAP_VALUE
    .value = FIO_MAP_VALUE_FROM_INTERNAL(r.node->value),
#endif
#if !FIO_MAP_RECALC_HASH
    .hash = r.node->hash,
#endif
    .private_ = {.index = (uint32_t)(r.node - m->map),
                 .pos = 0,
                 .map_validator = (uintptr_t)m->map},
  };

#endif
  return r;
  (void)imap; /* if unused */
}

SFUNC FIO_NAME(FIO_MAP_NAME, iterator_s)
    FIO_NAME(FIO_MAP_NAME,
             get_prev)(FIO_MAP_PTR map,
                       FIO_NAME(FIO_MAP_NAME, iterator_s) * current_pos) {
  FIO_NAME(FIO_MAP_NAME, iterator_s) r = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(map, r);
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
#if FIO_MAP_ORDERED
  uint32_t ipos;
#else
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(m);
#endif
  if (!m->count)
    return r;
  if (!current_pos)
    goto empty;
  if (!current_pos->private_.pos)
    return r;
  if (current_pos->private_.map_validator != (uintptr_t)(m->map))
    return r; /* mutation stops iteration */
#if FIO_MAP_ORDERED
  if (current_pos->private_.index == m->head)
    return r;
  r.node = m->map + current_pos->node->node.prev;
#else
  for (size_t i = current_pos->node - m->map; i;) {
    --i;
    if (!imap[i] || imap[i] == 0xFFU)
      continue;
    r.node = m->map + i;
    break;
  }
#endif

  r = (FIO_NAME(FIO_MAP_NAME, iterator_s)) {
    .node = r.node, .key = FIO_MAP_KEY_FROM_INTERNAL(r.node->key),
#ifdef FIO_MAP_VALUE
    .value = FIO_MAP_VALUE_FROM_INTERNAL(r.node->value),
#endif
#if !FIO_MAP_RECALC_HASH
    .hash = r.node->hash,
#endif
    .private_ = {.index = (uint32_t)(r.node - m->map),
                 .pos = current_pos->private_.pos - 1,
                 .map_validator = (uintptr_t)m->map},
  };
  return r;
empty:

#if FIO_MAP_ORDERED

  ipos = m->map[m->head].node.prev;
  r = (FIO_NAME(FIO_MAP_NAME, iterator_s)) {
    .node = m->map + ipos, .key = FIO_MAP_KEY_FROM_INTERNAL(m->map[ipos].key),
#ifdef FIO_MAP_VALUE
    .value = FIO_MAP_VALUE_FROM_INTERNAL(m->map[ipos].value),
#endif
#if !FIO_MAP_RECALC_HASH
    .hash = m->map[ipos].hash,
#endif
    .private_ = {.index = ipos,
                 .pos = m->count - 1,
                 .map_validator = (uintptr_t)m->map},
  };

#else
  for (size_t i = FIO_MAP_CAPA(m->bits); i;) {
    --i;
    if (!imap[i] || imap[i] == 0xFFU)
      continue;
    r.node = m->map + i;
    break;
  }

  r = (FIO_NAME(FIO_MAP_NAME, iterator_s)) {
    .node = r.node, .key = FIO_MAP_KEY_FROM_INTERNAL(r.node->key),
#ifdef FIO_MAP_VALUE
    .value = FIO_MAP_VALUE_FROM_INTERNAL(r.node->value),
#endif
#if !FIO_MAP_RECALC_HASH
    .hash = r.node->hash,
#endif
    .private_ = {.index = (uint32_t)(r.node - m->map),
                 .pos = m->count - 1,
                 .map_validator = (uintptr_t)m->map},
  };

#endif

  return r;
}

/* *****************************************************************************



Map Each



***************************************************************************** */

typedef struct {
  FIO_NAME(FIO_MAP_NAME, each_s) each;
  ssize_t start_at;
} FIO_NAME(FIO_MAP_NAME, __each_info_s);

FIO_SFUNC int FIO_NAME(FIO_MAP_NAME,
                       __each_task)(FIO_NAME(FIO_MAP_NAME, __each_node_s) * e) {
  int r;
  FIO_NAME(FIO_MAP_NAME, __each_info_s) *info =
      (FIO_NAME(FIO_MAP_NAME, __each_info_s) *)e->udata;
  info->each.key = FIO_MAP_KEY_FROM_INTERNAL(e->node->key);
#ifdef FIO_MAP_VALUE
  info->each.value = FIO_MAP_VALUE_FROM_INTERNAL(e->node->value);
#endif
  r = info->each.task(&info->each);
  ++info->each.index;
  return r;
}

FIO_SFUNC int FIO_NAME(FIO_MAP_NAME, __each_task_offset)(
    FIO_NAME(FIO_MAP_NAME, __each_node_s) * e) {
  FIO_NAME(FIO_MAP_NAME, __each_info_s) *info =
      (FIO_NAME(FIO_MAP_NAME, __each_info_s) *)e->udata;
  if (FIO_LIKELY(info->each.index < (uint64_t)info->start_at)) {
    ++info->each.index;
    return 0;
  }
  return (e->fn = FIO_NAME(FIO_MAP_NAME, __each_task))(e);
}

/**
 * Iteration using a callback for each element in the map.
 *
 * The callback task function must accept an each_s pointer, see above.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
SFUNC uint32_t FIO_NAME(FIO_MAP_NAME,
                        each)(FIO_MAP_PTR map,
                              int (*task)(FIO_NAME(FIO_MAP_NAME, each_s) *),
                              void *udata,
                              ssize_t start_at) {
  uint32_t r = (uint32_t)-1;
  FIO_PTR_TAG_VALID_OR_RETURN(map, r);
  FIO_NAME(FIO_MAP_NAME, s) *m = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (start_at < 0)
    start_at += m->count;
  if (start_at < 0)
    return m->count;
  FIO_NAME(FIO_MAP_NAME, __each_info_s)
  e = {
      .each =
          {
              .parent = map,
              .index = 0,
              .task = task,
              .udata = udata,
          },
      .start_at = start_at,
  };

  FIO_NAME(FIO_MAP_NAME, __each_node)
  (m,
   !start_at ? FIO_NAME(FIO_MAP_NAME, __each_task)
             : FIO_NAME(FIO_MAP_NAME, __each_task_offset),
   &e);
  return (uint32_t)e.each.index;
}

/* *****************************************************************************
Map Testing
***************************************************************************** */
#ifdef FIO_MAP_TEST

#ifdef FIO_MAP_HASH_FN
#define FIO___M_HASH(k)
#else
#define FIO___M_HASH(k) (k),
#endif
#ifdef FIO_MAP_VALUE
#define FIO___M_VAL(v) , (v)
#define FIO___M_OLD    , NULL
#else
#define FIO___M_VAL(v)
#define FIO___M_OLD
#endif

FIO_SFUNC void FIO_NAME_TEST(stl, FIO_MAP_NAME)(void) {
  /* testing only only works with integer external types */
  fprintf(
      stderr,
      "\t* Testing map " FIO_MACRO2STR(FIO_MAP_NAME) " with key " FIO_MACRO2STR(
          FIO_MAP_KEY) " (=> " FIO_MACRO2STR(FIO_MAP_VALUE) ").\n");
  size_t test_len_limit = (1UL << (FIO_MAP_ARRAY_LOG_LIMIT + 15));
  { /* test set / get overwrite , FIO_MAP_EACH and evict */
    FIO_NAME(FIO_MAP_NAME, s) map = FIO_MAP_INIT;
    for (size_t i = 1; i < test_len_limit; ++i) {
      FIO_NAME(FIO_MAP_NAME, set)
      (&map, FIO___M_HASH(i) i FIO___M_VAL(i) FIO___M_OLD);
      FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == i,
                 "map `set` failed? %zu != %zu",
                 (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
                 i);
      for (size_t j = ((i << 2) + 1); j < i; ++j) { /* effects LRU ordering */
        FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, get_ptr)(&map, FIO___M_HASH(j) j) &&
                       FIO_NAME(FIO_MAP_NAME, node2val)(
                           FIO_NAME(FIO_MAP_NAME,
                                    get_ptr)(&map, FIO___M_HASH(j) j)) == j,
                   "map `get` failed? %zu/%zu (%p)",
                   j,
                   i,
                   FIO_NAME(FIO_MAP_NAME, get_ptr)(&map, FIO___M_HASH(j) j));
        FIO_NAME(FIO_MAP_NAME, set)
        (&map, FIO___M_HASH(j) j FIO___M_VAL(j) FIO___M_OLD);
        FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == i,
                   "map `set` added an item that already exists? %zu != %zu",
                   (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
                   i);
      }
    }
    /* test FIO_MAP_EACH and ordering */
    uint32_t count = FIO_NAME(FIO_MAP_NAME, count)(&map);
    uint32_t loop_test = 0;
    FIO_MAP_EACH(FIO_MAP_NAME, &map, i) {
      /* test ordering */
      ++loop_test;
#ifdef FIO_MAP_LRU
      FIO_ASSERT(i.key == loop_test,
                 "map FIO_MAP_EACH LRU ordering broken? %zu != %zu",
                 (size_t)(i.key),
                 (size_t)(count - loop_test));
#elif FIO_MAP_ORDERED
      FIO_ASSERT(i.key == loop_test,
                 "map FIO_MAP_EACH ordering broken? %zu != %zu",
                 (size_t)(i.key),
                 (size_t)(loop_test));
#else
      FIO_ASSERT(i.key < test_len_limit,
                 "map FIO_MAP_EACH invalid data? %zu !< %zu",
                 (size_t)(i.key),
                 (size_t)(test_len_limit));
#endif
    }
    FIO_ASSERT(loop_test == count,
               "FIO_MAP_EACH failed to iterate all elements? (%zu != %zu",
               (size_t)loop_test != (size_t)count);
    loop_test = 0;
    FIO_MAP_EACH_REVERSED(FIO_MAP_NAME, &map, i) {
      /* test reversed ordering */
      ++loop_test;
#ifdef FIO_MAP_LRU
      FIO_ASSERT(i.key == (count - (loop_test - 1)),
                 "map FIO_MAP_EACH_REVERSED LRU ordering broken? %zu != %zu",
                 (size_t)(i.key),
                 (size_t)(count - loop_test));
#elif FIO_MAP_ORDERED
      FIO_ASSERT(i.key == (count - (loop_test - 1)),
                 "map FIO_MAP_EACH_REVERSED ordering broken? %zu != %zu",
                 (size_t)(i.key),
                 (size_t)(loop_test));
#endif
    }
    FIO_ASSERT(
        loop_test == count,
        "FIO_MAP_EACH_REVERSED failed to iterate all elements? (%zu != %zu",
        (size_t)loop_test != (size_t)count);
    /* test `evict` while we're here */
    FIO_NAME(FIO_MAP_NAME, evict)(&map, (count >> 1));
    FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == (count - (count >> 1)),
               "map `evict` count error %zu != %zu",
               (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
               (size_t)(count - (count >> 1)));
    /* cleanup */
    FIO_NAME(FIO_MAP_NAME, destroy)(&map);
  }
#if !FIO_MAP_RECALC_HASH
  { /* test full collision guard and zero hash*/
    FIO_NAME(FIO_MAP_NAME, s) map = FIO_MAP_INIT;
    fprintf(
        stderr,
        "\t* Testing full collision guard for " FIO_MACRO2STR(
            FIO_NAME(FIO_MAP_NAME, s)) " - expect SECURITY log messages.\n");
    for (size_t i = 1; i < 4096; ++i) {
      FIO_NAME(FIO_MAP_NAME, set)
      (&map, FIO___M_HASH(0) i FIO___M_VAL(i) FIO___M_OLD);
    }
    FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map),
               "zero hash fails insertion?");
    FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) <= FIO_MAP_ATTACK_LIMIT,
               "map attack guard failed? %zu != %zu",
               (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
               (size_t)FIO_MAP_ATTACK_LIMIT);
    FIO_NAME(FIO_MAP_NAME, destroy)(&map);
  }
#endif
  { /* test reserve, remove */
    FIO_NAME(FIO_MAP_NAME, s) map = FIO_MAP_INIT;
    FIO_NAME(FIO_MAP_NAME, reserve)(&map, 4096);
    FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, capa)(&map) == 4096,
               "map reserve error? %zu != %zu",
               (size_t)FIO_NAME(FIO_MAP_NAME, capa)(&map),
               4096);
    for (size_t i = 1; i < test_len_limit; ++i) {
      FIO_NAME(FIO_MAP_NAME, set)
      (&map, FIO___M_HASH(i) i FIO___M_VAL(i) FIO___M_OLD);
      FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == i, "insertion failed?");
    }
    for (size_t i = 1; i < test_len_limit; ++i) {
      FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, get)(&map, FIO___M_HASH(i) i),
                 "key missing?");
      size_t count = FIO_NAME(FIO_MAP_NAME, count)(&map);
      FIO_NAME(FIO_MAP_NAME, remove)
      (&map, FIO___M_HASH(i) i, NULL);
      FIO_ASSERT(!FIO_NAME(FIO_MAP_NAME, get)(&map, FIO___M_HASH(i) i),
                 "map_remove error?");
      FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == count - 1,
                 "map count error after removal? %zu != %zu",
                 (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
                 count - 1);
      /* see if removal produces errors while rehashing */
      FIO_NAME(FIO_MAP_NAME, compact)(&map);
    }
    FIO_NAME(FIO_MAP_NAME, destroy)(&map);
  }
}
#undef FIO___M_HASH
#undef FIO___M_VAL
#undef FIO___M_OLD

#endif /* FIO_MAP_TEST */
/* *****************************************************************************
Map Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */

#undef FIO___MAP_UPDATE_ORDER
#undef FIO_MAP___MAKE_BITMAP
#undef FIO_MAP___STEP_POS
#undef FIO_MAP___TEST_MATCH
#undef FIO_MAP_ARRAY_LOG_LIMIT
#undef FIO_MAP_ATTACK_LIMIT
#undef FIO_MAP_CAPA
#undef FIO_MAP_CAPA_BITS_LIMIT
#undef FIO_MAP_CUCKOO_STEPS
#undef FIO_MAP_GET_T
#undef FIO_MAP_HASH_FN
#undef FIO_MAP_IS_SPARSE
#undef FIO_MAP_KEY
#undef FIO_MAP_KEY_BSTR
#undef FIO_MAP_KEY_CMP
#undef FIO_MAP_KEY_COPY
#undef FIO_MAP_KEY_DESTROY
#undef FIO_MAP_KEY_DESTROY_SIMPLE
#undef FIO_MAP_KEY_DISCARD
#undef FIO_MAP_KEY_FROM_INTERNAL
#undef FIO_MAP_KEY_INTERNAL
#undef FIO_MAP_KEY_IS_GREATER_THAN
#undef FIO_MAP_KEY_KSTR
#undef FIO_MAP_LRU
#undef FIO_MAP_MINIMAL_BITS
#undef FIO_MAP_NAME
#undef FIO_MAP_ORDERED
#undef FIO_MAP_PTR
#undef FIO_MAP_RECALC_HASH
#undef FIO_MAP_SEEK_LIMIT
#undef FIO_MAP_T
#undef FIO_MAP_TEST
#undef FIO_MAP_VALUE
#undef FIO_MAP_VALUE_BSTR
#undef FIO_MAP_VALUE_COPY
#undef FIO_MAP_VALUE_DESTROY
#undef FIO_MAP_VALUE_DESTROY_SIMPLE
#undef FIO_MAP_VALUE_DISCARD
#undef FIO_MAP_VALUE_FROM_INTERNAL
#undef FIO_MAP_VALUE_INTERNAL

#undef FIO_OMAP_NAME
#undef FIO_UMAP_NAME

#endif /* FIO_MAP_NAME */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_MAP2_NAME map      /* Development inclusion - ignore line */
#define FIO_MAP2_TEST          /* Development inclusion - ignore line */
#define FIO_MAP2_KEY  size_t   /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                  Unordered/Ordered Map Implementation



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_MAP2_NAME)
/* *****************************************************************************
Map Settings - Sets have only keys (value == key) - Hash Maps have values
***************************************************************************** */

/* if FIO_MAP2_KEY_KSTR is defined, use fio_keystr_s keys */
#ifdef FIO_MAP2_KEY_KSTR
#define FIO_MAP2_KEY                  fio_str_info_s
#define FIO_MAP2_KEY_INTERNAL         fio_keystr_s
#define FIO_MAP2_KEY_FROM_INTERNAL(k) fio_keystr_info(&(k))
#define FIO_MAP2_KEY_COPY(dest, src)                                           \
  (dest) = fio_keystr_init((src), FIO_NAME(FIO_MAP2_NAME, __key_alloc))
#define FIO_MAP2_KEY_CMP(a, b) fio_keystr_is_eq2((a), (b))
#define FIO_MAP2_KEY_DESTROY(key)                                              \
  fio_keystr_destroy(&(key), FIO_NAME(FIO_MAP2_NAME, __key_free))
#define FIO_MAP2_KEY_DISCARD(key)
FIO_SFUNC void *FIO_NAME(FIO_MAP2_NAME, __key_alloc)(size_t len) {
  return FIO_MEM_REALLOC_(NULL, 0, len, 0);
}
FIO_SFUNC void FIO_NAME(FIO_MAP2_NAME, __key_free)(void *ptr, size_t len) {
  FIO_MEM_FREE_(ptr, len);
  (void)len; /* if unused */
}
#undef FIO_MAP2_KEY_KSTR

/* if FIO_MAP2_KEY is undefined, assume String keys (using `fio_bstr`). */
#elif !defined(FIO_MAP2_KEY) || defined(FIO_MAP2_KEY_BSTR)
#define FIO_MAP2_KEY                  fio_str_info_s
#define FIO_MAP2_KEY_INTERNAL         char *
#define FIO_MAP2_KEY_FROM_INTERNAL(k) fio_bstr_info((k))
#define FIO_MAP2_KEY_COPY(dest, src)                                           \
  (dest) = fio_bstr_write(NULL, (src).buf, (src).len)
#define FIO_MAP2_KEY_CMP(a, b)    fio_bstr_is_eq2info((a), (b))
#define FIO_MAP2_KEY_DESTROY(key) fio_bstr_free((key))
#define FIO_MAP2_KEY_DISCARD(key)
#endif
#undef FIO_MAP2_KEY_BSTR

#ifndef FIO_MAP2_KEY_INTERNAL
#define FIO_MAP2_KEY_INTERNAL FIO_MAP2_KEY
#endif

#ifndef FIO_MAP2_KEY_FROM_INTERNAL
#define FIO_MAP2_KEY_FROM_INTERNAL(o) o
#endif

#ifndef FIO_MAP2_KEY_COPY
#define FIO_MAP2_KEY_COPY(dest, src) ((dest) = (src))
#endif

#ifndef FIO_MAP2_KEY_CMP
#define FIO_MAP2_KEY_CMP(a, b) ((a) == (b))
#endif

#ifndef FIO_MAP2_KEY_DESTROY
#define FIO_MAP2_KEY_DESTROY(o)
#define FIO_MAP2_KEY_DESTROY_SIMPLE 1
#endif

#ifndef FIO_MAP2_KEY_DISCARD
#define FIO_MAP2_KEY_DISCARD(o)
#endif

/* FIO_MAP2_HASH_FN(key) - used instead of providing a hash value. */
#ifndef FIO_MAP2_HASH_FN
#undef FIO_MAP2_RECALC_HASH
#endif

/* FIO_MAP2_RECALC_HASH - if true, hash values won't be cached. */
#ifndef FIO_MAP2_RECALC_HASH
#define FIO_MAP2_RECALC_HASH 0
#endif

#ifdef FIO_MAP2_VALUE_BSTR
#define FIO_MAP2_VALUE                  fio_str_info_s
#define FIO_MAP2_VALUE_INTERNAL         char *
#define FIO_MAP2_VALUE_FROM_INTERNAL(v) fio_bstr_info((v))
#define FIO_MAP2_VALUE_COPY(dest, src)                                         \
  (dest) = fio_bstr_write(NULL, (src).buf, (src).len)
#define FIO_MAP2_VALUE_DESTROY(v) fio_bstr_free((v))
#define FIO_MAP2_VALUE_DISCARD(v)
#endif

#ifdef FIO_MAP2_VALUE
#define FIO_MAP2_GET_T FIO_MAP2_VALUE
#else
#define FIO_MAP2_GET_T FIO_MAP2_KEY
#endif

#ifndef FIO_MAP2_VALUE_INTERNAL
#define FIO_MAP2_VALUE_INTERNAL FIO_MAP2_VALUE
#endif

#ifndef FIO_MAP2_VALUE_FROM_INTERNAL
#ifdef FIO_MAP2_VALUE
#define FIO_MAP2_VALUE_FROM_INTERNAL(o) o
#else
#define FIO_MAP2_VALUE_FROM_INTERNAL(o)
#endif
#endif

#ifndef FIO_MAP2_VALUE_COPY
#ifdef FIO_MAP2_VALUE
#define FIO_MAP2_VALUE_COPY(dest, src) (dest) = (src)
#else
#define FIO_MAP2_VALUE_COPY(dest, src)
#endif
#endif

#ifndef FIO_MAP2_VALUE_DESTROY
#define FIO_MAP2_VALUE_DESTROY(o)
#define FIO_MAP2_VALUE_DESTROY_SIMPLE 1
#endif

#ifndef FIO_MAP2_VALUE_DISCARD
#define FIO_MAP2_VALUE_DISCARD(o)
#endif

#ifdef FIO_MAP2_LRU
#undef FIO_MAP2_ORDERED
#define FIO_MAP2_ORDERED 1 /* required for least recently used order */
#endif

/* test if FIO_MAP2_ORDERED was defined as an empty macro */
#if defined(FIO_MAP2_ORDERED) && ((0 - FIO_MAP2_ORDERED - 1) == 1)
#undef FIO_MAP2_ORDERED
#define FIO_MAP2_ORDERED 1 /* assume developer's intention */
#endif

#ifndef FIO_MAP2_ORDERED
#define FIO_MAP2_ORDERED 0
#endif

/* *****************************************************************************
Pointer Tagging Support
***************************************************************************** */

#ifdef FIO_PTR_TAG_TYPE
#define FIO_MAP2_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_MAP2_PTR FIO_NAME(FIO_MAP2_NAME, s) *
#endif
#define FIO_MAP2_T FIO_NAME(FIO_MAP2_NAME, s)

/* *****************************************************************************
Map Types
***************************************************************************** */

/** internal object data representation */
typedef struct FIO_NAME(FIO_MAP2_NAME, node_s) FIO_NAME(FIO_MAP2_NAME, node_s);

/** A Hash Map / Set type */
typedef struct FIO_NAME(FIO_MAP2_NAME, s) {
  uint32_t bits;
  uint32_t count;
  FIO_NAME(FIO_MAP2_NAME, node_s) * map;
#if FIO_MAP2_ORDERED
  FIO_INDEXED_LIST32_HEAD head;
#endif
} FIO_NAME(FIO_MAP2_NAME, s);

/** internal object data representation */
struct FIO_NAME(FIO_MAP2_NAME, node_s) {
#if !FIO_MAP2_RECALC_HASH
  uint64_t hash;
#endif
  FIO_MAP2_KEY_INTERNAL key;
#ifdef FIO_MAP2_VALUE
  FIO_MAP2_VALUE_INTERNAL value;
#endif
#if FIO_MAP2_ORDERED
  FIO_INDEXED_LIST32_NODE node;
#endif
};

/** Map iterator type */
typedef struct {
  /** the node in the internal map */
  FIO_NAME(FIO_MAP2_NAME, node_s) * node;
  /** the key in the current position */
  FIO_MAP2_KEY key;
#ifdef FIO_MAP2_VALUE
  /** the value in the current position */
  FIO_MAP2_VALUE value;
#endif
#if !FIO_MAP2_RECALC_HASH
  /** the hash for the current position */
  uint64_t hash;
#endif
  struct {                   /* internal usage, do not access */
    uint32_t index;          /* the index in the internal map */
    uint32_t pos;            /* the position in the ordering scheme */
    uintptr_t map_validator; /* map mutation guard */
  } private_;
} FIO_NAME(FIO_MAP2_NAME, iterator_s);

#ifndef FIO_MAP2_INIT
/* Initialization macro. */
#define FIO_MAP2_INIT                                                          \
  { 0 }
#endif

/* *****************************************************************************
Construction / Deconstruction
***************************************************************************** */

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY

/* Allocates a new object on the heap and initializes it's memory. */
SFUNC FIO_MAP2_PTR FIO_NAME(FIO_MAP2_NAME, new)(void);

/* Frees any internal data AND the object's container! */
SFUNC void FIO_NAME(FIO_MAP2_NAME, free)(FIO_MAP2_PTR map);

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/** Destroys the object, reinitializing its container. */
SFUNC void FIO_NAME(FIO_MAP2_NAME, destroy)(FIO_MAP2_PTR map);

/* *****************************************************************************
Map State
***************************************************************************** */

/** Theoretical map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP2_NAME, capa)(FIO_MAP2_PTR map);

/** The number of objects in the map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP2_NAME, count)(FIO_MAP2_PTR map);

/** Reserves at minimum the capacity requested. */
SFUNC void FIO_NAME(FIO_MAP2_NAME, reserve)(FIO_MAP2_PTR map, size_t capa);

/** Returns the key value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP2_KEY FIO_NAME(FIO_MAP2_NAME,
                                node2key)(FIO_NAME(FIO_MAP2_NAME, node_s) *
                                          node);

/** Returns the hash value associated with the node's pointer (see set_ptr). */
FIO_IFUNC uint64_t FIO_NAME(FIO_MAP2_NAME,
                            node2hash)(FIO_NAME(FIO_MAP2_NAME, node_s) * node);

#ifdef FIO_MAP2_VALUE
/** Returns the value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP2_VALUE FIO_NAME(FIO_MAP2_NAME,
                                  node2val)(FIO_NAME(FIO_MAP2_NAME, node_s) *
                                            node);
#endif

/** Returns the key value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP2_KEY_INTERNAL *FIO_NAME(FIO_MAP2_NAME, node2key_ptr)(
    FIO_NAME(FIO_MAP2_NAME, node_s) * node);

#ifdef FIO_MAP2_VALUE
/** Returns the value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP2_VALUE_INTERNAL *FIO_NAME(FIO_MAP2_NAME, node2val_ptr)(
    FIO_NAME(FIO_MAP2_NAME, node_s) * node);
#endif

/* *****************************************************************************
Adding / Removing Elements from the Map
***************************************************************************** */

/** Removes an object in the map, returning a pointer to the map data. */
SFUNC int FIO_NAME(FIO_MAP2_NAME, remove)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                          uint64_t hash,
#endif
                                          FIO_MAP2_KEY key,
#ifdef FIO_MAP2_VALUE
                                          FIO_MAP2_VALUE_INTERNAL *old
#else
                                          FIO_MAP2_KEY_INTERNAL *old
#endif
);

/** Evicts elements in order least recently used (LRU), FIFO or undefined. */
SFUNC void FIO_NAME(FIO_MAP2_NAME, evict)(FIO_MAP2_PTR map,
                                          size_t number_of_elements);

/** Removes all objects from the map, without releasing the map's resources. */
SFUNC void FIO_NAME(FIO_MAP2_NAME, clear)(FIO_MAP2_PTR map);

/** Attempts to minimize memory use. */
SFUNC void FIO_NAME(FIO_MAP2_NAME, compact)(FIO_MAP2_PTR map);

/** Gets a value from the map, if exists. */
FIO_IFUNC FIO_MAP2_GET_T FIO_NAME(FIO_MAP2_NAME, get)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                                      uint64_t hash,
#endif
                                                      FIO_MAP2_KEY key);

/** Sets a value in the map, hash maps will overwrite existing data if any. */
FIO_IFUNC FIO_MAP2_GET_T FIO_NAME(FIO_MAP2_NAME,
                                  set)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                       uint64_t hash,
#endif
#ifdef FIO_MAP2_VALUE
                                       FIO_MAP2_KEY key,
                                       FIO_MAP2_VALUE obj,
                                       FIO_MAP2_VALUE_INTERNAL *old
#else
                                       FIO_MAP2_KEY key
#endif
);

/** Sets a value in the map if not set previously. */
FIO_IFUNC FIO_MAP2_GET_T FIO_NAME(FIO_MAP2_NAME,
                                  set_if_missing)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                                  uint64_t hash,
#endif
                                                  FIO_MAP2_KEY key
#ifdef FIO_MAP2_VALUE
                                                  ,
                                                  FIO_MAP2_VALUE obj
#endif
);

/**
 * The core set function.
 *
 * This function returns `NULL` on error (errors are logged).
 *
 * If the map is a hash map, overwriting the value (while keeping the key) is
 * possible. In this case the `old` pointer is optional, and if set than the old
 * data will be copied to over during an overwrite.
 *
 * NOTE: the function returns a pointer to the map's internal storage.
 */
SFUNC FIO_NAME(FIO_MAP2_NAME, node_s) *
    FIO_NAME(FIO_MAP2_NAME, set_ptr)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                     uint64_t hash,
#endif
#ifdef FIO_MAP2_VALUE
                                     FIO_MAP2_KEY key,
                                     FIO_MAP2_VALUE val,
                                     FIO_MAP2_VALUE_INTERNAL *old,
                                     int overwrite
#else
                                     FIO_MAP2_KEY key
#endif
    );

/**
 * The core get function. This function returns NULL if item is missing.
 *
 * NOTE: the function returns a pointer to the map's internal storage.
 */
SFUNC FIO_NAME(FIO_MAP2_NAME, node_s) *
    FIO_NAME(FIO_MAP2_NAME, get_ptr)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                     uint64_t hash,
#endif
                                     FIO_MAP2_KEY key);
/* *****************************************************************************
Map Iteration and Traversal
***************************************************************************** */

/**
 * Returns the next iterator object after `current_pos` or the first if `NULL`.
 *
 * Note that adding objects to the map or rehashing between iterations could
 * incur performance penalties when re-setting and re-seeking the previous
 * iterator position.
 *
 * Adding objects to, or rehashing, an unordered maps could invalidate the
 * iterator object completely as the ordering may have changed and so the "next"
 * object might be any object in the map.
 */
SFUNC FIO_NAME(FIO_MAP2_NAME, iterator_s)
    FIO_NAME(FIO_MAP2_NAME,
             get_next)(FIO_MAP2_PTR map,
                       FIO_NAME(FIO_MAP2_NAME, iterator_s) * current_pos);

/**
 * Returns the next iterator object after `current_pos` or the last if `NULL`.
 *
 * See notes in `get_next`.
 */
SFUNC FIO_NAME(FIO_MAP2_NAME, iterator_s)
    FIO_NAME(FIO_MAP2_NAME,
             get_prev)(FIO_MAP2_PTR map,
                       FIO_NAME(FIO_MAP2_NAME, iterator_s) * current_pos);

/** Returns 1 if the iterator is out of bounds, otherwise returns 0. */
FIO_IFUNC int FIO_NAME(FIO_MAP2_NAME,
                       iterator_is_valid)(FIO_NAME(FIO_MAP2_NAME, iterator_s) *
                                          iterator);

/** Returns a pointer to the node object in the internal map. */
FIO_IFUNC FIO_NAME(FIO_MAP2_NAME, node_s) *
    FIO_NAME(FIO_MAP2_NAME,
             iterator2node)(FIO_MAP2_PTR map,
                            FIO_NAME(FIO_MAP2_NAME, iterator_s) * iterator);

#ifndef FIO_MAP2_EACH
/** Iterates through the map using an iterator object. */
#define FIO_MAP2_EACH(map_name, map_ptr, i)                                    \
  for (FIO_NAME(map_name, iterator_s)                                          \
           i = FIO_NAME(map_name, get_next)(map_ptr, NULL);                    \
       FIO_NAME(map_name, iterator_is_valid)(&i);                              \
       i = FIO_NAME(map_name, get_next)(map_ptr, &i))
/** Iterates through the map using an iterator object. */
#define FIO_MAP2_EACH_REVERSED(map_name, map_ptr, i)                           \
  for (FIO_NAME(map_name, iterator_s)                                          \
           i = FIO_NAME(map_name, get_prev)(map_ptr, NULL);                    \
       FIO_NAME(map_name, iterator_is_valid)(&i);                              \
       i = FIO_NAME(map_name, get_prev)(map_ptr, &i))
#endif

/** Iteration information structure passed to the callback. */
typedef struct FIO_NAME(FIO_MAP2_NAME, each_s) {
  /** The being iterated. Once set, cannot be safely changed. */
  FIO_MAP2_PTR const parent;
  /** The current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct FIO_NAME(FIO_MAP2_NAME, each_s) * info);
  /** Opaque user data. */
  void *udata;
#ifdef FIO_MAP2_VALUE
  /** The object's value at the current index. */
  FIO_MAP2_VALUE value;
#endif
  /** The object's key the current index. */
  FIO_MAP2_KEY key;
} FIO_NAME(FIO_MAP2_NAME, each_s);

/**
 * Iteration using a callback for each element in the map.
 *
 * The callback task function must accept an each_s pointer, see above.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
SFUNC uint32_t FIO_NAME(FIO_MAP2_NAME,
                        each)(FIO_MAP2_PTR map,
                              int (*task)(FIO_NAME(FIO_MAP2_NAME, each_s) *),
                              void *udata,
                              ssize_t start_at);

/* *****************************************************************************
Optional Sorting Support - TODO? (convert to array, sort, rehash)
***************************************************************************** */

#if defined(FIO_MAP2_KEY_IS_GREATER_THAN) && !defined(FIO_SORT_TYPE) &&        \
    FIO_MAP2_ORDERED
#undef FIO_SORT_NAME
#endif

/* *****************************************************************************
Map Implementation - inlined static functions
***************************************************************************** */

#ifndef FIO_MAP2_CAPA_BITS_LIMIT
/* Note: cannot be more than 31 bits unless some of the code is rewritten. */
#define FIO_MAP2_CAPA_BITS_LIMIT 31
#endif

/* Theoretical map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP2_NAME, capa)(FIO_MAP2_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, 0);
  FIO_MAP2_T *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  if (o->map)
    return (uint32_t)((size_t)1ULL << o->bits);
  return 0;
}

/* The number of objects in the map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP2_NAME, count)(FIO_MAP2_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, 0);
  return ((FIO_NAME(FIO_MAP2_NAME, s) *)FIO_PTR_UNTAG(map))->count;
}

/** Returns 1 if the iterator points to a valid object, otherwise returns 0. */
FIO_IFUNC int FIO_NAME(FIO_MAP2_NAME,
                       iterator_is_valid)(FIO_NAME(FIO_MAP2_NAME, iterator_s) *
                                          iterator) {
  return (iterator && iterator->private_.map_validator);
}

/** Returns the key value associated with the node's pointer. */
FIO_IFUNC FIO_MAP2_KEY FIO_NAME(FIO_MAP2_NAME,
                                node2key)(FIO_NAME(FIO_MAP2_NAME, node_s) *
                                          node) {
  FIO_MAP2_KEY r = (FIO_MAP2_KEY){0};
  if (!node)
    return r;
  return FIO_MAP2_KEY_FROM_INTERNAL(node->key);
}

/** Returns the hash value associated with the node's pointer. */
FIO_IFUNC uint64_t FIO_NAME(FIO_MAP2_NAME,
                            node2hash)(FIO_NAME(FIO_MAP2_NAME, node_s) * node) {
  uint32_t r = (uint32_t){0};
  if (!node)
    return r;
#if FIO_MAP2_RECALC_HASH
  FIO_MAP2_KEY k = FIO_MAP2_KEY_FROM_INTERNAL(node->key);
  uint64_t hash = FIO_MAP2_HASH_FN(k);
  hash += !hash;
  return hash;
#else
  return node->hash;
#endif
}

#ifdef FIO_MAP2_VALUE
/** Returns the value associated with the node's pointer. */
FIO_IFUNC FIO_MAP2_VALUE FIO_NAME(FIO_MAP2_NAME,
                                  node2val)(FIO_NAME(FIO_MAP2_NAME, node_s) *
                                            node) {
  FIO_MAP2_VALUE r = (FIO_MAP2_VALUE){0};
  if (!node)
    return r;
  return FIO_MAP2_VALUE_FROM_INTERNAL(node->value);
}
#else
/* If called for a node without a value, returns the key (simplifies stuff). */
FIO_IFUNC FIO_MAP2_KEY FIO_NAME(FIO_MAP2_NAME,
                                node2val)(FIO_NAME(FIO_MAP2_NAME, node_s) *
                                          node) {
  return FIO_NAME(FIO_MAP2_NAME, node2key)(node);
}
#endif

/** Returns the key value associated with the node's pointer. */
FIO_IFUNC FIO_MAP2_KEY_INTERNAL *FIO_NAME(FIO_MAP2_NAME, node2key_ptr)(
    FIO_NAME(FIO_MAP2_NAME, node_s) * node) {
  if (!node)
    return NULL;
  return &(node->key);
}

#ifdef FIO_MAP2_VALUE
/** Returns the value associated with the node's pointer. */
FIO_IFUNC FIO_MAP2_VALUE_INTERNAL *FIO_NAME(FIO_MAP2_NAME, node2val_ptr)(
    FIO_NAME(FIO_MAP2_NAME, node_s) * node) {
  if (!node)
    return NULL;
  return &(node->value);
}
#else
/* If called for a node without a value, returns the key (simplifies stuff). */
FIO_IFUNC FIO_MAP2_KEY_INTERNAL *FIO_NAME(FIO_MAP2_NAME, node2val_ptr)(
    FIO_NAME(FIO_MAP2_NAME, node_s) * node) {
  return FIO_NAME(FIO_MAP2_NAME, node2key_ptr)(node);
}
#endif

/** Gets a value from the map, if exists. */
FIO_IFUNC FIO_MAP2_GET_T FIO_NAME(FIO_MAP2_NAME, get)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                                      uint64_t hash,
#endif
                                                      FIO_MAP2_KEY key) {
  return FIO_NAME(FIO_MAP2_NAME,
                  node2val)(FIO_NAME(FIO_MAP2_NAME, get_ptr)(map,
#if !defined(FIO_MAP2_HASH_FN)
                                                             hash,
#endif
                                                             key));
}

/** Sets a value in the map, hash maps will overwrite existing data if any. */
FIO_IFUNC FIO_MAP2_GET_T FIO_NAME(FIO_MAP2_NAME,
                                  set)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                       uint64_t hash,
#endif
#ifdef FIO_MAP2_VALUE
                                       FIO_MAP2_KEY key,
                                       FIO_MAP2_VALUE obj,
                                       FIO_MAP2_VALUE_INTERNAL *old
#else
                                       FIO_MAP2_KEY key
#endif
) {
  return FIO_NAME(FIO_MAP2_NAME,
                  node2val)(FIO_NAME(FIO_MAP2_NAME, set_ptr)(map,
#if !defined(FIO_MAP2_HASH_FN)
                                                             hash,
#endif
                                                             key
#ifdef FIO_MAP2_VALUE
                                                             ,
                                                             obj,
                                                             old,
                                                             1
#endif
                                                             ));
}

/** Sets a value in the map if not set previously. */
FIO_IFUNC FIO_MAP2_GET_T FIO_NAME(FIO_MAP2_NAME,
                                  set_if_missing)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                                  uint64_t hash,
#endif
                                                  FIO_MAP2_KEY key
#ifdef FIO_MAP2_VALUE
                                                  ,
                                                  FIO_MAP2_VALUE obj
#endif
) {
  return FIO_NAME(FIO_MAP2_NAME,
                  node2val)(FIO_NAME(FIO_MAP2_NAME, set_ptr)(map,
#if !defined(FIO_MAP2_HASH_FN)
                                                             hash,
#endif
                                                             key
#ifdef FIO_MAP2_VALUE
                                                             ,
                                                             obj,
                                                             NULL,
                                                             0
#endif
                                                             ));
}

/** Returns a pointer to the node object in the internal map. */
FIO_IFUNC FIO_NAME(FIO_MAP2_NAME, node_s) *
    FIO_NAME(FIO_MAP2_NAME,
             iterator2node)(FIO_MAP2_PTR map,
                            FIO_NAME(FIO_MAP2_NAME, iterator_s) * iterator) {
  FIO_NAME(FIO_MAP2_NAME, node_s) *node = NULL;
  if (!iterator || !iterator->private_.map_validator)
    return node;
  FIO_PTR_TAG_VALID_OR_RETURN(map, node);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  node = o->map + iterator->private_.index;
  return node;
}

/* *****************************************************************************
Map Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_MAP2_NAME, s))
FIO_LEAK_COUNTER_DEF(FIO_NAME(FIO_MAP2_NAME, destroy))
/* *****************************************************************************
Constructors
***************************************************************************** */

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY
/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC FIO_MAP2_PTR FIO_NAME(FIO_MAP2_NAME, new)(void) {
  FIO_NAME(FIO_MAP2_NAME, s) *o =
      (FIO_NAME(FIO_MAP2_NAME, s) *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*o), 0);
  if (!o)
    return (FIO_MAP2_PTR)NULL;
  FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_MAP2_NAME, s));
  *o = (FIO_NAME(FIO_MAP2_NAME, s))FIO_MAP2_INIT;
  return (FIO_MAP2_PTR)FIO_PTR_TAG(o);
}
/* Frees any internal data AND the object's container! */
FIO_IFUNC void FIO_NAME(FIO_MAP2_NAME, free)(FIO_MAP2_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP2_NAME, destroy)(map);
  FIO_NAME(FIO_MAP2_NAME, s) *o =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_MAP2_NAME, s), map);
  FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_MAP2_NAME, s));
  FIO_MEM_FREE_(o, sizeof(*o));
}
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/* *****************************************************************************
Internal Helpers
***************************************************************************** */

#ifndef FIO_MAP2_ATTACK_LIMIT
#define FIO_MAP2_ATTACK_LIMIT 16
#endif
#ifndef FIO_MAP2_CUCKOO_STEPS
/* Prime numbers are better */
#define FIO_MAP2_CUCKOO_STEPS (0x43F82D0BUL) /* a big high prime */
#endif
#ifndef FIO_MAP2_SEEK_LIMIT
#define FIO_MAP2_SEEK_LIMIT 13U
#endif
#ifndef FIO_MAP2_ARRAY_LOG_LIMIT
#define FIO_MAP2_ARRAY_LOG_LIMIT 3
#endif
#ifndef FIO_MAP2_CAPA
#define FIO_MAP2_CAPA(bits) ((size_t)1ULL << (bits))
#endif

#ifndef FIO_MAP2_IS_SPARSE
#define FIO_MAP2_IS_SPARSE(map)                                                \
  (o->bits > FIO_MAP2_ARRAY_LOG_LIMIT && ((capa >> 2) > o->count))
#endif

/* The number of objects in the map capacity. */
FIO_IFUNC uint8_t *FIO_NAME(FIO_MAP2_NAME,
                            __imap)(FIO_NAME(FIO_MAP2_NAME, s) * o) {
  // FIO_ASSERT(o && o->map, "shouldn't have been called.");
  return (uint8_t *)(o->map + FIO_MAP2_CAPA(o->bits));
}

FIO_IFUNC uint64_t FIO_NAME(FIO_MAP2_NAME,
                            __byte_hash)(FIO_NAME(FIO_MAP2_NAME, s) * o,
                                         uint64_t hash) {
  hash = (hash >> o->bits);
  hash &= 0xFF;
  hash += !(hash);
  hash -= (hash == 255);
  return hash;
}

FIO_IFUNC uint64_t FIO_NAME(FIO_MAP2_NAME,
                            __is_eq_hash)(FIO_NAME(FIO_MAP2_NAME, node_s) * o,
                                          uint64_t hash) {
#if FIO_MAP2_RECALC_HASH && defined(FIO_MAP2_HASH_FN)
  uint64_t khash = FIO_MAP2_HASH_FN(FIO_MAP2_KEY_FROM_INTERNAL(o->key));
  khash += !khash;
#else
  const uint64_t khash = o->hash;
#endif
  return (khash == hash);
}

FIO_SFUNC uint32_t FIO_NAME(FIO_MAP2_NAME,
                            __index)(FIO_NAME(FIO_MAP2_NAME, s) * o,
                                     FIO_MAP2_KEY key,
                                     uint64_t hash) {
  uint32_t r = (uint32_t)-1;
  if (!o->map)
    return r;
  static int guard_print = 0;
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);
  size_t capa = FIO_MAP2_CAPA(o->bits);
  size_t bhash = FIO_NAME(FIO_MAP2_NAME, __byte_hash)(o, hash);
  size_t guard = FIO_MAP2_ATTACK_LIMIT + 1;
  if (o->bits > FIO_MAP2_ARRAY_LOG_LIMIT) { /* treat as map */
    uint64_t bhash64 = bhash | (bhash << 8);
    bhash64 |= bhash64 << 16;
    bhash64 |= bhash64 << 32;
    bhash64 = ~bhash64;
    const uintptr_t pos_mask = capa - 1;
    const uint_fast8_t offsets[8] = {0, 3, 8, 17, 28, 41, 58, 60};
    for (uintptr_t pos = hash, c = 0; c < FIO_MAP2_SEEK_LIMIT;
         (pos += FIO_MAP2_CUCKOO_STEPS), ++c) {
      uint64_t comb = imap[(pos + offsets[0]) & pos_mask];
      comb |= ((uint64_t)imap[(pos + offsets[1]) & pos_mask]) << (1 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[2]) & pos_mask]) << (2 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[3]) & pos_mask]) << (3 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[4]) & pos_mask]) << (4 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[5]) & pos_mask]) << (5 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[6]) & pos_mask]) << (6 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[7]) & pos_mask]) << (7 * 8);
      const uint64_t has_possible_match =
          (((comb ^ bhash64) & 0x7F7F7F7F7F7F7F7FULL) + 0x0101010101010101ULL) &
          0x8080808080808080ULL;
      if (has_possible_match) {
        /* there was a 7 bit match in one of the bytes in this 8 byte group */
        for (size_t i = 0; i < 8; ++i) {
          const uint32_t tmp = (uint32_t)((pos + offsets[i]) & pos_mask);
          if (imap[tmp] != bhash)
            continue;
          /* test key and hash equality */
          if (FIO_NAME(FIO_MAP2_NAME, __is_eq_hash)(o->map + tmp, hash)) {
            if (FIO_MAP2_KEY_CMP(o->map[tmp].key, key)) {
              guard_print = 0;
              return (r = tmp);
            }
            if (!(--guard)) {
              if (!guard_print)
                FIO_LOG_SECURITY("hash map " FIO_MACRO2STR(
                    FIO_NAME(FIO_MAP2_NAME, s)) " under attack?");
              guard_print = 1;
              return (r = tmp);
            }
          }
        }
      }
      const uint64_t has_possible_full_byte =
          (((comb)&0x7F7F7F7F7F7F7F7FULL) + 0x0101010101010101ULL) &
          0x8080808080808080ULL;
      const uint64_t has_possible_empty_byte =
          (((~comb) & 0x7F7F7F7F7F7F7F7FULL) + 0x0101010101010101ULL) &
          0x8080808080808080ULL;
      if (!(has_possible_full_byte | has_possible_empty_byte))
        continue;
      /* there was a 7 bit match for a possible free space in this group */
      for (size_t i = 0; i < 8; ++i) {
        const uint32_t tmp = (uint32_t)((pos + offsets[i]) & pos_mask);
        if (!imap[tmp])
          return (r = tmp); /* empty slot always ends search */
        if (r > pos_mask && imap[tmp] == 255)
          r = tmp; /* mark hole to be filled */
      }
    }
    return r;
  } /* treat as array */
  for (size_t i = 0; i < capa; ++i) {
    if (!imap[i])
      return (r = (uint32_t)i);
    if (imap[i] == bhash) {
      /* test key and hash equality */
      if (FIO_NAME(FIO_MAP2_NAME, __is_eq_hash)(o->map + i, hash)) {
        if (FIO_MAP2_KEY_CMP(o->map[i].key, key)) {
          guard_print = 0;
          return (r = (uint32_t)i);
        }
        if (!(--guard)) {
          if (!guard_print)
            FIO_LOG_SECURITY("hash map " FIO_MACRO2STR(
                FIO_NAME(FIO_MAP2_NAME, s)) " under attack?");
          guard_print = 1;
          return (r = (uint32_t)i);
        }
      }
    }
    if (imap[i] == 0xFF)
      r = (uint32_t)i; /* a free spot is available*/
  }
  return r;
}
/* deallocate the map's memory. */
FIO_SFUNC void FIO_NAME(FIO_MAP2_NAME,
                        __dealloc_map)(FIO_NAME(FIO_MAP2_NAME, s) * o) {
  if (!o->map)
    return;
  const size_t capa = FIO_MAP2_CAPA(o->bits);
  FIO_LEAK_COUNTER_ON_FREE(FIO_NAME(FIO_MAP2_NAME, destroy));
  FIO_MEM_FREE_(o->map, (capa * sizeof(*o->map)) + capa);
  (void)capa;
}

/** duplicates an objects between two maps. */
FIO_IFUNC int FIO_NAME(FIO_MAP2_NAME,
                       __copy_obj)(FIO_NAME(FIO_MAP2_NAME, s) * dest,
                                   FIO_NAME(FIO_MAP2_NAME, node_s) * o,
                                   uint32_t internal) {
  FIO_MAP2_KEY key = FIO_MAP2_KEY_FROM_INTERNAL(o->key);
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(dest);
#if FIO_MAP2_RECALC_HASH
  uint64_t ohash = FIO_MAP2_HASH_FN(key);
  ohash += !ohash;
#else
  const uint64_t ohash = o->hash;
#endif
  uint32_t i = FIO_NAME(FIO_MAP2_NAME, __index)(dest, key, ohash);
  if (i == (uint32_t)-1 || (imap[i] + 1) > 1)
    return -1;
  if (internal) {
    dest->map[i] = *o;
    imap[i] = FIO_NAME(FIO_MAP2_NAME, __byte_hash)(dest, ohash);
#if FIO_MAP2_ORDERED
    if (dest->count) { /* update ordering */
      FIO_INDEXED_LIST_PUSH(dest->map, node, dest->head, i);
    } else { /* set first order */
      dest->map[i].node.next = dest->map[i].node.prev = i;
      dest->head = i;
    }
#endif
    ++dest->count;
    return 0;
  }
  imap[i] = FIO_NAME(FIO_MAP2_NAME, __byte_hash)(dest, ohash);
  FIO_MAP2_KEY_COPY(dest->map[i].key, FIO_MAP2_KEY_FROM_INTERNAL(o->key));
  FIO_MAP2_VALUE_COPY(dest->map[i].value,
                      FIO_MAP2_VALUE_FROM_INTERNAL(o->value));
#if !FIO_MAP2_RECALC_HASH
  dest->map[i].hash = o->hash;
#endif
#if FIO_MAP2_ORDERED
  if (dest->count) { /* update ordering */
    FIO_INDEXED_LIST_PUSH(dest->map, node, dest->head, i);
  } else { /* set first order */
    dest->map[i].node.next = dest->map[i].node.prev = i;
    dest->head = i;
  }
#endif
  ++dest->count;
  return 0;
}

/** duplicates a map to a new copy (usually for rehashing / reserving space). */
FIO_IFUNC FIO_NAME(FIO_MAP2_NAME, s)
    FIO_NAME(FIO_MAP2_NAME, __duplicate)(FIO_NAME(FIO_MAP2_NAME, s) * o,
                                         uint32_t bits,
                                         uint32_t internal) {
  FIO_NAME(FIO_MAP2_NAME, s) cpy = {0};
  if (bits > FIO_MAP2_CAPA_BITS_LIMIT)
    return cpy;
  size_t capa = FIO_MAP2_CAPA(bits);
  cpy.map = (FIO_NAME(FIO_MAP2_NAME, node_s) *)
      FIO_MEM_REALLOC_(NULL, 0, ((capa * sizeof(*cpy.map)) + capa), 0);
  if (!cpy.map)
    return cpy;
  FIO_LEAK_COUNTER_ON_ALLOC(FIO_NAME(FIO_MAP2_NAME, destroy));
  if (!FIO_MEM_REALLOC_IS_SAFE_) {
    /* set only the imap, the rest can be junk data */
    FIO_MEMSET((cpy.map + capa), 0, capa);
  }
  cpy.bits = bits;
  if (!o->count)
    return cpy;
#if FIO_MAP2_ORDERED
  /* copy objects in order */
  FIO_INDEXED_LIST_EACH(o->map, node, o->head, i) {
    if (FIO_NAME(FIO_MAP2_NAME, __copy_obj)(&cpy, o->map + i, internal))
      goto error;
  }
#else
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);
  capa = FIO_MAP2_CAPA(o->bits);
  if (FIO_MAP2_IS_SPARSE(o)) { /* sparsely populated */
    for (size_t i = 0; i < capa; i += 8) {
      uint64_t comb = *((uint64_t *)(imap + i));
      if (!comb || comb == 0xFFFFFFFFFFFFFFFFULL)
        continue;
      for (size_t j = 0; j < 8; ++j) {
        const size_t tmp = j + i;
        if (!imap[tmp] || imap[tmp] == 0xFF)
          continue;
        if (FIO_NAME(FIO_MAP2_NAME, __copy_obj)(&cpy, o->map + tmp, internal))
          goto error;
      }
    }
    return cpy;
  } /* review as array */
  for (size_t i = 0; i < capa; ++i) {
    if (!imap[i] || imap[i] == 0xFF)
      continue;
    if (FIO_NAME(FIO_MAP2_NAME, __copy_obj)(&cpy, o->map + i, internal))
      goto error;
  }
#endif
  return cpy;
error:
  FIO_NAME(FIO_MAP2_NAME, __dealloc_map)(&cpy);
  cpy = (FIO_NAME(FIO_MAP2_NAME, s)){0};
  return cpy;
}

/* destroys all objects in the map, without(!) resetting the `imap`. */
FIO_SFUNC void FIO_NAME(FIO_MAP2_NAME,
                        __destroy_objects)(FIO_NAME(FIO_MAP2_NAME, s) * o) {
#if FIO_MAP2_VALUE_DESTROY_SIMPLE && FIO_MAP2_KEY_DESTROY_SIMPLE
  (void)o;
  return;
#else
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);
  const size_t capa = FIO_MAP2_CAPA(o->bits);
  if (FIO_MAP2_IS_SPARSE(o)) {
    for (size_t i = 0; i < capa; i += 8) {
      uint64_t comb = *((uint64_t *)(imap + i));
      if (!comb || comb == 0xFFFFFFFFFFFFFFFFULL)
        continue;
      for (size_t j = i; j < i + 8; ++j) {
        FIO_MAP2_KEY_DESTROY(o->map[j].key);
        FIO_MAP2_VALUE_DESTROY(o->map[j].value);
      }
    }
  } else { /* review as array */
    for (size_t i = 0; i < capa; ++i) {
      if (!imap[i] || imap[i] == 0xFF)
        continue;
      FIO_MAP2_KEY_DESTROY(o->map[i].key);
      FIO_MAP2_VALUE_DESTROY(o->map[i].value);
    }
  }
#endif /* FIO_MAP2_VALUE_DESTROY_SIMPLE */
}

/* *****************************************************************************
API implementation
***************************************************************************** */

/** Reserves at minimum the capacity requested. */
SFUNC void FIO_NAME(FIO_MAP2_NAME, reserve)(FIO_MAP2_PTR map, size_t capa) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  capa += o->count;
  if (FIO_MAP2_CAPA(o->bits) >= capa || (capa >> FIO_MAP2_CAPA_BITS_LIMIT))
    return;
  uint_fast8_t bits = o->bits + 1;
  while (FIO_MAP2_CAPA(bits) < capa)
    ++bits;
  FIO_NAME(FIO_MAP2_NAME, s)
  cpy = FIO_NAME(FIO_MAP2_NAME, __duplicate)(o, bits, 1);
  if (!cpy.map)
    return;
  FIO_NAME(FIO_MAP2_NAME, __dealloc_map)(o);
  *o = cpy;
}

/* Removes all objects from the map, without releasing the map's resources. */
SFUNC void FIO_NAME(FIO_MAP2_NAME, clear)(FIO_MAP2_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  if (!o->map || !o->count)
    return;
  FIO_NAME(FIO_MAP2_NAME, __destroy_objects)(o);
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);
  const size_t capa = FIO_MAP2_CAPA(o->bits);
  FIO_MEMSET(imap, 0, capa);
  o->count = 0;
#if FIO_MAP2_ORDERED
  o->head = 0;
#endif
}

/** Attempts to minimize memory use. */
SFUNC void FIO_NAME(FIO_MAP2_NAME, compact)(FIO_MAP2_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  if (!o->map || !o->count)
    return;
  uint32_t bits = o->bits;
  while (FIO_MAP2_CAPA(bits >> 1) > o->count)
    bits >>= 1;
  ++bits;
  for (;;) {
    if (bits >= o->bits)
      return;
    FIO_NAME(FIO_MAP2_NAME, s)
    cpy = FIO_NAME(FIO_MAP2_NAME, __duplicate)(o, bits, 1);
    if (!cpy.map) {
      ++bits;
      continue;
    }
    FIO_NAME(FIO_MAP2_NAME, __dealloc_map)(o);
    *o = cpy;
    return;
  }
}

/* Frees any internal data AND the object's container! */
SFUNC void FIO_NAME(FIO_MAP2_NAME, destroy)(FIO_MAP2_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  if (o->map && o->count)
    FIO_NAME(FIO_MAP2_NAME, __destroy_objects)(o);
  FIO_NAME(FIO_MAP2_NAME, __dealloc_map)(o);
  *o = (FIO_NAME(FIO_MAP2_NAME, s))FIO_MAP2_INIT;
  return;
}

/** Evicts elements least recently used (LRU), FIFO or undefined. */
SFUNC void FIO_NAME(FIO_MAP2_NAME, evict)(FIO_MAP2_PTR map,
                                          size_t number_of_elements) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  if (!o->count)
    return;
  if (number_of_elements >= o->count) {
    FIO_NAME(FIO_MAP2_NAME, clear)(map);
    return;
  }
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);
#ifdef FIO_MAP2_LRU /* remove last X elements from the list */
  FIO_INDEXED_LIST_EACH_REVERSED(o->map, node, o->head, i) {
    FIO_MAP2_KEY_DESTROY(o->map[i].key);
    FIO_MAP2_VALUE_DESTROY(o->map[i].value);
    FIO_INDEXED_LIST_REMOVE(o->map, node, i);
    imap[i] = 0xFF;
    --o->count;
    if (!(--number_of_elements))
      return;
  }
#elif FIO_MAP2_ORDERED /* remove first X elements from the list */
  FIO_INDEXED_LIST_EACH(o->map, node, o->head, i) {
    FIO_MAP2_KEY_DESTROY(o->map[i].key);
    FIO_MAP2_VALUE_DESTROY(o->map[i].value);
    FIO_INDEXED_LIST_REMOVE(o->map, node, i);
    imap[i] = 0xFF;
    --o->count;
    if (!(--number_of_elements)) {
      o->head = o->map[i].node.next;
      return;
    }
  }
#else                  /* remove whatever... */
  if (o->bits > FIO_MAP2_ARRAY_LOG_LIMIT) {
    /* map is scattered */
    uint32_t pos_mask = (uint32_t)(FIO_MAP2_CAPA(o->bits) - 1);
    uint32_t pos = *(uint32_t *)o->map;
    for (size_t i = 0; i < 3; ++i) {
      struct timespec t = {0};
      clock_gettime(CLOCK_MONOTONIC, &t);
      pos *= t.tv_nsec ^ t.tv_sec ^ (uintptr_t)imap;
      pos ^= pos >> 7;
    }
    for (;;) { /* a bit of non-random randomness... */
      uint32_t offset = ((pos << 3)) & pos_mask;
      for (uint_fast8_t i = 0; i < 8; ++i) { /* ordering bias? vs performance */
        const uint32_t tmp = offset + i;
        if (!imap[tmp] || imap[tmp] == 0xFF)
          continue;
        FIO_MAP2_KEY_DESTROY(o->map[tmp].key);
        FIO_MAP2_VALUE_DESTROY(o->map[tmp].value);
        imap[tmp] = 0xFF;
        --o->count;
        if (!(--number_of_elements))
          return;
      }
      pos += FIO_MAP2_CUCKOO_STEPS;
    }
  }
  /* map is a simple array */
  while (number_of_elements--) {
    FIO_MAP2_KEY_DESTROY(o->map[number_of_elements].key);
    FIO_MAP2_VALUE_DESTROY(o->map[number_of_elements].value);
    imap[number_of_elements] = 0xFF;
  }
#endif                 /* FIO_MAP2_LRU / FIO_MAP2_ORDERED */
}

/* *****************************************************************************
The Map set/get functions
***************************************************************************** */

/**
 * The core get function. This function returns NULL if item is missing.
 *
 * NOTE: the function returns the internal representation of objects.
 */
SFUNC FIO_NAME(FIO_MAP2_NAME, node_s) *
    FIO_NAME(FIO_MAP2_NAME, get_ptr)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                     uint64_t hash,
#endif
                                     FIO_MAP2_KEY key) {
  FIO_NAME(FIO_MAP2_NAME, node_s) *r = NULL;
  FIO_PTR_TAG_VALID_OR_RETURN(map, r);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  if (!o->count)
    return r;
#if defined(FIO_MAP2_HASH_FN)
  uint64_t hash = FIO_MAP2_HASH_FN(key);
#endif
  hash += !hash;
  uint32_t pos = FIO_NAME(FIO_MAP2_NAME, __index)(o, key, hash);
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);
  if (pos == (uint32_t)-1 || !imap[pos] || imap[pos] == 0xFF)
    return r;
#ifdef FIO_MAP2_LRU
  if (o->head != pos) {
    FIO_INDEXED_LIST_REMOVE(o->map, node, pos);
    FIO_INDEXED_LIST_PUSH(o->map, node, o->head, pos);
    o->head = pos;
  }
#endif
  r = o->map + pos;
  return r;
}

/** sets / removes an object in the map, returning a pointer to the map data. */
SFUNC FIO_NAME(FIO_MAP2_NAME, node_s) *
    FIO_NAME(FIO_MAP2_NAME, set_ptr)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                     uint64_t hash,
#endif
#ifdef FIO_MAP2_VALUE
                                     FIO_MAP2_KEY key,
                                     FIO_MAP2_VALUE val,
                                     FIO_MAP2_VALUE_INTERNAL *old,
                                     int overwrite
#else
                                     FIO_MAP2_KEY key
#endif
    ) {
  FIO_NAME(FIO_MAP2_NAME, node_s) *r = NULL;
#ifdef FIO_MAP2_VALUE
  if (old)
    *old = (FIO_MAP2_VALUE_INTERNAL){0};
#endif
  FIO_NAME(FIO_MAP2_NAME, s) * o;
#if defined(FIO_MAP2_HASH_FN)
  uint64_t hash;
#endif
  uint32_t pos;
  uint8_t *imap = NULL;

  FIO_PTR_TAG_VALID_OR_GOTO(map, relinquish_attempt);
  o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
#if defined(FIO_MAP2_HASH_FN)
  hash = FIO_MAP2_HASH_FN(key);
#endif
  hash += !hash;  /* hash is never zero */
  if (!o->bits) { /* minimal space is 8 objects... */
    *o = FIO_NAME(FIO_MAP2_NAME, __duplicate)(o, 3, 1);
  }
  /* find the object's (potential) position in the array */
  for (size_t i = 0;;) {
    pos = FIO_NAME(FIO_MAP2_NAME, __index)(o, key, hash);
    if (pos != (uint32_t)-1)
      break;
    if (i == 2)
      goto internal_error;
    FIO_NAME(FIO_MAP2_NAME, s)
    tmp = FIO_NAME(FIO_MAP2_NAME, __duplicate)(o, o->bits + (++i), 1);
    if (!tmp.map) /* no memory? something bad? */
      goto internal_error;
    FIO_NAME(FIO_MAP2_NAME, __dealloc_map)(o);
    *o = tmp;
  }
  /* imap may have been reallocated, collect info now. */
  imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);
  /* set return value */
  r = o->map + pos;

  if (!imap[pos] || imap[pos] == 0xFF) {
    /* insert new object */
    imap[pos] = FIO_NAME(FIO_MAP2_NAME, __byte_hash)(o, hash);
#if !FIO_MAP2_RECALC_HASH
    r->hash = hash;
#endif
    FIO_MAP2_KEY_COPY(r->key, key);
    FIO_MAP2_VALUE_COPY(r->value, val);
#if FIO_MAP2_ORDERED
    if (o->count) { /* update ordering */
      FIO_INDEXED_LIST_PUSH(o->map, node, o->head, pos);
#ifdef FIO_MAP2_LRU
      o->head = pos;                  /* update LRU head */
      if (FIO_MAP2_LRU == o->count) { /* limit reached - evict 1 LRU element */
        uint32_t to_evict = o->map[pos].node.prev;
        FIO_MAP2_KEY_DESTROY(o->map[to_evict].key);
        FIO_MAP2_VALUE_DESTROY(o->map[to_evict].value);
        FIO_INDEXED_LIST_REMOVE(o->map, node, to_evict);
        imap[to_evict] = 0xFF;
        --o->count;
      }
#endif       /* FIO_MAP2_LRU */
    } else { /* set first order */
      o->map[pos].node.next = o->map[pos].node.prev = pos;
      o->head = pos;
    }
#endif /* FIO_MAP2_ORDERED */
    ++o->count;
    return r;
  }

#ifdef FIO_MAP2_LRU
  /* update ordering (even if not overwriting) */
  if (o->head != pos) {
    FIO_INDEXED_LIST_REMOVE(o->map, node, pos);
    FIO_INDEXED_LIST_PUSH(o->map, node, o->head, pos);
    o->head = pos;
  }
#endif

#ifdef FIO_MAP2_VALUE
  if (overwrite) {
    /* overwrite existing object (only relevant for hash maps) */
    FIO_MAP2_KEY_DISCARD(key);
    if (!old) {
      FIO_MAP2_VALUE_DESTROY(o->map[pos].value);
      FIO_MAP2_VALUE_COPY(o->map[pos].value, val);
      return r;
    }
    *old = o->map[pos].value;
    o->map[pos].value = (FIO_MAP2_VALUE_INTERNAL){0};
    FIO_MAP2_VALUE_COPY(o->map[pos].value, val);
    return r;
  }
#endif
relinquish_attempt:
  /* discard attempt */
  FIO_MAP2_KEY_DISCARD(key);
  FIO_MAP2_VALUE_DISCARD(val);
  return r;
internal_error:
  FIO_MAP2_KEY_DISCARD(key);
  FIO_MAP2_VALUE_DISCARD(val);
  FIO_LOG_ERROR("unknown error occurred trying to add an entry to the map");
  FIO_ASSERT_DEBUG(0, "these errors shouldn't happen");
  return r;
}

/* *****************************************************************************
The Map remove function
***************************************************************************** */

/** Removes an object in the map, returning a pointer to the map data. */
SFUNC int FIO_NAME(FIO_MAP2_NAME, remove)(FIO_MAP2_PTR map,
#if !defined(FIO_MAP2_HASH_FN)
                                          uint64_t hash,
#endif
                                          FIO_MAP2_KEY key,
#ifdef FIO_MAP2_VALUE
                                          FIO_MAP2_VALUE_INTERNAL *old
#else
                                          FIO_MAP2_KEY_INTERNAL *old
#endif
) {
#ifdef FIO_MAP2_VALUE
  if (old)
    *old = (FIO_MAP2_VALUE_INTERNAL){0};
#else
  if (old)
    *old = (FIO_MAP2_KEY_INTERNAL){0};
#endif

  FIO_PTR_TAG_VALID_OR_RETURN(map, -1);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
#if defined(FIO_MAP2_HASH_FN)
  uint64_t hash = FIO_MAP2_HASH_FN(key);
#endif
  hash += !hash; /* hash is never zero */
  uint32_t pos = FIO_NAME(FIO_MAP2_NAME, __index)(o, key, hash);
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);

  if (pos == (uint32_t)-1 || !imap[pos] || imap[pos] == 0xFF)
    return -1;

  imap[pos] = 0xFF; /* mark hole and update count */
  --o->count;

#if FIO_MAP2_ORDERED
  /* update ordering */
  if (o->head == pos)
    o->head = o->map[pos].node.next;
  if (o->head == pos)
    o->head = 0;
  else {
    FIO_INDEXED_LIST_REMOVE(o->map, node, pos);
  }
#endif

/* destroy data, copy to `old` pointer if necessary. */
#ifdef FIO_MAP2_VALUE
  FIO_MAP2_KEY_DESTROY(o->map[pos].key);
  o->map[pos].key = (FIO_MAP2_KEY_INTERNAL){0};
  if (!old) {
    FIO_MAP2_VALUE_DESTROY(o->map[pos].value);
  } else {
    *old = o->map[pos].value;
  }
  o->map[pos].value = (FIO_MAP2_VALUE_INTERNAL){0};
#else
  if (!old) {
    FIO_MAP2_KEY_DESTROY(o->map[pos].key);
  } else {
    *old = o->map[pos].key;
  }
  o->map[pos].key = (FIO_MAP2_KEY_INTERNAL){0};
#endif
#if !FIO_MAP2_RECALC_HASH && defined(DEBUG)
  o->map[pos].hash = 0; /* not necessary, but ... good for debugging? */
#endif
  return 0;
}

/* *****************************************************************************
Map Iteration
***************************************************************************** */

/** Returns the next iterator position after `current_pos`, first if `NULL`. */
SFUNC FIO_NAME(FIO_MAP2_NAME, iterator_s)
    FIO_NAME(FIO_MAP2_NAME,
             get_next)(FIO_MAP2_PTR map,
                       FIO_NAME(FIO_MAP2_NAME, iterator_s) * current_pos) {
  FIO_NAME(FIO_MAP2_NAME, iterator_s) r = {.private_ = {.pos = 0}};
  FIO_PTR_TAG_VALID_OR_RETURN(map, r);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  if (!o->count)
    return r;
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);
  size_t capa = FIO_MAP2_CAPA(o->bits);
  size_t pos_counter = 0;
  if (!current_pos || !current_pos->private_.map_validator) {
    goto find_pos;
  }
  if (current_pos->private_.pos + 1 == o->count)
    return r;
  r.private_.pos = current_pos->private_.pos + 1;
  if (current_pos->private_.map_validator != (uintptr_t)o) {
    goto refind_pos;
  }
  r.private_.index = current_pos->private_.index;

#if !FIO_MAP2_RECALC_HASH
#define FIO_MAP2___EACH_COPY_HASH() r.hash = o->map[r.private_.index].hash
#else
#define FIO_MAP2___EACH_COPY_HASH()
#endif

#ifdef FIO_MAP2_VALUE
#define FIO_MAP2___EACH_COPY_DATA()                                            \
  FIO_MAP2___EACH_COPY_HASH();                                                 \
  r.private_.map_validator = (uintptr_t)o;                                     \
  r.node = o->map + r.private_.index;                                          \
  r.key = FIO_MAP2_KEY_FROM_INTERNAL(o->map[r.private_.index].key);            \
  r.value = FIO_MAP2_VALUE_FROM_INTERNAL(o->map[r.private_.index].value)
#else
#define FIO_MAP2___EACH_COPY_DATA()                                            \
  FIO_MAP2___EACH_COPY_HASH();                                                 \
  r.private_.map_validator = (uintptr_t)o;                                     \
  r.node = o->map + r.private_.index;                                          \
  r.key = FIO_MAP2_KEY_FROM_INTERNAL(o->map[r.private_.index].key)
#endif

/* start seeking at the position inherited from current_pos */
#if FIO_MAP2_ORDERED
  (void)imap; /* unused in ordered maps */
  (void)capa; /* unused in ordered maps */
  r.private_.index = o->map[r.private_.index].node.next;
  if (r.private_.index == o->head)
    goto not_found;
  FIO_MAP2___EACH_COPY_DATA();
  return r;
#else
  if (FIO_MAP2_IS_SPARSE(o)) { /* sparsely populated */
    while ((++r.private_.index) & 7) {
      if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
        continue;
      FIO_MAP2___EACH_COPY_DATA();
      return r;
    }
    while (r.private_.index < capa) {
      uint64_t simd = *(uint64_t *)(imap + r.private_.index);
      if (!simd || simd == 0xFFFFFFFFFFFFFFFFULL) {
        r.private_.index += 8;
        continue;
      }
      for (size_t i = 0; i < 8; (++i), (++r.private_.index)) {
        if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
          continue;
        FIO_MAP2___EACH_COPY_DATA();
        return r;
      }
    }
    goto not_found;
  }
  /* review as array */
  while ((++r.private_.index) < capa) {
    if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
      continue;
    FIO_MAP2___EACH_COPY_DATA();
    return r;
  }
  goto not_found;
#endif /* FIO_MAP2_ORDERED */

refind_pos:
  if (current_pos->private_.index)
    goto not_found;
find_pos:
/* first seek... re-start seeking */
#if FIO_MAP2_ORDERED
  FIO_INDEXED_LIST_EACH(o->map, node, o->head, i) {
    if (pos_counter != r.private_.pos) {
      ++pos_counter;
      continue;
    }
    r.private_.index = (uint32_t)i;
    FIO_MAP2___EACH_COPY_DATA();
    return r;
  }
  goto not_found;
#else
  if (FIO_MAP2_IS_SPARSE(o)) { /* sparsely populated */
    while (r.private_.index < capa) {
      uint64_t simd = *(uint64_t *)(imap + r.private_.index);
      if (!simd || simd == 0xFFFFFFFFFFFFFFFFULL) {
        r.private_.index += 8;
        continue;
      }
      for (size_t i = 0; i < 8; (++i), (++r.private_.index)) {
        if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
          continue;
        if (pos_counter != r.private_.pos) {
          ++pos_counter;
          continue;
        }
        FIO_MAP2___EACH_COPY_DATA();
        return r;
      }
    }
    goto not_found;
  }
  /* review as array */
  while (r.private_.index < capa) {
    if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF) {
      ++r.private_.index;
      continue;
    }
    FIO_MAP2___EACH_COPY_DATA();
    return r;
  }
#endif /* FIO_MAP2_ORDERED */

not_found:
  return (r = (FIO_NAME(FIO_MAP2_NAME, iterator_s)){.private_ = {.pos = 0}});
  FIO_ASSERT_DEBUG(0, "should this happen? ever?");
}

/** Returns the next iterator position after `current_pos`, first if `NULL`. */
SFUNC FIO_NAME(FIO_MAP2_NAME, iterator_s)
    FIO_NAME(FIO_MAP2_NAME,
             get_prev)(FIO_MAP2_PTR map,
                       FIO_NAME(FIO_MAP2_NAME, iterator_s) * current_pos) {
  FIO_NAME(FIO_MAP2_NAME, iterator_s) r = {.private_ = {.pos = 0}};
  FIO_PTR_TAG_VALID_OR_RETURN(map, r);
  FIO_NAME(FIO_MAP2_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP2_T, map);
  if (!o->count)
    return r;
#if !FIO_MAP2_ORDERED
  uint8_t *imap = FIO_NAME(FIO_MAP2_NAME, __imap)(o);
  size_t capa = FIO_MAP2_CAPA(o->bits);
#endif
  size_t pos_counter = o->count;
  if (!current_pos || !current_pos->private_.map_validator) {
    r.private_.map_validator = (uintptr_t)o;
    r.private_.pos = o->count;
    goto find_pos;
  }
  if (!current_pos->private_.pos)
    return r;
  r.private_.pos = current_pos->private_.pos - 1;
  r.private_.map_validator = (uintptr_t)o;
  if (current_pos->private_.map_validator != (uintptr_t)o) {
    goto refind_pos;
  }
  r.private_.index = current_pos->private_.index;

/* start seeking at the position inherited from current_pos */
#if FIO_MAP2_ORDERED
  if (r.private_.index == o->head)
    goto not_found;
  r.private_.index = o->map[r.private_.index].node.prev;
  FIO_MAP2___EACH_COPY_DATA();
  return r;
#else
  if (FIO_MAP2_IS_SPARSE(o)) { /* sparsely populated */
    while ((--r.private_.index) & 7) {
      if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
        continue;
      FIO_MAP2___EACH_COPY_DATA();
      return r;
    }
    while (r.private_.index) {
      uint64_t simd = *(uint64_t *)(imap + (r.private_.index - 8));
      if (!simd || simd == 0xFFFFFFFFFFFFFFFFULL) {
        r.private_.index -= 8;
        continue;
      }
      for (size_t i = 0; i < 8; ++i) {
        --r.private_.index;
        if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
          continue;
        FIO_MAP2___EACH_COPY_DATA();
        return r;
      }
    }
    goto not_found;
  }
  /* review as array */
  while (r.private_.index--) {
    if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
      continue;
    FIO_MAP2___EACH_COPY_DATA();
    return r;
  }
  goto not_found;
#endif /* FIO_MAP2_ORDERED */

refind_pos:
  if (current_pos->private_.index)
    goto not_found;
find_pos:
/* first seek... re-start seeking */
#if FIO_MAP2_ORDERED
  FIO_INDEXED_LIST_EACH_REVERSED(o->map, node, o->head, i) {
    if (pos_counter != r.private_.pos) {
      --pos_counter;
      continue;
    }
    r.private_.index = (uint32_t)i;
    FIO_MAP2___EACH_COPY_DATA();
    return r;
  }
  goto not_found;
#else
  r.private_.index = (uint32_t)capa;
  if (FIO_MAP2_IS_SPARSE(o)) { /* sparsely populated */
    while (r.private_.index) {
      uint64_t simd = *(uint64_t *)(imap + r.private_.index);
      if (!simd || simd == 0xFFFFFFFFFFFFFFFFULL) {
        r.private_.index -= 8;
        continue;
      }
      for (size_t i = 0; i < 8; (++i), (--r.private_.index)) {
        if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
          continue;
        if (pos_counter != r.private_.pos) {
          ++pos_counter;
          continue;
        }
        FIO_MAP2___EACH_COPY_DATA();
        return r;
      }
    }
    goto not_found;
  }
  /* review as array */
  while ((r.private_.index--)) {
    if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
      continue;
    FIO_MAP2___EACH_COPY_DATA();
    return r;
  }
#endif /* FIO_MAP2_ORDERED */

not_found:
  return (r = (FIO_NAME(FIO_MAP2_NAME, iterator_s)){.private_ = {.pos = 0}});
  FIO_ASSERT_DEBUG(0, "should this happen? ever?");
}
#undef FIO_MAP2___EACH_COPY_HASH
#undef FIO_MAP2___EACH_COPY_DATA

/**
 * Iteration using a callback for each element in the map.
 *
 * The callback task function must accept an each_s pointer, see above.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
SFUNC uint32_t FIO_NAME(FIO_MAP2_NAME,
                        each)(FIO_MAP2_PTR map,
                              int (*task)(FIO_NAME(FIO_MAP2_NAME, each_s) *),
                              void *udata,
                              ssize_t start_at) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, 1);
  FIO_NAME(FIO_MAP2_NAME, each_s)
  e = {
      .parent = map,
      .task = task,
      .udata = udata,
  };
  FIO_NAME(FIO_MAP2_NAME, s) *o =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_MAP2_NAME, s), map);
  if (start_at < 0) {
    start_at += o->count;
    if (start_at < 0)
      start_at = 0;
  } else if (start_at > o->count)
    return o->count;
  FIO_NAME(FIO_MAP2_NAME, iterator_s) i = {.private_ = {.pos = 0}};
  for (;;) {
    i = FIO_NAME(FIO_MAP2_NAME, get_next)(map, &i);
    if (!FIO_NAME(FIO_MAP2_NAME, iterator_is_valid)(&i))
      return o->count;
    e.index = i.private_.pos;
    e.key = i.key;
#ifdef FIO_MAP2_VALUE
    e.value = i.value;
#endif
    if (e.task(&e))
      return (uint32_t)(e.index + 1);
  }
  return o->count;
}

/* *****************************************************************************
Speed Testing
***************************************************************************** */

/* *****************************************************************************
Map Testing
***************************************************************************** */
#ifdef FIO_MAP2_TEST

#ifdef FIO_MAP2_HASH_FN
#define FIO___M_HASH(k)
#else
#define FIO___M_HASH(k) (k),
#endif
#ifdef FIO_MAP2_VALUE
#define FIO___M_VAL(v) , (v)
#define FIO___M_OLD    , NULL
#else
#define FIO___M_VAL(v)
#define FIO___M_OLD
#endif

FIO_SFUNC void FIO_NAME_TEST(stl, FIO_MAP2_NAME)(void) {
  /* testing only only works with integer external types */
  fprintf(stderr,
          "* Testing maps with key " FIO_MACRO2STR(
              FIO_MAP2_KEY) " (=> " FIO_MACRO2STR(FIO_MAP2_VALUE) ").\n");
  { /* test set / get overwrite , FIO_MAP2_EACH and evict */
    FIO_NAME(FIO_MAP2_NAME, s) map = FIO_MAP2_INIT;
    for (size_t i = 1; i < (1UL << (FIO_MAP2_ARRAY_LOG_LIMIT + 5)); ++i) {
      FIO_NAME(FIO_MAP2_NAME, set)
      (&map, FIO___M_HASH(i) i FIO___M_VAL(i) FIO___M_OLD);
      FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, count)(&map) == i,
                 "map `set` failed? %zu != %zu",
                 (size_t)FIO_NAME(FIO_MAP2_NAME, count)(&map),
                 i);
      for (size_t j = ((i << 2) + 1); j < i; ++j) { /* effects LRU ordering */
        FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, get_ptr)(&map, FIO___M_HASH(j) j) &&
                       FIO_NAME(FIO_MAP2_NAME, node2val)(
                           FIO_NAME(FIO_MAP2_NAME,
                                    get_ptr)(&map, FIO___M_HASH(j) j)) == j,
                   "map `get` failed? %zu/%zu (%p)",
                   j,
                   i,
                   FIO_NAME(FIO_MAP2_NAME, get_ptr)(&map, FIO___M_HASH(j) j));
        FIO_NAME(FIO_MAP2_NAME, set)
        (&map, FIO___M_HASH(j) j FIO___M_VAL(j) FIO___M_OLD);
        FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, count)(&map) == i,
                   "map `set` added an item that already exists? %zu != %zu",
                   (size_t)FIO_NAME(FIO_MAP2_NAME, count)(&map),
                   i);
      }
    }
    /* test FIO_MAP2_EACH and ordering */
    uint32_t count = FIO_NAME(FIO_MAP2_NAME, count)(&map);
    uint32_t loop_test = 0;
    FIO_MAP2_EACH(FIO_MAP2_NAME, &map, i) {
      /* test ordering */
#ifdef FIO_MAP2_LRU
      FIO_ASSERT(i.key == (count - loop_test),
                 "map FIO_MAP2_EACH LRU ordering broken? %zu != %zu",
                 (size_t)(i.key),
                 (size_t)(count - loop_test));
      ++loop_test;
#elif FIO_MAP2_ORDERED
      ++loop_test;
      FIO_ASSERT(i.key == loop_test,
                 "map FIO_MAP2_EACH LRU ordering broken? %zu != %zu",
                 (size_t)(i.key),
                 (size_t)(loop_test));
#else
      ++loop_test;
#endif
    }
    FIO_ASSERT(loop_test == count,
               "FIO_MAP2_EACH failed to iterate all elements? (%zu != %zu",
               (size_t)loop_test != (size_t)count);
    loop_test = 0;
    FIO_MAP2_EACH_REVERSED(FIO_MAP2_NAME, &map, i) { ++loop_test; }
    FIO_ASSERT(
        loop_test == count,
        "FIO_MAP2_EACH_REVERSED failed to iterate all elements? (%zu != %zu",
        (size_t)loop_test != (size_t)count);
    /* test `evict` while we're here */
    FIO_NAME(FIO_MAP2_NAME, evict)(&map, (count >> 1));
    FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, count)(&map) == (count - (count >> 1)),
               "map `evict` count error %zu != %zu",
               (size_t)FIO_NAME(FIO_MAP2_NAME, count)(&map),
               (size_t)(count - (count >> 1)));
    /* cleanup */
    FIO_NAME(FIO_MAP2_NAME, destroy)(&map);
  }
#ifndef FIO_MAP2_HASH_FN
  { /* test full collision guard and zero hash*/
    FIO_NAME(FIO_MAP2_NAME, s) map = FIO_MAP2_INIT;
    fprintf(
        stderr,
        "* Testing full collision guard for " FIO_MACRO2STR(
            FIO_NAME(FIO_MAP2_NAME, s)) " - expect SECURITY log messages.\n");
    for (size_t i = 1; i < 4096; ++i) {
      FIO_NAME(FIO_MAP2_NAME, set)
      (&map, FIO___M_HASH(0) i FIO___M_VAL(i) FIO___M_OLD);
    }
    FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, count)(&map),
               "zero hash fails insertion?");
    FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, count)(&map) <= FIO_MAP2_ATTACK_LIMIT,
               "map attack guard failed? %zu != %zu",
               (size_t)FIO_NAME(FIO_MAP2_NAME, count)(&map),
               (size_t)FIO_MAP2_ATTACK_LIMIT);
    FIO_NAME(FIO_MAP2_NAME, destroy)(&map);
  }
#endif
  { /* test reserve, remove */
    FIO_NAME(FIO_MAP2_NAME, s) map = FIO_MAP2_INIT;
    FIO_NAME(FIO_MAP2_NAME, reserve)(&map, 4096);
    FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, capa)(&map) == 4096,
               "map reserve error? %zu != %zu",
               (size_t)FIO_NAME(FIO_MAP2_NAME, capa)(&map),
               4096);
    for (size_t i = 1; i < 4096; ++i) {
      FIO_NAME(FIO_MAP2_NAME, set)
      (&map, FIO___M_HASH(i) i FIO___M_VAL(i) FIO___M_OLD);
      FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, count)(&map) == i,
                 "insertion failed?");
    }
    for (size_t i = 1; i < 4096; ++i) {
      FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, get)(&map, FIO___M_HASH(i) i),
                 "key missing?");
      FIO_NAME(FIO_MAP2_NAME, remove)
      (&map, FIO___M_HASH(i) i, NULL);
      FIO_ASSERT(!FIO_NAME(FIO_MAP2_NAME, get)(&map, FIO___M_HASH(i) i),
                 "map_remove error?");
      FIO_ASSERT(FIO_NAME(FIO_MAP2_NAME, count)(&map) == 4095 - i,
                 "map count error after removal? %zu != %zu",
                 (size_t)FIO_NAME(FIO_MAP2_NAME, count)(&map),
                 i);
    }
    FIO_NAME(FIO_MAP2_NAME, destroy)(&map);
  }
}
#undef FIO___M_HASH
#undef FIO___M_VAL
#undef FIO___M_OLD

#endif /* FIO_MAP2_TEST */
/* *****************************************************************************
Map Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */

#undef FIO_MAP2_ARRAY_LOG_LIMIT
#undef FIO_MAP2_ATTACK_LIMIT
#undef FIO_MAP2_CAPA
#undef FIO_MAP2_CAPA_BITS_LIMIT
#undef FIO_MAP2_CUCKOO_STEPS
#undef FIO_MAP2_GET_T
#undef FIO_MAP2_HASH_FN
#undef FIO_MAP2_IS_SPARSE
#undef FIO_MAP2_KEY
#undef FIO_MAP2_KEY_CMP
#undef FIO_MAP2_KEY_COPY
#undef FIO_MAP2_KEY_DESTROY
#undef FIO_MAP2_KEY_DESTROY_SIMPLE
#undef FIO_MAP2_KEY_DISCARD
#undef FIO_MAP2_KEY_FROM_INTERNAL
#undef FIO_MAP2_KEY_INTERNAL
#undef FIO_MAP2_KEY_IS_GREATER_THAN
#undef FIO_MAP2_LRU
#undef FIO_MAP2_NAME
#undef FIO_MAP2_ORDERED
#undef FIO_MAP2_PTR
#undef FIO_MAP2_RECALC_HASH
#undef FIO_MAP2_SEEK_LIMIT
#undef FIO_MAP2_T
#undef FIO_MAP2_TEST
#undef FIO_MAP2_VALUE
#undef FIO_MAP2_VALUE_BSTR
#undef FIO_MAP2_VALUE_COPY
#undef FIO_MAP2_VALUE_DESTROY
#undef FIO_MAP2_VALUE_DESTROY_SIMPLE
#undef FIO_MAP2_VALUE_DISCARD
#undef FIO_MAP2_VALUE_FROM_INTERNAL
#undef FIO_MAP2_VALUE_INTERNAL
#undef FIO_OMAP_NAME
#undef FIO_UMAP_NAME

#endif /* FIO_MAP2_NAME */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_REF_NAME long_ref  /* Development inclusion - ignore line */
#define FIO_REF_TYPE long      /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                      Reference Counting / Wrapper
                   (must be placed after all type macros)


Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#ifdef FIO_REF_NAME

#ifndef FIO_REF_TYPE
#define FIO_REF_TYPE FIO_NAME(FIO_REF_NAME, s)
#endif

#ifndef FIO_REF_INIT
#define FIO_REF_INIT(obj)                                                      \
  do {                                                                         \
    if (!FIO_MEM_REALLOC_IS_SAFE_)                                             \
      (obj) = (FIO_REF_TYPE){0};                                               \
  } while (0)
#endif

#ifndef FIO_REF_DESTROY
#define FIO_REF_DESTROY(obj)
#endif

#ifndef FIO_REF_METADATA_INIT
#ifdef FIO_REF_METADATA
#define FIO_REF_METADATA_INIT(meta)                                            \
  do {                                                                         \
    if (!FIO_MEM_REALLOC_IS_SAFE_)                                             \
      (meta) = (FIO_REF_METADATA){0};                                          \
  } while (0)
#else
#define FIO_REF_METADATA_INIT(meta)
#endif
#endif

#ifndef FIO_REF_METADATA_DESTROY
#define FIO_REF_METADATA_DESTROY(meta)
#endif

/**
 * FIO_REF_CONSTRUCTOR_ONLY allows the reference counter constructor (TYPE_new)
 * to be the only constructor function.
 *
 * When set, the reference counting functions will use `X_new` and `X_free`.
 * Otherwise (assuming `X_new` and `X_free` are already defined), the reference
 * counter will define `X_new2` and `X_free2` instead.
 */
#ifdef FIO_REF_CONSTRUCTOR_ONLY
#define FIO_REF_CONSTRUCTOR new
#define FIO_REF_DESTRUCTOR  free
#define FIO_REF_DUPNAME     dup
#else
#define FIO_REF_CONSTRUCTOR new2
#define FIO_REF_DESTRUCTOR  free2
#define FIO_REF_DUPNAME     dup2
#endif

typedef struct {
#ifdef FIO_REF_FLEX_TYPE
  volatile uint32_t ref;
  uint32_t flx_size;
#else
  volatile size_t ref;
#endif
#ifdef FIO_REF_METADATA
  FIO_REF_METADATA metadata;
#endif
} FIO_NAME(FIO_REF_NAME, _wrapper_s);

#ifdef FIO_PTR_TAG_TYPE
#define FIO_REF_TYPE_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_REF_TYPE_PTR FIO_REF_TYPE *
#endif

/* *****************************************************************************
Reference Counter (Wrapper) API
***************************************************************************** */

/** Allocates a reference counted object. */
#ifdef FIO_REF_FLEX_TYPE
IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME,
                                FIO_REF_CONSTRUCTOR)(size_t members);
#else
IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME, FIO_REF_CONSTRUCTOR)(void);
#endif /* FIO_REF_FLEX_TYPE */

/** Increases the reference count. */
FIO_IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME,
                                    FIO_REF_DUPNAME)(FIO_REF_TYPE_PTR wrapped);

/** Frees a reference counted object (or decreases the reference count). */
IFUNC void FIO_NAME(FIO_REF_NAME, FIO_REF_DESTRUCTOR)(FIO_REF_TYPE_PTR wrapped);

#ifdef FIO_REF_METADATA
/** Returns a pointer to the object's metadata, if defined. */
IFUNC FIO_REF_METADATA *FIO_NAME(FIO_REF_NAME,
                                 metadata)(FIO_REF_TYPE_PTR wrapped);
#endif

#ifdef FIO_REF_FLEX_TYPE
/** The allocation length for the flex type */
IFUNC uint32_t FIO_NAME(FIO_REF_NAME,
                        metadata_flex_len)(FIO_REF_TYPE_PTR wrapped);
#endif
/* *****************************************************************************
Inline Implementation
***************************************************************************** */
/** Increases the reference count. */
FIO_IFUNC FIO_REF_TYPE_PTR
FIO_NAME(FIO_REF_NAME, FIO_REF_DUPNAME)(FIO_REF_TYPE_PTR wrapped_) {
  FIO_REF_TYPE *wrapped = (FIO_REF_TYPE *)(FIO_PTR_UNTAG(wrapped_));
  if (!wrapped || !wrapped_)
    return 0;
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      ((FIO_NAME(FIO_REF_NAME, _wrapper_s) *)wrapped) - 1;
  fio_atomic_add(&o->ref, 1);
  return wrapped_;
}

/** Debugging helper, do not use for data, as returned value is unstable. */
FIO_IFUNC size_t FIO_NAME(FIO_REF_NAME, references)(FIO_REF_TYPE_PTR wrapped_) {
  FIO_REF_TYPE *wrapped = (FIO_REF_TYPE *)(FIO_PTR_UNTAG(wrapped_));
  if (!wrapped || !wrapped_)
    return 0;
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      ((FIO_NAME(FIO_REF_NAME, _wrapper_s) *)wrapped) - 1;
  return o->ref;
}

#ifdef FIO_REF_FLEX_TYPE
/** The allocation length for the flex type */
IFUNC uint32_t FIO_NAME(FIO_REF_NAME,
                        metadata_flex_len)(FIO_REF_TYPE_PTR wrapped_) {
  FIO_REF_TYPE *wrapped = (FIO_REF_TYPE *)(FIO_PTR_UNTAG(wrapped_));
  if (!wrapped || !wrapped_)
    return 0;
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      ((FIO_NAME(FIO_REF_NAME, _wrapper_s) *)wrapped) - 1;
  return o->flx_size;
}
#endif

/* *****************************************************************************
Reference Counter (Wrapper) Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_LEAK_COUNTER_DEF(FIO_REF_NAME)

/** Allocates a reference counted object. */
#ifdef FIO_REF_FLEX_TYPE
IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME,
                                FIO_REF_CONSTRUCTOR)(size_t members) {
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      (FIO_NAME(FIO_REF_NAME, _wrapper_s) *)FIO_MEM_REALLOC_(
          NULL,
          0,
          sizeof(*o) + sizeof(FIO_REF_TYPE) +
              (sizeof(FIO_REF_FLEX_TYPE) * members),
          0);
#else
IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME, FIO_REF_CONSTRUCTOR)(void) {
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o = (FIO_NAME(FIO_REF_NAME, _wrapper_s) *)
      FIO_MEM_REALLOC_(NULL, 0, sizeof(*o) + sizeof(FIO_REF_TYPE), 0);
#endif /* FIO_REF_FLEX_TYPE */
  if (!o)
    return (FIO_REF_TYPE_PTR)(o);
  FIO_LEAK_COUNTER_ON_ALLOC(FIO_REF_NAME);
  o->ref = 1;
#ifdef FIO_REF_FLEX_TYPE
  o->flx_size = (uint32_t)members;
#endif
  FIO_REF_METADATA_INIT((o->metadata));
  FIO_REF_TYPE *ret = (FIO_REF_TYPE *)(o + 1);
  FIO_REF_INIT((ret[0]));
  return (FIO_REF_TYPE_PTR)(FIO_PTR_TAG(ret));
  (void)FIO_NAME(FIO_REF_NAME, references);
}

/** Frees a reference counted object (or decreases the reference count). */
IFUNC void FIO_NAME(FIO_REF_NAME,
                    FIO_REF_DESTRUCTOR)(FIO_REF_TYPE_PTR wrapped_) {
  FIO_REF_TYPE *wrapped = (FIO_REF_TYPE *)(FIO_PTR_UNTAG(wrapped_));
  if (!wrapped || !wrapped_)
    return;
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(wrapped_);
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      ((FIO_NAME(FIO_REF_NAME, _wrapper_s) *)wrapped) - 1;
  if (!o)
    return;
  if (fio_atomic_sub_fetch(&o->ref, 1))
    return;
  FIO_REF_DESTROY((wrapped[0]));
  FIO_REF_METADATA_DESTROY((o->metadata));
  FIO_LEAK_COUNTER_ON_FREE(FIO_REF_NAME);
  FIO_MEM_FREE_(o, sizeof(*o) + (o->flx_size * sizeof(FIO_REF_TYPE)));
}

#ifdef FIO_REF_METADATA
/** Returns a pointer to the object's metadata, if defined. */
IFUNC FIO_REF_METADATA *FIO_NAME(FIO_REF_NAME,
                                 metadata)(FIO_REF_TYPE_PTR wrapped_) {
  FIO_REF_TYPE *wrapped = (FIO_REF_TYPE *)(FIO_PTR_UNTAG(wrapped_));
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      ((FIO_NAME(FIO_REF_NAME, _wrapper_s) *)wrapped) - 1;
  return &o->metadata;
}
#endif

/* *****************************************************************************
Reference Counter (Wrapper) Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_REF_NAME
#undef FIO_REF_FLEX_TYPE
#undef FIO_REF_TYPE
#undef FIO_REF_INIT
#undef FIO_REF_DESTROY
#undef FIO_REF_METADATA
#undef FIO_REF_METADATA_INIT
#undef FIO_REF_METADATA_DESTROY
#undef FIO_REF_TYPE_PTR
#undef FIO_REF_CONSTRUCTOR_ONLY
#undef FIO_REF_CONSTRUCTOR
#undef FIO_REF_DUPNAME
#undef FIO_REF_DESTRUCTOR
#endif
/* *****************************************************************************
Pointer Tagging Cleanup
***************************************************************************** */
#ifndef FIO___DEV___
#undef FIO_PTR_TAG
#undef FIO_PTR_UNTAG
#undef FIO_PTR_TAG_TYPE
#undef FIO_PTR_TAG_VALIDATE
#undef FIO_PTR_TAG_VALID_OR_RETURN
#undef FIO_PTR_TAG_VALID_OR_RETURN_VOID
#undef FIO_PTR_TAG_VALID_OR_GOTO
#endif
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_FIOBJ              /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************








                          FIOBJ - soft (dynamic) types



FIOBJ - dynamic types

These are dynamic types that use pointer tagging for fast type identification.

Pointer tagging on 64 bit systems allows for 3 bits at the lower bits. On most
32 bit systems this is also true due to allocator alignment. When in doubt, use
the provided custom allocator.

To keep the 64bit memory address alignment on 32bit systems, a 32bit metadata
integer is added when a virtual function table is missing. This doesn't effect
memory consumption on 64 bit systems and uses 4 bytes on 32 bit systems.

Note: this code is placed at the end of the STL file, since it leverages most of
the SLT features and could be affected by their inclusion.

Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_FIOBJ) && !defined(H___FIO_FIOBJ___H) &&                       \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_FIOBJ___H
#define FIO___RECURSIVE_INCLUDE 99 /* 99 keeps EXTERN rules */
/* *****************************************************************************
FIOBJ compilation settings (type names and JSON nesting limits).

Type Naming Macros for FIOBJ types. By default, results in:
- fiobj_true()     (constant, cannot be changed except manually)
- fiobj_false()    (constant, cannot be changed except manually)
- fiobj_null()
- fiobj_num_new() ... (etc')
- fiobj_float_new() ... (etc')
- fiobj_str_new() ... (etc')
- fiobj_array_new() ... (etc')
- fiobj_hash_new() ... (etc')
***************************************************************************** */

#ifndef FIOBJ___NAME_NULL
#define FIOBJ___NAME_NULL null
#endif
#ifndef FIOBJ___NAME_NUMBER
#define FIOBJ___NAME_NUMBER num
#endif
#ifndef FIOBJ___NAME_FLOAT
#define FIOBJ___NAME_FLOAT float
#endif
#ifndef FIOBJ___NAME_STRING
#define FIOBJ___NAME_STRING str
#endif
#ifndef FIOBJ___NAME_ARRAY
#define FIOBJ___NAME_ARRAY array
#endif
#ifndef FIOBJ___NAME_HASH
#define FIOBJ___NAME_HASH hash
#endif

#ifndef FIOBJ_MAX_NESTING
/**
 * Sets the limit on nesting level transversal by recursive functions.
 *
 * This effects JSON output / input and the `fiobj_each2` function since they
 * are recursive.
 *
 * HOWEVER: this value will NOT effect the recursive `fiobj_free` which could
 * (potentially) expload the stack if given melformed input such as cyclic data
 * structures.
 *
 * Values should be less than 32K.
 */
#define FIOBJ_MAX_NESTING 512
#endif

/* make sure roundtrips work */
#ifndef JSON_MAX_DEPTH
#define JSON_MAX_DEPTH FIOBJ_MAX_NESTING
#endif

#ifndef FIOBJ_JSON_APPEND
#define FIOBJ_JSON_APPEND 1
#endif
/* *****************************************************************************
General Requirements / Macros
***************************************************************************** */

#ifdef __cplusplus /* C++ doesn't allow declarations for static variables */
#define FIOBJ_EXTERN_OBJ     extern "C" FIO_WEAK
#define FIOBJ_EXTERN_OBJ_IMP extern "C" FIO_WEAK
#elif defined(FIO_EXTERN)
#define FIOBJ_EXTERN_OBJ     extern
#define FIOBJ_EXTERN_OBJ_IMP FIO_WEAK
#else
#define FIOBJ_EXTERN_OBJ     static FIO_MAYBE_UNUSED
#define FIOBJ_EXTERN_OBJ_IMP static FIO_MAYBE_UNUSED
#endif
/* *****************************************************************************
Debugging / Leak Detection
***************************************************************************** */
#if defined(TEST) || defined(DEBUG) || defined(FIO_LEAK_COUNTER)
size_t FIO_WEAK FIOBJ_MARK_MEMORY_ALLOC_COUNTER;
size_t FIO_WEAK FIOBJ_MARK_MEMORY_FREE_COUNTER;
#define FIOBJ_MARK_MEMORY_ALLOC()                                              \
  fio_atomic_add(&FIOBJ_MARK_MEMORY_ALLOC_COUNTER, 1)
#define FIOBJ_MARK_MEMORY_FREE()                                               \
  fio_atomic_add(&FIOBJ_MARK_MEMORY_FREE_COUNTER, 1)
#define FIOBJ_MARK_MEMORY_PRINT()                                              \
  FIO___LOG_PRINT_LEVEL(                                                       \
      ((FIOBJ_MARK_MEMORY_ALLOC_COUNTER == FIOBJ_MARK_MEMORY_FREE_COUNTER)     \
           ? 4 /* FIO_LOG_LEVEL_INFO */                                        \
           : 3 /* FIO_LOG_LEVEL_WARNING */),                                   \
      ((FIOBJ_MARK_MEMORY_ALLOC_COUNTER == FIOBJ_MARK_MEMORY_FREE_COUNTER)     \
           ? "INFO: total remaining FIOBJ allocations: %zu (%zu - %zu)"        \
           : "WARNING: LEAKED! FIOBJ allocations: %zu (%zu - %zu)"),           \
      FIOBJ_MARK_MEMORY_ALLOC_COUNTER - FIOBJ_MARK_MEMORY_FREE_COUNTER,        \
      FIOBJ_MARK_MEMORY_ALLOC_COUNTER,                                         \
      FIOBJ_MARK_MEMORY_FREE_COUNTER)
#define FIOBJ_MARK_MEMORY_ENABLED 1

#else

#define FIOBJ_MARK_MEMORY_ALLOC_COUNTER 0 /* when testing unmarked FIOBJ */
#define FIOBJ_MARK_MEMORY_FREE_COUNTER  0 /* when testing unmarked FIOBJ */
#define FIOBJ_MARK_MEMORY_ALLOC()
#define FIOBJ_MARK_MEMORY_FREE()
#define FIOBJ_MARK_MEMORY_PRINT()
#define FIOBJ_MARK_MEMORY_ENABLED 0
#endif

/* *****************************************************************************
The FIOBJ Type
***************************************************************************** */

/** Use the FIOBJ type for dynamic types. */
typedef struct FIOBJ_s {
  struct FIOBJ_s *compiler_validation_type;
} * FIOBJ;

/** FIOBJ type enum for common / primitive types. */
typedef enum {
  FIOBJ_T_NUMBER = 0x01, /* 0b001 3 bits taken for small numbers */
  FIOBJ_T_PRIMITIVE = 2, /* 0b010 a lonely second bit signifies a primitive */
  FIOBJ_T_STRING = 3,    /* 0b011 */
  FIOBJ_T_ARRAY = 4,     /* 0b100 */
  FIOBJ_T_HASH = 5,      /* 0b101 */
  FIOBJ_T_FLOAT = 6,     /* 0b110 */
  FIOBJ_T_OTHER = 7,     /* 0b111 dynamic type - test content */
} fiobj_class_en;

#define FIOBJ_T_NULL  2  /* 0b010 a lonely second bit signifies a primitive */
#define FIOBJ_T_TRUE  18 /* 0b010 010 - primitive value */
#define FIOBJ_T_FALSE 34 /* 0b100 010 - primitive value */

/** Use the macros to avoid future API changes. */
#define FIOBJ_TYPE(o) fiobj_type(o)
/** Use the macros to avoid future API changes. */
#define FIOBJ_TYPE_IS(o, type) (fiobj_type(o) == type)
/** Identifies an invalid type identifier (returned from FIOBJ_TYPE(o) */
#define FIOBJ_T_INVALID 0
/** Identifies an invalid object */
#define FIOBJ_INVALID 0
/** Tests if the object is (probably) a valid FIOBJ */
#define FIOBJ_IS_INVALID(o)     (((uintptr_t)(o)&7UL) == 0)
#define FIOBJ_IS_NULL(o)        (FIOBJ_IS_INVALID(o) || ((o) == FIOBJ_T_NULL))
#define FIOBJ_TYPE_CLASS(o)     ((fiobj_class_en)(((uintptr_t)(o)) & 7UL))
#define FIOBJ_PTR_TAG(o, klass) ((uintptr_t)(((uintptr_t)(o)) | (klass)))
#define FIOBJ_PTR_UNTAG(o)      ((uintptr_t)(((uintptr_t)(o)) & (~7ULL)))
/** Returns an objects type. This isn't limited to known types. */
FIO_IFUNC size_t fiobj_type(FIOBJ o);

/* *****************************************************************************
FIOBJ Memory Management
***************************************************************************** */

/** Increases an object's reference count (or copies) and returns it. */
FIO_IFUNC FIOBJ fiobj_dup(FIOBJ o);

/** Decreases an object's reference count or frees it. */
FIO_IFUNC void fiobj_free(FIOBJ o);

/* *****************************************************************************
FIOBJ Data / Info
***************************************************************************** */

/** Compares two objects. */
FIO_IFUNC unsigned char FIO_NAME_BL(fiobj, eq)(FIOBJ a, FIOBJ b);

/** Returns a temporary String representation for any FIOBJ object. */
FIO_IFUNC fio_str_info_s FIO_NAME2(fiobj, cstr)(FIOBJ o);

/** Returns an integer representation for any FIOBJ object. */
FIO_IFUNC intptr_t FIO_NAME2(fiobj, i)(FIOBJ o);

/** Returns a float (double) representation for any FIOBJ object. */
FIO_IFUNC double FIO_NAME2(fiobj, f)(FIOBJ o);

/** Calculates an object's hash value for a specific hash map object. */
FIO_IFUNC uint64_t FIO_NAME2(fiobj, hash)(FIOBJ object_key);

/* *****************************************************************************
FIOBJ Containers (iteration)
***************************************************************************** */

/** Iteration information structure passed to the callback. */
typedef struct fiobj_each_s {
  /** The being iterated. Once set, cannot be safely changed. */
  FIOBJ const parent;
  /** The index to start at / the current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct fiobj_each_s *info);
  /** The argument passed along to the task. */
  void *udata;
  /** The value of the current object in the Array or Hash Map */
  FIOBJ value;
  /* The key, if a Hash Map */
  FIOBJ key;
} fiobj_each_s;

/**
 * Performs a task for each element held by the FIOBJ object.
 *
 * If `task` returns -1, the `each` loop will break (stop).
 *
 * Returns the "stop" position - the number of elements processed + `start_at`.
 */
FIO_SFUNC uint32_t fiobj_each1(FIOBJ o,
                               int (*task)(fiobj_each_s *info),
                               void *udata,
                               int32_t start_at);

/**
 * Performs a task for the object itself and each element held by the FIOBJ
 * object or any of it's elements (a deep task).
 *
 * The order of performance is by order of appearance, as if all nesting levels
 * were flattened.
 *
 * If `task` returns -1, the `each` loop will break (stop).
 *
 * Returns the number of elements processed.
 */
SFUNC uint32_t fiobj_each2(FIOBJ o,
                           int (*task)(fiobj_each_s *info),
                           void *udata);

/* *****************************************************************************
FIOBJ Primitives (NULL, True, False)
***************************************************************************** */

/** Returns the `true` primitive. */
FIO_IFUNC FIOBJ fiobj_true(void) { return (FIOBJ)(FIOBJ_T_TRUE); }

/** Returns the `false` primitive. */
FIO_IFUNC FIOBJ fiobj_false(void) { return (FIOBJ)(FIOBJ_T_FALSE); }

/** Returns the `nil` / `null` primitive. */
FIO_IFUNC FIOBJ FIO_NAME(fiobj, FIOBJ___NAME_NULL)(void) {
  return (FIOBJ)(FIOBJ_T_NULL);
}

/* *****************************************************************************
FIOBJ Type - Extensibility (FIOBJ_T_OTHER)
***************************************************************************** */

/** FIOBJ types can be extended using virtual function tables. */
typedef struct {
  /**
   * MUST return a unique number to identify object type.
   *
   * Numbers (type IDs) under 100 are reserved. Numbers under 40 are illegal.
   */
  size_t type_id;
  /** Test for equality between two objects with the same `type_id` */
  unsigned char (*is_eq)(FIOBJ restrict a, FIOBJ restrict b);
  /** Converts an object to a String */
  fio_str_info_s (*to_s)(FIOBJ o);
  /** Converts an object to an integer */
  intptr_t (*to_i)(FIOBJ o);
  /** Converts an object to a double */
  double (*to_f)(FIOBJ o);
  /** Returns the number of exposed elements held by the object, if any. */
  uint32_t (*count)(FIOBJ o);
  /** Iterates the exposed elements held by the object. See `fiobj_each1`. */
  uint32_t (*each1)(FIOBJ o,
                    int (*task)(fiobj_each_s *e),
                    void *udata,
                    int32_t start_at);
  /**
   * Decreases the reference count and/or frees the object, calling `free2` for
   * any nested objects.
   */
  void (*free2)(FIOBJ o);
} FIOBJ_class_vtable_s;

FIOBJ_EXTERN_OBJ const FIOBJ_class_vtable_s FIOBJ___OBJECT_CLASS_VTBL;

#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_REF_NAME             fiobj_object
#define FIO_REF_TYPE             void *
#define FIO_REF_METADATA         const FIOBJ_class_vtable_s *
#define FIO_REF_METADATA_INIT(m)                                               \
  do {                                                                         \
    m = &FIOBJ___OBJECT_CLASS_VTBL;                                            \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#define FIO_REF_METADATA_DESTROY(m)                                            \
  do {                                                                         \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_PTR_TAG(p)          FIOBJ_PTR_TAG(p, FIOBJ_T_OTHER)
#define FIO_PTR_UNTAG(p)        FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_VALIDATE(p) (FIOBJ_TYPE_CLASS(p) == FIOBJ_T_OTHER)
#define FIO_PTR_TAG_TYPE        FIOBJ
#include FIO_INCLUDE_FILE

/* *****************************************************************************
FIOBJ Integers
***************************************************************************** */

/** Creates a new Number object. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)(intptr_t i);

/** Reads the number from a FIOBJ Number. */
FIO_IFUNC intptr_t FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(FIOBJ i);

/** Reads the number from a FIOBJ Number, fitting it in a double. */
FIO_IFUNC double FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), f)(FIOBJ i);

/** Returns a String representation of the number (in base 10). */
SFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER),
                               cstr)(FIOBJ i);

/** Frees a FIOBJ number. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), free)(FIOBJ i);

FIOBJ_EXTERN_OBJ const FIOBJ_class_vtable_s FIOBJ___NUMBER_CLASS_VTBL;

/* *****************************************************************************
FIOBJ Floats
***************************************************************************** */

/** Creates a new Float (double) object. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), new)(double i);

/** Reads the number from a FIOBJ Float rounding it to an integer. */
FIO_IFUNC intptr_t FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), i)(FIOBJ i);

/** Reads the value from a FIOBJ Float, as a double. */
FIO_IFUNC double FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(FIOBJ i);

/** Returns a String representation of the float. */
SFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT),
                               cstr)(FIOBJ i);

/** Frees a FIOBJ Float. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), free)(FIOBJ i);

FIOBJ_EXTERN_OBJ const FIOBJ_class_vtable_s FIOBJ___FLOAT_CLASS_VTBL;

/* *****************************************************************************
FIOBJ Strings
***************************************************************************** */

#define FIO_STR_NAME              FIO_NAME(fiobj, FIOBJ___NAME_STRING)
#define FIO_STR_OPTIMIZE_EMBEDDED 1
#define FIO_REF_NAME              FIO_NAME(fiobj, FIOBJ___NAME_STRING)
#define FIO_REF_CONSTRUCTOR_ONLY  1
#define FIO_REF_DESTROY(s)                                                     \
  do {                                                                         \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), destroy)                    \
    ((FIOBJ)FIOBJ_PTR_TAG(&s, FIOBJ_T_STRING));                                \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_REF_INIT(s_)                                                       \
  do {                                                                         \
    s_ = (FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s))FIO_STR_INIT;      \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)

#if SIZE_T_MAX == 0xFFFFFFFF /* for 32bit system pointer alignment */
#define FIO_REF_METADATA uint32_t
#endif
#define FIO_PTR_TAG(p)          FIOBJ_PTR_TAG(p, FIOBJ_T_STRING)
#define FIO_PTR_UNTAG(p)        FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_VALIDATE(p) (FIOBJ_TYPE_CLASS(p) == FIOBJ_T_STRING)
#define FIO_PTR_TAG_TYPE        FIOBJ
#include FIO_INCLUDE_FILE

/* Creates a new FIOBJ string object, copying the data to the new string. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                         new_cstr)(const char *ptr, size_t len) {
  FIOBJ s = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_ASSERT_ALLOC(FIOBJ_PTR_UNTAG(s));
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(s, ptr, len);
  return s;
}

/* Creates a new FIOBJ string object with (at least) the requested capacity. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                         new_buf)(size_t capa) {
  FIOBJ s = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_ASSERT_ALLOC(FIOBJ_PTR_UNTAG(s));
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), reserve)(s, capa);
  return s;
}

/* Creates a new FIOBJ string object, copying the origin (`fiobj2cstr`). */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                         new_copy)(FIOBJ original) {
  FIOBJ s = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_ASSERT_ALLOC(FIOBJ_PTR_UNTAG(s));
  fio_str_info_s i = FIO_NAME2(fiobj, cstr)(original);
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(s, i.buf, i.len);
  return s;
}

/** Returns information about the string. Same as fiobj_str_info(). */
FIO_IFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                                   cstr)(FIOBJ s) {
  return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), info)(s);
}

/**
 * Creates a temporary FIOBJ String object on the stack.
 *
 * String data might be allocated dynamically.
 */
#define FIOBJ_STR_TEMP_VAR(str_name)                                           \
  struct {                                                                     \
    uint64_t i1;                                                               \
    uint64_t i2;                                                               \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s) s;                       \
  } FIO_NAME(str_name, __auto_mem_tmp) = {0x7f7f7f7f7f7f7f7fULL,               \
                                          0x7f7f7f7f7f7f7f7fULL,               \
                                          FIO_STR_INIT};                       \
  FIOBJ str_name =                                                             \
      (FIOBJ)(((uintptr_t) & (FIO_NAME(str_name, __auto_mem_tmp).s)) |         \
              FIOBJ_T_STRING);

/**
 * Creates a temporary FIOBJ String object on the stack, initialized with a
 * static string.
 *
 * String data might be allocated dynamically.
 */
#define FIOBJ_STR_TEMP_VAR_STATIC(str_name, buf_, len_)                        \
  struct {                                                                     \
    uint64_t i1;                                                               \
    uint64_t i2;                                                               \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s) s;                       \
  } FIO_NAME(str_name,                                                         \
             __auto_mem_tmp) = {0x7f7f7f7f7f7f7f7fULL,                         \
                                0x7f7f7f7f7f7f7f7fULL,                         \
                                FIO_STR_INIT_STATIC2((buf_), (len_))};         \
  FIOBJ str_name =                                                             \
      (FIOBJ)(((uintptr_t) & (FIO_NAME(str_name, __auto_mem_tmp).s)) |         \
              FIOBJ_T_STRING);

/**
 * Creates a temporary FIOBJ String object on the stack, initialized with a
 * static string.
 *
 * String data might be allocated dynamically.
 */
#define FIOBJ_STR_TEMP_VAR_EXISTING(str_name, buf_, len_, capa_)               \
  struct {                                                                     \
    uint64_t i1;                                                               \
    uint64_t i2;                                                               \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s) s;                       \
  } FIO_NAME(str_name, __auto_mem_tmp) = {                                     \
      0x7f7f7f7f7f7f7f7fULL,                                                   \
      0x7f7f7f7f7f7f7f7fULL,                                                   \
      FIO_STR_INIT_EXISTING((buf_), (len_), (capa_))};                         \
  FIOBJ str_name =                                                             \
      (FIOBJ)(((uintptr_t) & (FIO_NAME(str_name, __auto_mem_tmp).s)) |         \
              FIOBJ_T_STRING);

/** Resets a temporary FIOBJ String, freeing and any resources allocated. */
#define FIOBJ_STR_TEMP_DESTROY(str_name)                                       \
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), destroy)(str_name);

/* *****************************************************************************
FIOBJ Arrays
***************************************************************************** */

#define FIO_ARRAY_NAME           FIO_NAME(fiobj, FIOBJ___NAME_ARRAY)
#define FIO_REF_NAME             FIO_NAME(fiobj, FIOBJ___NAME_ARRAY)
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_REF_DESTROY(a)                                                     \
  do {                                                                         \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), destroy)                     \
    ((FIOBJ)FIOBJ_PTR_TAG(&a, FIOBJ_T_ARRAY));                                 \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_REF_INIT(a)                                                        \
  do {                                                                         \
    a = (FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), s))FIO_ARRAY_INIT;      \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#if SIZE_T_MAX == 0xFFFFFFFF /* for 32bit system pointer alignment */
#define FIO_REF_METADATA uint32_t
#endif
#define FIO_ARRAY_TYPE            FIOBJ
#define FIO_ARRAY_TYPE_CMP(a, b)  FIO_NAME_BL(fiobj, eq)((a), (b))
#define FIO_ARRAY_TYPE_DESTROY(o) fiobj_free(o)
#define FIO_ARRAY_TYPE_CONCAT_COPY(dest, obj)                                  \
  do {                                                                         \
    dest = fiobj_dup(obj);                                                     \
  } while (0)
#define FIO_PTR_TAG(p)          FIOBJ_PTR_TAG(p, FIOBJ_T_ARRAY)
#define FIO_PTR_UNTAG(p)        FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_VALIDATE(p) (FIOBJ_TYPE_CLASS(p) == FIOBJ_T_ARRAY)
#define FIO_PTR_TAG_TYPE        FIOBJ
#include FIO_INCLUDE_FILE

/* *****************************************************************************
FIOBJ Hash Maps
***************************************************************************** */

#define FIO_REF_NAME             FIO_NAME(fiobj, FIOBJ___NAME_HASH)
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_REF_DESTROY(a)                                                     \
  do {                                                                         \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), destroy)                      \
    ((FIOBJ)FIOBJ_PTR_TAG(&(a), FIOBJ_T_HASH));                                \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_REF_INIT(a)                                                        \
  do {                                                                         \
    a = (FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), s))FIO_MAP_INIT;         \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#if SIZE_T_MAX == 0xFFFFFFFF /* for 32bit system pointer alignment */
#define FIO_REF_METADATA uint32_t
#endif
#define FIO_MAP_NAME              FIO_NAME(fiobj, FIOBJ___NAME_HASH)
#define FIO_MAP_ORDERED           1
#define FIO_MAP_KEY               FIOBJ
#define FIO_MAP_KEY_CMP(a, b)     FIO_NAME_BL(fiobj, eq)((a), (b))
#define FIO_MAP_KEY_COPY(dest, o) (dest = fiobj_dup(o))
#define FIO_MAP_KEY_DESTROY(o)    fiobj_free(o)
#define FIO_MAP_VALUE             FIOBJ
#define FIO_MAP_HASH_FN(o)        FIO_NAME2(fiobj, hash)(o)
#define FIO_MAP_VALUE_DESTROY(o)  fiobj_free(o)
#define FIO_MAP_VALUE_DISCARD(o)  fiobj_free(o)
#define FIO_PTR_TAG(p)            FIOBJ_PTR_TAG(p, FIOBJ_T_HASH)
#define FIO_PTR_UNTAG(p)          FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_VALIDATE(p)   (FIOBJ_TYPE_CLASS(p) == FIOBJ_T_HASH)
#define FIO_PTR_TAG_TYPE          FIOBJ
/* TODO! auto-hash object value */
#include FIO_INCLUDE_FILE
/**
 * Sets a value in a hash map, allocating the key String and automatically
 * calculating the hash value.
 */
FIO_IFUNC
FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
               set2)(FIOBJ hash, const char *key, size_t len, FIOBJ value);

/**
 * Finds a value in the hash map, using a temporary String and automatically
 * calculating the hash value.
 */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         get2)(FIOBJ hash, const char *buf, size_t len);

/**
 * Removes a value in a hash map, using a temporary String and automatically
 * calculating the hash value.
 */
FIO_IFUNC int FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                       remove2)(FIOBJ hash,
                                const char *buf,
                                size_t len,
                                FIOBJ *old);

/* *****************************************************************************
FIOBJ JSON support
***************************************************************************** */

/**
 * Returns a JSON valid FIOBJ String, representing the object.
 *
 * If `dest` is an existing String, the formatted JSON data will be appended to
 * the existing string.
 */
FIO_IFUNC FIOBJ FIO_NAME2(fiobj, json)(FIOBJ dest, FIOBJ o, uint8_t beautify);

/**
 * Updates a Hash using JSON data.
 *
 * Parsing errors and non-dictionary object JSON data are silently ignored,
 * attempting to update the Hash as much as possible before any errors
 * encountered.
 *
 * Conflicting Hash data is overwritten (preferring the new over the old).
 *
 * Returns the number of bytes consumed. On Error, 0 is returned and no data is
 * consumed.
 */
SFUNC size_t FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                      update_json)(FIOBJ hash, fio_str_info_s str);

/** Helper function, calls `fiobj_hash_update_json` with string information */
FIO_IFUNC size_t FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                          update_json2)(FIOBJ hash, char *ptr, size_t len);

/**
 * Parses a C string for JSON data. If `consumed` is not NULL, the `size_t`
 * variable will contain the number of bytes consumed before the parser stopped
 * (due to either error or end of a valid JSON data segment).
 *
 * Returns a FIOBJ object matching the JSON valid C string `str`.
 *
 * If the parsing failed (no complete valid JSON data) `FIOBJ_INVALID` is
 * returned.
 */
SFUNC FIOBJ fiobj_json_parse(fio_str_info_s str, size_t *consumed);

/** Helper macro, calls `fiobj_json_parse` with string information */
#define fiobj_json_parse2(data_, len_, consumed)                               \
  fiobj_json_parse(FIO_STR_INFO2(data_, len_), consumed)

/**
 * Uses JavaScript style notation to find data in an object structure.
 *
 * For example, "[0].name" will return the "name" property of the first object
 * in an array object.
 *
 * Returns a temporary reference to the object or FIOBJ_INVALID on an error.
 *
 * Use `fiobj_dup` to collect an actual reference to the returned object.
 */
SFUNC FIOBJ fiobj_json_find(FIOBJ object, fio_str_info_s notation);
/**
 * Uses JavaScript style notation to find data in an object structure.
 *
 * For example, "[0].name" will return the "name" property of the first object
 * in an array object.
 *
 * Returns a temporary reference to the object or FIOBJ_INVALID on an error.
 *
 * Use `fiobj_dup` to collect an actual reference to the returned object.
 */
#define fiobj_json_find2(object, str, length)                                  \
  fiobj_json_find(object, FIO_STR_INFO2(str, length))

/* *****************************************************************************
FIOBJ Mustache support
***************************************************************************** */

/**
 * Builds a Mustache template using a FIOBJ context (usually a Hash).
 *
 * Returns a FIOBJ String with the rendered template. May return `FIOBJ_INVALID`
 * if nothing was written.
 */
FIO_IFUNC FIOBJ fiobj_mustache_build(fio_mustache_s *m, FIOBJ ctx);

/**
 * Builds a Mustache template using a FIOBJ context (usually a Hash).
 *
 * Writes output to `dest` string (may be `FIOBJ_INVALID` / `NULL`).
 *
 * Returns `dest` (or a new String). May return `FIOBJ_INVALID` if nothing was
 * written and `dest` was empty.
 */
FIO_IFUNC FIOBJ fiobj_mustache_build2(fio_mustache_s *m, FIOBJ dest, FIOBJ ctx);

/* *****************************************************************************







FIOBJ - Implementation - Inline / Macro like fucntions







***************************************************************************** */

/* *****************************************************************************
The FIOBJ Type
***************************************************************************** */

/** Returns an objects type. This isn't limited to known types. */
FIO_IFUNC size_t fiobj_type(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    switch ((uintptr_t)(o)) {
    case FIOBJ_T_NULL: return FIOBJ_T_NULL;
    case FIOBJ_T_TRUE: return FIOBJ_T_TRUE;
    case FIOBJ_T_FALSE: return FIOBJ_T_FALSE;
    };
    return FIOBJ_T_INVALID;
  case FIOBJ_T_NUMBER: return FIOBJ_T_NUMBER;
  case FIOBJ_T_FLOAT: return FIOBJ_T_FLOAT;
  case FIOBJ_T_STRING: return FIOBJ_T_STRING;
  case FIOBJ_T_ARRAY: return FIOBJ_T_ARRAY;
  case FIOBJ_T_HASH: return FIOBJ_T_HASH;
  case FIOBJ_T_OTHER: return (*fiobj_object_metadata(o))->type_id;
  }
  if (!o)
    return FIOBJ_T_NULL;
  return FIOBJ_T_INVALID;
}

/* *****************************************************************************
FIOBJ Memory Management
***************************************************************************** */

/** Increases an object's reference count (or copies) and returns it. */
FIO_IFUNC FIOBJ fiobj_dup(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_FLOAT: /* fall through */ return o;
  case FIOBJ_T_STRING: /* fall through */
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), dup)(o);
    break;
  case FIOBJ_T_ARRAY: /* fall through */
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), dup)(o);
    break;
  case FIOBJ_T_HASH: /* fall through */
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), dup)(o);
    break;
  case FIOBJ_T_OTHER: /* fall through */ fiobj_object_dup(o);
  }
  return o;
}

/** Decreases an object's reference count or frees it. */
FIO_IFUNC void fiobj_free(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_FLOAT: return;
  case FIOBJ_T_STRING:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), free)(o);
    return;
  case FIOBJ_T_ARRAY:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), free)(o);
    return;
  case FIOBJ_T_HASH:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), free)(o);
    return;
  case FIOBJ_T_OTHER: (*fiobj_object_metadata(o))->free2(o); return;
  }
}

/* *****************************************************************************
FIOBJ Data / Info
***************************************************************************** */

/** Internal: compares two nestable objects. */
SFUNC unsigned char fiobj___test_eq_nested(FIOBJ restrict a,
                                           FIOBJ restrict b,
                                           size_t nesting);

/** Compares two objects. */
FIO_IFUNC unsigned char FIO_NAME_BL(fiobj, eq)(FIOBJ a, FIOBJ b) {
  if (a == b)
    return 1;
  if (FIOBJ_TYPE_CLASS(a) != FIOBJ_TYPE_CLASS(b))
    return 0;
  switch (FIOBJ_TYPE_CLASS(a)) {
  case FIOBJ_T_PRIMITIVE:
  case FIOBJ_T_NUMBER: /* fall through */
  case FIOBJ_T_FLOAT: /* fall through */ return a == b;
  case FIOBJ_T_STRING:
    return FIO_NAME_BL(FIO_NAME(fiobj, FIOBJ___NAME_STRING), eq)(a, b);
  case FIOBJ_T_ARRAY: return fiobj___test_eq_nested(a, b, 0);
  case FIOBJ_T_HASH: return fiobj___test_eq_nested(a, b, 0);
  case FIOBJ_T_OTHER:
    if ((*fiobj_object_metadata(a))->count(a) ||
        (*fiobj_object_metadata(b))->count(b)) {
      if ((*fiobj_object_metadata(a))->count(a) !=
          (*fiobj_object_metadata(b))->count(b))
        return 0;
      return fiobj___test_eq_nested(a, b, 0);
    }
    return (*fiobj_object_metadata(a))->type_id ==
               (*fiobj_object_metadata(b))->type_id &&
           (*fiobj_object_metadata(a))->is_eq(a, b);
  }
  return 0;
}

/** Returns a temporary String representation for any FIOBJ object. */
FIO_IFUNC fio_str_info_s FIO_NAME2(fiobj, cstr)(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    switch ((uintptr_t)(o)) {
    case FIOBJ_T_NULL: return FIO_STR_INFO2((char *)"null", 4);
    case FIOBJ_T_TRUE: return FIO_STR_INFO2((char *)"true", 4);
    case FIOBJ_T_FALSE: return FIO_STR_INFO2((char *)"false", 5);
    };
    return (fio_str_info_s){.buf = (char *)""};
  case FIOBJ_T_NUMBER:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), cstr)(o);
  case FIOBJ_T_FLOAT:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), cstr)(o);
  case FIOBJ_T_STRING:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), info)(o);
  case FIOBJ_T_ARRAY: /* fall through */
    return FIO_STR_INFO2((char *)"[...]", 5);
  case FIOBJ_T_HASH: {
    return FIO_STR_INFO2((char *)"{...}", 5);
  }
  case FIOBJ_T_OTHER: return (*fiobj_object_metadata(o))->to_s(o);
  }
  /* a non-explicit NULL is an empty string. */
  return (fio_str_info_s){.buf = (char *)""};
}

/** Returns an integer representation for any FIOBJ object. */
FIO_IFUNC intptr_t FIO_NAME2(fiobj, i)(FIOBJ o) {
  fio_str_info_s tmp;
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    switch ((uintptr_t)(o)) {
    case FIOBJ_T_NULL: return 0;
    case FIOBJ_T_TRUE: return 1;
    case FIOBJ_T_FALSE: return 0;
    };
    return -1;
  case FIOBJ_T_NUMBER:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(o);
  case FIOBJ_T_FLOAT:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), i)(o);
  case FIOBJ_T_STRING:
    tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), info)(o);
    if (!tmp.len)
      return 0;
    return fio_atol(&tmp.buf);
  case FIOBJ_T_ARRAY:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
  case FIOBJ_T_HASH:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
  case FIOBJ_T_OTHER: return (*fiobj_object_metadata(o))->to_i(o);
  }
  if (!o)
    return 0;
  return -1;
}

/** Returns a float (double) representation for any FIOBJ object. */
FIO_IFUNC double FIO_NAME2(fiobj, f)(FIOBJ o) {
  fio_str_info_s tmp;
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    switch ((uintptr_t)(o)) {
    case FIOBJ_T_FALSE: /* fall through */
    case FIOBJ_T_NULL: return 0.0;
    case FIOBJ_T_TRUE: return 1.0;
    };
    return -1.0;
  case FIOBJ_T_NUMBER:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), f)(o);
  case FIOBJ_T_FLOAT:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(o);
  case FIOBJ_T_STRING:
    tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), info)(o);
    if (!tmp.len)
      return 0;
    return (double)fio_atof(&tmp.buf);
  case FIOBJ_T_ARRAY:
    return (double)FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
  case FIOBJ_T_HASH:
    return (double)FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
  case FIOBJ_T_OTHER: return (*fiobj_object_metadata(o))->to_f(o);
  }
  if (!o)
    return 0.0;
  return -1.0;
}

/* *****************************************************************************
FIOBJ Integers
***************************************************************************** */

#define FIO_REF_NAME     fiobj___bignum
#define FIO_REF_TYPE     intptr_t
#define FIO_REF_METADATA const FIOBJ_class_vtable_s *
#define FIO_REF_METADATA_INIT(m)                                               \
  do {                                                                         \
    m = &FIOBJ___NUMBER_CLASS_VTBL;                                            \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#define FIO_REF_METADATA_DESTROY(m)                                            \
  do {                                                                         \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_PTR_TAG(p)          FIOBJ_PTR_TAG(p, FIOBJ_T_OTHER)
#define FIO_PTR_UNTAG(p)        FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_VALIDATE(p) (FIOBJ_TYPE_CLASS(p) == FIOBJ_T_OTHER)
#define FIO_PTR_TAG_TYPE        FIOBJ
#include FIO_INCLUDE_FILE

/* Places a 61 or 29 bit signed integer in the leftmost bits of a word. */
#define FIO_NUMBER_ENCODE(i) (((uintptr_t)(i) << 3) | FIOBJ_T_NUMBER)
/* Reads a 61 or 29 bit signed integer from the leftmost bits of a word. */
#define FIO_NUMBER_DECODE(i)                                                   \
  ((intptr_t)(((uintptr_t)(i) >> 3) |                                          \
              ((uintptr_t)0 -                                                  \
               (((uintptr_t)(i) >> 3) &                                        \
                ((uintptr_t)1 << ((sizeof(uintptr_t) * 8) - 4))))))

/** Creates a new Number object. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER),
                         new)(intptr_t i) {
  FIOBJ o = (FIOBJ)FIO_NUMBER_ENCODE(i);
  if (FIO_NUMBER_DECODE(o) == i)
    return o;
  o = fiobj___bignum_new2();

  FIO_PTR_MATH_RMASK(intptr_t, o, 3)[0] = i;
  return o;
}

/** Reads the number from a FIOBJ number. */
FIO_IFUNC intptr_t FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(FIOBJ i) {
  if (FIOBJ_TYPE_CLASS(i) == FIOBJ_T_NUMBER)
    return FIO_NUMBER_DECODE(i);
  if (FIOBJ_TYPE_CLASS(i) == FIOBJ_T_OTHER)
    return FIO_PTR_MATH_RMASK(intptr_t, i, 3)[0];
  return 0;
}

/** Reads the number from a FIOBJ number, fitting it in a double. */
FIO_IFUNC double FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), f)(FIOBJ i) {
  return (double)FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(i);
}

/** Frees a FIOBJ number. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), free)(FIOBJ i) {
  if (FIOBJ_TYPE_CLASS(i) == FIOBJ_T_OTHER)
    fiobj___bignum_free2(i);
}

FIO_IFUNC unsigned char FIO_NAME_BL(fiobj___num, eq)(FIOBJ restrict a,
                                                     FIOBJ restrict b) {
  /* it should be safe to assume that FIOBJ_TYPE_CLASS(i) != FIOBJ_T_NUMBER */
  return FIO_PTR_MATH_RMASK(intptr_t, a, 3)[0] ==
         FIO_PTR_MATH_RMASK(intptr_t, b, 3)[0];
  // return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(a) ==
  //        FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(b);
}

#undef FIO_NUMBER_ENCODE
#undef FIO_NUMBER_DECODE

/* *****************************************************************************
FIOBJ Floats
***************************************************************************** */

#define FIO_REF_NAME     fiobj___bigfloat
#define FIO_REF_TYPE     double
#define FIO_REF_METADATA const FIOBJ_class_vtable_s *
#define FIO_REF_METADATA_INIT(m)                                               \
  do {                                                                         \
    m = &FIOBJ___FLOAT_CLASS_VTBL;                                             \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#define FIO_REF_METADATA_DESTROY(m)                                            \
  do {                                                                         \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_PTR_TAG(p)          FIOBJ_PTR_TAG(p, FIOBJ_T_OTHER)
#define FIO_PTR_UNTAG(p)        FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_VALIDATE(p) (FIOBJ_TYPE_CLASS(p) == FIOBJ_T_OTHER)
#define FIO_PTR_TAG_TYPE        FIOBJ
#include FIO_INCLUDE_FILE

/** Creates a new Float object. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), new)(double i) {
  FIOBJ ui;
  if (sizeof(double) <= sizeof(FIOBJ)) {
    union {
      double d;
      uintptr_t i;
    } punned;
    punned.i = 0; /* dead code, but leave it, just in case */
    punned.d = i;
    if ((punned.i & 7) == 0) {
      return (FIOBJ)(punned.i | FIOBJ_T_FLOAT);
    }
  }
  ui = fiobj___bigfloat_new2();

  FIO_PTR_MATH_RMASK(double, ui, 3)[0] = i;
  return ui;
}

/** Reads the integer part from a FIOBJ Float. */
FIO_IFUNC intptr_t FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), i)(FIOBJ i) {
  return (intptr_t)floor(FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(i));
}

/** Reads the number from a FIOBJ number, fitting it in a double. */
FIO_IFUNC double FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(FIOBJ i) {
  if (sizeof(double) <= sizeof(FIOBJ) && FIOBJ_TYPE_CLASS(i) == FIOBJ_T_FLOAT) {
    union {
      double d;
      uint64_t i;
    } punned;
    punned.d = 0; /* dead code, but leave it, just in case */
    punned.i = (uint64_t)(uintptr_t)i;
    punned.i = ((uint64_t)(uintptr_t)i & (~(uintptr_t)7ULL));
    return punned.d;
  }
  if (FIOBJ_TYPE_CLASS(i) == FIOBJ_T_OTHER)
    return FIO_PTR_MATH_RMASK(double, i, 3)[0];
  return 0.0;
}

/** Frees a FIOBJ number. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), free)(FIOBJ i) {
  if (FIOBJ_TYPE_CLASS(i) == FIOBJ_T_OTHER)
    fiobj___bigfloat_free2(i);
  return;
}

/* *****************************************************************************
FIOBJ Basic Iteration
***************************************************************************** */

/**
 * Performs a task for each element held by the FIOBJ object.
 *
 * If `task` returns -1, the `each` loop will break (stop).
 *
 * Returns the "stop" position - the number of elements processed + `start_at`.
 */
FIO_SFUNC uint32_t fiobj_each1(FIOBJ o,
                               int (*task)(fiobj_each_s *e),
                               void *udata,
                               int32_t start_at) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_STRING:    /* fall through */
  case FIOBJ_T_FLOAT: return 0;
  case FIOBJ_T_ARRAY:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), each)(
        o,
        (int (*)(FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), each_s *)))task,
        udata,
        start_at);
  case FIOBJ_T_HASH:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), each)(
        o,
        (int (*)(FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), each_s *)))task,
        udata,
        start_at);
  case FIOBJ_T_OTHER:
    return (*fiobj_object_metadata(o))->each1(o, task, udata, start_at);
  }
  return 0;
}

/* *****************************************************************************
FIOBJ Hash Maps
***************************************************************************** */

/** Calculates an object's hash value for a specific hash map object. */
FIO_IFUNC uint64_t FIO_NAME2(fiobj, hash)(FIOBJ o) {
  uint64_t seed = (uint64_t)(uintptr_t)&FIO_NAME2(fiobj, hash);
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    return fio_risky_hash(&o, sizeof(o), seed + (uintptr_t)o);
  case FIOBJ_T_NUMBER: {
    uintptr_t tmp = FIO_NAME2(fiobj, i)(o);
    return fio_risky_hash(&tmp, sizeof(tmp), seed);
  }
  case FIOBJ_T_FLOAT: {
    double tmp = FIO_NAME2(fiobj, f)(o);
    return fio_risky_hash(&tmp, sizeof(tmp), seed);
  }
  case FIOBJ_T_STRING: /* fall through */
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), hash)(o, seed);
  case FIOBJ_T_ARRAY: {
    uint64_t h = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
    h += fio_risky_hash(&h, sizeof(h), seed + FIOBJ_T_ARRAY);
    {
      FIOBJ *a = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), ptr)(o);
      const size_t count =
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
      if (a) {
        for (size_t i = 0; i < count; ++i) {
          h += FIO_NAME2(fiobj, hash)(a[i]);
        }
      }
    }
    return h;
  }
  case FIOBJ_T_HASH: {
    uint64_t h = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
    h += fio_risky_hash(&h, sizeof(h), seed + FIOBJ_T_HASH);
    FIO_MAP_EACH(FIO_NAME(fiobj, FIOBJ___NAME_HASH), o, i) {
      h += i.hash;
      h += FIO_NAME2(fiobj, hash)(i.value);
    }
    return h;
  }
  case FIOBJ_T_OTHER: {
    /* TODO: can we avoid "stringifying" the object? */
    fio_str_info_s tmp = (*fiobj_object_metadata(o))->to_s(o);
    return fio_risky_hash(tmp.buf, tmp.len, seed);
  }
  }
  return 0;
}

/**
 * Sets a String value in a hash map, allocating the String and automatically
 * calculating the hash value.
 */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         set2)(FIOBJ hash,
                               const char *key,
                               size_t len,
                               FIOBJ value) {
  FIOBJ tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(tmp, (char *)key, len);
  FIOBJ v =
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), set)(hash, tmp, value, NULL);
  fiobj_free(tmp);
  return v;
}

/**
 * Finds a String value in a hash map, using a temporary String and
 * automatically calculating the hash value.
 */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         get2)(FIOBJ hash, const char *buf, size_t len) {
  if (FIOBJ_TYPE_CLASS(hash) != FIOBJ_T_HASH)
    return FIOBJ_INVALID;
  FIOBJ_STR_TEMP_VAR_STATIC(tmp, buf, len);
  FIOBJ v = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get)(hash, tmp);
  return v;
}

/**
 * Removes a String value in a hash map, using a temporary String and
 * automatically calculating the hash value.
 */
FIO_IFUNC int FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                       remove2)(FIOBJ hash,
                                const char *buf,
                                size_t len,
                                FIOBJ *old) {
  FIOBJ_STR_TEMP_VAR_STATIC(tmp, buf, len);
  int r = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), remove)(hash, tmp, old);
  FIOBJ_STR_TEMP_DESTROY(tmp);
  return r;
}

/** Updates a hash using information from another Hash. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), update)(FIOBJ dest,
                                                                    FIOBJ src) {
  if (FIOBJ_TYPE_CLASS(dest) != FIOBJ_T_HASH ||
      FIOBJ_TYPE_CLASS(src) != FIOBJ_T_HASH)
    return;
  FIO_MAP_EACH(FIO_NAME(fiobj, FIOBJ___NAME_HASH), src, i) {
    if (i.key == FIOBJ_INVALID || FIOBJ_TYPE_CLASS(i.key) == FIOBJ_T_NULL) {
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), remove)(dest, i.key, NULL);
      continue;
    }
    register FIOBJ tmp;
    switch (FIOBJ_TYPE_CLASS(i.value)) {
    case FIOBJ_T_ARRAY:
      /* TODO? decide if we should merge elements or overwrite...? */
      tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get)(dest, i.key);
      if (FIOBJ_TYPE_CLASS(tmp) == FIOBJ_T_ARRAY) {
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), concat)
        (tmp, i.value);
        continue;
      }
      break;
    case FIOBJ_T_HASH:
      tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get)(dest, i.key);
      if (FIOBJ_TYPE_CLASS(tmp) == FIOBJ_T_HASH)
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), update)
      (dest, i.value);
      else break;
      continue;
    case FIOBJ_T_NUMBER:    /* fall through */
    case FIOBJ_T_PRIMITIVE: /* fall through */
    case FIOBJ_T_STRING:    /* fall through */
    case FIOBJ_T_FLOAT:     /* fall through */
    case FIOBJ_T_OTHER: break;
    }
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), set)
    (dest, i.key, fiobj_dup(i.value), NULL);
  }
}

/* *****************************************************************************
FIOBJ JSON support (inline functions)
***************************************************************************** */

typedef struct {
  FIOBJ json;
  size_t level;
  uint8_t beautify;
} fiobj___json_format_internal__s;

/* internal helper function for recursive JSON formatting. */
SFUNC void fiobj___json_format_internal__(fiobj___json_format_internal__s *,
                                          FIOBJ);

/** Helper function, calls `fiobj_hash_update_json` with string information */
FIO_IFUNC size_t FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                          update_json2)(FIOBJ hash, char *ptr, size_t len) {
  return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                  update_json)(hash, FIO_STR_INFO2(ptr, len));
}

/**
 * Returns a JSON valid FIOBJ String, representing the object.
 *
 * If `dest` is an existing String, the formatted JSON data will be appended to
 * the existing string.
 */
FIO_IFUNC FIOBJ FIO_NAME2(fiobj, json)(FIOBJ dest, FIOBJ o, uint8_t beautify) {
  fiobj___json_format_internal__s args =
      (fiobj___json_format_internal__s){.json = dest, .beautify = beautify};
  if (FIOBJ_TYPE_CLASS(dest) != FIOBJ_T_STRING)
    args.json = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  fiobj___json_format_internal__(&args, o);
  return args.json;
}

#undef FIO___RECURSIVE_INCLUDE /* from now on, type helpers are internal */

/* *****************************************************************************
FIOBJ Mustache support - inline implementation
***************************************************************************** */

/* callback should write `txt` to output and return updated `udata.` */
FIO_SFUNC void *fiobj___mustache_write_text(void *udata, fio_buf_info_s txt);
/* same as `write_text`, but should also  HTML escape (sanitize) data. */
FIO_SFUNC void *fiobj___mustache_write_text_escaped(void *udata,
                                                    fio_buf_info_s raw);
/* callback should return a new context pointer with the value of `name`. */
FIO_SFUNC void *fiobj___mustache_get_var(void *ctx, fio_buf_info_s name);
/* if context is an Array, should return its length. */
FIO_SFUNC size_t fiobj___mustache_array_length(void *ctx);
/* if context is an Array, should return a context pointer @ index. */
FIO_SFUNC void *fiobj___mustache_get_var_index(void *ctx, size_t index);
/* should return the String value of context `var` as a `fio_buf_info_s`. */
FIO_SFUNC fio_buf_info_s fiobj___mustache_var2str(void *var);
/* should return non-zero if the context pointer refers to a valid value. */
FIO_SFUNC int fiobj___mustache_var_is_truthful(void *ctx);

/**
 * Builds a Mustache template using a FIOBJ context (usually a Hash).
 *
 * Returns a FIOBJ String with the rendered template. May return `FIOBJ_INVALID`
 * if nothing was written.
 */
FIO_IFUNC FIOBJ fiobj_mustache_build(fio_mustache_s *m, FIOBJ ctx) {
  return (FIOBJ)fio_mustache_build(
      m,
      .write_text = fiobj___mustache_write_text,
      .write_text_escaped = fiobj___mustache_write_text_escaped,
      .get_var = fiobj___mustache_get_var,
      .array_length = fiobj___mustache_array_length,
      .get_var_index = fiobj___mustache_get_var_index,
      .var2str = fiobj___mustache_var2str,
      .var_is_truthful = fiobj___mustache_var_is_truthful,
      .ctx = ctx,
      .udata = NULL);
}

/**
 * Builds a Mustache template using a FIOBJ context (usually a Hash).
 *
 * Writes output to `dest` string (may be `FIOBJ_INVALID` / `NULL`).
 *
 * Returns `dest` (or a new String). May return `FIOBJ_INVALID` if nothing was
 * written and `dest` was empty.
 */
FIO_IFUNC FIOBJ fiobj_mustache_build2(fio_mustache_s *m,
                                      FIOBJ dest,
                                      FIOBJ ctx) {
  dest = (FIOBJ)fio_mustache_build(
      m,
      .write_text = fiobj___mustache_write_text,
      .write_text_escaped = fiobj___mustache_write_text_escaped,
      .get_var = fiobj___mustache_get_var,
      .array_length = fiobj___mustache_array_length,
      .get_var_index = fiobj___mustache_get_var_index,
      .var2str = fiobj___mustache_var2str,
      .var_is_truthful = fiobj___mustache_var_is_truthful,
      .ctx = ctx,
      .udata = dest);
  return dest;
}

/* callback should write `txt` to output and return updated `udata.` */
FIO_SFUNC void *fiobj___mustache_write_text(void *udata, fio_buf_info_s txt) {
  FIOBJ d = (FIOBJ)udata;
  if (!d)
    d = fiobj_str_new_buf(txt.len + 32);
  fiobj_str_write(d, txt.buf, txt.len);
  return (void *)d;
}
/* same as `write_text`, but should also  HTML escape (sanitize) data. */
FIO_SFUNC void *fiobj___mustache_write_text_escaped(void *ud,
                                                    fio_buf_info_s raw) {
  FIOBJ d = (FIOBJ)ud;
  if (!d)
    d = fiobj_str_new_buf(raw.len + 32);
  fiobj_str_write_html_escape(d, raw.buf, raw.len);
  return (void *)d;
}
/* callback should return a new context pointer with the value of `name`. */
FIO_SFUNC void *fiobj___mustache_get_var(void *ctx, fio_buf_info_s name) {
  if (!ctx)
    return NULL;
  if (!FIOBJ_TYPE_IS((FIOBJ)ctx, FIOBJ_T_HASH))
    return NULL;
  return fiobj_hash_get2((FIOBJ)ctx, name.buf, name.len);
}
/* if context is an Array, should return its length. */
FIO_SFUNC size_t fiobj___mustache_array_length(void *ctx) {
  if (!FIOBJ_TYPE_IS((FIOBJ)ctx, FIOBJ_T_ARRAY))
    return 0;
  return fiobj_array_count((FIOBJ)ctx);
}
/* if context is an Array, should return a context pointer @ index. */
FIO_SFUNC void *fiobj___mustache_get_var_index(void *ctx, size_t index) {
  if (!FIOBJ_TYPE_IS((FIOBJ)ctx, FIOBJ_T_ARRAY) || index > 0xFFFFFFFFUL)
    return NULL;
  return fiobj_array_get((FIOBJ)ctx, (uint32_t)index);
}
/* should return the String value of context `var` as a `fio_buf_info_s`. */
FIO_SFUNC fio_buf_info_s fiobj___mustache_var2str(void *var) {
  fio_buf_info_s r = {0};
  if (!var || var == fiobj_null())
    return r;
  fio_str_info_s tmp = fiobj2cstr((FIOBJ)var);
  r = FIO_STR2BUF_INFO(tmp);
  return r;
}
/* should return non-zero if the context pointer refers to a valid value. */
FIO_SFUNC int fiobj___mustache_var_is_truthful(void *v) {
  return v && (FIOBJ)v != fiobj_null() && (FIOBJ)v != fiobj_false() &&
         (!FIOBJ_TYPE_IS((FIOBJ)v, FIOBJ_T_ARRAY) ||
          fiobj_array_count((FIOBJ)v));
}

/* *****************************************************************************


FIOBJ - Externed Implementation


***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
FIOBJ Basic Object vtable
***************************************************************************** */

FIOBJ_EXTERN_OBJ_IMP const FIOBJ_class_vtable_s FIOBJ___OBJECT_CLASS_VTBL = {
    .type_id = 99, /* type IDs below 100 are reserved. */
};

/* *****************************************************************************
FIOBJ Complex Iteration
***************************************************************************** */
typedef struct {
  FIOBJ obj;
  size_t pos;
} fiobj___stack_element_s;

#define FIO_ARRAY_NAME fiobj___active_stack
#define FIO_ARRAY_TYPE fiobj___stack_element_s
#define FIO_ARRAY_COPY(dest, src)                                              \
  do {                                                                         \
    (dest).obj = fiobj_dup((src).obj);                                         \
    (dest).pos = (src).pos;                                                    \
  } while (0)
#define FIO_ARRAY_TYPE_CMP(a, b) (a).obj == (b).obj
#define FIO_ARRAY_DESTROY(o)     fiobj_free(o)
#define FIO___RECURSIVE_INCLUDE  1
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

#define FIO_ARRAY_TYPE_CMP(a, b) (a).obj == (b).obj
#define FIO_ARRAY_NAME           fiobj___stack
#define FIO_ARRAY_TYPE           fiobj___stack_element_s
#define FIO___RECURSIVE_INCLUDE  1
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

typedef struct {
  int (*task)(fiobj_each_s *info);
  void *arg;
  FIOBJ next;
  size_t count;
  fiobj___stack_s stack;
  uint32_t end;
  uint8_t stop;
} fiobj_____each2_data_s;

FIO_SFUNC uint32_t fiobj____each2_element_count(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_STRING:    /* fall through */
  case FIOBJ_T_FLOAT: return 0;
  case FIOBJ_T_ARRAY:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
  case FIOBJ_T_HASH:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
  case FIOBJ_T_OTHER: /* fall through */
    return (*fiobj_object_metadata(o))->count(o);
  }
  return 0;
}
FIO_SFUNC int fiobj____each2_wrapper_task(fiobj_each_s *e) {
  fiobj_____each2_data_s *d = (fiobj_____each2_data_s *)e->udata;
  e->task = d->task;
  e->udata = d->arg;
  d->stop = (d->task(e) == -1);
  d->task = e->task;
  d->arg = e->udata;
  e->task = fiobj____each2_wrapper_task;
  e->udata = d;
  ++d->count;
  if (d->stop)
    return -1;
  uint32_t c = fiobj____each2_element_count(e->value);
  if (c) {
    d->next = e->value;
    d->end = c;
    return -1;
  }
  return 0;
}

/**
 * Performs a task for the object itself and each element held by the FIOBJ
 * object or any of it's elements (a deep task).
 *
 * The order of performance is by order of appearance, as if all nesting levels
 * were flattened.
 *
 * If `task` returns -1, the `each` loop will break (stop).
 *
 * Returns the number of elements processed.
 */
SFUNC uint32_t fiobj_each2(FIOBJ o, int (*task)(fiobj_each_s *), void *udata) {
  /* TODO - move to recursion with nesting limiter? */
  fiobj_____each2_data_s d = {
      .task = task,
      .arg = udata,
      .next = FIOBJ_INVALID,
      .stack = FIO_ARRAY_INIT,
  };
  struct FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), each_s) e_tmp = {

      .parent = FIOBJ_INVALID,
      .task = (int (*)(FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                                each_s) *))fiobj____each2_wrapper_task,
      .udata = &d,
      .value = o,
  };
  fiobj___stack_element_s i = {.obj = o, .pos = 0};
  uint32_t end = fiobj____each2_element_count(o);
  fiobj____each2_wrapper_task((fiobj_each_s *)&e_tmp);
  while (!d.stop && i.obj && i.pos < end) {
    i.pos =
        fiobj_each1(i.obj, fiobj____each2_wrapper_task, &d, (uint32_t)i.pos);
    if (d.next != FIOBJ_INVALID) {
      if (fiobj___stack_count(&d.stack) + 1 > FIOBJ_MAX_NESTING) {
        FIO_LOG_ERROR("FIOBJ nesting level too deep (%u)."
                      "`fiobj_each2` stopping loop early.",
                      (unsigned int)fiobj___stack_count(&d.stack));
        d.stop = 1;
        continue;
      }
      fiobj___stack_push(&d.stack, i);
      i.pos = 0;
      i.obj = d.next;
      d.next = FIOBJ_INVALID;
      end = d.end;
    } else {
      /* re-collect end position to accommodate for changes */
      end = fiobj____each2_element_count(i.obj);
    }
    while (i.pos >= end && fiobj___stack_count(&d.stack)) {
      fiobj___stack_pop(&d.stack, &i);
      end = fiobj____each2_element_count(i.obj);
    }
  };
  fiobj___stack_destroy(&d.stack);
  return (uint32_t)d.count;
}

/* *****************************************************************************
FIOBJ Hash / Array / Other (enumerable) Equality test.
***************************************************************************** */

/** Internal: compares two nestable objects. */
SFUNC unsigned char fiobj___test_eq_nested(FIOBJ restrict a,
                                           FIOBJ restrict b,
                                           size_t nesting) {
  if (a == b)
    return 1;
  if (FIOBJ_TYPE_CLASS(a) != FIOBJ_TYPE_CLASS(b))
    return 0;
  if (fiobj____each2_element_count(a) != fiobj____each2_element_count(b))
    return 0;
  if (nesting >= FIOBJ_MAX_NESTING)
    return 0;

  ++nesting;

  switch (FIOBJ_TYPE_CLASS(a)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_FLOAT: return a == b;
  case FIOBJ_T_STRING:
    return FIO_NAME_BL(FIO_NAME(fiobj, FIOBJ___NAME_STRING), eq)(a, b);

  case FIOBJ_T_ARRAY:
    if (!fiobj____each2_element_count(a))
      return 1;
    /* test each array member with matching index */
    {
      const size_t count = fiobj____each2_element_count(a);
      for (size_t i = 0; i < count; ++i) {
        if (!fiobj___test_eq_nested(
                FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(a,
                                                                   (int32_t)i),
                FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(b,
                                                                   (int32_t)i),
                nesting))
          return 0;
      }
    }
    return 1;

  case FIOBJ_T_HASH:
    if (!fiobj____each2_element_count(a))
      return 1;
    FIO_MAP_EACH(FIO_NAME(fiobj, FIOBJ___NAME_HASH), a, pos) {
      FIOBJ val = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get)(b, pos.key);
      if (!fiobj___test_eq_nested(val, pos.value, nesting))
        return 0;
    }
    return 1;
  case FIOBJ_T_OTHER:
    if (!fiobj____each2_element_count(a) &&
        (*fiobj_object_metadata(a))->is_eq(a, b))
      return 1;
    /* TODO: iterate through objects and test equality within nesting */
    return (*fiobj_object_metadata(a))->is_eq(a, b);
    return 1;
  }
  return 0;
}

/* *****************************************************************************
FIOBJ general helpers
***************************************************************************** */

FIO_SFUNC uint32_t fiobj___count_noop(FIOBJ o) {
  return 0;
  (void)o;
}

/* *****************************************************************************
FIOBJ Integers (bigger numbers)
***************************************************************************** */

SFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER),
                               cstr)(FIOBJ i) {
  static char buf[32 * 128];
  static uint8_t pos = 0;
  size_t at = fio_atomic_add(&pos, 1);
  fio_str_info_s s = {.buf = buf + ((at & 127) << 5), .capa = 31};
  fio_string_write_i(&s,
                     NULL,
                     FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(i));
  return s;
}

FIOBJ_EXTERN_OBJ_IMP const FIOBJ_class_vtable_s FIOBJ___NUMBER_CLASS_VTBL = {
    /**
     * MUST return a unique number to identify object type.
     *
     * Numbers (IDs) under 100 are reserved.
     */
    .type_id = FIOBJ_T_NUMBER,
    /** Test for equality between two objects with the same `type_id` */
    .is_eq = FIO_NAME_BL(fiobj___num, eq),
    /** Converts an object to a String */
    .to_s = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), cstr),
    /** Converts and object to an integer */
    .to_i = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i),
    /** Converts and object to a float */
    .to_f = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), f),
    /** Returns the number of exposed elements held by the object, if any. */
    .count = fiobj___count_noop,
    /** Iterates the exposed elements held by the object. See `fiobj_each1`. */
    .each1 = NULL,
    /** Deallocates the element (but NOT any of it's exposed elements). */
    .free2 = fiobj___bignum_free2,
};

/* *****************************************************************************
FIOBJ Floats (bigger / smaller doubles)
***************************************************************************** */

FIO_SFUNC unsigned char FIO_NAME_BL(fiobj___float, eq)(FIOBJ restrict a,
                                                       FIOBJ restrict b) {
  unsigned char r = 0;
  union {
    uint64_t u;
    double f;
  } da, db;
  da.f = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(a);
  db.f = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(b);
  /* regular equality? */
  r |= da.f == db.f;
  /* test for small rounding errors (4 bit difference) on normalize floats */
  r |= !((da.u ^ db.u) & UINT64_C(0xFFFFFFFFFFFFFFF0)) &&
       (da.u & UINT64_C(0x7FF0000000000000));
  /* test for small ULP: */
  r |= (((da.u > db.u) ? da.u - db.u : db.u - da.u) < 2);
  /* test for +-0 */
  r |= !((da.u | db.u) & UINT64_C(0x7FFFFFFFFFFFFFFF));
  return r;
}

SFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT),
                               cstr)(FIOBJ i) {
  static char buf[32 * 128];
  static uint8_t pos = 0;
  size_t at = fio_atomic_add(&pos, 1);
  char *tmp = buf + ((at & 127) << 5);
  size_t len =
      fio_ftoa(tmp, FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(i), 10);
  tmp[len] = 0;
  return FIO_STR_INFO2(tmp, len);
}

FIOBJ_EXTERN_OBJ_IMP const FIOBJ_class_vtable_s FIOBJ___FLOAT_CLASS_VTBL = {
    /**
     * MUST return a unique number to identify object type.
     *
     * Numbers (IDs) under 100 are reserved.
     */
    .type_id = FIOBJ_T_FLOAT,
    /** Test for equality between two objects with the same `type_id` */
    .is_eq = FIO_NAME_BL(fiobj___float, eq),
    /** Converts an object to a String */
    .to_s = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), cstr),
    /** Converts and object to an integer */
    .to_i = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), i),
    /** Converts and object to a float */
    .to_f = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f),
    /** Returns the number of exposed elements held by the object, if any. */
    .count = fiobj___count_noop,
    /** Iterates the exposed elements held by the object. See `fiobj_each1`. */
    .each1 = NULL,
    /** Deallocates the element (but NOT any of it's exposed elements). */
    .free2 = fiobj___bigfloat_free2,
};

/* *****************************************************************************
FIOBJ JSON support - output
***************************************************************************** */

FIO_IFUNC void fiobj___json_format_internal_beauty_pad(FIOBJ json,
                                                       size_t level) {
  size_t pos = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(json);
  fio_str_info_s tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                                resize)(json, (level << 1) + pos + 2);
  tmp.buf[pos++] = '\r';
  tmp.buf[pos++] = '\n';
  for (size_t i = 0; i < level; ++i) {
    tmp.buf[pos++] = ' ';
    tmp.buf[pos++] = ' ';
  }
}

SFUNC void fiobj___json_format_internal__(fiobj___json_format_internal__s *args,
                                          FIOBJ o) {
  switch (FIOBJ_TYPE(o)) {
  case FIOBJ_T_TRUE:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
    (args->json, "true", 4);
    return;
  case FIOBJ_T_FALSE:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
    (args->json, "false", 5);
    return;
  case FIOBJ_T_NULL:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
    (args->json, "null", 4);
    return;
  case FIOBJ_T_NUMBER:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_i)
    (args->json, FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(o));
    return;
  case FIOBJ_T_FLOAT: {
    char tmp_buf[256];
    size_t len = fio_ftoa(tmp_buf,
                          FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(o),
                          10);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
    (args->json, tmp_buf, len);
    return;
  }
  case FIOBJ_T_STRING: /* fall through */
  default: {
    fio_str_info_s info = FIO_NAME2(fiobj, cstr)(o);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(args->json, "\"", 1);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_escape)
    (args->json, info.buf, info.len);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(args->json, "\"", 1);
    return;
  }
  case FIOBJ_T_ARRAY:
    if (!FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o))
      goto empty_array;
    if (args->level == FIOBJ_MAX_NESTING)
      goto err_array_nesting;
    {
      ++args->level;
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(args->json, "[", 1);
      const uint32_t len =
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
      if (args->beautify) {
        fiobj___json_format_internal_beauty_pad(args->json, args->level);
      }
      fiobj___json_format_internal__(
          args,
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(o, 0));
      if (args->beautify) {
        for (size_t i = 1; i < len; ++i) {
          FIOBJ child =
              FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(o, i);
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
          (args->json, ",", 1);
          fiobj___json_format_internal_beauty_pad(args->json, args->level);
          fiobj___json_format_internal__(args, child);
        }
      } else {
        for (size_t i = 1; i < len; ++i) {
          FIOBJ child =
              FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(o, i);
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
          (args->json, ",", 1);
          fiobj___json_format_internal__(args, child);
        }
      }
      --args->level;
      if (args->beautify) {
        fiobj___json_format_internal_beauty_pad(args->json, args->level);
      }
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(args->json, "]", 1);
    }
    return;
  case FIOBJ_T_HASH:
    if (!FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o))
      goto empty_hash;
    if (args->level == FIOBJ_MAX_NESTING)
      goto err_hash_nesting;
    {
      size_t i = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
      (args->json, "{", 1);
      ++args->level;
      FIO_MAP_EACH(FIO_NAME(fiobj, FIOBJ___NAME_HASH), o, couplet) {
        if (args->beautify) {
          fiobj___json_format_internal_beauty_pad(args->json, args->level);
        }
        fio_str_info_s info = FIO_NAME2(fiobj, cstr)(couplet.key);
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
        (args->json, "\"", 1);
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_escape)
        (args->json, info.buf, info.len);
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
        (args->json, "\":", 2);
        fiobj___json_format_internal__(args, couplet.value);
        if (--i)
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
        (args->json, ",", 1);
      }
      --args->level;
      if (args->beautify) {
        fiobj___json_format_internal_beauty_pad(args->json, args->level);
      }
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
      (args->json, "}", 1);
    }
    return;
  }
empty_hash:
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
  (args->json, "{}", 2);
  return;
empty_array:
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
  (args->json, "[]", 2);
  return;
err_array_nesting:
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
  (args->json, "[ ]", 3);
  goto log_nesting_error;
err_hash_nesting:
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
  (args->json, "{ }", 3);
log_nesting_error:
  FIO_LOG_ERROR("JSON formatting truncated - nesting level too deep.");
}

/* *****************************************************************************
FIOBJ JSON parsing
***************************************************************************** */
#if 1

FIO_SFUNC void *fiobj___json_on_null(void) {
  return FIO_NAME(fiobj, FIOBJ___NAME_NULL)();
}
FIO_SFUNC void *fiobj___json_on_true(void) { return fiobj_true(); }
FIO_SFUNC void *fiobj___json_on_false(void) { return fiobj_false(); }
FIO_SFUNC void *fiobj___json_on_number(int64_t i) {
  return FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_NUMBER, new))(i);
}
FIO_SFUNC void *fiobj___json_on_float(double f) {
  return FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_FLOAT, new))(f);
}
FIO_SFUNC void *fiobj___json_on_string(const void *start, size_t len) {
  FIOBJ str = FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_STRING, new))();
  FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_STRING, write_unescape))
  (str, (const char *)start, len);
  return str;
}
FIO_SFUNC void *fiobj___json_on_string_simple(const void *start, size_t len) {
  FIOBJ str = FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_STRING, new))();
  FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_STRING, write))
  (str, (const char *)start, len);
  return str;
}
FIO_SFUNC void *fiobj___json_on_map(void *ctx, void *at) {
  FIOBJ m = FIOBJ_INVALID;
  if (ctx && at && FIOBJ_TYPE_CLASS(ctx) == FIOBJ_T_HASH)
    m = FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_HASH, get))((FIOBJ)ctx,
                                                          (FIOBJ)at);
  if (!m || m == FIOBJ_INVALID || FIOBJ_TYPE_CLASS(m) != FIOBJ_T_ARRAY)
    m = FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_HASH, new))();
  return m;
}
FIO_SFUNC void *fiobj___json_on_array(void *ctx, void *at) {
  FIOBJ m = FIOBJ_INVALID;
  if (ctx && at && FIOBJ_TYPE_CLASS(ctx) == FIOBJ_T_HASH)
    m = FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_HASH, get))((FIOBJ)ctx,
                                                          (FIOBJ)at);
  if (!m || m == FIOBJ_INVALID || FIOBJ_TYPE_CLASS(m) != FIOBJ_T_ARRAY)
    m = FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_ARRAY, new))();
  return m;
}
FIO_SFUNC int fiobj___json_map_push(void *ctx, void *key, void *value) {
  FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_HASH, set))
  ((FIOBJ)ctx, (FIOBJ)key, (FIOBJ)value, NULL);
  fiobj_free((FIOBJ)key);
  return 0;
}
FIO_SFUNC int fiobj___json_array_push(void *ctx, void *value) {
  FIO_NAME(fiobj, FIO_NAME(FIOBJ___NAME_ARRAY, push))((FIOBJ)ctx, (FIOBJ)value);
  return 0;
}
FIO_SFUNC void fiobj___json_free_unused_object(void *ctx) {
  fiobj_free((FIOBJ)ctx);
}
FIO_SFUNC void *fiobj___json_on_error(void *ctx) {
  fiobj_free((FIOBJ)ctx);
  return FIOBJ_INVALID;
}
static fio_json_parser_callbacks_s FIOBJ_JSON_PARSER_CALLBACKS = {
    .on_null = fiobj___json_on_null,
    .on_true = fiobj___json_on_true,
    .on_false = fiobj___json_on_false,
    .on_number = fiobj___json_on_number,
    .on_float = fiobj___json_on_float,
    .on_string = fiobj___json_on_string,
    .on_string_simple = fiobj___json_on_string_simple,
    .on_map = fiobj___json_on_map,
    .on_array = fiobj___json_on_array,
    .map_push = fiobj___json_map_push,
    .array_push = fiobj___json_array_push,
    .free_unused_object = fiobj___json_free_unused_object,
    .on_error = fiobj___json_on_error,
};

/** Returns a JSON valid FIOBJ String, representing the object. */
SFUNC FIOBJ fiobj_json_parse(fio_str_info_s str, size_t *consumed_p) {
  fio_json_result_s result =
      fio_json_parse(&FIOBJ_JSON_PARSER_CALLBACKS, str.buf, str.len);
  if (consumed_p)
    *consumed_p = result.stop_pos;
  if (result.err) {
#ifdef DEBUG
    FIOBJ s = FIO_NAME2(fiobj, json)(FIOBJ_INVALID, (FIOBJ)result.ctx, 0);
    FIO_LOG_DEBUG("JSON data being deleted:\n%s",
                  FIO_NAME2(fiobj, cstr)(s).buf);
    fiobj_free(s);
#endif
    fiobj_free((FIOBJ)result.ctx);
    result.ctx = FIOBJ_INVALID;
  }
  return (FIOBJ)result.ctx;
}

/**
 * Updates a Hash using JSON data.
 *
 * Parsing errors and non-dictionary object JSON data are silently ignored,
 * attempting to update the Hash as much as possible before any errors
 * encountered.
 *
 * Conflicting Hash data is overwritten (preferring the new over the old).
 *
 * Returns the number of bytes consumed. On Error, 0 is returned and no data is
 * consumed.
 */
SFUNC size_t FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                      update_json)(FIOBJ hash, fio_str_info_s str) {
  /* TODO! FIXME! this will leak memory on NULL hash and break on Arrays */
  fio_json_result_s result = fio_json_parse_update(&FIOBJ_JSON_PARSER_CALLBACKS,
                                                   hash,
                                                   str.buf,
                                                   str.len);
  // if (consumed_p)
  //   *consumed_p = result.stop_pos;
  if (result.err) {
#ifdef DEBUG
    FIOBJ s = FIO_NAME2(fiobj, json)(FIOBJ_INVALID, (FIOBJ)result.ctx, 0);
    FIO_LOG_DEBUG("JSON data being deleted:\n%s",
                  FIO_NAME2(fiobj, cstr)(s).buf);
    fiobj_free(s);
#endif
    fiobj_free((FIOBJ)result.ctx);
    result.ctx = FIOBJ_INVALID;
  }
  return result.stop_pos;
  FIO_LOG_ERROR("fiobj_hash_update_json note yet implemented");
  return 0;
  (void)str;
}

#else
#define FIO_JSON
#define FIO___RECURSIVE_INCLUDE 1
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

/* FIOBJ JSON parser */
typedef struct {
  fio_json_parser_s p;
  size_t so; /* stack offset */
  FIOBJ key;
  FIOBJ top;
  FIOBJ target;
  FIOBJ stack[JSON_MAX_DEPTH + 1];
} fiobj_json_parser_s;

static inline void fiobj_json_add2parser(fiobj_json_parser_s *p, FIOBJ o) {
  if (p->top) {
    if (FIOBJ_TYPE_CLASS(p->top) == FIOBJ_T_HASH) {
      if (p->key) {
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), set)
        (p->top, p->key, o, NULL);
        fiobj_free(p->key);
        p->key = FIOBJ_INVALID;
      } else {
        p->key = o;
      }
    } else {
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(p->top, o);
    }
  } else {
    p->top = o;
  }
}

/** a NULL object was detected */
static inline void fio_json_on_null(fio_json_parser_s *p) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p,
                        FIO_NAME(fiobj, FIOBJ___NAME_NULL)());
}
/** a TRUE object was detected */
static inline void fio_json_on_true(fio_json_parser_s *p) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p, fiobj_true());
}
/** a FALSE object was detected */
static inline void fio_json_on_false(fio_json_parser_s *p) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p, fiobj_false());
}
/** a Numeral was detected (long long). */
static inline void fio_json_on_number(fio_json_parser_s *p, long long i) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p,
                        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)(i));
}
/** a Float was detected (double). */
static inline void fio_json_on_float(fio_json_parser_s *p, double f) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p,
                        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), new)(f));
}
/** a String was detected (int / float). update `pos` to point at ending */
static inline void fio_json_on_string(fio_json_parser_s *p,
                                      const void *start,
                                      size_t len) {
  FIOBJ str = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_unescape)
  (str, start, len);
  fiobj_json_add2parser((fiobj_json_parser_s *)p, str);
}
/** a dictionary object was detected */
static inline int fio_json_on_start_object(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  if (pr->target) {
    /* push NULL, don't free the objects */
    pr->stack[pr->so++] = FIOBJ_INVALID;
    pr->top = pr->target;
    pr->target = FIOBJ_INVALID;
  } else {
    FIOBJ hash;
#if FIOBJ_JSON_APPEND
    hash = FIOBJ_INVALID;
    if (pr->key && FIOBJ_TYPE_CLASS(pr->top) == FIOBJ_T_HASH) {
      hash =
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get)(pr->top, pr->key);
    }
    if (FIOBJ_TYPE_CLASS(hash) != FIOBJ_T_HASH) {
      hash = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), new)();
      fiobj_json_add2parser(pr, hash);
    } else {
      fiobj_free(pr->key);
      pr->key = FIOBJ_INVALID;
    }
#else
    hash = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), new)();
    fiobj_json_add2parser(pr, hash);
#endif
    pr->stack[pr->so++] = pr->top;
    pr->top = hash;
  }
  return 0;
}
/** a dictionary object closure detected */
static inline void fio_json_on_end_object(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  if (pr->key) {
    FIO_LOG_WARNING("(JSON parsing) malformed JSON, "
                    "ignoring dangling Hash key.");
    fiobj_free(pr->key);
    pr->key = FIOBJ_INVALID;
  }
  pr->top = FIOBJ_INVALID;
  if (pr->so)
    pr->top = pr->stack[--pr->so];
}
/** an array object was detected */
static int fio_json_on_start_array(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  FIOBJ ary = FIOBJ_INVALID;
  if (pr->target != FIOBJ_INVALID) {
    if (FIOBJ_TYPE_CLASS(pr->target) != FIOBJ_T_ARRAY)
      return -1;
    ary = pr->target;
    pr->target = FIOBJ_INVALID;
  }
#if FIOBJ_JSON_APPEND
  if (pr->key && FIOBJ_TYPE_CLASS(pr->top) == FIOBJ_T_HASH) {
    ary = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get)(pr->top, pr->key);
  }
  if (FIOBJ_TYPE_CLASS(ary) != FIOBJ_T_ARRAY) {
    ary = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    fiobj_json_add2parser(pr, ary);
  } else {
    fiobj_free(pr->key);
    pr->key = FIOBJ_INVALID;
  }
#else
  FIOBJ ary = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
  fiobj_json_add2parser(pr, ary);
#endif

  pr->stack[pr->so++] = pr->top;
  pr->top = ary;
  return 0;
}
/** an array closure was detected */
static inline void fio_json_on_end_array(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  pr->top = FIOBJ_INVALID;
  if (pr->so)
    pr->top = pr->stack[--pr->so];
}
/** the JSON parsing is complete */
static void fio_json_on_json(fio_json_parser_s *p) {
  (void)p; /* nothing special... right? */
}
/** the JSON parsing is complete */
static inline void fio_json_on_error(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  fiobj_free(pr->stack[0]);
  fiobj_free(pr->key);
  *pr = (fiobj_json_parser_s){.top = FIOBJ_INVALID};
  FIO_LOG_DEBUG("JSON on_error callback called.");
}

/**
 * Updates a Hash using JSON data.
 *
 * Parsing errors and non-dictionary object JSON data are silently ignored,
 * attempting to update the Hash as much as possible before any errors
 * encountered.
 *
 * Conflicting Hash data is overwritten (preferring the new over the old).
 *
 * Returns the number of bytes consumed. On Error, 0 is returned and no data is
 * consumed.
 */
SFUNC size_t FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                      update_json)(FIOBJ hash, fio_str_info_s str) {
  if (hash == FIOBJ_INVALID)
    return 0;
  fiobj_json_parser_s p = {.top = FIOBJ_INVALID, .target = hash};
  size_t consumed = fio_json_parse(&p.p, str.buf, str.len);
  fiobj_free(p.key);
  if (p.top != hash)
    fiobj_free(p.top);
  return consumed;
}

/** Returns a JSON valid FIOBJ String, representing the object. */
SFUNC FIOBJ fiobj_json_parse(fio_str_info_s str, size_t *consumed_p) {
  fiobj_json_parser_s p = {.top = FIOBJ_INVALID};
  register const size_t consumed = fio_json_parse(&p.p, str.buf, str.len);
  if (consumed_p) {
    *consumed_p = consumed;
  }
  if (!consumed || p.p.depth) {
    if (p.top) {
      FIO_LOG_DEBUG("WARNING - JSON failed secondary validation, no on_error");
    }
#ifdef DEBUG
    FIOBJ s = FIO_NAME2(fiobj, json)(FIOBJ_INVALID, p.top, 0);
    FIO_LOG_DEBUG("JSON data being deleted:\n%s",
                  FIO_NAME2(fiobj, cstr)(s).buf);
    fiobj_free(s);
#endif
    fiobj_free(p.stack[0]);
    p.top = FIOBJ_INVALID;
  }
  fiobj_free(p.key);
  return p.top;
}
#endif

/** Uses JSON (JavaScript) notation to find data in an object structure. Returns
 * a temporary object. */
SFUNC FIOBJ fiobj_json_find(FIOBJ o, fio_str_info_s n) {
  for (;;) {
  top:
    if (!n.len || (n.len == 1 && n.buf[0] == '.'))
      return o;
    switch (FIOBJ_TYPE_CLASS(o)) {
    case FIOBJ_T_ARRAY: {
      if (n.len <= 2 || n.buf[0] != '[' || n.buf[1] < '0' || n.buf[1] > '9')
        return FIOBJ_INVALID;
      size_t i = 0;
      ++n.buf;
      --n.len;
      while (n.len && fio_c2i(n.buf[0]) < 10) {
        i = (i * 10) + fio_c2i(n.buf[0]);
        ++n.buf;
        --n.len;
      }
      if (!n.len || n.buf[0] != ']' || i > 0xFFFFFFFFU)
        return FIOBJ_INVALID;
      o = fiobj_array_get(o, (uint32_t)i);
      ++n.buf;
      --n.len;
      if (n.len) {
        if (n.buf[0] == '.') {
          ++n.buf;
          --n.len;
        } else if (n.buf[0] != '[') {
          return FIOBJ_INVALID;
        }
        continue;
      }
      return o;
    }
    case FIOBJ_T_HASH: {
      FIOBJ tmp = fiobj_hash_get2(o, n.buf, n.len);
      if (tmp != FIOBJ_INVALID)
        return tmp;
      char *end = n.buf + n.len - 1;
      while (end > n.buf) {
        while (end > n.buf && end[0] != '.' && end[0] != '[')
          --end;
        if (end == n.buf)
          return FIOBJ_INVALID;
        const size_t t_len = end - n.buf;
        tmp = fiobj_hash_get2(o, n.buf, t_len);
        if (tmp != FIOBJ_INVALID) {
          o = tmp;
          n.len -= t_len + (end[0] == '.');
          n.buf = end + (end[0] == '.');
          goto top;
        }
        --end;
      }
    } /* fall through */
    default: return FIOBJ_INVALID;
    }
  }
}
/* *****************************************************************************
FIOBJ cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIOBJ_EXTERN_OBJ
#undef FIOBJ_EXTERN_OBJ_IMP
#undef FIO_FIOBJ
#endif /* FIO_FIOBJ */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_PEM                /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                          PEM File Parser for TLS 1.3
                    (RFC 7468 - Textual Encodings of PKIX)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_PEM) && !defined(H___FIO_PEM___H)
#define H___FIO_PEM___H

/* *****************************************************************************
PEM Parser Module

This module provides PEM file parsing for loading X.509 certificates and
private keys from PEM-encoded files. It supports:

- Certificate parsing ("CERTIFICATE" label)
- PKCS#8 private keys ("PRIVATE KEY" label)
- Legacy RSA private keys ("RSA PRIVATE KEY" label - PKCS#1)
- Legacy EC private keys ("EC PRIVATE KEY" label - SEC1)

PEM format (RFC 7468):
  -----BEGIN <label>-----
  <base64-encoded DER data>
  -----END <label>-----

**Note**: This parser does not support encrypted private keys.
***************************************************************************** */

/* *****************************************************************************
PEM Type Definitions
***************************************************************************** */

/** Private key algorithm types */
typedef enum {
  FIO_PEM_KEY_UNKNOWN = 0,
  FIO_PEM_KEY_RSA = 1,
  FIO_PEM_KEY_ECDSA_P256 = 2,
  FIO_PEM_KEY_ED25519 = 3,
} fio_pem_key_type_e;

/** Parsed PEM block */
typedef struct {
  const uint8_t *der; /**< Pointer to decoded DER data */
  size_t der_len;     /**< Length of DER data */
  const char *label;  /**< PEM label (e.g., "CERTIFICATE", "PRIVATE KEY") */
  size_t label_len;   /**< Length of label */
} fio_pem_s;

/** Parsed private key structure */
typedef struct {
  fio_pem_key_type_e type;
  union {
    struct {
      const uint8_t *n; /**< RSA modulus (big-endian) */
      size_t n_len;
      const uint8_t *e; /**< RSA public exponent (big-endian) */
      size_t e_len;
      const uint8_t *d; /**< RSA private exponent (big-endian) */
      size_t d_len;
      const uint8_t *p; /**< RSA prime p (optional) */
      size_t p_len;
      const uint8_t *q; /**< RSA prime q (optional) */
      size_t q_len;
    } rsa;
    struct {
      uint8_t private_key[32]; /**< P-256 scalar (32 bytes) */
      uint8_t public_key[65];  /**< Uncompressed point (optional, can derive) */
      int has_public_key;      /**< 1 if public_key is populated */
    } ecdsa_p256;
    struct {
      uint8_t private_key[32]; /**< Ed25519 seed (32 bytes) */
      uint8_t public_key[32];  /**< Ed25519 public key (optional) */
      int has_public_key;      /**< 1 if public_key is populated */
    } ed25519;
  };
} fio_pem_private_key_s;

/* *****************************************************************************
PEM Parser API
***************************************************************************** */

/**
 * Parse a single PEM block from data.
 *
 * Finds the next -----BEGIN <label>----- and -----END <label>----- markers,
 * base64 decodes the content between them, and returns the DER data.
 *
 * @param out Output structure to fill with parsed PEM block info
 * @param der_buf Buffer to store decoded DER data (caller-provided)
 * @param der_buf_len Size of der_buf
 * @param pem_data PEM-encoded data
 * @param pem_len Length of PEM data
 * @return Number of bytes consumed from pem_data, or 0 on error
 */
SFUNC size_t fio_pem_parse(fio_pem_s *out,
                           uint8_t *der_buf,
                           size_t der_buf_len,
                           const char *pem_data,
                           size_t pem_len);

/**
 * Parse certificate from PEM file content.
 *
 * Handles "CERTIFICATE" label and parses the X.509 certificate.
 *
 * @param cert Output certificate structure (from fio_x509.h)
 * @param pem_data PEM-encoded certificate data
 * @param pem_len Length of PEM data
 * @return 0 on success, -1 on error
 */
SFUNC int fio_pem_parse_certificate(fio_x509_cert_s *cert,
                                    const char *pem_data,
                                    size_t pem_len);

/**
 * Parse private key from PEM file content.
 *
 * Supports:
 * - "PRIVATE KEY" (PKCS#8 PrivateKeyInfo)
 * - "RSA PRIVATE KEY" (PKCS#1 RSAPrivateKey)
 * - "EC PRIVATE KEY" (SEC1 ECPrivateKey)
 *
 * @param key Output private key structure
 * @param pem_data PEM-encoded private key data
 * @param pem_len Length of PEM data
 * @return 0 on success, -1 on error
 */
SFUNC int fio_pem_parse_private_key(fio_pem_private_key_s *key,
                                    const char *pem_data,
                                    size_t pem_len);

/**
 * Get the DER-encoded certificate from PEM data.
 *
 * This is a convenience function that extracts just the DER bytes
 * without parsing the X.509 structure.
 *
 * @param der_out Output buffer for DER data
 * @param der_out_len Size of output buffer
 * @param pem_data PEM-encoded certificate data
 * @param pem_len Length of PEM data
 * @return Length of DER data written, or 0 on error
 */
SFUNC size_t fio_pem_get_certificate_der(uint8_t *der_out,
                                         size_t der_out_len,
                                         const char *pem_data,
                                         size_t pem_len);

/**
 * Securely clear a private key structure.
 *
 * @param key Private key to clear
 */
FIO_IFUNC void fio_pem_private_key_clear(fio_pem_private_key_s *key);

/* *****************************************************************************
Implementation - Inline Functions
***************************************************************************** */

/** Securely clear private key */
FIO_IFUNC void fio_pem_private_key_clear(fio_pem_private_key_s *key) {
  if (key) {
    fio_secure_zero(key, sizeof(*key));
  }
}

/* *****************************************************************************
Implementation - Possibly Externed Functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Implementation - PEM Parsing Helpers
***************************************************************************** */

/** Find a string in data (like memmem but simpler) */
FIO_SFUNC const char *fio___pem_find(const char *haystack,
                                     size_t haystack_len,
                                     const char *needle,
                                     size_t needle_len) {
  if (needle_len > haystack_len || needle_len == 0)
    return NULL;

  const char *end = haystack + haystack_len - needle_len + 1;
  for (const char *p = haystack; p < end; ++p) {
    if (FIO_MEMCMP(p, needle, needle_len) == 0)
      return p;
  }
  return NULL;
}

/** Skip whitespace and newlines */
FIO_SFUNC const char *fio___pem_skip_ws(const char *p, const char *end) {
  while (p < end && (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n'))
    ++p;
  return p;
}

/* *****************************************************************************
Implementation - Core PEM Parser
***************************************************************************** */

SFUNC size_t fio_pem_parse(fio_pem_s *out,
                           uint8_t *der_buf,
                           size_t der_buf_len,
                           const char *pem_data,
                           size_t pem_len) {
  if (!out || !der_buf || !pem_data || pem_len == 0)
    return 0;

  FIO_MEMSET(out, 0, sizeof(*out));

  /* Find -----BEGIN */
  static const char begin_marker[] = "-----BEGIN ";
  static const char end_marker[] = "-----END ";
  static const char dashes[] = "-----";

  const char *begin = fio___pem_find(pem_data, pem_len, begin_marker, 11);
  if (!begin)
    return 0;

  /* Extract label */
  const char *label_start = begin + 11;
  const char *label_end = fio___pem_find(label_start,
                                         pem_len - (label_start - pem_data),
                                         dashes,
                                         5);
  if (!label_end)
    return 0;

  out->label = label_start;
  out->label_len = (size_t)(label_end - label_start);

  /* Find start of base64 data (after -----) */
  const char *data_start = label_end + 5;
  data_start = fio___pem_skip_ws(data_start, pem_data + pem_len);

  /* Find -----END <label>----- */
  char end_pattern[128];
  if (out->label_len + 16 > sizeof(end_pattern))
    return 0;

  FIO_MEMCPY(end_pattern, end_marker, 9);
  FIO_MEMCPY(end_pattern + 9, out->label, out->label_len);
  FIO_MEMCPY(end_pattern + 9 + out->label_len, dashes, 5);
  size_t end_pattern_len = 9 + out->label_len + 5;

  const char *data_end = fio___pem_find(data_start,
                                        pem_len - (data_start - pem_data),
                                        end_pattern,
                                        end_pattern_len);
  if (!data_end)
    return 0;

  /* Trim trailing whitespace from data */
  while (data_end > data_start &&
         (data_end[-1] == ' ' || data_end[-1] == '\t' || data_end[-1] == '\r' ||
          data_end[-1] == '\n'))
    --data_end;

  /* Base64 decode the data */
  size_t base64_len = (size_t)(data_end - data_start);
  fio_str_info_s der_str = FIO_STR_INFO3((char *)der_buf, 0, der_buf_len);

  if (fio_string_write_base64dec(&der_str, NULL, data_start, base64_len) != 0) {
    /* Buffer too small or decode error */
    return 0;
  }

  out->der = der_buf;
  out->der_len = der_str.len;

  /* Return total bytes consumed (up to and including end marker) */
  const char *consumed_end = data_end + end_pattern_len;
  /* Skip past any trailing newline */
  while (consumed_end < pem_data + pem_len &&
         (*consumed_end == '\r' || *consumed_end == '\n'))
    ++consumed_end;

  return (size_t)(consumed_end - pem_data);
}

/* *****************************************************************************
Implementation - Certificate Parsing
***************************************************************************** */

SFUNC size_t fio_pem_get_certificate_der(uint8_t *der_out,
                                         size_t der_out_len,
                                         const char *pem_data,
                                         size_t pem_len) {
  if (!der_out || !pem_data || pem_len == 0)
    return 0;

  fio_pem_s pem;
  size_t consumed =
      fio_pem_parse(&pem, der_out, der_out_len, pem_data, pem_len);
  if (consumed == 0)
    return 0;

  /* Verify it's a certificate */
  if (pem.label_len != 11 || FIO_MEMCMP(pem.label, "CERTIFICATE", 11) != 0) {
    FIO_LOG_DEBUG("PEM: expected CERTIFICATE label, got '%.*s'",
                  (int)pem.label_len,
                  pem.label);
    return 0;
  }

  return pem.der_len;
}

SFUNC int fio_pem_parse_certificate(fio_x509_cert_s *cert,
                                    const char *pem_data,
                                    size_t pem_len) {
#if !defined(H___FIO_X509___H)
  FIO_LOG_ERROR("PEM: X.509 module not available");
  (void)cert;
  (void)pem_data;
  (void)pem_len;
  return -1;
#else
  if (!cert || !pem_data || pem_len == 0)
    return -1;

  /* Allocate buffer for DER data (PEM is ~4/3 larger due to base64) */
  size_t der_buf_len = pem_len; /* Conservative estimate */
  uint8_t *der_buf = (uint8_t *)FIO_MEM_REALLOC(NULL, 0, der_buf_len, 0);
  if (!der_buf)
    return -1;

  size_t der_len =
      fio_pem_get_certificate_der(der_buf, der_buf_len, pem_data, pem_len);
  if (der_len == 0) {
    FIO_MEM_FREE(der_buf, der_buf_len);
    return -1;
  }

  /* Parse the X.509 certificate */
  int result = fio_x509_parse(cert, der_buf, der_len);

  /* Note: The cert structure contains pointers into der_buf,
   * so we cannot free it here. The caller must manage the lifetime.
   * For now, we leak the buffer - a proper implementation would
   * require the caller to provide the buffer or use a different API. */
  if (result != 0) {
    FIO_MEM_FREE(der_buf, der_buf_len);
  }
  /* If successful, der_buf is intentionally not freed - cert points into it */

  return result;
#endif
}

/* *****************************************************************************
Implementation - PKCS#8 Private Key Parsing
***************************************************************************** */

/**
 * Parse PKCS#8 PrivateKeyInfo (RFC 5958):
 *
 * PrivateKeyInfo ::= SEQUENCE {
 *   version                   Version,
 *   privateKeyAlgorithm       AlgorithmIdentifier,
 *   privateKey                OCTET STRING,
 *   attributes           [0]  IMPLICIT Attributes OPTIONAL
 * }
 */
FIO_SFUNC int fio___pem_parse_pkcs8(fio_pem_private_key_s *key,
                                    const uint8_t *der,
                                    size_t der_len) {
#if !defined(H___FIO_ASN1___H)
  (void)key;
  (void)der;
  (void)der_len;
  return -1;
#else
  if (!key || !der || der_len == 0)
    return -1;

  fio_asn1_element_s seq;
  if (!fio_asn1_parse(&seq, der, der_len))
    return -1;
  if (!fio_asn1_is_tag(&seq, FIO_ASN1_SEQUENCE))
    return -1;

  fio_asn1_iterator_s it;
  fio_asn1_element_s elem;
  fio_asn1_iterator_init(&it, &seq);

  /* Parse version (INTEGER) */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_INTEGER))
    return -1;

  /* Parse privateKeyAlgorithm (AlgorithmIdentifier = SEQUENCE) */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_SEQUENCE))
    return -1;

  /* Extract algorithm OID */
  fio_asn1_iterator_s alg_it;
  fio_asn1_element_s oid, params;
  fio_asn1_iterator_init(&alg_it, &elem);

  if (fio_asn1_iterator_next(&alg_it, &oid) != 0)
    return -1;
  if (!fio_asn1_is_tag(&oid, FIO_ASN1_OID))
    return -1;

  /* Parse privateKey (OCTET STRING) */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_OCTET_STRING))
    return -1;

  const uint8_t *priv_key_data = elem.data;
  size_t priv_key_len = elem.len;

  /* Determine key type from algorithm OID */
  if (fio_asn1_oid_eq(&oid, FIO_OID_RSA_ENCRYPTION)) {
    /* RSA private key - privateKey contains RSAPrivateKey */
    key->type = FIO_PEM_KEY_RSA;

    /* Parse RSAPrivateKey structure */
    fio_asn1_element_s rsa_seq;
    if (!fio_asn1_parse(&rsa_seq, priv_key_data, priv_key_len))
      return -1;
    if (!fio_asn1_is_tag(&rsa_seq, FIO_ASN1_SEQUENCE))
      return -1;

    fio_asn1_iterator_s rsa_it;
    fio_asn1_element_s rsa_elem;
    fio_asn1_iterator_init(&rsa_it, &rsa_seq);

    /* version */
    if (fio_asn1_iterator_next(&rsa_it, &rsa_elem) != 0)
      return -1;

    /* modulus (n) */
    if (fio_asn1_iterator_next(&rsa_it, &rsa_elem) != 0)
      return -1;
    if (!fio_asn1_is_tag(&rsa_elem, FIO_ASN1_INTEGER))
      return -1;
    key->rsa.n = rsa_elem.data;
    key->rsa.n_len = rsa_elem.len;
    /* Skip leading zero if present */
    if (key->rsa.n_len > 1 && key->rsa.n[0] == 0x00) {
      key->rsa.n++;
      key->rsa.n_len--;
    }

    /* publicExponent (e) */
    if (fio_asn1_iterator_next(&rsa_it, &rsa_elem) != 0)
      return -1;
    if (!fio_asn1_is_tag(&rsa_elem, FIO_ASN1_INTEGER))
      return -1;
    key->rsa.e = rsa_elem.data;
    key->rsa.e_len = rsa_elem.len;
    if (key->rsa.e_len > 1 && key->rsa.e[0] == 0x00) {
      key->rsa.e++;
      key->rsa.e_len--;
    }

    /* privateExponent (d) */
    if (fio_asn1_iterator_next(&rsa_it, &rsa_elem) != 0)
      return -1;
    if (!fio_asn1_is_tag(&rsa_elem, FIO_ASN1_INTEGER))
      return -1;
    key->rsa.d = rsa_elem.data;
    key->rsa.d_len = rsa_elem.len;
    if (key->rsa.d_len > 1 && key->rsa.d[0] == 0x00) {
      key->rsa.d++;
      key->rsa.d_len--;
    }

    /* prime1 (p) */
    if (fio_asn1_iterator_next(&rsa_it, &rsa_elem) == 0 &&
        fio_asn1_is_tag(&rsa_elem, FIO_ASN1_INTEGER)) {
      key->rsa.p = rsa_elem.data;
      key->rsa.p_len = rsa_elem.len;
      if (key->rsa.p_len > 1 && key->rsa.p[0] == 0x00) {
        key->rsa.p++;
        key->rsa.p_len--;
      }

      /* prime2 (q) */
      if (fio_asn1_iterator_next(&rsa_it, &rsa_elem) == 0 &&
          fio_asn1_is_tag(&rsa_elem, FIO_ASN1_INTEGER)) {
        key->rsa.q = rsa_elem.data;
        key->rsa.q_len = rsa_elem.len;
        if (key->rsa.q_len > 1 && key->rsa.q[0] == 0x00) {
          key->rsa.q++;
          key->rsa.q_len--;
        }
      }
    }

    return 0;

  } else if (fio_asn1_oid_eq(&oid, FIO_OID_EC_PUBLIC_KEY)) {
    /* EC private key - check curve parameter */
    if (fio_asn1_iterator_next(&alg_it, &params) != 0)
      return -1;

    if (fio_asn1_oid_eq(&params, FIO_OID_SECP256R1)) {
      key->type = FIO_PEM_KEY_ECDSA_P256;

      /* Parse ECPrivateKey structure (SEC1) */
      fio_asn1_element_s ec_seq;
      if (!fio_asn1_parse(&ec_seq, priv_key_data, priv_key_len))
        return -1;
      if (!fio_asn1_is_tag(&ec_seq, FIO_ASN1_SEQUENCE))
        return -1;

      fio_asn1_iterator_s ec_it;
      fio_asn1_element_s ec_elem;
      fio_asn1_iterator_init(&ec_it, &ec_seq);

      /* version */
      if (fio_asn1_iterator_next(&ec_it, &ec_elem) != 0)
        return -1;

      /* privateKey (OCTET STRING, 32 bytes for P-256) */
      if (fio_asn1_iterator_next(&ec_it, &ec_elem) != 0)
        return -1;
      if (!fio_asn1_is_tag(&ec_elem, FIO_ASN1_OCTET_STRING))
        return -1;
      if (ec_elem.len != 32)
        return -1;

      FIO_MEMCPY(key->ecdsa_p256.private_key, ec_elem.data, 32);

      /* Optional: publicKey [1] BIT STRING */
      key->ecdsa_p256.has_public_key = 0;
      while (fio_asn1_iterator_next(&ec_it, &ec_elem) == 0) {
        if (fio_asn1_is_context_tag(&ec_elem, 1)) {
          /* Parse BIT STRING containing public key */
          fio_asn1_element_s bits;
          if (fio_asn1_parse(&bits, ec_elem.data, ec_elem.len) &&
              fio_asn1_is_tag(&bits, FIO_ASN1_BIT_STRING)) {
            const uint8_t *pubkey_bits;
            size_t pubkey_len;
            uint8_t unused;
            if (fio_asn1_parse_bit_string(&bits,
                                          &pubkey_bits,
                                          &pubkey_len,
                                          &unused) == 0) {
              if (pubkey_len == 65 && pubkey_bits[0] == 0x04) {
                FIO_MEMCPY(key->ecdsa_p256.public_key, pubkey_bits, 65);
                key->ecdsa_p256.has_public_key = 1;
              }
            }
          }
          break;
        }
      }

      return 0;
    }
    /* Other curves not supported */
    return -1;

  } else if (fio_asn1_oid_eq(&oid, FIO_OID_ED25519)) {
    /* Ed25519 private key */
    key->type = FIO_PEM_KEY_ED25519;

    /* For Ed25519, privateKey is an OCTET STRING containing another
     * OCTET STRING with the 32-byte seed */
    fio_asn1_element_s seed;
    if (!fio_asn1_parse(&seed, priv_key_data, priv_key_len))
      return -1;
    if (!fio_asn1_is_tag(&seed, FIO_ASN1_OCTET_STRING))
      return -1;
    if (seed.len != 32)
      return -1;

    FIO_MEMCPY(key->ed25519.private_key, seed.data, 32);
    key->ed25519.has_public_key = 0;

    return 0;
  }

  return -1; /* Unknown algorithm */
#endif
}

/* *****************************************************************************
Implementation - Legacy RSA Private Key Parsing (PKCS#1)
***************************************************************************** */

/**
 * Parse PKCS#1 RSAPrivateKey:
 *
 * RSAPrivateKey ::= SEQUENCE {
 *   version           Version,
 *   modulus           INTEGER,  -- n
 *   publicExponent    INTEGER,  -- e
 *   privateExponent   INTEGER,  -- d
 *   prime1            INTEGER,  -- p
 *   prime2            INTEGER,  -- q
 *   exponent1         INTEGER,  -- d mod (p-1)
 *   exponent2         INTEGER,  -- d mod (q-1)
 *   coefficient       INTEGER,  -- (inverse of q) mod p
 *   otherPrimeInfos   OtherPrimeInfos OPTIONAL
 * }
 */
FIO_SFUNC int fio___pem_parse_rsa_private_key(fio_pem_private_key_s *key,
                                              const uint8_t *der,
                                              size_t der_len) {
#if !defined(H___FIO_ASN1___H)
  (void)key;
  (void)der;
  (void)der_len;
  return -1;
#else
  if (!key || !der || der_len == 0)
    return -1;

  key->type = FIO_PEM_KEY_RSA;

  fio_asn1_element_s seq;
  if (!fio_asn1_parse(&seq, der, der_len))
    return -1;
  if (!fio_asn1_is_tag(&seq, FIO_ASN1_SEQUENCE))
    return -1;

  fio_asn1_iterator_s it;
  fio_asn1_element_s elem;
  fio_asn1_iterator_init(&it, &seq);

  /* version */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_INTEGER))
    return -1;

  /* modulus (n) */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_INTEGER))
    return -1;
  key->rsa.n = elem.data;
  key->rsa.n_len = elem.len;
  if (key->rsa.n_len > 1 && key->rsa.n[0] == 0x00) {
    key->rsa.n++;
    key->rsa.n_len--;
  }

  /* publicExponent (e) */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_INTEGER))
    return -1;
  key->rsa.e = elem.data;
  key->rsa.e_len = elem.len;
  if (key->rsa.e_len > 1 && key->rsa.e[0] == 0x00) {
    key->rsa.e++;
    key->rsa.e_len--;
  }

  /* privateExponent (d) */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_INTEGER))
    return -1;
  key->rsa.d = elem.data;
  key->rsa.d_len = elem.len;
  if (key->rsa.d_len > 1 && key->rsa.d[0] == 0x00) {
    key->rsa.d++;
    key->rsa.d_len--;
  }

  /* prime1 (p) */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_INTEGER))
    return -1;
  key->rsa.p = elem.data;
  key->rsa.p_len = elem.len;
  if (key->rsa.p_len > 1 && key->rsa.p[0] == 0x00) {
    key->rsa.p++;
    key->rsa.p_len--;
  }

  /* prime2 (q) */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_INTEGER))
    return -1;
  key->rsa.q = elem.data;
  key->rsa.q_len = elem.len;
  if (key->rsa.q_len > 1 && key->rsa.q[0] == 0x00) {
    key->rsa.q++;
    key->rsa.q_len--;
  }

  return 0;
#endif
}

/* *****************************************************************************
Implementation - Legacy EC Private Key Parsing (SEC1)
***************************************************************************** */

/**
 * Parse SEC1 ECPrivateKey:
 *
 * ECPrivateKey ::= SEQUENCE {
 *   version        INTEGER { ecPrivkeyVer1(1) },
 *   privateKey     OCTET STRING,
 *   parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
 *   publicKey  [1] BIT STRING OPTIONAL
 * }
 */
FIO_SFUNC int fio___pem_parse_ec_private_key(fio_pem_private_key_s *key,
                                             const uint8_t *der,
                                             size_t der_len) {
#if !defined(H___FIO_ASN1___H)
  (void)key;
  (void)der;
  (void)der_len;
  return -1;
#else
  if (!key || !der || der_len == 0)
    return -1;

  fio_asn1_element_s seq;
  if (!fio_asn1_parse(&seq, der, der_len))
    return -1;
  if (!fio_asn1_is_tag(&seq, FIO_ASN1_SEQUENCE))
    return -1;

  fio_asn1_iterator_s it;
  fio_asn1_element_s elem;
  fio_asn1_iterator_init(&it, &seq);

  /* version */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_INTEGER))
    return -1;

  /* privateKey (OCTET STRING) */
  if (fio_asn1_iterator_next(&it, &elem) != 0)
    return -1;
  if (!fio_asn1_is_tag(&elem, FIO_ASN1_OCTET_STRING))
    return -1;

  /* Determine curve from key length or parameters */
  if (elem.len == 32) {
    /* Assume P-256 based on key length */
    key->type = FIO_PEM_KEY_ECDSA_P256;
    FIO_MEMCPY(key->ecdsa_p256.private_key, elem.data, 32);
    key->ecdsa_p256.has_public_key = 0;

    /* Look for parameters [0] to confirm curve */
    while (fio_asn1_iterator_next(&it, &elem) == 0) {
      if (fio_asn1_is_context_tag(&elem, 0)) {
        /* Parse curve OID */
        fio_asn1_element_s curve_oid;
        if (fio_asn1_parse(&curve_oid, elem.data, elem.len) &&
            fio_asn1_is_tag(&curve_oid, FIO_ASN1_OID)) {
          if (!fio_asn1_oid_eq(&curve_oid, FIO_OID_SECP256R1)) {
            /* Not P-256, unsupported */
            return -1;
          }
        }
      } else if (fio_asn1_is_context_tag(&elem, 1)) {
        /* Parse public key [1] BIT STRING */
        fio_asn1_element_s bits;
        if (fio_asn1_parse(&bits, elem.data, elem.len) &&
            fio_asn1_is_tag(&bits, FIO_ASN1_BIT_STRING)) {
          const uint8_t *pubkey_bits;
          size_t pubkey_len;
          uint8_t unused;
          if (fio_asn1_parse_bit_string(&bits,
                                        &pubkey_bits,
                                        &pubkey_len,
                                        &unused) == 0) {
            if (pubkey_len == 65 && pubkey_bits[0] == 0x04) {
              FIO_MEMCPY(key->ecdsa_p256.public_key, pubkey_bits, 65);
              key->ecdsa_p256.has_public_key = 1;
            }
          }
        }
      }
    }

    return 0;
  }

  return -1; /* Unsupported key length/curve */
#endif
}

/* *****************************************************************************
Implementation - Main Private Key Parser
***************************************************************************** */

SFUNC int fio_pem_parse_private_key(fio_pem_private_key_s *key,
                                    const char *pem_data,
                                    size_t pem_len) {
  if (!key || !pem_data || pem_len == 0)
    return -1;

  FIO_MEMSET(key, 0, sizeof(*key));

  /* Allocate buffer for DER data */
  size_t der_buf_len = pem_len;
  uint8_t *der_buf = (uint8_t *)FIO_MEM_REALLOC(NULL, 0, der_buf_len, 0);
  if (!der_buf)
    return -1;

  fio_pem_s pem;
  size_t consumed =
      fio_pem_parse(&pem, der_buf, der_buf_len, pem_data, pem_len);
  if (consumed == 0) {
    FIO_MEM_FREE(der_buf, der_buf_len);
    return -1;
  }

  int result = -1;

  /* Dispatch based on label */
  if (pem.label_len == 11 && FIO_MEMCMP(pem.label, "PRIVATE KEY", 11) == 0) {
    /* PKCS#8 PrivateKeyInfo */
    result = fio___pem_parse_pkcs8(key, pem.der, pem.der_len);
  } else if (pem.label_len == 15 &&
             FIO_MEMCMP(pem.label, "RSA PRIVATE KEY", 15) == 0) {
    /* PKCS#1 RSAPrivateKey */
    result = fio___pem_parse_rsa_private_key(key, pem.der, pem.der_len);
  } else if (pem.label_len == 14 &&
             FIO_MEMCMP(pem.label, "EC PRIVATE KEY", 14) == 0) {
    /* SEC1 ECPrivateKey */
    result = fio___pem_parse_ec_private_key(key, pem.der, pem.der_len);
  } else {
    FIO_LOG_DEBUG("PEM: unsupported private key label '%.*s'",
                  (int)pem.label_len,
                  pem.label);
  }

  FIO_MEM_FREE(der_buf, der_buf_len);

  if (result != 0) {
    fio_pem_private_key_clear(key);
  }

  return result;
}

/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_PEM */
#undef FIO_PEM
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_IO                 /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




              IO Reactor - an Evented IO Reactor, Single-Threaded



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_IO) && !defined(FIO___RECURSIVE_INCLUDE) &&                    \
    !defined(H___FIO_IO___H)
#define H___FIO_IO___H
/* *****************************************************************************
IO Reactor Settings

At this point, define any MACROs and customizable settings available to the
developer.
***************************************************************************** */

#ifndef FIO_IO_BUFFER_PER_WRITE
/** Control the size of the on-stack buffer used for `write` events. */
#define FIO_IO_BUFFER_PER_WRITE 65536U
#endif

#ifndef FIO_IO_THROTTLE_LIMIT
/** IO will be throttled (no `on_data` events) if outgoing buffer is large. */
#define FIO_IO_THROTTLE_LIMIT 2097152U
#endif

#ifndef FIO_IO_TIMEOUT_MAX
/** Controls the maximum and default timeout in milliseconds (5 minutes). */
#define FIO_IO_TIMEOUT_MAX 300000
#endif

#ifndef FIO_IO_SHUTDOWN_TIMEOUT
/* Sets the hard timeout (in milliseconds) for the reactor's shutdown loop. */
#define FIO_IO_SHUTDOWN_TIMEOUT 15000
#endif

#ifndef FIO_IO_COUNT_STORAGE
#ifdef DEBUG
#define FIO_IO_COUNT_STORAGE 1
#else
#define FIO_IO_COUNT_STORAGE 0
#endif
#endif
/* *****************************************************************************
IO Types
***************************************************************************** */

/** The main protocol object type. See `struct fio_io_protocol_s`. */
typedef struct fio_io_protocol_s fio_io_protocol_s;

/** The IO functions used by the protocol object. */
typedef struct fio_io_functions_s fio_io_functions_s;

/** The main IO object type. Should be treated as an opaque pointer. */
typedef struct fio_io_s fio_io_s;

/** An opaque type used for the SSL/TLS helper functions. */
typedef struct fio_io_tls_s fio_io_tls_s;

/** Message structure, as received by the `on_message` subscription callback. */
typedef struct fio_msg_s fio_msg_s;

/** The IO Async Queue type. */
typedef struct fio_io_async_s fio_io_async_s;

/* *****************************************************************************
Starting / Stopping the IO Reactor
***************************************************************************** */

/** Stopping the IO reactor. */
SFUNC void fio_io_stop(void);

/** Adds `workers` amount of workers to the root IO reactor process. */
SFUNC void fio_io_add_workers(int workers);

/** Starts the IO reactor, using optional `workers` processes. Will BLOCK! */
SFUNC void fio_io_start(int workers);

/** Retiers all existing workers and restarts with the number of workers. */
SFUNC void fio_io_restart(int workers);

/** Sets a signal to listen to for a hot restart (see `fio_io_restart`). */
SFUNC void fio_io_restart_on_signal(int signal);

/** Returns the shutdown timeout for the reactor. */
SFUNC size_t fio_io_shutdown_timsout(void);

/** Sets the shutdown timeout for the reactor, returning the new value. */
SFUNC size_t fio_io_shutdown_timsout_set(size_t milliseconds);

/* *****************************************************************************
The IO Reactor's State
***************************************************************************** */

/** Returns true if IO reactor running and 0 if stopped or shutting down. */
SFUNC int fio_io_is_running(void);

/** Returns true if the current process is the IO reactor's master process. */
SFUNC int fio_io_is_master(void);

/** Returns true if the current process is an IO reactor's worker process. */
SFUNC int fio_io_is_worker(void);

/** Returns the number or workers the IO reactor will actually run. */
SFUNC uint16_t fio_io_workers(int workers_requested);

/** Returns current process id. */
SFUNC int fio_io_pid(void);

/** Returns the root / master process id. */
SFUNC int fio_io_root_pid(void);

/** Returns the last millisecond when the IO reactor polled for events. */
SFUNC int64_t fio_io_last_tick(void);

/* *****************************************************************************
Listening to Incoming Connections
***************************************************************************** */

/** Arguments for the fio_io_listen function */
typedef struct fio_io_listen_args_s {
  /**
   * The binding address in URL format. Defaults to: tcp://0.0.0.0:3000
   *
   * Note: `.url` accept an optional query for building a TLS context.
   *
   * Possible query values include:
   *
   * - `tls` or `ssl` (no value): sets TLS as active, possibly self-signed.
   * - `tls=` or `ssl=`: value is a prefix for "key.pem" and "cert.pem".
   * - `key=` and `cert=`: file paths for ".pem" files.
   *
   * i.e.:
   *
   *     fio_io_listen(.url = "0.0.0.0:3000/?tls", ...);
   *     fio_io_listen(.url = "0.0.0.0:3000/?tls=./", ...);
   *     // same as:
   *     fio_io_listen(.url = "0.0.0.0:3000/"
   *                            "?key=./key.pem"
   *                            "&cert=./cert.pem", ...);
   */
  const char *url;
  /** The `fio_io_protocol_s` that will be assigned to incoming
   * connections. */
  fio_io_protocol_s *protocol;
  /** The default `udata` set for (new) incoming connections. */
  void *udata;
  /** TLS object used for incoming connections (ownership moved to listener). */
  fio_io_tls_s *tls;
  /**
   * Called when the a listening socket starts to listen.
   *
   * May be called multiple times (i.e., if the IO reactor stops and restarts).
   */
  void (*on_start)(fio_io_protocol_s *protocol, void *udata);
  /**
   * Called during listener cleanup.
   *
   * This will be called separately for every process before exiting.
   */
  void (*on_stop)(fio_io_protocol_s *protocol, void *udata);
  /**
   * Selects a queue that will be used to schedule a pre-accept task.
   * May be used to test user thread stress levels before accepting connections.
   */
  fio_io_async_s *queue_for_accept;
  /** When forking the IO reactor - limits `listen` to the root process. */
  uint8_t on_root;
  /** Hides "started/stopped listening" messages from log (if set). */
  uint8_t hide_from_log;
} fio_io_listen_args_s;

typedef struct fio_io_listener_s fio_io_listener_s;
/**
 * Sets up a network service on a listening socket.
 *
 * Returns a self-destructible listener handle on success or NULL on error.
 */
SFUNC fio_io_listener_s *fio_io_listen(fio_io_listen_args_s args);
#define fio_io_listen(...) fio_io_listen((fio_io_listen_args_s){__VA_ARGS__})

/** Notifies a listener to stop listening. */
SFUNC void fio_io_listen_stop(fio_io_listener_s *l);

/** Returns the listener's associated protocol. */
SFUNC fio_io_protocol_s *fio_io_listener_protocol(fio_io_listener_s *l);

/** Returns the listener's associated `udata`. */
SFUNC void *fio_io_listener_udata(fio_io_listener_s *l);

/** Sets the listener's associated `udata`, returning the old value. */
SFUNC void *fio_io_listener_udata_set(fio_io_listener_s *l, void *new_udata);

/** Returns the URL on which the listener is listening. */
SFUNC fio_buf_info_s fio_io_listener_url(fio_io_listener_s *l);

/** Returns true if the listener protocol has an attached TLS context. */
SFUNC int fio_io_listener_is_tls(fio_io_listener_s *l);

/* *****************************************************************************
Connecting as a Client
***************************************************************************** */

/** Named arguments for fio_io_connect */
typedef struct {
  /** The URL to connect to (may contain TLS hints in query / `tls` scheme). */
  const char *url;
  /** Connection protocol (once connection established). */
  fio_io_protocol_s *protocol;
  /** Called in case of a failed connection, use for cleanup. */
  void (*on_failed)(fio_io_protocol_s *protocol, void *udata);
  /** Opaque user data (set only once connection was established). */
  void *udata;
  /** TLS builder object for TLS connections. */
  fio_io_tls_s *tls;
  /** Connection timeout in milliseconds (defaults to 30 seconds). */
  uint32_t timeout;
} fio_io_connect_args_s;

/** Connects to a specific URL, returning the `fio_io_s` IO object or `NULL`. */
SFUNC fio_io_s *fio_io_connect(fio_io_connect_args_s args);

#define fio_io_connect(url_, ...)                                              \
  fio_io_connect((fio_io_connect_args_s){.url = url_, __VA_ARGS__})

/* *****************************************************************************
IO Operations
***************************************************************************** */

/**
 * Attaches the socket in `fd` to the facio.io engine (reactor).
 *
 * * `fd` should point to a valid socket.
 *
 * * `protocol` may be the existing protocol or NULL (for partial hijack).
 *
 * * `udata` is opaque user data and may be any value, including NULL.
 *
 * * `tls` is a context for Transport Layer (Security) and can be used to
 *   redirect read/write operations, as set by the protocol.
 *
 * Returns NULL on error. the `fio_io_s` pointer must NOT be used except
 * within proper callbacks.
 */
SFUNC fio_io_s *fio_io_attach_fd(int fd,
                                 fio_io_protocol_s *protocol,
                                 void *udata,
                                 void *tls);

/** Sets a new protocol object. `NULL` is a valid "only-write" protocol. */
SFUNC fio_io_protocol_s *fio_io_protocol_set(fio_io_s *io,
                                             fio_io_protocol_s *protocol);

/**
 * Returns a pointer to the current protocol object.
 *
 * If `protocol` wasn't properly set, the pointer might be NULL or invalid.
 *
 * If `protocol` wasn't attached yet, may return the previous protocol.
 */
IFUNC fio_io_protocol_s *fio_io_protocol(fio_io_s *io);

/** Returns the a pointer to the memory buffer required by the protocol. */
IFUNC void *fio_io_buffer(fio_io_s *io);

/** Returns the length of the `buf` buffer. */
IFUNC size_t fio_io_buffer_len(fio_io_s *io);

/** Associates a new `udata` pointer with the IO, returning the old `udata` */
IFUNC void *fio_io_udata_set(fio_io_s *io, void *udata);

/** Returns the `udata` pointer associated with the IO. */
IFUNC void *fio_io_udata(fio_io_s *io);

/** Associates a new `tls` pointer with the IO, returning the old `tls` */
IFUNC void *fio_io_tls_set(fio_io_s *io, void *tls);

/** Returns the `tls` pointer associated with the IO. */
IFUNC void *fio_io_tls(fio_io_s *io);

/** Returns the socket file descriptor (fd) associated with the IO. */
IFUNC int fio_io_fd(fio_io_s *io);

/** Resets a socket's timeout counter. */
SFUNC void fio_io_touch(fio_io_s *io);

/**
 * Reads data to the buffer, if any data exists. Returns the number of bytes
 * read.
 *
 * NOTE: zero (`0`) is a valid return value meaning no data was available.
 */
SFUNC size_t fio_io_read(fio_io_s *io, void *buf, size_t len);

typedef struct {
  /** The buffer with the data to send (if no file descriptor) */
  void *buf;
  /** The file descriptor to send (if no buffer) */
  intptr_t fd;
  /** The length of the data to be sent. On files, 0 = the whole file. */
  size_t len;
  /** The length of the data to be sent. On files, 0 = the whole file. */
  size_t offset;
  /**
   * If this is a buffer, the de-allocation function used to free it.
   *
   * If NULL, the buffer will NOT be de-allocated.
   */
  void (*dealloc)(void *);
  /** If non-zero, makes a copy of the buffer or keeps a file open. */
  uint8_t copy;
} fio_io_write_args_s;

/**
 * Writes data to the outgoing buffer and schedules the buffer to be sent.
 */
SFUNC void fio_io_write2(fio_io_s *io, fio_io_write_args_s args);
#define fio_io_write2(io, ...)                                                 \
  fio_io_write2(io, (fio_io_write_args_s){__VA_ARGS__})

/** Helper macro for a common fio_io_write2 (copies the buffer). */
#define fio_io_write(io, buf_, len_)                                           \
  fio_io_write2(io, .buf = (buf_), .len = (len_), .copy = 1)

/**
 * Sends data from a file as if it were a single atomic packet (sends up to
 * length bytes or until EOF is reached).
 *
 * Once the file was sent, the `source_fd` will be closed using `close`.
 *
 * The file will be buffered to the socket chunk by chunk, so that memory
 * consumption is capped.
 *
 * `offset` dictates the starting point for the data to be sent and length sets
 * the maximum amount of data to be sent.
 *
 * Closes the file on error.
 */
#define fio_io_sendfile(io, source_fd, offset_, bytes)                         \
  fio_io_write2((io),                                                          \
                .fd = (source_fd),                                             \
                .offset = (size_t)(offset_),                                   \
                .len = (bytes))

/** Marks the IO for closure as soon as scheduled data was sent. */
SFUNC void fio_io_close(fio_io_s *io);

/** Marks the IO for immediate closure. */
SFUNC void fio_io_close_now(fio_io_s *io);

/**
 * Increases a IO's reference count, so it won't be automatically destroyed
 * when all tasks have completed.
 *
 * Use this function in order to use the IO outside of a scheduled task.
 *
 * This function is thread-safe.
 */
SFUNC fio_io_s *fio_io_dup(fio_io_s *io);

/**
 * Decreases a IO's reference count, so it could be automatically destroyed
 * when all other tasks have completed.
 *
 * Use this function once finished with a IO that was `dup`-ed.
 *
 * This function is thread-safe.
 */
SFUNC void fio_io_free(fio_io_s *io);

/** Suspends future `on_data` events for the IO. */
SFUNC void fio_io_suspend(fio_io_s *io);

/** Listens for future `on_data` events related to the IO. */
SFUNC void fio_io_unsuspend(fio_io_s *io);

/** Returns 1 if the IO handle was suspended. */
SFUNC int fio_io_is_suspended(fio_io_s *io);

/** Returns 1 if the IO handle is marked as open. */
SFUNC int fio_io_is_open(fio_io_s *io);

/** Returns the approximate number of bytes in the outgoing buffer. */
SFUNC size_t fio_io_backlog(fio_io_s *io);

/** Does nothing. */
SFUNC void fio_io_noop(fio_io_s *io);

/* *****************************************************************************
Task Scheduling
***************************************************************************** */

/** Schedules a task for delayed execution. This function is thread-safe. */
SFUNC void fio_io_defer(void (*task)(void *, void *),
                        void *udata1,
                        void *udata2);

/** Schedules a timer bound task, see `fio_timer_schedule`. */
SFUNC void fio_io_run_every(fio_timer_schedule_args_s args);
/**
 * Schedules a timer bound task, see `fio_timer_schedule`.
 *
 * Possible "named arguments" (fio_timer_schedule_args_s members) include:
 *
 * * The timer function. If it returns a non-zero value, the timer stops:
 *        int (*fn)(void *, void *)
 * * Opaque user data:
 *        void *udata1
 * * Opaque user data:
 *        void *udata2
 * * Called when the timer is done (finished):
 *        void (*on_stop)(void *, void *)
 * * Timer interval, in milliseconds:
 *        uint32_t every
 * * The number of times the timer should be performed. -1 == infinity:
 *        int32_t repetitions
 */
#define fio_io_run_every(...)                                                  \
  fio_io_run_every((fio_timer_schedule_args_s){__VA_ARGS__})

/** Returns a pointer for the IO reactor's queue. */
SFUNC fio_queue_s *fio_io_queue(void);

/**************************************************************************/ /**
Protocol IO Functions
============

The Protocol struct uses IO callbacks to allow an easy way to override the
system's IO functions.

This defines Transport Layer callbacks that facil.io will treat as non-blocking
system calls and allows any protocol to easily add a secure (SSL/TLS) flavor if
desired.
*/
struct fio_io_functions_s {
  /** Helper that converts a `fio_io_tls_s` into the implementation's context.
   */
  void *(*build_context)(fio_io_tls_s *tls, uint8_t is_client);
  /** Helper to free the context built by build_context. */
  void (*free_context)(void *context);
  /** called when a new IO is first attached to a valid protocol. */
  void (*start)(fio_io_s *io);
  /** Called to perform a non-blocking `read`, same as the system call. */
  ssize_t (*read)(int fd, void *buf, size_t len, void *context);
  /** Called to perform a non-blocking `write`, same as the system call. */
  ssize_t (*write)(int fd, const void *buf, size_t len, void *context);
  /** Sends any unsent internal data. Returns 0 only if all data was sent. */
  int (*flush)(int fd, void *context);
  /** Called when the IO object finished sending all data before closure. */
  void (*finish)(int fd, void *context);
  /** Called after the IO object is closed, used to cleanup its `tls` object. */
  void (*cleanup)(void *context);
};

/**************************************************************************/ /**
The Protocol
============

The Protocol struct defines the callbacks used for a family of connections and
sets their behavior. The Protocol struct is part of facil.io's core design.

Protocols are usually global objects and the same protocol can be assigned to
multiple IO handles.

All the callbacks receive a IO handle, which is used instead of the system's
file descriptor and protects callbacks and IO operations from sending data to
incorrect clients (possible `fd` "recycling").
*/
struct fio_io_protocol_s {
  /**
   * Reserved / private data - used by facil.io internally.
   * MUST be initialized to zero.
   */
  struct {
    /* A linked list of currently attached IOs (ordered) - do NOT alter. */
    FIO_LIST_HEAD ios;
    /* A linked list of other protocols used by IO core - do NOT alter. */
    FIO_LIST_NODE protocols;
    /* internal flags - do NOT alter after initial initialization to zero. */
    uintptr_t flags;
  } reserved;
  /** Called when an IO is attached to the protocol. */
  void (*on_attach)(fio_io_s *io);
  /** Called when a data is available. */
  void (*on_data)(fio_io_s *io);
  /** called once all pending `fio_write` calls are finished. */
  void (*on_ready)(fio_io_s *io);

  /**
   * Called when the IO reactor is shutting down, immediately before closing the
   * connection.
   *
   * After the `on_shutdown` callback returns, the socket is marked for closure.
   *
   * Once the socket was marked for closure, facil.io will allow a limited
   * amount of time for data to be sent, after which the socket might be closed
   * even if the client did not consume all buffered data.
   */
  void (*on_shutdown)(fio_io_s *io);
  /**
   * Called when a connection's timeout was reached
   *
   * Can be set to `fio_io_touch` if timeout is irrelevant (i.e., UDP).
   */
  void (*on_timeout)(fio_io_s *io);
  /** Used as a default `on_message` when an IO object subscribes. */

  /** Called after the connection was closed (once per IO). */
  void (*on_close)(void *iobuf, void *udata);

  void (*on_pubsub)(struct fio_msg_s *msg);
  /** Allows user specific protocol agnostic callbacks. */
  void (*on_user1)(fio_io_s *io, void *user_data);
  /** Allows user specific protocol agnostic callbacks. */
  void (*on_user2)(fio_io_s *io, void *user_data);
  /** Allows user specific protocol agnostic callbacks. */
  void (*on_user3)(fio_io_s *io, void *user_data);
  /** Reserved for future protocol agnostic callbacks. */
  void (*on_reserved)(fio_io_s *io, void *user_data);
  /**
   * Defines Transport Layer callbacks that facil.io will treat as non-blocking
   * system calls.
   */
  fio_io_functions_s io_functions;
  /**
   * The timeout value in milliseconds for all connections using this protocol.
   *
   * Limited to FIO_IO_TIMEOUT_MAX seconds. Zero (0) == FIO_IO_TIMEOUT_MAX
   */
  uint32_t timeout;
  /** The number of bytes to allocate for the fio_io_buf buffer. */
  uint32_t buffer_size;
};

/** Performs a task for each IO in the stated protocol. */
SFUNC size_t fio_io_protocol_each(fio_io_protocol_s *protocol,
                                  void (*task)(fio_io_s *, void *udata2),
                                  void *udata2);

/* *****************************************************************************
Connection Object Links / Environment
***************************************************************************** */

/** Named arguments for the `fio_io_env_set` function. */
typedef struct {
  /** A numerical type filter. Defaults to 0. Negative values are reserved. */
  intptr_t type;
  /** The name for the link. The name and type uniquely identify the object. */
  fio_buf_info_s name;
  /** The object being linked to the connection. */
  void *udata;
  /** A callback that will be called once the connection is closed. */
  void (*on_close)(void *data);
  /** Set to true (1) if the name string's life lives as long as the `env` . */
  uint8_t const_name;
} fio_io_env_set_args_s;

/** Named arguments for the `fio_io_env_unset` function. */
typedef struct {
  /** A numerical type filter. Should be the same as used with
   * `fio_io_env_set` */
  intptr_t type;
  /** The name of the object. Should be the same as used with `fio_io_env_set`
   */
  fio_buf_info_s name;
} fio_io_env_get_args_s;

/** Returns the named `udata` associated with the IO object (or `NULL`). */
SFUNC void *fio_io_env_get(fio_io_s *io, fio_io_env_get_args_s);

/** Returns the named `udata` associated with the IO object (or `NULL`). */
#define fio_io_env_get(io, ...)                                                \
  fio_io_env_get(io, (fio_io_env_get_args_s){__VA_ARGS__})

/**
 * Links an object to a connection's lifetime / environment.
 *
 * The `on_close` callback will be called once the connection has died.
 *
 * If the `io` is NULL, the value will be set for the global environment.
 */
SFUNC void fio_io_env_set(fio_io_s *io, fio_io_env_set_args_s);

/**
 * Links an object to a connection's lifetime, calling the `on_close` callback
 * once the connection has died.
 *
 * If the `io` is NULL, the value will be set for the global environment, in
 * which case the `on_close` callback will only be called once the process
 * exits.
 *
 * This is a helper MACRO that allows the function to be called using named
 * arguments.
 */
#define fio_io_env_set(io, ...)                                                \
  fio_io_env_set(io, (fio_io_env_set_args_s){__VA_ARGS__})

/**
 * Un-links an object from the connection's lifetime, so it's `on_close`
 * callback will NOT be called.
 *
 * Returns 0 on success and -1 if the object couldn't be found.
 */
SFUNC int fio_io_env_unset(fio_io_s *io, fio_io_env_get_args_s);

/**
 * Un-links an object from the connection's lifetime, so it's `on_close`
 * callback will NOT be called.
 *
 * Returns 0 on success and -1 if the object couldn't be found.
 *
 * This is a helper MACRO that allows the function to be called using named
 * arguments.
 */
#define fio_io_env_unset(io, ...)                                              \
  fio_io_env_unset(io, (fio_io_env_get_args_s){__VA_ARGS__})

/**
 * Removes an object from the connection's lifetime / environment, calling it's
 * `on_close` callback as if the connection was closed.
 */
SFUNC int fio_io_env_remove(fio_io_s *io, fio_io_env_get_args_s);

/**
 * Removes an object from the connection's lifetime / environment, calling it's
 * `on_close` callback as if the connection was closed.
 *
 * This is a helper MACRO that allows the function to be called using named
 * arguments.
 */
#define fio_io_env_remove(io, ...)                                             \
  fio_io_env_remove(io, (fio_io_env_get_args_s){__VA_ARGS__})

/* *****************************************************************************
TLS Context Helper Types
***************************************************************************** */

/** Performs a `new` operation, returning a new `fio_io_tls_s` context. */
SFUNC fio_io_tls_s *fio_io_tls_new(void);

/** Takes a parsed URL and optional TLS target and returns a TLS if needed. */
SFUNC fio_io_tls_s *fio_io_tls_from_url(fio_io_tls_s *target_or_null,
                                        fio_url_s url);

/** Performs a `dup` operation, increasing the object's reference count. */
SFUNC fio_io_tls_s *fio_io_tls_dup(fio_io_tls_s *);

/** Performs a `free` operation, reducing the reference count and freeing. */
SFUNC void fio_io_tls_free(fio_io_tls_s *);

/**
 * Adds a certificate a new SSL/TLS context / settings object (SNI support).
 *
 *      fio_io_tls_cert_add(tls, "www.example.com",
 *                            "public_key.pem",
 *                            "private_key.pem", NULL );
 *
 * NOTE: Except for the `tls` and `server_name` arguments, all arguments might
 * be `NULL`, which a context builder (`fio_io_functions_s`) should
 * treat as a request for a self-signed certificate. It may be silently ignored.
 */
SFUNC fio_io_tls_s *fio_io_tls_cert_add(fio_io_tls_s *,
                                        const char *server_name,
                                        const char *public_cert_file,
                                        const char *private_key_file,
                                        const char *pk_password);

/**
 * Adds an ALPN protocol callback to the SSL/TLS context.
 *
 * The first protocol added will act as the default protocol to be selected.
 *
 * A `NULL` protocol name will be silently ignored.
 *
 * A `NULL` callback (`on_selected`) will be silently replaced with a no-op.
 */
SFUNC fio_io_tls_s *fio_io_tls_alpn_add(fio_io_tls_s *tls,
                                        const char *protocol_name,
                                        void (*on_selected)(fio_io_s *));

/** Calls the `on_selected` callback for the `fio_io_tls_s` object. */
SFUNC int fio_io_tls_alpn_select(fio_io_tls_s *tls,
                                 const char *protocol_name,
                                 size_t name_length,
                                 fio_io_s *);

/**
 * Adds a certificate to the "trust" list, which automatically adds a peer
 * verification requirement.
 *
 * If `public_cert_file` is `NULL`, implementation is expected to add the
 * system's default trust registry.
 *
 * Note: when the `fio_io_tls_s` object is used for server connections, this
 * should limit connections to clients that connect using a trusted certificate.
 *
 *      fio_io_tls_trust_add(tls, "google-ca.pem" );
 */
SFUNC fio_io_tls_s *fio_io_tls_trust_add(fio_io_tls_s *,
                                         const char *public_cert_file);

/**
 * Returns the number of `fio_io_tls_cert_add` instructions.
 *
 * This could be used when deciding if to add a NULL instruction (self-signed).
 *
 * If `fio_io_tls_cert_add` was never called, zero (0) is returned.
 */
SFUNC uintptr_t fio_io_tls_cert_count(fio_io_tls_s *tls);

/**
 * Returns the number of registered ALPN protocol names.
 *
 * This could be used when deciding if protocol selection should be delegated to
 * the ALPN mechanism, or whether a protocol should be immediately assigned.
 *
 * If no ALPN protocols are registered, zero (0) is returned.
 */
SFUNC uintptr_t fio_io_tls_alpn_count(fio_io_tls_s *tls);

/**
 * Returns the number of `fio_io_tls_trust_add` instructions.
 *
 * This could be used when deciding if to disable peer verification or not.
 *
 * If `fio_io_tls_trust_add` was never called, zero (0) is returned.
 */
SFUNC uintptr_t fio_io_tls_trust_count(fio_io_tls_s *tls);

/** Arguments (and info) for `fio_io_tls_each`. */
typedef struct fio_io_tls_each_s {
  fio_io_tls_s *tls;
  void *udata;
  void *udata2;
  int (*each_cert)(struct fio_io_tls_each_s *,
                   const char *server_name,
                   const char *public_cert_file,
                   const char *private_key_file,
                   const char *pk_password);
  int (*each_alpn)(struct fio_io_tls_each_s *,
                   const char *protocol_name,
                   void (*on_selected)(fio_io_s *));
  int (*each_trust)(struct fio_io_tls_each_s *, const char *public_cert_file);
} fio_io_tls_each_s;

/** Calls callbacks for certificate, trust certificate and ALPN added. */
SFUNC int fio_io_tls_each(fio_io_tls_each_s);

/** `fio_io_tls_each` helper macro, see `fio_io_tls_each_s` for named
 * arguments. */
#define fio_io_tls_each(tls_, ...)                                             \
  fio_io_tls_each(((fio_io_tls_each_s){.tls = tls_, __VA_ARGS__}))

/** If `NULL` returns current default, otherwise sets it. */
SFUNC fio_io_functions_s fio_io_tls_default_functions(fio_io_functions_s *);

/* *****************************************************************************
IO Async Queue - Worker Threads for non-IO tasks
***************************************************************************** */

/** The IO Async Queue type. */
struct fio_io_async_s {
  fio_queue_s *q;
  uint32_t count;
  fio_queue_s queue;
  fio_timer_queue_s timers;
  FIO_LIST_NODE node;
};

/**
 * Initializes an IO Async Queue (multi-threaded task queue).
 *
 * The queue automatically spawns threads and shuts down as the IO reactor
 * starts or stops.
 *
 * It is recommended that the `fio_io_async_s` be allocated as a static
 * variable, as its memory must remain valid throughout the lifetime of the
 * IO reactor's app.
 */
#define FIO_IO_ASYN_INIT ((fio_io_async_s){0})

/** Returns the current task queue associated with the IO Async Queue. */
FIO_IFUNC fio_queue_s *fio_io_async_queue(fio_io_async_s *q) { return q->q; }

/**
 * Attaches an IO Async Queue for use in multi-threaded (non IO) tasks.
 *
 * This function can be called multiple times for the same (or other) queue, as
 * long as the async queue (`fio_io_async_s`) was previously initialized using
 * `FIO_IO_ASYN_INIT` or zeroed out. i.e.:
 *
 *     static fio_io_async_s SLOW_HTTP_TASKS = FIO_IO_ASYN_INIT;
 *     fio_io_async_attach(&SLOW_HTTP_TASKS, 32);
 */
SFUNC void fio_io_async_attach(fio_io_async_s *q, uint32_t threads);

/** Pushes a task to an IO Async Queue (macro helper). */
#define fio_io_async(q_, ...) fio_queue_push((q_)->q, __VA_ARGS__)

/** Schedules a timer bound task for the async queue (`fio_timer_schedule`). */
SFUNC void fio_io_async_every(fio_io_async_s *q, fio_timer_schedule_args_s);

/**
 * Schedules a timer bound task, for the async queue, see `fio_timer_schedule`.
 *
 * Possible "named arguments" (fio_timer_schedule_args_s members) include:
 *
 * * The timer function. If it returns a non-zero value, the timer stops:
 *        int (*fn)(void *, void *)
 * * Opaque user data:
 *        void *udata1
 * * Opaque user data:
 *        void *udata2
 * * Called when the timer is done (finished):
 *        void (*on_stop)(void *, void *)
 * * Timer interval, in milliseconds:
 *        uint32_t every
 * * The number of times the timer should be performed. -1 == infinity:
 *        int32_t repetitions
 */
#define fio_io_async_every(async, ...)                                         \
  fio_io_async_every(async, (fio_timer_schedule_args_s){__VA_ARGS__})

/* *****************************************************************************
IO API Finish
***************************************************************************** */
#endif /* FIO_IO */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_IO                 /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************

              IO Reactor - an Evented IO Reactor, Single-Threaded

Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_IO) && !defined(FIO___RECURSIVE_INCLUDE) &&                    \
    !defined(H___FIO_IO_TYPES___H) &&                                          \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN))
#define H___FIO_IO_TYPES___H

/** I would love to use fio_time_mono, but using time_real enables logging. */
#define FIO___IO_GET_TIME_MILLI() fio_time2milli(fio_time_real())

/** Sets a flag in io->flag */
#define FIO___IO_FLAG_SET(io, flag_to_set)                                     \
  fio_atomic_or(&(io)->flags, flag_to_set)
/** unsets a flag in io->flag */
#define FIO___IO_FLAG_UNSET(io, flag_to_unset)                                 \
  fio_atomic_and(&(io)->flags, ~(flag_to_unset))

/* *****************************************************************************
IO environment support (`env`)
***************************************************************************** */

/** An object that can be linked to any facil.io connection (fio_s). */
typedef struct {
  void (*on_close)(void *data);
  void *udata;
} fio___io_env_obj_s;

/* unordered `env` dictionary style map */
#define FIO_UMAP_NAME fio___io_env
#define FIO_MAP_KEY_KSTR
#define FIO_MAP_VALUE fio___io_env_obj_s
#define FIO_MAP_VALUE_DESTROY(o)                                               \
  do {                                                                         \
    if ((o).on_close)                                                          \
      (o).on_close((o).udata);                                                 \
  } while (0)
#define FIO_MAP_DESTROY_AFTER_COPY 0

#define FIO___RECURSIVE_INCLUDE 1
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

typedef struct {
  fio_thread_mutex_t lock;
  fio___io_env_s env;
} fio___io_env_safe_s;

#define FIO___IO_ENV_SAFE_INIT                                                 \
  { .lock = FIO_THREAD_MUTEX_INIT, .env = FIO_MAP_INIT }

FIO_IFUNC void *fio___io_env_safe_get(fio___io_env_safe_s *e,
                                      char *key_,
                                      size_t len,
                                      intptr_t type_) {
  void *r;
  fio_str_info_s key = FIO_STR_INFO3(key_, len, 0);
  const uint64_t hash = fio_risky_hash(key_, len, (uint64_t)(type_));
  fio_thread_mutex_lock(&e->lock);
  r = fio___io_env_get(&e->env, hash, key).udata;
  fio_thread_mutex_unlock(&e->lock);
  return r;
}

FIO_IFUNC void fio___io_env_safe_set(fio___io_env_safe_s *e,
                                     char *key_,
                                     size_t len,
                                     intptr_t type_,
                                     fio___io_env_obj_s val,
                                     uint8_t key_is_const) {
  fio_str_info_s key = FIO_STR_INFO3(key_, len, !key_is_const);
  const uint64_t hash = fio_risky_hash(key_, len, (uint64_t)(type_));
  fio_thread_mutex_lock(&e->lock);
  fio___io_env_set(&e->env, hash, key, val, NULL);
  fio_thread_mutex_unlock(&e->lock);
}

FIO_IFUNC int fio___io_env_safe_unset(fio___io_env_safe_s *e,
                                      char *key_,
                                      size_t len,
                                      intptr_t type_) {
  int r;
  fio_str_info_s key = FIO_STR_INFO3(key_, len, 0);
  const uint64_t hash = fio_risky_hash(key_, len, (uint64_t)(type_));
  fio___io_env_obj_s old;
  fio_thread_mutex_lock(&e->lock);
  r = fio___io_env_remove(&e->env, hash, key, &old);
  fio_thread_mutex_unlock(&e->lock);
  return r;
}

FIO_IFUNC int fio___io_env_safe_remove(fio___io_env_safe_s *e,
                                       char *key_,
                                       size_t len,
                                       intptr_t type_) {
  int r;
  fio_str_info_s key = FIO_STR_INFO3(key_, len, 0);
  const uint64_t hash = fio_risky_hash(key_, len, (uint64_t)(type_));
  fio_thread_mutex_lock(&e->lock);
  r = fio___io_env_remove(&e->env, hash, key, NULL);
  fio_thread_mutex_unlock(&e->lock);
  return r;
}

FIO_IFUNC void fio___io_env_safe_destroy(fio___io_env_safe_s *e) {
  fio___io_env_destroy(&e->env); /* no need to lock, performed in IO thread. */
  fio_thread_mutex_destroy(&e->lock);
  *e = (fio___io_env_safe_s)FIO___IO_ENV_SAFE_INIT;
}

/* *****************************************************************************
Protocol Type Initialization
***************************************************************************** */

SFUNC void fio_io_noop(fio_io_s *io) { (void)(io); }

static void fio___io_on_ev_pubsub_mock(struct fio_msg_s *msg) { (void)(msg); }
static void fio___io_on_user_mock(fio_io_s *io, void *i_) {
  (void)io, (void)i_;
}
static void fio___io_on_close_mock(void *p1, void *p2) { (void)p1, (void)p2; }

/* Called to perform a non-blocking `read`, same as the system call. */
static ssize_t fio___io_func_default_read(int fd,
                                          void *buf,
                                          size_t len,
                                          void *tls) {
  return fio_sock_read(fd, buf, len);
  (void)tls;
}
/** Called to perform a non-blocking `write`, same as the system call. */
static ssize_t fio___io_func_default_write(int fd,
                                           const void *buf,
                                           size_t len,
                                           void *tls) {
  return fio_sock_write(fd, buf, len);
  (void)tls;
}
/** Sends any unsent internal data. Returns 0 only if all data was sent. */
static int fio___io_func_default_flush(int fd, void *tls) {
  return 0;
  (void)fd, (void)tls;
}
/** Sends any unsent internal data. Returns 0 only if all data was sent. */
static void fio___io_func_default_finish(int fd, void *tls) {
  (void)fd, (void)tls;
}
static void fio___io_func_default_cleanup(void *p1) { (void)p1; }

/** Builds a local TLS context out of the fio_io_tls_s object. */
static void *fio___io_func_default_build_context(fio_io_tls_s *tls,
                                                 uint8_t is_client) {
  if (!tls)
    return NULL;
  FIO_ASSERT(0,
             "SSL/TLS `build_context` was called, but no SSL/TLS "
             "implementation found.");
  return NULL;
  (void)tls, (void)is_client;
}
/** Builds a local TLS context out of the fio_io_tls_s object. */
static void fio___io_func_default_free_context(void *context) {
  if (!context)
    return;
  FIO_ASSERT(0,
             "SSL/TLS `free_context` was called, but no SSL/TLS "
             "implementation found.");
  (void)context;
}

static void fio___io_func_free_context_caller_task(void *fn_ptr,
                                                   void *context) {
  union {
    void (*free_context)(void *context);
    void *fn_ptr;
  } u = {.fn_ptr = fn_ptr};
  u.free_context(context);
}

static void fio___io_func_free_context_caller(void (*free_context)(void *),
                                              void *context) {
  union {
    void (*free_context)(void *context);
    void *fn_ptr;
  } u = {.free_context = free_context};
  fio_queue_push(fio_io_queue(),
                 fio___io_func_free_context_caller_task,
                 u.fn_ptr,
                 context);
}

FIO_SFUNC void fio___io_init_protocol(fio_io_protocol_s *pr, _Bool has_tls) {
  pr->reserved.protocols = FIO_LIST_INIT(pr->reserved.protocols);
  pr->reserved.ios = FIO_LIST_INIT(pr->reserved.ios);
  fio_io_functions_s io_fn = {
      .build_context = fio___io_func_default_build_context,
      .free_context = fio___io_func_default_free_context,
      .start = fio_io_noop,
      .read = fio___io_func_default_read,
      .write = fio___io_func_default_write,
      .flush = fio___io_func_default_flush,
      .finish = fio___io_func_default_finish,
      .cleanup = fio___io_func_default_cleanup,
  };
  if (has_tls)
    io_fn = fio_io_tls_default_functions(NULL);
  if (!pr->on_attach)
    pr->on_attach = fio_io_noop;
  if (!pr->on_data)
    pr->on_data = fio_io_suspend;
  if (!pr->on_ready)
    pr->on_ready = fio_io_noop;
  if (!pr->on_close)
    pr->on_close = fio___io_on_close_mock;
  if (!pr->on_shutdown)
    pr->on_shutdown = fio_io_noop;
  if (!pr->on_timeout)
    pr->on_timeout = fio_io_close_now;
  if (!pr->on_pubsub)
    pr->on_pubsub = fio___io_on_ev_pubsub_mock;
  if (!pr->on_user1)
    pr->on_user1 = fio___io_on_user_mock;
  if (!pr->on_user2)
    pr->on_user2 = fio___io_on_user_mock;
  if (!pr->on_user3)
    pr->on_user3 = fio___io_on_user_mock;
  if (!pr->on_reserved)
    pr->on_reserved = fio___io_on_user_mock;
  if (!pr->io_functions.build_context)
    pr->io_functions.build_context = io_fn.build_context;
  if (!pr->io_functions.free_context)
    pr->io_functions.free_context = io_fn.free_context;
  if (!pr->io_functions.start)
    pr->io_functions.start = io_fn.start;
  if (!pr->io_functions.read)
    pr->io_functions.read = io_fn.read;
  if (!pr->io_functions.write)
    pr->io_functions.write = io_fn.write;
  if (!pr->io_functions.flush)
    pr->io_functions.flush = io_fn.flush;
  if (!pr->io_functions.finish)
    pr->io_functions.finish = io_fn.finish;
  if (!pr->io_functions.cleanup)
    pr->io_functions.cleanup = io_fn.cleanup;
  if (!pr->timeout)
    pr->timeout = FIO_IO_TIMEOUT_MAX;
  /* round up to nearest 16 byte size */
  pr->buffer_size = ((pr->buffer_size + 15ULL) & (~15ULL));
}

/* the FIO___MOCK_PROTOCOL is used to manage hijacked / zombie connections. */
static fio_io_protocol_s FIO___IO_MOCK_PROTOCOL;

FIO_IFUNC void fio___io_init_protocol_test(fio_io_protocol_s *pr,
                                           _Bool has_tls) {
  if (!fio_atomic_or(&pr->reserved.flags, 1))
    fio___io_init_protocol(pr, has_tls);
}

/* *****************************************************************************
IO Reactor State Machine
***************************************************************************** */

#define FIO___IO_FLAG_WAKEUP   (1U)
#define FIO___IO_FLAG_CYCLING  (2U)
#define FIO___IO_FLAG_TICK_SET (4U)

typedef struct {
  FIO_LIST_NODE node;
  fio_thread_pid_t pid;
  volatile unsigned done;
  volatile unsigned stop;
} fio___io_pid_s;

static struct FIO___IO_S {
  fio_poll_s poll;
  int64_t tick;
  fio_queue_s queue;
  uint32_t flags;
  uint16_t workers;
  uint8_t is_worker;
  volatile uint8_t stop;
  fio_timer_queue_s timer;
  int restart_signal;
  int wakeup_fd;
  fio_thread_pid_t root_pid;
  fio_thread_pid_t pid;
  fio___io_env_safe_s env;
  FIO_LIST_NODE protocols;
  FIO_LIST_NODE async;
  FIO_LIST_NODE pids;
  uint32_t to_spawn;
  fio_io_s *wakeup;
  FIO___LOCK_TYPE lock;
  size_t shutdown_timeout;
} FIO___IO = {
    .tick = 0,
    .wakeup_fd = -1,
    .stop = 1,
    .lock = FIO___LOCK_INIT,
    .shutdown_timeout = FIO_IO_SHUTDOWN_TIMEOUT,
};

FIO_IFUNC void fio___io_defer_no_wakeup(void (*task)(void *, void *),
                                        void *udata1,
                                        void *udata2) {
  fio_queue_push(&FIO___IO.queue, task, udata1, udata2);
}

FIO_SFUNC void fio___io_wakeup(void);
void fio_io_defer___(void);
/** Schedules a task for delayed execution. This function is thread-safe. */
SFUNC void fio_io_defer FIO_NOOP(void (*task)(void *, void *),
                                 void *udata1,
                                 void *udata2) {
  fio_queue_push(&FIO___IO.queue, task, udata1, udata2);
  fio___io_wakeup();
}

void fio_io_run_every___(void);
/** Schedules a timer bound task, see `fio_timer_schedule`. */
SFUNC void fio_io_run_every FIO_NOOP(fio_timer_schedule_args_s args) {
  args.start_at = FIO___IO.tick;
  fio_timer_schedule FIO_NOOP(&FIO___IO.timer, args);
}

/** Returns a pointer for the IO reactor's queue. */
SFUNC fio_queue_s *fio_io_queue(void) { return &FIO___IO.queue; }

/** Stopping the IO reactor. */
SFUNC void fio_io_stop(void) { fio_atomic_or_fetch(&FIO___IO.stop, 1); }

/** Returns current process id. */
SFUNC int fio_io_pid(void) { return FIO___IO.pid; }

/** Returns the root / master process id. */
SFUNC int fio_io_root_pid(void) { return FIO___IO.root_pid; }

/** Returns true if running and 0 if stopped or shutting down. */
SFUNC int fio_io_is_running(void) { return !FIO___IO.stop; }

/** Returns true if the current process is the master process. */
SFUNC int fio_io_is_master(void) { return FIO___IO.root_pid == FIO___IO.pid; }

/** Returns true if the current process is a worker process. */
SFUNC int fio_io_is_worker(void) { return FIO___IO.is_worker; }

FIO_SFUNC void fio___io_last_tick_update(void *ignr_1, void *ignr_2) {
  FIO___IO_FLAG_UNSET(&FIO___IO, FIO___IO_FLAG_TICK_SET);
  FIO___IO.tick = FIO___IO_GET_TIME_MILLI();
  (void)ignr_1, (void)ignr_2;
}

/** Returns the last millisecond when the polled for IO events. */
SFUNC int64_t fio_io_last_tick(void) {
  if (!(FIO___IO_FLAG_SET(&FIO___IO, FIO___IO_FLAG_TICK_SET) &
        FIO___IO_FLAG_TICK_SET))
    fio___io_defer_no_wakeup(fio___io_last_tick_update, NULL, NULL);
  return FIO___IO.tick;
}

/** Sets a signal to listen to for a hot restart (see `fio_io_restart`). */
SFUNC void fio_io_restart_on_signal(int signal) {
  FIO___IO.restart_signal = signal;
}

/** Returns the shutdown timeout for the reactor. */
SFUNC size_t fio_io_shutdown_timsout(void) { return FIO___IO.shutdown_timeout; }

/** Sets the shutdown timeout for the reactor, returning the new value. */
SFUNC size_t fio_io_shutdown_timsout_set(size_t milliseconds) {
  return (FIO___IO.shutdown_timeout = milliseconds);
}

/* *****************************************************************************
IO Type
***************************************************************************** */

#define FIO___IO_FLAG_OPEN         ((uint32_t)1U)
#define FIO___IO_FLAG_SUSPENDED    ((uint32_t)2U)
#define FIO___IO_FLAG_THROTTLED    ((uint32_t)4U)
#define FIO___IO_FLAG_CLOSE        ((uint32_t)8U)
#define FIO___IO_FLAG_CLOSE_REMOTE ((uint32_t)16U)
#define FIO___IO_FLAG_CLOSE_ERROR  ((uint32_t)32U)
#define FIO___IO_FLAG_CLOSED_ALL                                               \
  (FIO___IO_FLAG_CLOSE | FIO___IO_FLAG_CLOSE_REMOTE | FIO___IO_FLAG_CLOSE_ERROR)
#define FIO___IO_FLAG_TOUCH       ((uint32_t)64U)
#define FIO___IO_FLAG_WRITE_SCHD  ((uint32_t)128U)
#define FIO___IO_FLAG_POLLIN_SET  ((uint32_t)256U)
#define FIO___IO_FLAG_POLLOUT_SET ((uint32_t)512U)

#define FIO___IO_FLAG_PREVENT_ON_DATA                                          \
  (FIO___IO_FLAG_SUSPENDED | FIO___IO_FLAG_THROTTLED)

#define FIO___IO_FLAG_POLL_SET                                                 \
  (FIO___IO_FLAG_POLLIN_SET | FIO___IO_FLAG_POLLOUT_SET)

static void fio___io_poll_on_data_schd(void *io);
static void fio___io_poll_on_ready_schd(void *io);
static void fio___io_poll_on_close_schd(void *io);

/** The main IO object type. Should be treated as an opaque pointer. */
struct fio_io_s {
  int fd;
  uint32_t flags;
  FIO_LIST_NODE node;
  void *udata;
  void *tls;
  fio_io_protocol_s *pr;
  fio_stream_s out;
  fio___io_env_safe_s env;
#if FIO_IO_COUNT_STORAGE
  size_t total_sent;
  size_t total_recieved;
#endif
  int64_t active;
};

FIO_IFUNC void fio___io_monitor_in(fio_io_s *io) {
  FIO_LOG_DDEBUG2("(%d) IO monitoring Input for %d (called)",
                  fio_io_pid(),
                  io->fd);
  if (io->flags & (FIO___IO_FLAG_PREVENT_ON_DATA | FIO___IO_FLAG_CLOSED_ALL))
    return;
  if ((FIO___IO_FLAG_SET(io, FIO___IO_FLAG_POLLIN_SET) &
       FIO___IO_FLAG_POLLIN_SET)) {
    return;
  }
  fio_poll_monitor(&FIO___IO.poll, io->fd, (void *)io, POLLIN);
  FIO_LOG_DDEBUG2("(%d) IO monitoring Input for %d", fio_io_pid(), io->fd);
}
FIO_IFUNC void fio___io_monitor_out(fio_io_s *io) {
  FIO_LOG_DDEBUG2("(%d) IO monitoring Output for %d (called)",
                  fio_io_pid(),
                  io->fd);
  if (io->flags & FIO___IO_FLAG_WRITE_SCHD)
    return;
  if ((FIO___IO_FLAG_SET(io, FIO___IO_FLAG_POLLOUT_SET) &
       FIO___IO_FLAG_POLLOUT_SET))
    return;
  fio_poll_monitor(&FIO___IO.poll, io->fd, (void *)io, POLLOUT);
  FIO_LOG_DDEBUG2("(%d) IO monitoring Output for %d", fio_io_pid(), io->fd);
}

FIO_IFUNC void fio___io_monitor_forget(fio_io_s *io) {
  FIO_LOG_DDEBUG2("(%d) IO monitoring Removed for %d (called)",
                  fio_io_pid(),
                  io->fd);
  if (!(FIO___IO_FLAG_UNSET(io, FIO___IO_FLAG_POLL_SET) &
        FIO___IO_FLAG_POLL_SET))
    return;
  fio_poll_forget(&FIO___IO.poll, io->fd);
  FIO_LOG_DDEBUG2("(%d) IO monitoring Removed for %d", fio_io_pid(), io->fd);
}

FIO_SFUNC void fio___io_destroy(fio_io_s *io) {
  fio_io_protocol_s *pr = io->pr;
  FIO_LIST_REMOVE(&io->node);
#if FIO_IO_COUNT_STORAGE
  FIO_LOG_DDEBUG2(
      "(%d) detaching and destroying %p (fd %d): %zu/%zu bytes received/sent",
      FIO___IO.pid,
      (void *)io,
      io->fd,
      io->total_recieved,
      io->total_sent);
#else
  FIO_LOG_DDEBUG2("(%d) detaching and destroying %p (fd %d).",
                  FIO___IO.pid,
                  (void *)io,
                  io->fd);
#endif
  /* store info, as it might be freed if the protocol is freed. */
  if (FIO_LIST_IS_EMPTY(&io->pr->reserved.ios))
    FIO_LIST_REMOVE_RESET(&io->pr->reserved.protocols);
  /* call on_stop / free callbacks . */
  pr->io_functions.cleanup(io->tls);
  pr->on_close((void *)(io + 1), io->udata);
  fio___io_env_safe_destroy(&io->env);
  fio_sock_close(io->fd);
  fio_stream_destroy(&io->out);
  fio___io_monitor_forget(io);
  FIO_LOG_DDEBUG2("(%d) IO closed and destroyed for fd %d",
                  fio_io_pid(),
                  io->fd);
}

#define FIO_REF_NAME            fio___io
#define FIO_REF_TYPE            fio_io_s
#define FIO_REF_FLEX_TYPE       uint8_t
#define FIO_REF_DESTROY(io)     fio___io_destroy(&io)
#define FIO___RECURSIVE_INCLUDE 1
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

FIO_SFUNC void fio___io_protocol_set(void *io_, void *pr_) {
  fio_io_s *io = (fio_io_s *)io_;
  fio_io_protocol_s *pr = (fio_io_protocol_s *)pr_;
  fio_io_protocol_s *old = io->pr;
  if (!pr)
    pr = &FIO___IO_MOCK_PROTOCOL;
  fio___io_init_protocol_test(pr, (io->tls != NULL));
  FIO_LIST_REMOVE(&io->node);
  if (FIO_LIST_IS_EMPTY(&old->reserved.ios))
    FIO_LIST_REMOVE_RESET(&old->reserved.protocols);
  if (FIO_LIST_IS_EMPTY(&pr->reserved.ios))
    FIO_LIST_PUSH(&FIO___IO.protocols, &pr->reserved.protocols);
  FIO_LIST_PUSH(&pr->reserved.ios, &io->node);
  io->pr = pr;
  FIO_LOG_DDEBUG2("(%d) protocol set for IO with fd %d",
                  fio_io_pid(),
                  fio_io_fd(io));
  pr->on_attach(io);
  /* avoid calling `start` and setting `on_ready` more than once */
  if (old == &FIO___IO_MOCK_PROTOCOL) {
    pr->io_functions.start(io);
    fio___io_monitor_out(io);
  }
  fio___io_monitor_in(io);
  fio___io_free2(io);
}

/** Performs a task for each IO in the stated protocol. */
SFUNC size_t fio_io_protocol_each(fio_io_protocol_s *protocol,
                                  void (*task)(fio_io_s *, void *udata2),
                                  void *udata2) {
  size_t count = 0;
  if (!protocol || !protocol->reserved.protocols.next)
    return count;
  FIO_LIST_EACH(fio_io_s, node, &protocol->reserved.ios, io) {
    task(io, udata2);
    ++count;
  }
  return count;
}

/* Attaches the socket in `fd` to the facio.io engine (reactor). */
SFUNC fio_io_s *fio_io_attach_fd(int fd,
                                 fio_io_protocol_s *pr,
                                 void *udata,
                                 void *tls) {
  fio_io_s *io = NULL;
  fio_io_protocol_s cpy;
  if (fd == -1)
    goto error;
  io = fio___io_new2(pr->buffer_size);
  *io = (fio_io_s){
      .fd = fd,
      .flags = FIO___IO_FLAG_OPEN,
      .pr = &FIO___IO_MOCK_PROTOCOL,
      .node = FIO_LIST_INIT(io->node),
      .udata = udata,
      .tls = tls,
      .active = FIO___IO.tick,
  };
  fio_sock_set_non_block(fd);
  FIO_LOG_DDEBUG2("(%d) attaching fd %d to IO object %p (%zu bytes buffer)",
                  fio_io_pid(),
                  fd,
                  (void *)io,
                  fio_io_buffer_len(io));
  fio_io_defer(fio___io_protocol_set, (void *)fio___io_dup2(io), (void *)pr);
  return io;

error:
  cpy = *pr;
  cpy.on_close(NULL, udata);
  cpy.io_functions.cleanup(tls);
  return io;
}

/** Sets a new protocol object. `NULL` is a valid "only-write" protocol. */
SFUNC fio_io_protocol_s *fio_io_protocol_set(fio_io_s *io,
                                             fio_io_protocol_s *pr) {
  fio_io_defer(fio___io_protocol_set, (void *)fio___io_dup2(io), (void *)pr);
  return pr;
}

/**
 * Returns a pointer to the current protocol object.
 *
 * If `protocol` wasn't properly set, the pointer might be NULL or invalid.
 *
 * If `protocol` wasn't attached yet, may return the previous protocol.
 */
IFUNC fio_io_protocol_s *fio_io_protocol(fio_io_s *io) { return io->pr; }

/** Returns the a pointer to the memory buffer required by the protocol. */
IFUNC void *fio_io_buffer(fio_io_s *io) { return (void *)(io + 1); }

/** Returns the length of the `buffer` buffer. */
IFUNC size_t fio_io_buffer_len(fio_io_s *io) {
  return fio___io_metadata_flex_len(io);
}

/** Associates a new `udata` pointer with the IO, returning the old `udata` */
FIO_DEF_SET_FUNC(IFUNC, fio_io, fio_io_s, void *, udata, FIO_NOOP_FN)

/** Returns the `udata` pointer associated with the IO. */
IFUNC void *fio_io_udata(fio_io_s *io) { return io->udata; }

/** Associates a new `tls` pointer with the IO, returning the old `tls` */
IFUNC void *fio_io_tls_set(fio_io_s *io, void *tls) {
  void *old = io->tls;
  io->tls = tls;
  return old;
}

/** Returns the `tls` pointer associated with the IO. */
IFUNC void *fio_io_tls(fio_io_s *io) { return io->tls; }

/** Returns the socket file descriptor (fd) associated with the IO. */
IFUNC int fio_io_fd(fio_io_s *io) { return io->fd; }

FIO_SFUNC void fio___io_touch(void *io_, void *ignr_) {
  fio_io_s *io = (fio_io_s *)io_;
  fio_atomic_and(&io->flags, ~FIO___IO_FLAG_TOUCH);
  io->active = FIO___IO.tick;
  FIO_LIST_REMOVE(&io->node); /* timeout IO ordering */
  FIO_LIST_PUSH(&io->pr->reserved.ios, &io->node);
  fio___io_free2(io);
  (void)ignr_;
}

/* Resets a socket's timeout counter. */
SFUNC void fio_io_touch(fio_io_s *io) {
  if (!(fio_atomic_or(&io->flags, FIO___IO_FLAG_TOUCH) & FIO___IO_FLAG_TOUCH))
    fio_queue_push_urgent(&FIO___IO.queue, fio___io_touch, fio___io_dup2(io));
}

/**
 * Reads data to the buffer, if any data exists. Returns the number of bytes
 * read.
 *
 * NOTE: zero (`0`) is a valid return value meaning no data was available.
 */
SFUNC size_t fio_io_read(fio_io_s *io, void *buf, size_t len) {
  if (!io)
    return 0;
  ssize_t r = io->pr->io_functions.read(io->fd, buf, len, io->tls);
  if (r > 0) {
#if FIO_IO_COUNT_STORAGE
    io->total_recieved += r;
#endif
    fio_io_touch(io);
    return r;
  }
  if ((unsigned)(!len) |
      ((unsigned)(r == -1) & ((unsigned)(errno == EAGAIN) |
                              (errno == EWOULDBLOCK) | (errno == EINTR))))
    return 0;
  fio_io_close(io);
  return 0;
}

FIO_SFUNC void fio___io_write2_dealloc_task(void *fn, void *data) {
  union {
    void *ptr;
    void (*fn)(void *);
  } u = {.ptr = fn};
  u.fn(data);
}

FIO_SFUNC void fio___io_write2(void *io_, void *packet_) {
  fio_io_s *io = (fio_io_s *)io_;
  fio_stream_packet_s *packet = (fio_stream_packet_s *)packet_;
  if (!(io->flags & FIO___IO_FLAG_OPEN))
    goto io_closed;

  fio_stream_add(&io->out, packet);
  fio___io_poll_on_ready_schd((void *)io);
  fio___io_free2(io);
  return;

io_closed:
  FIO_LOG_DEBUG2("(%d) write task to closed IO %d failed (task too late).",
                 fio_io_pid(),
                 fio_io_fd(io));
  fio_stream_packet_free(packet);
  fio___io_free2(io);
}

void fio_io_write2___(void);
/**
 * Writes data to the outgoing buffer and schedules the buffer to be sent.
 */
SFUNC void fio_io_write2 FIO_NOOP(fio_io_s *io, fio_io_write_args_s args) {
  fio_stream_packet_s *packet = NULL;
  if (!io)
    goto io_error_null;
  if (args.buf) {
    packet = fio_stream_pack_data(args.buf,
                                  args.len,
                                  args.offset,
                                  args.copy,
                                  args.dealloc);
  } else if ((unsigned)(args.fd + 1) > 1) {
    packet = fio_stream_pack_fd((int)args.fd, args.len, args.offset, args.copy);
  } else /* fio_io_write2 called without data */
    goto do_nothing;
  if (!packet)
    goto error;
  if ((io->flags & FIO___IO_FLAG_CLOSE))
    goto write_called_after_close;
  fio_io_defer(fio___io_write2, (void *)fio___io_dup2(io), (void *)packet);
  return;

error: /* note: `dealloc` already called by the `fio_stream` error handler. */
  FIO_LOG_ERROR(
      "(%d) couldn't create %zu bytes long user-packet for IO %p (%d)",
      fio_io_pid(),
      args.len,
      (void *)io,
      (io ? io->fd : -1));
  return;

write_called_after_close:
  FIO_LOG_DEBUG2("(%d) `write` called after `close` was called for IO.",
                 fio_io_pid());
  {
    union {
      void *ptr;
      void (*fn)(fio_stream_packet_s *);
    } u = {.fn = fio_stream_pack_free};
    fio___io_defer_no_wakeup(fio___io_write2_dealloc_task, u.ptr, packet);
  }
  return;

io_error_null:
  FIO_LOG_ERROR("(%d) `fio_write2` called for invalid IO (NULL)", FIO___IO.pid);
do_nothing:
  if (args.dealloc) {
    union {
      void *ptr;
      void (*fn)(void *);
    } u = {.fn = args.dealloc};
    fio___io_defer_no_wakeup(fio___io_write2_dealloc_task, u.ptr, args.buf);
    if ((unsigned)(args.fd + 1) > 1)
      close((int)args.fd);
  }
}

/** Marks the IO for closure as soon as scheduled data was sent. */
SFUNC void fio_io_close(fio_io_s *io) {
  if (io && (io->flags & FIO___IO_FLAG_OPEN) &&
      !(FIO___IO_FLAG_SET(io, FIO___IO_FLAG_CLOSE) & FIO___IO_FLAG_CLOSE)) {
    FIO_LOG_DDEBUG2("(%d) scheduling IO %p (fd %d) for closure",
                    fio_io_pid(),
                    (void *)io,
                    io->fd);
    fio___io_poll_on_ready_schd((void *)io);
  }
}

/** Marks the IO for immediate closure. */
SFUNC void fio_io_close_now(fio_io_s *io) {
  if (!io)
    return;
  FIO_LOG_DDEBUG2("(%d) pre-destruction close called for fd %d",
                  fio_io_pid(),
                  fio_io_fd(io));
  FIO___IO_FLAG_SET(io, FIO___IO_FLAG_CLOSE);
  if ((FIO___IO_FLAG_UNSET(io, FIO___IO_FLAG_OPEN) & FIO___IO_FLAG_OPEN))
    fio_io_free(io);
}

/**
 * Increases a IO's reference count, so it won't be automatically destroyed
 * when all tasks have completed.
 *
 * Use this function in order to use the IO outside of a scheduled task.
 *
 * This function is thread-safe.
 */
SFUNC fio_io_s *fio_io_dup(fio_io_s *io) { return fio___io_dup2(io); }

SFUNC void fio___io_free_task(void *io_, void *ignr_) {
  fio___io_free2((fio_io_s *)io_);
  (void)ignr_;
}
/** Free IO (reference) - thread-safe */
SFUNC void fio_io_free(fio_io_s *io) {
  fio___io_defer_no_wakeup(fio___io_free_task, (void *)io, NULL);
}

/** Suspends future "on_data" events for the IO. */
SFUNC void fio_io_suspend(fio_io_s *io) {
  FIO___IO_FLAG_SET(io, FIO___IO_FLAG_SUSPENDED);
}

SFUNC void fio___io_unsuspend(void *io_, void *ignr_) {
  fio_io_s *io = (fio_io_s *)io_;
  if (FIO___IO.stop)
    fio_io_close(io);
  else
    fio___io_monitor_in(io);
  return;
  (void)ignr_;
}

/** Listens for future "on_data" events related to the IO. */
SFUNC void fio_io_unsuspend(fio_io_s *io) {
  if ((FIO___IO_FLAG_UNSET(io, FIO___IO_FLAG_SUSPENDED) &
       FIO___IO_FLAG_SUSPENDED))
    fio_io_defer(fio___io_unsuspend, (void *)io, NULL);
}

/** Returns 1 if the IO handle was suspended. */
SFUNC int fio_io_is_suspended(fio_io_s *io) {
  return (int)((io->flags & FIO___IO_FLAG_SUSPENDED) / FIO___IO_FLAG_SUSPENDED);
}

/** Returns 1 if the IO handle is marked as open. */
SFUNC int fio_io_is_open(fio_io_s *io) {
  return (int)((io->flags & FIO___IO_FLAG_OPEN) / FIO___IO_FLAG_OPEN);
}

/** Returns the approximate number of bytes in the outgoing buffer. */
SFUNC size_t fio_io_backlog(fio_io_s *io) {
  return fio_stream_length(&io->out);
}

/* *****************************************************************************
Connection Object Links / Environment
***************************************************************************** */

void *fio_io_env_get___(void); /* IDE Marker */
/** Returns the named `udata` associated with the IO object (or `NULL`). */
SFUNC void *fio_io_env_get FIO_NOOP(fio_io_s *io, fio_io_env_get_args_s a) {
  fio___io_env_safe_s *e = io ? &io->env : &FIO___IO.env;
  return fio___io_env_safe_get(e, a.name.buf, a.name.len, a.type);
}

void fio_io_env_set___(void); /* IDE Marker */
/** Links an object to a connection's lifetime / environment. */
SFUNC void fio_io_env_set FIO_NOOP(fio_io_s *io, fio_io_env_set_args_s a) {
  fio___io_env_safe_s *e = io ? &io->env : &FIO___IO.env;
  fio___io_env_safe_set(e,
                        a.name.buf,
                        a.name.len,
                        a.type,
                        (fio___io_env_obj_s){.on_close = a.on_close, a.udata},
                        a.const_name);
}

int fio_io_env_unset___(void); /* IDE Marker */
/** Un-links an object from the connection's lifetime, so it's `on_close` */
SFUNC int fio_io_env_unset FIO_NOOP(fio_io_s *io, fio_io_env_get_args_s a) {
  fio___io_env_safe_s *e = io ? &io->env : &FIO___IO.env;
  return fio___io_env_safe_unset(e, a.name.buf, a.name.len, a.type);
}

int fio_io_env_remove___(void); /* IDE Marker */
/**
 * Removes an object from the connection's lifetime / environment, calling it's
 * `on_close` callback as if the connection was closed.
 */
SFUNC int fio_io_env_remove FIO_NOOP(fio_io_s *io, fio_io_env_get_args_s a) {
  fio___io_env_safe_s *e = io ? &io->env : &FIO___IO.env;
  return fio___io_env_safe_remove(e, a.name.buf, a.name.len, a.type);
}

/* *****************************************************************************
Event handling
***************************************************************************** */

static void fio___io_poll_on_data(void *io_, void *ignr_) {
  (void)ignr_;
  fio_io_s *io = (fio_io_s *)io_;
  FIO___IO_FLAG_UNSET(io, FIO___IO_FLAG_POLLIN_SET);
  if (!(io->flags & FIO___IO_FLAG_PREVENT_ON_DATA)) {
    /* this also tests for the suspended / throttled flags, allows closed */
    io->pr->on_data(io);
    fio___io_monitor_in(io);
  } else if ((io->flags & FIO___IO_FLAG_OPEN)) {
    fio___io_monitor_out(io);
  }
  fio___io_free2(io);
  return;
}

static void fio___io_poll_on_ready(void *io_, void *ignr_) {
  (void)ignr_;
#if defined(DEBUG) && DEBUG
  errno = 0;
#endif
  fio_io_s *io = (fio_io_s *)io_;
  char buf_mem[FIO_IO_BUFFER_PER_WRITE];
  size_t total = 0;
  FIO___IO_FLAG_UNSET(io,
                      (FIO___IO_FLAG_POLLOUT_SET | FIO___IO_FLAG_WRITE_SCHD));
  FIO_LOG_DDEBUG2("(%d) poll_on_ready callback for fd %d",
                  fio_io_pid(),
                  fio_io_fd(io));
  if (!(io->flags & FIO___IO_FLAG_OPEN))
    goto finish;
  for (;;) {
    size_t len = FIO_IO_BUFFER_PER_WRITE;
    char *buf = buf_mem;
    fio_stream_read(&io->out, &buf, &len);
    if (!len)
      break;
    ssize_t r = io->pr->io_functions.write(io->fd, buf, len, io->tls);
    if (r > 0) {
      FIO_LOG_DDEBUG2("(%d) written %zu bytes to fd %d",
                      FIO___IO.pid,
                      (size_t)r,
                      io->fd);
      total += r;
      fio_stream_advance(&io->out, r);
      continue;
    }
    if (r == -1) {
      if ((errno == EWOULDBLOCK) || (errno == EAGAIN))
        break;
      if (errno == EINTR)
        continue;
    }
    goto connection_error;
  }
  if (total) {
    fio___io_touch((void *)fio___io_dup2(io), NULL);
#if FIO_IO_COUNT_STORAGE
    io->total_sent += total;
#endif
  }
  if (fio_stream_any(&io->out) || io->pr->io_functions.flush(io->fd, io->tls)) {
    if (fio_stream_length(&io->out) >= FIO_IO_THROTTLE_LIMIT) {
      if (!(io->flags & FIO___IO_FLAG_THROTTLED))
        FIO_LOG_DDEBUG2("(%d), throttled IO %p (fd %d)",
                        FIO___IO.pid,
                        (void *)io,
                        io->fd);
      FIO___IO_FLAG_SET(io, FIO___IO_FLAG_THROTTLED);
    }
    fio___io_monitor_out(io);
  } else if ((io->flags & FIO___IO_FLAG_CLOSE)) {
    io->pr->io_functions.finish(io->fd, io->tls);
    fio_io_close_now(io);
  } else {
    if ((io->flags & FIO___IO_FLAG_THROTTLED)) {
      FIO___IO_FLAG_UNSET(io, FIO___IO_FLAG_THROTTLED);
      fio___io_monitor_in(io);
    }
    FIO_LOG_DDEBUG2("(%d) calling on_ready for %p (fd %d) - %zu data left.",
                    FIO___IO.pid,
                    (void *)io,
                    io->fd,
                    fio_stream_length(&io->out));
    io->pr->on_ready(io);
  }

finish:
  fio___io_free2(io);
  return;

connection_error:
#if defined(DEBUG) && DEBUG
  if (fio_stream_any(&io->out))
    FIO_LOG_DERROR(
        "(%d) IO write failed (%d), disconnecting: %p (fd %d)\n\tError: %s",
        FIO___IO.pid,
        errno,
        (void *)io,
        io->fd,
        strerror(errno));
#endif
  fio_io_close_now(io);
  fio___io_free2(io);
}

// static void fio___io_poll_on_close_task(void *io_, void *ignr_) {
//   (void)ignr_;
//   fio_io_s *io = (fio_io_s *)io_;
//   fio_io_close_now(io);
//   fio___io_free2(io);
// }

static void fio___io_poll_on_close(void *io_, void *ignr_) {
  (void)ignr_;
  fio_io_s *io = (fio_io_s *)io_;
  if (!(io->flags & FIO___IO_FLAG_CLOSE)) {
    FIO___IO_FLAG_SET(io, FIO___IO_FLAG_CLOSE_REMOTE);
    FIO_LOG_DEBUG2("(%d) fd %d closed by remote peer", FIO___IO.pid, io->fd);
  }
  /* allow on_data tasks to complete before closing? */
  fio_io_close_now(io);
  fio___io_free2(io);
}

static void fio___io_poll_on_timeout(void *io_, void *ignr_) {
  (void)ignr_;
  fio_io_s *io = (fio_io_s *)io_;
  io->pr->on_timeout(io);
  fio___io_free2(io);
}

/* *****************************************************************************
Event scheduling
***************************************************************************** */

static void fio___io_poll_on_data_schd(void *io) {
  FIO_LOG_DDEBUG2("(%d) `on_data` scheduled for fd %d.",
                  fio_io_pid(),
                  fio_io_fd((fio_io_s *)io));
  // FIO___IO_FLAG_POLLIN_SET
  fio___io_defer_no_wakeup(fio___io_poll_on_data,
                           (void *)fio___io_dup2((fio_io_s *)io),
                           NULL);
}
static void fio___io_poll_on_ready_schd(void *io) {
  if (!(FIO___IO_FLAG_SET((fio_io_s *)io, FIO___IO_FLAG_WRITE_SCHD) &
        FIO___IO_FLAG_WRITE_SCHD)) {
    FIO_LOG_DDEBUG2("(%d) `on_ready` scheduled for fd %d.",
                    fio_io_pid(),
                    fio_io_fd((fio_io_s *)io));
    fio___io_defer_no_wakeup(fio___io_poll_on_ready,
                             (void *)fio___io_dup2((fio_io_s *)io),
                             NULL);
  }
}
static void fio___io_poll_on_close_schd(void *io) {
  FIO_LOG_DDEBUG2("(%d) remote closure for fd %d.",
                  fio_io_pid(),
                  fio_io_fd((fio_io_s *)io));
  fio___io_defer_no_wakeup(fio___io_poll_on_close,
                           (void *)fio___io_dup2((fio_io_s *)io),
                           NULL);
}

/* *****************************************************************************
Timeout Review
***************************************************************************** */

/** Schedules the timeout event for any timed out IO object */
static int fio___io_review_timeouts(void) {
  int c = 0;
  static time_t last_to_review = 0;
  /* test timeouts at whole second intervals */
  if (last_to_review + 1000 > FIO___IO.tick)
    return c;
  last_to_review = FIO___IO.tick;
  const int64_t now_milli = FIO___IO.tick;

  FIO_LIST_EACH(fio_io_protocol_s,
                reserved.protocols,
                &FIO___IO.protocols,
                pr) {
    FIO_ASSERT_DEBUG(pr->reserved.flags, "protocol object flags unmarked?!");
    if (!pr->timeout || pr->timeout > FIO_IO_TIMEOUT_MAX)
      pr->timeout = FIO_IO_TIMEOUT_MAX;
    int64_t limit = now_milli - ((int64_t)pr->timeout);
    FIO_LIST_EACH(fio_io_s, node, &pr->reserved.ios, io) {
      FIO_ASSERT_DEBUG(io->pr == pr, "IO protocol ownership error");
      if (io->active >= limit)
        break;
      FIO_LOG_DDEBUG2("(%d) scheduling timeout for %p (fd %d)",
                      FIO___IO.pid,
                      (void *)io,
                      io->fd);
      fio___io_defer_no_wakeup(fio___io_poll_on_timeout,
                               (void *)fio___io_dup2(io),
                               NULL);
      ++c;
    }
  }
  return c;
}

/* *****************************************************************************
Wakeup Protocol
***************************************************************************** */

FIO_SFUNC void fio___io_wakeup_cb(fio_io_s *io) {
  char buf[512];
  ssize_t r = fio_sock_read(fio_io_fd(io), buf, 512);
  (void)r;
  FIO_LOG_DDEBUG2("(%d) fio___io_wakeup called", FIO___IO.pid);
  FIO___IO_FLAG_UNSET(&FIO___IO, FIO___IO_FLAG_WAKEUP);
}
FIO_SFUNC void fio___io_wakeup_on_close(void *ignr1_, void *ignr2_) {
  fio_sock_close(FIO___IO.wakeup_fd);
  FIO___IO.wakeup = NULL;
  FIO___IO.wakeup_fd = -1;
  FIO_LOG_DDEBUG2("(%d) fio___io_wakeup destroyed", FIO___IO.pid);
  (void)ignr1_, (void)ignr2_;
}

FIO_SFUNC void fio___io_wakeup(void) {
  if (!FIO___IO.wakeup || (FIO___IO_FLAG_SET(&FIO___IO, FIO___IO_FLAG_WAKEUP) &
                           FIO___IO_FLAG_WAKEUP))
    return;
  char buf[1] = {(char)~0};
  ssize_t ignr = fio_sock_write(FIO___IO.wakeup_fd, buf, 1);
  (void)ignr;
}

static fio_io_protocol_s FIO___IO_WAKEUP_PROTOCOL = {
    .on_data = fio___io_wakeup_cb,
    .on_close = fio___io_wakeup_on_close,
    .on_timeout = fio_io_touch,
};

FIO_SFUNC void fio___io_wakeup_init(void) {
  if (FIO___IO.wakeup)
    return;
  int fds[2];
  if (pipe(fds)) {
    FIO_LOG_ERROR("(%d) couldn't open wakeup pipes, fio___io_wakeup disabled.",
                  FIO___IO.pid);
    return;
  }
  fio_sock_set_non_block(fds[0]);
  fio_sock_set_non_block(fds[1]);
  FIO___IO.wakeup_fd = fds[1];
  FIO___IO.wakeup = fio_io_attach_fd(fds[0],
                                     &FIO___IO_WAKEUP_PROTOCOL,
                                     (void *)(uintptr_t)fds[1],
                                     NULL);
  FIO_LOG_DDEBUG2("(%d) fio___io_wakeup initialized", FIO___IO.pid);
}

/* *****************************************************************************
TLS Context Type and Helpers
***************************************************************************** */

typedef struct {
  fio_keystr_s nm;
  void (*fn)(fio_io_s *);
} fio___io_tls_alpn_s;

typedef struct {
  fio_keystr_s nm;
  fio_keystr_s public_cert_file;
  fio_keystr_s private_key_file;
  fio_keystr_s pk_password;
} fio___io_tls_cert_s;

typedef struct {
  fio_keystr_s nm;
} fio___io_tls_trust_s;

#undef FIO_TYPEDEF_IMAP_REALLOC
#undef FIO_TYPEDEF_IMAP_FREE
#undef FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE
#define FIO_TYPEDEF_IMAP_REALLOC(p, size_old, size, copy) realloc(p, size)
#define FIO_TYPEDEF_IMAP_FREE(ptr, len)                   free(ptr)
#define FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE                  0

#define FIO___IO_ALPN_HASH(o)   ((uint16_t)fio_keystr_hash(o->nm))
#define FIO___IO_ALPN_CMP(a, b) fio_keystr_is_eq(a->nm, b->nm)
#define FIO___IO_ALPN_VALID(o)  fio_keystr_buf(&o->nm).len

FIO_TYPEDEF_IMAP_ARRAY(fio___io_tls_alpn_map,
                       fio___io_tls_alpn_s,
                       uint16_t,
                       FIO___IO_ALPN_HASH,
                       FIO___IO_ALPN_CMP,
                       FIO___IO_ALPN_VALID)
FIO_TYPEDEF_IMAP_ARRAY(fio___io_tls_trust_map,
                       fio___io_tls_trust_s,
                       uint16_t,
                       FIO___IO_ALPN_HASH,
                       FIO___IO_ALPN_CMP,
                       FIO___IO_ALPN_VALID)
FIO_TYPEDEF_IMAP_ARRAY(fio___io_tls_cert_map,
                       fio___io_tls_cert_s,
                       uint16_t,
                       FIO___IO_ALPN_HASH,
                       FIO___IO_ALPN_CMP,
                       FIO_IMAP_ALWAYS_VALID)

#undef FIO___IO_ALPN_HASH
#undef FIO___IO_ALPN_CMP
#undef FIO___IO_ALPN_VALID
#undef FIO_TYPEDEF_IMAP_REALLOC
#undef FIO_TYPEDEF_IMAP_FREE
#undef FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE
#define FIO_TYPEDEF_IMAP_REALLOC         FIO_MEM_REALLOC
#define FIO_TYPEDEF_IMAP_FREE            FIO_MEM_FREE
#define FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE FIO_MEM_REALLOC_IS_SAFE

struct fio_io_tls_s {
  fio___io_tls_cert_map_s cert;
  fio___io_tls_alpn_map_s alpn;
  fio___io_tls_trust_map_s trust;
  uint8_t trust_sys; /** Set to 1 if system certificate registry is trusted */
};

#define FIO___RECURSIVE_INCLUDE 1
#define FIO_REF_NAME            fio_io_tls
#define FIO_REF_DESTROY(tls)                                                   \
  do {                                                                         \
    FIO_IMAP_EACH(fio___io_tls_alpn_map, &tls.alpn, i) {                       \
      fio_keystr_destroy(&tls.alpn.ary[i].nm, FIO_STRING_FREE_KEY);            \
    }                                                                          \
    FIO_IMAP_EACH(fio___io_tls_trust_map, &tls.trust, i) {                     \
      fio_keystr_destroy(&tls.trust.ary[i].nm, FIO_STRING_FREE_KEY);           \
    }                                                                          \
    FIO_IMAP_EACH(fio___io_tls_cert_map, &tls.cert, i) {                       \
      fio_keystr_destroy(&tls.cert.ary[i].nm, FIO_STRING_FREE_KEY);            \
      fio_keystr_destroy(&tls.cert.ary[i].public_cert_file,                    \
                         FIO_STRING_FREE_KEY);                                 \
      fio_keystr_destroy(&tls.cert.ary[i].private_key_file,                    \
                         FIO_STRING_FREE_KEY);                                 \
      fio_keystr_destroy(&tls.cert.ary[i].pk_password, FIO_STRING_FREE_KEY);   \
    }                                                                          \
    fio___io_tls_alpn_map_destroy(&tls.alpn);                                  \
    fio___io_tls_trust_map_destroy(&tls.trust);                                \
    fio___io_tls_cert_map_destroy(&tls.cert);                                  \
  } while (0)
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

/** Performs a `new` operation, returning a new `fio_io_tls_s` context. */
SFUNC fio_io_tls_s *fio_io_tls_new(void) {
  fio_io_tls_s *r = fio_io_tls_new2();
  FIO_ASSERT_ALLOC(r);
  *r = (fio_io_tls_s){.trust_sys = 0};
  return r;
}

/** Performs a `dup` operation, increasing the object's reference count. */
SFUNC fio_io_tls_s *fio_io_tls_dup(fio_io_tls_s *tls) {
  return fio_io_tls_dup2(tls);
}

/** Performs a `free` operation, reducing the reference count and freeing. */
SFUNC void fio_io_tls_free(fio_io_tls_s *tls) {
  if (!tls)
    return;
  fio_io_tls_free2(tls);
}

/** Takes a parsed URL and optional TLS target and returns a TLS if needed. */
SFUNC fio_io_tls_s *fio_io_tls_from_url(fio_io_tls_s *tls, fio_url_s url) {
  /* test for TLS info in URL */
  fio_url_tls_info_s tls_info = fio_url_is_tls(url);
  if (!tls_info.tls)
    return tls;

  if (!tls && tls_info.tls)
    tls = fio_io_tls_new();

  if (tls_info.key.buf && tls_info.cert.buf) {
    const char *tmp = NULL;
    FIO_STR_INFO_TMP_VAR(host_tmp, 512);
    FIO_STR_INFO_TMP_VAR(key_tmp, 128);
    FIO_STR_INFO_TMP_VAR(cert_tmp, 128);
    FIO_STR_INFO_TMP_VAR(pass_tmp, 128);
    if (url.host.len < 512 && url.host.buf)
      fio_string_write(&host_tmp, NULL, url.host.buf, url.host.len);
    else
      host_tmp.buf = NULL;

    if (tls_info.key.len < 124 && tls_info.cert.len < 124 &&
        tls_info.pass.len < 124) {
      fio_string_write(&key_tmp, NULL, tls_info.key.buf, tls_info.key.len);
      fio_string_write(&cert_tmp, NULL, tls_info.cert.buf, tls_info.cert.len);
      if (tls_info.pass.len)
        fio_string_write(&pass_tmp, NULL, tls_info.pass.buf, tls_info.pass.len);
      else
        pass_tmp.buf = NULL;

      if (tls_info.key.buf ==
          tls_info.cert.buf) { /* assume value is prefix / folder */
        if ((tmp = getenv(cert_tmp.buf))) {
          fio_buf_info_s buf_tmp = FIO_BUF_INFO1((char *)tmp);
          if (buf_tmp.len < 124) {
            key_tmp.len = cert_tmp.len = buf_tmp.len;
            FIO_MEMCPY(key_tmp.buf, buf_tmp.buf, buf_tmp.len);
            FIO_MEMCPY(cert_tmp.buf, buf_tmp.buf, buf_tmp.len);
          }
        }
        fio_string_write(&key_tmp, NULL, "key.pem", 7);
        fio_string_write(&cert_tmp, NULL, "cert.pem", 8);
      } else {
        if ((tmp = getenv(key_tmp.buf))) {
          fio_buf_info_s buf_tmp = FIO_BUF_INFO1((char *)tmp);
          if (buf_tmp.len < 124) {
            key_tmp.len = buf_tmp.len;
            FIO_MEMCPY(key_tmp.buf, buf_tmp.buf, buf_tmp.len);
          }
        }

        if ((tmp = getenv(cert_tmp.buf))) {
          fio_buf_info_s buf_tmp = FIO_BUF_INFO1((char *)tmp);
          if (buf_tmp.len < 124) {
            cert_tmp.len = buf_tmp.len;
            FIO_MEMCPY(cert_tmp.buf, buf_tmp.buf, buf_tmp.len);
          }
        }

        if (tls_info.key.len < 5 ||
            (fio_buf2u32u(tls_info.key.buf + (tls_info.key.len - 4)) |
             0x20202020UL) != fio_buf2u32u(".pem")) {
          fio_string_write(&key_tmp, NULL, ".pem", 4);
        }
        if (tls_info.cert.len < 5 ||
            (fio_buf2u32u(tls_info.cert.buf + (tls_info.cert.len - 4)) |
             0x20202020UL) != fio_buf2u32u(".pem")) {
          fio_string_write(&cert_tmp, NULL, ".pem", 4);
        }
      }
      fio_io_tls_cert_add(tls,
                          host_tmp.buf,
                          cert_tmp.buf,
                          key_tmp.buf,
                          pass_tmp.buf);
    } else {
      FIO_LOG_ERROR("TLS files in `fio_io_listen` URL too long, "
                    "construct TLS object separately");
    }
  }
  return tls;
}

/** Adds a certificate a new SSL/TLS context / settings object (SNI support). */
SFUNC fio_io_tls_s *fio_io_tls_cert_add(fio_io_tls_s *t,
                                        const char *server_name,
                                        const char *public_cert_file,
                                        const char *private_key_file,
                                        const char *pk_password) {
  if (!t)
    return t;
  fio___io_tls_cert_s o = {
      .nm = fio_keystr_init(FIO_STR_INFO1((char *)server_name),
                            FIO_STRING_ALLOC_KEY),
      .public_cert_file =
          fio_keystr_init(FIO_STR_INFO1((char *)public_cert_file),
                          FIO_STRING_ALLOC_KEY),
      .private_key_file =
          fio_keystr_init(FIO_STR_INFO1((char *)private_key_file),
                          FIO_STRING_ALLOC_KEY),
      .pk_password = fio_keystr_init(FIO_STR_INFO1((char *)pk_password),
                                     FIO_STRING_ALLOC_KEY),
  };
  fio___io_tls_cert_s *old = fio___io_tls_cert_map_get(&t->cert, o);
  if (old)
    goto replace_old;
  fio___io_tls_cert_map_set(&t->cert, o, 1);
  return t;
replace_old:
  fio_keystr_destroy(&old->nm, FIO_STRING_FREE_KEY);
  fio_keystr_destroy(&old->public_cert_file, FIO_STRING_FREE_KEY);
  fio_keystr_destroy(&old->private_key_file, FIO_STRING_FREE_KEY);
  fio_keystr_destroy(&old->pk_password, FIO_STRING_FREE_KEY);
  *old = o;
  return t;
}

/**
 * Adds an ALPN protocol callback to the SSL/TLS context.
 *
 * The first protocol added will act as the default protocol to be selected.
 *
 * Except for the `tls` and `protocol_name` arguments, all arguments can be
 * NULL.
 */
SFUNC fio_io_tls_s *fio_io_tls_alpn_add(fio_io_tls_s *t,
                                        const char *protocol_name,
                                        void (*on_selected)(fio_io_s *)) {
  if (!t || !protocol_name)
    return t;
  if (!on_selected)
    on_selected = fio_io_noop;
  size_t pr_name_len = strlen(protocol_name);
  if (pr_name_len > 255) {
    FIO_LOG_ERROR(
        "fio_io_tls_alpn_add called with name longer than 255 chars!");
    return t;
  }
  fio___io_tls_alpn_s o = {
      .nm = fio_keystr_init(FIO_STR_INFO2((char *)protocol_name, pr_name_len),
                            FIO_STRING_ALLOC_KEY),
      .fn = on_selected,
  };
  fio___io_tls_alpn_s *old = fio___io_tls_alpn_map_get(&t->alpn, o);
  if (old)
    goto replace_old;
  fio___io_tls_alpn_map_set(&t->alpn, o, 1);
  return t;
replace_old:
  fio_keystr_destroy(&old->nm, FIO_STRING_FREE_KEY);
  *old = o;
  return t;
}

/** Calls the `on_selected` callback for the `fio_io_tls_s` object. */
SFUNC int fio_io_tls_alpn_select(fio_io_tls_s *t,
                                 const char *protocol_name,
                                 size_t name_length,
                                 fio_io_s *io) {
  if (!t || !protocol_name)
    return -1;
  fio___io_tls_alpn_s seeking = {
      .nm = fio_keystr_tmp(protocol_name, (uint32_t)name_length)};
  fio___io_tls_alpn_s *alpn = fio___io_tls_alpn_map_get(&t->alpn, seeking);
  if (!alpn) {
    FIO_LOG_DDEBUG2("TLS ALPN %.*s not found in %zu long list",
                    (int)name_length,
                    protocol_name,
                    t->alpn.count);
    return -1;
  }
  alpn->fn(io);
  return 0;
}

/**
 * Adds a certificate to the "trust" list, which automatically adds a peer
 * verification requirement.
 *
 * If `public_cert_file` is `NULL`, adds the system's default trust registry.
 *
 * Note: when the `fio_io_tls_s` object is used for server connections, this
 * will limit connections to clients that connect using a trusted certificate.
 *
 *      fio_io_tls_trust_add(tls, "google-ca.pem" );
 */
SFUNC fio_io_tls_s *fio_io_tls_trust_add(fio_io_tls_s *t,
                                         const char *public_cert_file) {
  if (!t)
    return t;
  if (!public_cert_file) {
    t->trust_sys = 1;
    return t;
  }
  fio___io_tls_trust_s o = {
      .nm = fio_keystr_init(FIO_STR_INFO1((char *)public_cert_file),
                            FIO_STRING_ALLOC_KEY),
  };
  fio___io_tls_trust_s *old = fio___io_tls_trust_map_get(&t->trust, o);
  if (old)
    goto replace_old;
  fio___io_tls_trust_map_set(&t->trust, o, 1);
  return t;
replace_old:
  fio_keystr_destroy(&old->nm, FIO_STRING_FREE_KEY);
  *old = o;
  return t;
}

/**
 * Returns the number of `fio_io_tls_cert_add` instructions.
 *
 * This could be used when deciding if to add a NULL instruction (self-signed).
 *
 * If `fio_io_tls_cert_add` was never called, zero (0) is returned.
 */
SFUNC uintptr_t fio_io_tls_cert_count(fio_io_tls_s *tls) {
  return tls ? tls->cert.count : 0;
}

/**
 * Returns the number of registered ALPN protocol names.
 *
 * This could be used when deciding if protocol selection should be delegated to
 * the ALPN mechanism, or whether a protocol should be immediately assigned.
 *
 * If no ALPN protocols are registered, zero (0) is returned.
 */
SFUNC uintptr_t fio_io_tls_alpn_count(fio_io_tls_s *tls) {
  return tls ? tls->alpn.count : 0;
}

/**
 * Returns the number of `fio_io_tls_trust_add` instructions.
 *
 * This could be used when deciding if to disable peer verification or not.
 *
 * If `fio_io_tls_trust_add` was never called, zero (0) is returned.
 */
SFUNC uintptr_t fio_io_tls_trust_count(fio_io_tls_s *tls) {
  return tls ? tls->trust.count : 0;
}

/** Calls callbacks for certificate, trust certificate and ALPN added. */
void fio_io_tls_each___(void); /* IDE Marker*/
SFUNC int fio_io_tls_each FIO_NOOP(fio_io_tls_each_s a) {
  if (!a.tls)
    return -1;
  if (a.each_cert) {
    FIO_IMAP_EACH(fio___io_tls_cert_map, &a.tls->cert, i) {
      if (a.each_cert(&a,
                      fio_keystr_buf(&a.tls->cert.ary[i].nm).buf,
                      fio_keystr_buf(&a.tls->cert.ary[i].public_cert_file).buf,
                      fio_keystr_buf(&a.tls->cert.ary[i].private_key_file).buf,
                      fio_keystr_buf(&a.tls->cert.ary[i].pk_password).buf))
        return -1;
    }
  }
  if (a.each_alpn) {
    FIO_IMAP_EACH(fio___io_tls_alpn_map, &a.tls->alpn, i) {
      if (a.each_alpn(&a,
                      fio_keystr_buf(&a.tls->alpn.ary[i].nm).buf,
                      a.tls->alpn.ary[i].fn))
        return -1;
    }
  }
  if (a.each_trust) {
    if (a.tls->trust_sys && a.each_trust(&a, NULL))
      return -1;
    FIO_IMAP_EACH(fio___io_tls_trust_map, &a.tls->trust, i) {
      if (a.each_trust(&a, fio_keystr_buf(&a.tls->trust.ary[i].nm).buf))
        return -1;
    }
  }
  return 0;
}

/** If `NULL` returns current default, otherwise sets it. */
SFUNC fio_io_functions_s fio_io_tls_default_functions(fio_io_functions_s *f) {
  static fio_io_functions_s default_io_functions = {
      .build_context = fio___io_func_default_build_context,
      .start = fio_io_noop,
      .read = fio___io_func_default_read,
      .write = fio___io_func_default_write,
      .flush = fio___io_func_default_flush,
      .finish = fio___io_func_default_finish,
      .cleanup = fio___io_func_default_cleanup,
  };
  if (!f)
    return default_io_functions;
  if (!f->build_context)
    f->build_context = fio___io_func_default_build_context;
  if (!f->start)
    f->start = fio_io_noop;
  if (!f->read)
    f->read = fio___io_func_default_read;
  if (!f->write)
    f->write = fio___io_func_default_write;
  if (!f->flush)
    f->flush = fio___io_func_default_flush;
  if (!f->finish)
    f->finish = fio___io_func_default_finish;
  if (!f->cleanup)
    f->cleanup = fio___io_func_default_cleanup;
  default_io_functions = *f;
  return default_io_functions;
}

/* *****************************************************************************
IO Async Queues - Worker Threads for non-IO tasks
***************************************************************************** */

FIO_SFUNC void fio___io_async_start(fio_io_async_s *q) {
  if (!q->count)
    goto no_worker_threads;
  q->q = &q->queue;
  if (q->count > 4095)
    goto failed;
  fio_queue_workers_stop(&q->queue);
  if (fio_queue_workers_add(&q->queue, (size_t)q->count))
    goto failed;
  return;

failed:
  FIO_LOG_ERROR("IO Async Queue couldn't spawn threads!");
no_worker_threads:
  q->q = fio_io_queue();
  fio_queue_perform_all(&q->queue);
}
FIO_SFUNC void fio___io_async_stop(fio_io_async_s *q) {
  q->q = fio_io_queue();
  fio_queue_workers_stop(&q->queue);
  fio_queue_perform_all(&q->queue);
  fio_queue_destroy(&q->queue);
}

/**
 * Attaches an IO Async Queue for use in multi-threaded (non IO) tasks.
 *
 * This function can be called multiple times for the same (or other) queue, as
 * long as the async queue (`fio_io_async_s`) was previously initialized using
 * `FIO_IO_ASYN_INIT` or zeroed out. i.e.:
 *
 *     static fio_io_async_s SLOW_HTTP_TASKS = FIO_IO_ASYN_INIT;
 *     fio_io_async_attach(&SLOW_HTTP_TASKS, 32);
 */
SFUNC void fio_io_async_attach(fio_io_async_s *q, uint32_t threads) {
  if (!q)
    return;
  if (!q->node.next) {
    *q = (fio_io_async_s){
        .q = fio_io_queue(),
        .count = threads,
        .queue = FIO_QUEUE_STATIC_INIT(q->queue),
        .timers = FIO_TIMER_QUEUE_INIT,
        .node = FIO_LIST_INIT(q->node),
    };
    FIO_LIST_PUSH(&FIO___IO.async, &q->node);
  }
  q->count = threads;
  if (fio_io_is_running())
    fio___io_async_start(q);
}

void fio_io_async_every___(void); /* IDE Mark */
/** Schedules a timer bound task for the async queue (`fio_timer_schedule`). */
SFUNC void fio_io_async_every FIO_NOOP(fio_io_async_s *q,
                                       fio_timer_schedule_args_s a) {
  a.start_at = FIO___IO.tick;
  fio_timer_schedule FIO_NOOP(&q->timers, a);
}

/* *****************************************************************************
Managing data after a fork
***************************************************************************** */
FIO_SFUNC void fio___io_after_fork(void *ignr_) {
  (void)ignr_;
  FIO___IO.pid = fio_thread_getpid();
  FIO___IO.tick = FIO___IO_GET_TIME_MILLI();
  fio_queue_perform_all(&FIO___IO.queue);
  FIO_LIST_EACH(fio_io_protocol_s,
                reserved.protocols,
                &FIO___IO.protocols,
                pr) {
    FIO_LIST_EACH(fio_io_s, node, &pr->reserved.ios, io) {
      fio_io_close_now(io);
    }
  }
  fio_queue_perform_all(&FIO___IO.queue);
  fio_queue_destroy(&FIO___IO.queue);
  FIO___IO.pids = FIO_LIST_INIT(FIO___IO.pids);
}

FIO_SFUNC void fio___io_cleanup_at_exit(void *ignr_) {
#ifdef SIGKILL
  FIO_LIST_EACH(fio___io_pid_s, node, &FIO___IO.pids, w) {
    fio_thread_kill(w->pid, SIGKILL);
  }
#endif /* SIGKILL */
  FIO___LOCK_DESTROY(FIO___IO.lock);
  fio___io_after_fork(ignr_);
  fio_poll_destroy(&FIO___IO.poll);
  fio___io_env_safe_destroy(&FIO___IO.env);
  FIO___IO.tick = FIO___IO_GET_TIME_MILLI();
  fio_queue_perform_all(&FIO___IO.queue);
  fio_timer_destroy(&FIO___IO.timer);
  fio_queue_perform_all(&FIO___IO.queue);
}

/* *****************************************************************************
Initializing IO Reactor State
***************************************************************************** */
FIO_CONSTRUCTOR(fio___io) {
  fio_queue_init(&FIO___IO.queue);
  FIO___IO.protocols = FIO_LIST_INIT(FIO___IO.protocols);
  FIO___IO.tick = FIO___IO_GET_TIME_MILLI();
  FIO___IO.root_pid = FIO___IO.pid = fio_thread_getpid();
  FIO___IO.async = FIO_LIST_INIT(FIO___IO.async);
  FIO___IO.pids = FIO_LIST_INIT(FIO___IO.pids);
  fio___io_init_protocol(&FIO___IO_MOCK_PROTOCOL, 0);
  fio_poll_init(&FIO___IO.poll,
                .on_data = fio___io_poll_on_data_schd,
                .on_ready = fio___io_poll_on_ready_schd,
                .on_close = fio___io_poll_on_close_schd);
  fio___io_init_protocol_test(&FIO___IO_MOCK_PROTOCOL, 0);
  fio_state_callback_add(FIO_CALL_IN_CHILD, fio___io_after_fork, NULL);
  fio_state_callback_add(FIO_CALL_AT_EXIT, fio___io_cleanup_at_exit, NULL);
}

/* *****************************************************************************
IO Types Finish
***************************************************************************** */
#endif /* FIO_IO */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_IO                 /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************

              IO Reactor - an Evented IO Reactor, Single-Threaded

Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_IO) && !defined(FIO___RECURSIVE_INCLUDE) &&                    \
    !defined(H___FIO_IO_REACTOR___H) &&                                        \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN))
#define H___FIO_IO_REACTOR___H

/* *****************************************************************************
The IO Reactor Cycle (the actual work)
***************************************************************************** */

static void fio___io_signal_crash(int sig, void *flg) {
  FIO_LOG_FATAL("(%d) additional stop signal(!) - should crash.", FIO___IO.pid);
  fio_signal_forget(sig);

#ifdef SIGKILL
  /* cannot lock, signal may be received during critical section */
  FIO_LIST_EACH(fio___io_pid_s, node, &FIO___IO.pids, pos) {
    if (!pos->done)
      fio_thread_kill(pos->pid, SIGKILL);
  }
  fio_thread_kill(FIO___IO.root_pid, SIGKILL);
  fio_thread_kill(FIO___IO.pid, SIGKILL);
#endif
  exit(-1);
  (void)sig, (void)flg;
}

static void fio___io_signal_stop(int sig, void *flg) {
  FIO_LOG_INFO("(%d) stop signal detected.", FIO___IO.pid);
  fio_io_stop();
  if (fio_io_is_master())
    fio_signal_monitor(.sig = sig,
                       .callback = fio___io_signal_crash,
                       .udata = flg,
                       .propagate = 0,
                       .immediate = 1);
  (void)sig, (void)flg;
}

static void fio___io_signal_restart(int sig, void *flg) {
  if (fio_io_is_master())
    fio_io_restart(FIO___IO.workers);
  else {
    FIO_LOG_INFO("(%d) restart signal detected.", FIO___IO.pid);
    fio_io_stop();
  }
  (void)sig, (void)flg;
}

FIO_SFUNC void fio___io_tick(int timeout) {
  static size_t performed_idle = 0;
  size_t idle_round = (fio_poll_review(&FIO___IO.poll, timeout) == 0);
  performed_idle &= idle_round;
  idle_round &= (timeout > 0);
  idle_round ^= performed_idle;
  if ((idle_round & !FIO___IO.stop)) {
    fio_state_callback_force(FIO_CALL_ON_IDLE);
    performed_idle = 1;
  }
  FIO___IO.tick = FIO___IO_GET_TIME_MILLI();
  fio_timer_push2queue(&FIO___IO.queue, &FIO___IO.timer, FIO___IO.tick);
  FIO_LIST_EACH(fio_io_async_s, node, &FIO___IO.async, a) {
    fio_timer_push2queue(a->q, &a->timers, FIO___IO.tick);
  }
  for (size_t i = 0; i < 2048 && !fio_queue_perform(&FIO___IO.queue); ++i)
    ;
  fio___io_review_timeouts();
  fio_signal_review();
}

FIO_SFUNC void fio___io_run_async_as_sync(void *ignr_1, void *ignr_2) {
  (void)ignr_1, (void)ignr_2;
  unsigned repeat = 0;
  FIO_LIST_EACH(fio_io_async_s, node, &FIO___IO.async, pos) {
    fio_queue_task_s t = fio_queue_pop(&pos->queue);
    if (!t.fn)
      continue;
    t.fn(t.udata1, t.udata2);
    repeat = 1;
  }
  if (repeat)
    fio_queue_push(&FIO___IO.queue, fio___io_run_async_as_sync);
}

FIO_SFUNC void fio___io_shutdown_task(void *shutdown_start_, void *a2) {
  intptr_t shutdown_start =
      (intptr_t)shutdown_start_ + FIO___IO.shutdown_timeout;
  if (shutdown_start < FIO___IO.tick || FIO_LIST_IS_EMPTY(&FIO___IO.protocols))
    return;
  fio___io_tick(fio_queue_count(&FIO___IO.queue) ? 0 : 100);
  fio_queue_push(&FIO___IO.queue, fio___io_run_async_as_sync);
  fio_queue_push(&FIO___IO.queue, fio___io_shutdown_task, shutdown_start_, a2);
}

FIO_SFUNC void fio___io_shutdown(void) {
  /* collect tick for shutdown start, to monitor for possible timeout */
  int64_t shutdown_start = FIO___IO.tick = FIO___IO_GET_TIME_MILLI();
  size_t connected = 0;
  /* first notify that shutdown is starting */
  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);
  /* preform on_shutdown callback for each connection and close */
  FIO_LIST_EACH(fio_io_protocol_s,
                reserved.protocols,
                &FIO___IO.protocols,
                pr) {
    FIO_LIST_EACH(fio_io_s, node, &pr->reserved.ios, io) {
      pr->on_shutdown(io); /* TODO / FIX: move callback to task? */
      if (!(io->flags & FIO___IO_FLAG_SUSPENDED))
        fio_io_close(io); /* TODO / FIX: skip close on return value? */
      ++connected;
    }
  }
  FIO_LOG_DEBUG2("(%d) IO Reactor shutting down with %zu connected clients",
                 fio_io_pid(),
                 connected);
  /* cycle while connections exist. */
  fio_queue_push(&FIO___IO.queue,
                 fio___io_shutdown_task,
                 (void *)(intptr_t)shutdown_start,
                 NULL);
  fio_queue_perform_all(&FIO___IO.queue);
  /* in case of timeout, force close remaining connections. */
  connected = 0;
  FIO_LIST_EACH(fio_io_protocol_s,
                reserved.protocols,
                &FIO___IO.protocols,
                pr) {
    FIO_LIST_EACH(fio_io_s, node, &pr->reserved.ios, io) {
      fio_io_close_now(io);
      ++connected;
    }
  }
  FIO_LOG_DEBUG2("(%d) IO Reactor shutdown timeout/done with %zu clients",
                 fio_io_pid(),
                 connected);
  /* perform remaining tasks. */
  fio_queue_perform_all(&FIO___IO.queue);
}

FIO_SFUNC void fio___io_work_task(void *ignr_1, void *ignr_2) {
  if (FIO___IO.stop)
    goto no_run;
  fio___io_tick(fio_queue_count(&FIO___IO.queue) ? 0 : 500);
  fio_queue_push(&FIO___IO.queue, fio___io_work_task, ignr_1, ignr_2);
  return;
no_run:
  return;
}

FIO_SFUNC void fio___io_work(int is_worker) {
  FIO___IO.is_worker = is_worker;
  FIO_LIST_EACH(fio_io_async_s, node, &FIO___IO.async, q) {
    fio___io_async_start(q);
  }

  fio_queue_perform_all(&FIO___IO.queue);
  if (is_worker) {
    fio_state_callback_force(FIO_CALL_ON_START);
  }
  fio___io_wakeup_init();

  fio_queue_push(&FIO___IO.queue, fio___io_work_task);
  FIO___IO_FLAG_SET(&FIO___IO, FIO___IO_FLAG_CYCLING);
  fio_queue_perform_all(&FIO___IO.queue);
  FIO___IO_FLAG_UNSET(&FIO___IO, FIO___IO_FLAG_CYCLING);

  fio___io_shutdown();

  FIO_LIST_EACH(fio_io_async_s, node, &FIO___IO.async, q) {
    fio___io_async_stop(q);
  }
  /* signal all child workers to terminate, parent is going away. */
  FIO___LOCK_LOCK(FIO___IO.lock);
  FIO_LIST_EACH(fio___io_pid_s, node, &FIO___IO.pids, pos) {
    if (!pos->done)
      fio_thread_kill(pos->pid, SIGTERM);
  }
  FIO___LOCK_UNLOCK(FIO___IO.lock);

  fio_queue_perform_all(&FIO___IO.queue);
  fio_state_callback_force(FIO_CALL_ON_STOP);
  fio_queue_perform_all(&FIO___IO.queue);
  FIO___IO.workers = 0;
}

/* *****************************************************************************
Worker Forking
***************************************************************************** */
static void fio___io_spawn_workers_task(void *ignr_1, void *ignr_2);

static void fio___io_wait_for_worker(void *thr_) {
  fio_thread_t t = (fio_thread_t)thr_;
  fio_thread_join(&t);
}

/** Worker sentinel */
static void *fio___io_worker_sentinel(void *pid_data) {
#ifdef WEXITSTATUS
  fio___io_pid_s sentinal = {.pid = (fio_thread_pid_t)(uintptr_t)pid_data};
  int status = 0;
  (void)status;
  fio_thread_t thr = fio_thread_current();
  fio_state_callback_add(FIO_CALL_ON_STOP,
                         fio___io_wait_for_worker,
                         (void *)thr);

  FIO___LOCK_LOCK(FIO___IO.lock);
  FIO_LIST_PUSH(&FIO___IO.pids, &sentinal.node);
  FIO___LOCK_UNLOCK(FIO___IO.lock);

  if (fio_thread_waitpid(sentinal.pid, &status, 0) != sentinal.pid &&
      !FIO___IO.stop)
    FIO_LOG_ERROR("(%d) waitpid failed for %d, worker re-spawning might fail.",
                  fio_thread_getpid(),
                  sentinal.pid);
  sentinal.done = 1;
  FIO___LOCK_LOCK(FIO___IO.lock);
  FIO_LIST_REMOVE(&sentinal.node);
  FIO___LOCK_UNLOCK(FIO___IO.lock);

  if (!WIFEXITED(status) || WEXITSTATUS(status)) {
    FIO_LOG_WARNING("(%d) abnormal worker exit detected for %d",
                    FIO___IO.pid,
                    sentinal.pid);
    fio_state_callback_force(FIO_CALL_ON_CHILD_CRUSH);
  }
  if (!FIO___IO.stop && !sentinal.stop) {
    FIO_ASSERT_DEBUG(
        0,
        "DEBUG mode prevents worker re-spawning, now crashing parent.");
    fio_state_callback_remove(FIO_CALL_ON_STOP,
                              fio___io_wait_for_worker,
                              (void *)thr);
    fio_thread_detach(&thr);
    FIO_LOG_WARNING("(%d) worker exit detected, replacing worker %d",
                    FIO___IO.pid,
                    sentinal.pid);
    fio_atomic_add(&FIO___IO.to_spawn, (uint32_t)1);
    fio_queue_push_urgent(fio_io_queue(), fio___io_spawn_workers_task);
  }
#else /* Non POSIX? no `fork`? no fio_thread_waitpid? */
  FIO_ASSERT(
      0,
      "facil.io doesn't know how to spawn and wait on workers on this system.");
#endif
  return NULL;
}

static void fio___io_spawn_worker(void) {
  fio_thread_t t;
  fio_signal_review();

  if (FIO___IO.stop || !fio_io_is_master())
    return;

  fio_thread_pid_t pid = fio_thread_fork();
  FIO_ASSERT(pid != (fio_thread_pid_t)-1, "system call `fork` failed.");
  if (!pid)
    goto is_worker_process;
  if (fio_thread_create(&t, fio___io_worker_sentinel, (void *)(uintptr_t)pid)) {
    FIO_LOG_FATAL(
        "sentinel thread creation failed, no worker will be spawned.");
    fio_io_stop();
  }
  return;

is_worker_process:
  FIO___IO.pid = fio_thread_getpid();
  FIO___IO.is_worker = 1;

  /* close all inherited connections immediately? */
  FIO_LIST_EACH(fio_io_protocol_s,
                reserved.protocols,
                &FIO___IO.protocols,
                pr) {
    FIO_LIST_EACH(fio_io_s, node, &pr->reserved.ios, io) {
      fio_io_close_now(io);
    }
  }
  fio_queue_perform_all(&FIO___IO.queue);
  /* TODO: keep? */

  FIO_LOG_INFO("(%d) worker starting up.", fio_io_pid());

  if (FIO___IO.stop)
    goto skip_work;
  fio_state_callback_force(FIO_CALL_AFTER_FORK);
  fio_queue_perform_all(&FIO___IO.queue);
  fio_state_callback_force(FIO_CALL_IN_CHILD);
  fio_queue_perform_all(&FIO___IO.queue);
  fio___io_work(1);
  FIO_LOG_INFO("(%d) worker exiting.", fio_io_pid());
  exit(0);
skip_work:
  FIO_LOG_WARNING("(%d) worker exiting - stop signal detected during restart.",
                  fio_io_pid());
  exit(0);
}

static void fio___io_spawn_workers_task(void *ignr_1, void *ignr_2) {
  static volatile unsigned is_running = 0;

  if (!fio_io_is_master() || !FIO___IO.to_spawn)
    return;
  /* don't run nested */
  if (fio_atomic_or(&is_running, 1))
    return;
  FIO_LOG_INFO("(%d) spawning %d workers.", fio_io_pid(), FIO___IO.to_spawn);

  /* do not allow master tasks to run in worker - pretend to stop. */
  FIO___IO.tick = FIO___IO_GET_TIME_MILLI();
  if (fio_atomic_or_fetch(&FIO___IO.stop, 2) != 2)
    return;
  FIO_LIST_EACH(fio_io_async_s, node, &FIO___IO.async, q) {
    fio___io_async_stop(q);
  }
  fio_queue_perform_all(&FIO___IO.queue);

  /* perform forking procedure with the stop flag reset. */
  fio_atomic_and_fetch(&FIO___IO.stop, 1);
  fio_state_callback_force(FIO_CALL_BEFORE_FORK);
  FIO___IO.tick = FIO___IO_GET_TIME_MILLI();

  /* perform actual fork */
  do {
    fio___io_spawn_worker();
  } while (fio_atomic_sub_fetch(&FIO___IO.to_spawn, 1));

  /* finish up */
  fio_state_callback_force(FIO_CALL_AFTER_FORK);
  fio_state_callback_force(FIO_CALL_IN_MASTER);
  if ((FIO___IO.flags & FIO___IO_FLAG_CYCLING)) {
    fio___io_defer_no_wakeup(fio___io_work_task, NULL, NULL);
    FIO_LIST_EACH(fio_io_async_s, node, &FIO___IO.async, q) {
      fio___io_async_start(q);
    }
  }

  is_running = 0;
  (void)ignr_1, (void)ignr_2;
}

/* *****************************************************************************
Starting / Stopping the IO Reactor
***************************************************************************** */

/** Adds `workers` amount of workers to the root IO reactor process. */
SFUNC void fio_io_add_workers(int workers) {
  if (!workers || !fio_io_is_master())
    return;
  fio_atomic_add(&FIO___IO.to_spawn, (uint32_t)fio_io_workers(workers));
  fio_queue_push_urgent(&FIO___IO.queue, fio___io_spawn_workers_task);
}

/** Starts the IO reactor, using optional `workers` processes. Will BLOCK! */
SFUNC void fio_io_start(int workers) {
  FIO___IO.stop = 0;
  FIO___IO.workers = fio_io_workers(workers);
  workers = (int)FIO___IO.workers;
  FIO___IO.is_worker = !workers;
  fio_sock_maximize_limits(0);

  FIO_LIST_EACH(fio_io_async_s, node, &FIO___IO.async, q) {
    fio___io_async_start(q);
  }

  fio_state_callback_force(FIO_CALL_PRE_START);
  fio_queue_perform_all(&FIO___IO.queue);
  fio_signal_monitor(.sig = SIGINT,
                     .callback = fio___io_signal_stop,
                     .immediate = 1);
  fio_signal_monitor(.sig = SIGTERM,
                     .callback = fio___io_signal_stop,
                     .immediate = 1);
  if (FIO___IO.restart_signal)
    fio_signal_monitor(.sig = FIO___IO.restart_signal,
                       .callback = fio___io_signal_restart);

#ifdef SIGPIPE
  fio_signal_monitor(.sig = SIGPIPE);
#endif
  FIO___IO.tick = FIO___IO_GET_TIME_MILLI();
  if (workers) {
    FIO___IO.to_spawn = workers;
    fio___io_spawn_workers_task(NULL, NULL);
  } else {
    FIO_LOG_DEBUG2("(%d) starting facil.io IO reactor in single process mode.",
                   fio_io_root_pid());
  }
  fio___io_work(!workers);
  fio_signal_forget(SIGINT);
  fio_signal_forget(SIGTERM);
  if (FIO___IO.restart_signal)
    fio_signal_forget(FIO___IO.restart_signal);
#ifdef SIGPIPE
  fio_signal_forget(SIGPIPE);
#endif
  fio_queue_perform_all(&FIO___IO.queue);
}

/** Returns the number or workers the IO reactor will actually run. */
SFUNC uint16_t fio_io_workers(int workers) {
  if (workers < 0) {
    long cores = -1;
#ifdef _SC_NPROCESSORS_ONLN
    cores = sysconf(_SC_NPROCESSORS_ONLN);
#endif /* _SC_NPROCESSORS_ONLN */
    if (cores == -1L) {
      cores = 8;
      FIO_LOG_WARNING(
          "fio_io_start / fio_io_workers called with negative value for worker "
          "count, but auto-detect failed, assuming %d CPU cores",
          cores);
    }
    workers = (int)(cores / (0 - workers));
    workers += !workers;
  }
  return (uint16_t)workers;
}

/** Retiers all existing workers and restarts with the number of workers. */
SFUNC void fio___io_restart(void *workers_, void *ignr_) {
  int workers = (int)(uintptr_t)workers_;
  (void)ignr_;
  if (!fio_io_is_master())
    return;
  if (!FIO___IO.workers)
    goto no_workers;

  FIO___IO.workers = fio_io_workers(workers);
  workers = (int)FIO___IO.workers;
  if (workers) {
    FIO_LOG_INFO(
        "(%d) shutting down existing workers and (re)spawning %d workers.",
        fio_io_root_pid(),
        workers);
    fio_atomic_add(&FIO___IO.to_spawn, (uint32_t)workers);
    /* schedule workers to spawn - won't run until we return from function. */
    fio_queue_push_urgent(fio_io_queue(), fio___io_spawn_workers_task);
  } else {
    FIO_LOG_INFO(
        "(%d) shutting down existing workers and switching to single mode.",
        fio_io_root_pid());
  }
  /* signal existing children */
  FIO___LOCK_LOCK(FIO___IO.lock);
  FIO_LIST_EACH(fio___io_pid_s, node, &FIO___IO.pids, w) {
    w->stop = 1;
    fio_thread_kill(w->pid, FIO___IO.restart_signal);
  }
  FIO___LOCK_UNLOCK(FIO___IO.lock);
  /* switch to single mode? */
  if (!workers) {
    fio_state_callback_force(FIO_CALL_ON_START);
    FIO___IO.is_worker = 1;
  }
  return;
no_workers:
  FIO_LOG_ERROR("no workers to restart - IO worker restart is only available "
                "in cluster mode!");
  /* TODO: exec with all listeners intact...? */
  return;
}

SFUNC void fio_io_restart(int workers) {
  fio_queue_push(&FIO___IO.queue, fio___io_restart, (void *)(uintptr_t)workers);
}

/* *****************************************************************************
Listening to Incoming Connections
***************************************************************************** */

typedef struct {
  fio_io_protocol_s *protocol;
  void *udata;
  void *tls_ctx;
  fio_io_async_s *queue_for_accept;
  fio_queue_s *queue;
  fio_io_s *io;
  void (*on_start)(fio_io_protocol_s *protocol, void *udata);
  void (*on_stop)(fio_io_protocol_s *protocol, void *udata);
  int owner;
  int fd;
  size_t ref_count;
  size_t url_len;
  uint8_t hide_from_log;
  char url[];
} fio___io_listen_s;

FIO_LEAK_COUNTER_DEF(fio_io_listen)

static fio___io_listen_s *fio___io_listen_dup(fio___io_listen_s *l) {
  fio_atomic_add(&l->ref_count, 1);
  return l;
}

static void fio___io_listen_free(void *l_) {
  fio___io_listen_s *l = (fio___io_listen_s *)l_;
  if (l->io)
    fio_io_close(l->io);
  if (fio_atomic_sub(&l->ref_count, 1))
    return;

  fio_state_callback_remove(FIO_CALL_AT_EXIT, fio___io_listen_free, (void *)l);
  fio_state_callback_remove(FIO_CALL_ON_START, fio___io_listen_free, (void *)l);
  fio_state_callback_remove(FIO_CALL_PRE_START,
                            fio___io_listen_free,
                            (void *)l);
  fio___io_func_free_context_caller(l->protocol->io_functions.free_context,
                                    l->tls_ctx);
  fio_sock_close(l->fd);

#ifdef AF_UNIX
  /* delete the unix socket file, if any. */
  fio_url_s u = fio_url_parse(l->url, FIO_STRLEN(l->url));
  if (FIO___IO.pid == l->owner && !u.host.buf && !u.port.buf && u.path.buf) {
    unlink(u.path.buf);
  }
#endif

  if (l->on_stop)
    l->on_stop(l->protocol, l->udata);

  if (l->hide_from_log)
    FIO_LOG_DEBUG2("(%d) stopped listening @ %.*s",
                   fio_thread_getpid(),
                   (int)l->url_len,
                   l->url);
  else
    FIO_LOG_INFO("(%d) stopped listening @ %.*s",
                 fio_thread_getpid(),
                 (int)l->url_len,
                 l->url);
  fio_queue_perform_all(&FIO___IO.queue);
  FIO_LEAK_COUNTER_ON_FREE(fio_io_listen);
  FIO_MEM_FREE_(l, sizeof(*l) + l->url_len + 1);
}

SFUNC void fio_io_listen_stop(fio_io_listener_s *listener) {
  if (listener)
    fio___io_listen_free((fio___io_listen_s *)listener);
}

/** Returns the URL on which the listener is listening. */
SFUNC fio_buf_info_s fio_io_listener_url(fio_io_listener_s *listener) {
  fio___io_listen_s *l = (fio___io_listen_s *)listener;
  return FIO_BUF_INFO2(l->url, l->url_len);
}

/** Returns true if the listener protocol has an attached TLS context. */
SFUNC int fio_io_listener_is_tls(fio_io_listener_s *listener) {
  fio___io_listen_s *l = (fio___io_listen_s *)listener;
  return !!l->tls_ctx;
}

/** Returns the listener's associated protocol. */
SFUNC fio_io_protocol_s *fio_io_listener_protocol(fio_io_listener_s *listener) {
  fio___io_listen_s *l = (fio___io_listen_s *)listener;
  return l->protocol;
}

/** Returns the listener's associated `udata`. */
SFUNC void *fio_io_listener_udata(fio_io_listener_s *listener) {
  fio___io_listen_s *l = (fio___io_listen_s *)listener;
  return l->udata;
}

/** Sets the listener's associated `udata`, returning the old value. */
SFUNC void *fio_io_listener_udata_set(fio_io_listener_s *listener,
                                      void *new_udata) {
  void *old;
  fio___io_listen_s *l = (fio___io_listen_s *)listener;
  old = l->udata;
  l->udata = new_udata;
  return old;
}

static void fio___io_listen_on_data_task(void *io_, void *ignr_) {
  (void)ignr_;
  fio_io_s *io = (fio_io_s *)io_;
  int fd;
  fio___io_listen_s *l = (fio___io_listen_s *)fio_io_udata(io);
  fio_io_unsuspend(io);
  while (FIO_SOCK_FD_ISVALID(fd = fio_sock_accept(fio_io_fd(io), NULL, NULL))) {
    FIO_LOG_DDEBUG2("(%d) accepted new connection with fd %d",
                    fio_io_pid(),
                    fd);
    fio_io_attach_fd(fd, l->protocol, l->udata, l->tls_ctx);
  }
  fio___io_free2(io);
}
static void fio___io_listen_on_data_task_reschd(void *io_, void *ignr_) {
  fio_io_defer(fio___io_listen_on_data_task, io_, ignr_);
}
static void fio___io_listen_on_attach(fio_io_s *io) {
  fio___io_listen_s *l = (fio___io_listen_s *)(io->udata);
  l->queue = (l->queue_for_accept && l->queue_for_accept->q != &FIO___IO.queue)
                 ? l->queue_for_accept->q
                 : NULL;
  if (l->on_start)
    l->on_start(l->protocol, l->udata);
  if (l->hide_from_log)
    FIO_LOG_DEBUG2("(%d) started listening @ %s%s",
                   fio_io_pid(),
                   l->url,
                   l->tls_ctx ? " (TLS)" : "");
  else
    FIO_LOG_INFO("(%d) started listening @ %s%s",
                 fio_io_pid(),
                 l->url,
                 l->tls_ctx ? " (TLS)" : "");
}
static void fio___io_listen_on_shutdown(fio_io_s *io) {
  fio___io_listen_s *l = (fio___io_listen_s *)(io->udata);
  l->queue = fio_io_queue();
}
static void fio___io_listen_on_data(fio_io_s *io) {
  fio___io_listen_s *l = (fio___io_listen_s *)(io->udata);
  if (l->queue) {
    fio_io_suspend(io);
    fio_queue_push(l->queue,
                   fio___io_listen_on_data_task_reschd,
                   fio___io_dup2(io));
    return;
  }
  fio___io_listen_on_data_task(fio___io_dup2(io), NULL);
}
static void fio___io_listen_on_close(void *buffer, void *l) {
  ((fio___io_listen_s *)l)->io = NULL;
  fio___io_listen_free(l);
  (void)buffer;
}

static fio_io_protocol_s FIO___IO_LISTEN_PROTOCOL = {
    .on_attach = fio___io_listen_on_attach,
    .on_data = fio___io_listen_on_data,
    .on_close = fio___io_listen_on_close,
    .on_timeout = fio_io_touch,
    .on_shutdown = fio___io_listen_on_shutdown,
};

FIO_SFUNC void fio___io_listen_attach_task_deferred(void *l_, void *ignr_) {
  fio___io_listen_s *l = (fio___io_listen_s *)l_;
  l = fio___io_listen_dup(l);
  int fd = fio_sock_dup(l->fd);
  FIO_ASSERT(fd != -1, "listening socket failed to `dup`");
  FIO_LOG_DEBUG2("(%d) Called dup(%d) to attach %d as a listening socket.",
                 (int)fio_io_pid(),
                 l->fd,
                 fd);
  l->io = fio_io_attach_fd(fd, &FIO___IO_LISTEN_PROTOCOL, l, NULL);
  (void)ignr_;
}

FIO_SFUNC void fio___io_listen_attach_task(void *l_) {
  /* make sure to run in server thread */
  fio_io_defer(fio___io_listen_attach_task_deferred, l_, NULL);
}

int fio_io_listen___(void); /* IDE marker */
/**
 * Sets up a network service on a listening socket.
 *
 * Returns 0 on success or -1 on error.
 *
 * See the `fio_listen` Macro for details.
 */
SFUNC fio_io_listener_s *fio_io_listen
FIO_NOOP(struct fio_io_listen_args_s args) {
  fio___io_listen_s *l = NULL;
  void *built_tls = NULL;
  int should_free_tls = !args.tls;
  FIO_STR_INFO_TMP_VAR(url_alt, 2048);
  if (!args.protocol) {
    FIO_LOG_ERROR("fio_io_listen requires a protocol to be assigned.");
    return (fio_io_listener_s *)l;
  }
  if (args.on_root && !fio_io_is_master()) {
    FIO_LOG_ERROR("fio_io_listen called with `on_root` by a non-root worker.");
    return (fio_io_listener_s *)l;
  }
  if (!args.url) {
    args.url = getenv("ADDRESS");
    if (!args.url)
      args.url = "0.0.0.0";
  }
  url_alt.len = strlen(args.url);
  if (url_alt.len > 2024) {
    FIO_LOG_ERROR("binding address / url too long.");
    args.url = NULL;
  }
  fio_url_s url = fio_url_parse(args.url, url_alt.len);
  if (url.scheme.buf &&
      (url.scheme.len > 2 && url.scheme.len < 5 &&
       (url.scheme.buf[0] | (char)0x20) == 't' &&
       (url.scheme.buf[1] | (char)0x20) == 'c') &&
      (url.scheme.buf[2] | (char)0x20) == 'p')
    url.scheme = FIO_BUF_INFO0;
  if (!url.port.buf && !url.scheme.buf) {
    static size_t port_counter = 3000;
    size_t port = fio_atomic_add(&port_counter, 1);
    if (port == 3000 && getenv("PORT")) {
      char *port_env = getenv("PORT");
      port = fio_atol(&port_env);
      if (!port | (port > 65535ULL))
        port = 3000;
    }
    url_alt.len = 0;
    fio_string_write2(&url_alt,
                      NULL,
                      FIO_STRING_WRITE_STR2(url.scheme.buf, url.scheme.len),
                      (url.scheme.len ? FIO_STRING_WRITE_STR2("://", 3)
                                      : FIO_STRING_WRITE_STR2(NULL, 0)),
                      FIO_STRING_WRITE_STR2(url.host.buf, url.host.len),
                      FIO_STRING_WRITE_STR2(":", 1),
                      FIO_STRING_WRITE_NUM(port));
    args.url = url_alt.buf;
    url = fio_url_parse(args.url, url_alt.len);
  }

  args.tls = fio_io_tls_from_url(args.tls, url);
  fio___io_init_protocol_test(args.protocol, !!args.tls);
  built_tls = args.protocol->io_functions.build_context(args.tls, 0);
  fio_buf_info_s url_buf = FIO_BUF_INFO2((char *)args.url, url_alt.len);
  /* remove query details from URL */
  if (url.query.len)
    url_buf.len = url.query.buf - (url_buf.buf + 1);
  else if (url.target.len)
    url_buf.len = url.target.buf - (url_buf.buf + 1);
  l = (fio___io_listen_s *)
      FIO_MEM_REALLOC_(NULL, 0, sizeof(*l) + url_buf.len + 1, 0);
  FIO_ASSERT_ALLOC(l);
  FIO_LEAK_COUNTER_ON_ALLOC(fio_io_listen);
  *l = (fio___io_listen_s){
      .protocol = args.protocol,
      .udata = args.udata,
      .tls_ctx = built_tls,
      .queue_for_accept = args.queue_for_accept,
      .on_start = args.on_start,
      .on_stop = args.on_stop,
      .owner = FIO___IO.pid,
      .url_len = url_buf.len,
      .hide_from_log = args.hide_from_log,
  };
  FIO_MEMCPY(l->url, url_buf.buf, url_buf.len);
  l->url[l->url_len] = 0;
  if (should_free_tls)
    fio_io_tls_free(args.tls);

  l->fd = fio_sock_open2(l->url, FIO_SOCK_SERVER | FIO_SOCK_TCP);
  if (l->fd == -1) {
    fio___io_listen_free(l);
    return (fio_io_listener_s *)(l = NULL);
  }
  if (fio_io_is_running()) {
    fio_io_defer(fio___io_listen_attach_task_deferred, l, NULL);
  } else {
    fio_state_callback_add(
        (args.on_root ? FIO_CALL_PRE_START : FIO_CALL_ON_START),
        fio___io_listen_attach_task,
        (void *)l);
  }
  fio_state_callback_add(FIO_CALL_AT_EXIT, fio___io_listen_free, l);
  return (fio_io_listener_s *)l;
}

/* *****************************************************************************
Connecting as a Client
***************************************************************************** */

typedef struct {
  fio_io_protocol_s protocol;
  fio_io_protocol_s *upr;
  void (*on_failed)(fio_io_protocol_s *protocol, void *udata);
  void *udata;
  void *tls_ctx;
  size_t url_len;
  char url[];
} fio___io_connecting_s;

FIO_SFUNC void fio___connecting_cleanup(fio___io_connecting_s *c) {
  fio___io_func_free_context_caller(c->protocol.io_functions.free_context,
                                    c->tls_ctx);
  FIO_MEM_FREE_(c, sizeof(*c) + c->url_len + 1);
}

FIO_SFUNC void fio___connecting_on_close(void *buffer, void *udata) {
  fio___io_connecting_s *c = (fio___io_connecting_s *)udata;
  if (c->on_failed)
    c->on_failed(c->upr, c->udata);
  fio___connecting_cleanup(c);
  (void)buffer;
}

FIO_SFUNC void fio___connecting_on_ready(fio_io_s *io) {
  if (!fio_io_is_open(io))
    return;
  fio___io_connecting_s *c = (fio___io_connecting_s *)fio_io_udata(io);
  FIO_LOG_DEBUG2("(%d) established client connection to %s",
                 fio_io_pid(),
                 c->url);
  fio_io_udata_set(io, c->udata);
  fio_io_protocol_set(io, c->upr);
  c->on_failed = NULL;
  fio___io_defer_no_wakeup(fio___connecting_on_close, NULL, (void *)c);
}

void fio_io_connect___(void); /* IDE Marker */
SFUNC fio_io_s *fio_io_connect FIO_NOOP(fio_io_connect_args_s args) {
  int should_free_tls = !args.tls;
  if (!args.protocol)
    return NULL;
  if (!args.url) {
    if (args.on_failed)
      args.on_failed(args.protocol, args.udata);
    return NULL;
  }
  if (!args.timeout)
    args.timeout = 30000;

  size_t url_len = strlen(args.url);
  fio_url_s url = fio_url_parse(args.url, url_len);
  args.tls = fio_io_tls_from_url(args.tls, url);
  fio___io_init_protocol(args.protocol, !!args.tls);
  if (url.query.len)
    url_len = url.query.buf - (args.url + 1);
  else if (url.target.len)
    url_len = url.target.buf - (args.url + 1);
  fio___io_connecting_s *c = (fio___io_connecting_s *)
      FIO_MEM_REALLOC_(NULL, 0, sizeof(*c) + url_len + 1, 0);
  FIO_ASSERT_ALLOC(c);
  *c = (fio___io_connecting_s){
      .protocol =
          {
              .on_ready = fio___connecting_on_ready,
              .on_close = fio___connecting_on_close,
              .io_functions = args.protocol->io_functions,
              .timeout = args.timeout,
              .buffer_size = args.protocol->buffer_size,
          },
      .upr = args.protocol,
      .on_failed = args.on_failed,
      .udata = args.udata,
      .tls_ctx = args.protocol->io_functions.build_context(args.tls, 1),
  };
  FIO_MEMCPY(c->url, args.url, url_len);
  c->url[url_len] = 0;
  fio_io_s *io = fio_io_attach_fd(
      fio_sock_open2(c->url, FIO_SOCK_CLIENT | FIO_SOCK_NONBLOCK),
      &c->protocol,
      c,
      c->tls_ctx);
  if (should_free_tls)
    fio_io_tls_free(args.tls);
  return io;
}
/* *****************************************************************************
IO Reactor Finish
***************************************************************************** */
#undef FIO___IO_FLAG_SET
#undef FIO___IO_FLAG_UNSET
#undef FIO___IO_GET_TIME_MILLI
#endif /* FIO_IO */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_IO                 /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                  OpenSSL Implementation for IO Functions




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(H___FIO_IO___H) && !defined(FIO_NO_TLS) &&                         \
    (HAVE_OPENSSL || __has_include("openssl/ssl.h")) &&                        \
     !defined(H___FIO_OPENSSL___H) && !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_OPENSSL___H 1
/* *****************************************************************************
OpenSSL IO Function Getter
***************************************************************************** */

/* Returns the OpenSSL IO functions. */
SFUNC fio_io_functions_s fio_openssl_io_functions(void);

/* *****************************************************************************
OpenSSL Helpers Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

/* *****************************************************************************
Validate OpenSSL Library Version
***************************************************************************** */

#if !defined(OPENSSL_VERSION_MAJOR) || OPENSSL_VERSION_MAJOR < 3
#undef HAVE_OPENSSL
#warning HAVE_OPENSSL flag error - incompatible OpenSSL version
/* No valid OpenSSL, return the default TLS IO functions */
SFUNC fio_io_functions_s fio_openssl_io_functions(void) {
  return fio_io_tls_default_functions(NULL);
}
#else
FIO_ASSERT_STATIC(OPENSSL_VERSION_MAJOR > 2, "OpenSSL version mismatch");

/* *****************************************************************************
Self-Signed Certificates using ECDSA P-256

Security notes:
- ECDSA P-256 provides 128-bit security (equivalent to RSA-3072)
- Key generation is ~200x faster than RSA-4096 (~10ms vs ~2000ms)
- Smaller certificates reduce TLS handshake overhead
- SHA-256 is used for signing (matched to P-256 security level)
- 180-day validity balances security with operational convenience
- Random 128-bit serial numbers prevent prediction attacks
- X.509v3 extensions ensure browser compatibility
***************************************************************************** */

/* Global ECDSA private key for self-signed certificates */
static EVP_PKEY *fio___openssl_pkey = NULL;

/* Cleanup callback to free the private key at exit */
static void fio___openssl_clear_root_key(void *key) {
  if (key) {
    EVP_PKEY_free((EVP_PKEY *)key);
  }
  fio___openssl_pkey = NULL;
}

/*
 * Generate an ECDSA P-256 private key for self-signed certificates.
 * Thread-safe with lock protection.
 *
 * Why ECDSA P-256:
 * - 128-bit security level (equivalent to RSA-3072)
 * - Key generation: ~10ms (vs ~2000ms for RSA-4096)
 * - Smaller keys: 256 bits (vs 4096 bits for RSA)
 * - NIST approved, widely supported
 * - Better performance for TLS handshakes
 */
static void fio___openssl_make_root_key(void) {
  static fio_lock_i lock = FIO_LOCK_INIT;
  fio_lock(&lock);
  if (!fio___openssl_pkey) {
    FIO_LOG_DEBUG2("generating ECDSA P-256 private key for TLS...");

    /* Create ECDSA P-256 key using modern OpenSSL 3.x API */
    fio___openssl_pkey = EVP_EC_gen("P-256");

    if (!fio___openssl_pkey) {
      /* Log the OpenSSL error */
      unsigned long err = ERR_get_error();
      char err_buf[256];
      ERR_error_string_n(err, err_buf, sizeof(err_buf));
      FIO_LOG_ERROR("OpenSSL ECDSA P-256 key generation failed: %s", err_buf);
      FIO_ASSERT(0, "OpenSSL failed to create ECDSA private key.");
    }

    /* Register cleanup callback */
    fio_state_callback_add(FIO_CALL_AT_EXIT,
                           fio___openssl_clear_root_key,
                           fio___openssl_pkey);
    FIO_LOG_DEBUG2("ECDSA P-256 private key generated successfully.");
  }
  fio_unlock(&lock);
}

/*
 * Add X.509v3 extensions to a certificate.
 *
 * Extensions added:
 * - Subject Alternative Name (SAN): Required by modern browsers
 * - Basic Constraints: CA:FALSE (not a CA certificate)
 * - Key Usage: digitalSignature, keyEncipherment (for TLS)
 * - Extended Key Usage: serverAuth (for HTTPS/TLS servers)
 *
 * Returns 0 on success, -1 on failure.
 */
FIO_SFUNC int fio___openssl_add_x509v3_extensions(X509 *cert,
                                                  const char *server_name) {
  X509V3_CTX ctx;
  X509_EXTENSION *ext = NULL;
  int ret = -1;

  /* Initialize extension context */
  X509V3_set_ctx_nodb(&ctx);
  X509V3_set_ctx(&ctx, cert, cert, NULL, NULL, 0);

  /* Basic Constraints: CA:FALSE - this is not a CA certificate */
  ext = X509V3_EXT_conf_nid(NULL, &ctx, NID_basic_constraints, "CA:FALSE");
  if (!ext) {
    FIO_LOG_ERROR("OpenSSL: failed to create Basic Constraints extension");
    goto cleanup;
  }
  if (!X509_add_ext(cert, ext, -1)) {
    FIO_LOG_ERROR("OpenSSL: failed to add Basic Constraints extension");
    X509_EXTENSION_free(ext);
    goto cleanup;
  }
  X509_EXTENSION_free(ext);
  ext = NULL;

  /* Key Usage: digitalSignature, keyEncipherment */
  ext = X509V3_EXT_conf_nid(NULL,
                            &ctx,
                            NID_key_usage,
                            "critical,digitalSignature,keyEncipherment");
  if (!ext) {
    FIO_LOG_ERROR("OpenSSL: failed to create Key Usage extension");
    goto cleanup;
  }
  if (!X509_add_ext(cert, ext, -1)) {
    FIO_LOG_ERROR("OpenSSL: failed to add Key Usage extension");
    X509_EXTENSION_free(ext);
    goto cleanup;
  }
  X509_EXTENSION_free(ext);
  ext = NULL;

  /* Extended Key Usage: serverAuth */
  ext = X509V3_EXT_conf_nid(NULL, &ctx, NID_ext_key_usage, "serverAuth");
  if (!ext) {
    FIO_LOG_ERROR("OpenSSL: failed to create Extended Key Usage extension");
    goto cleanup;
  }
  if (!X509_add_ext(cert, ext, -1)) {
    FIO_LOG_ERROR("OpenSSL: failed to add Extended Key Usage extension");
    X509_EXTENSION_free(ext);
    goto cleanup;
  }
  X509_EXTENSION_free(ext);
  ext = NULL;

  /* Subject Alternative Name (SAN) - required by modern browsers */
  if (server_name && server_name[0]) {
    /* Build SAN value: DNS:hostname */
    char san_value[512];
    int san_len = snprintf(san_value, sizeof(san_value), "DNS:%s", server_name);
    if (san_len > 0 && (size_t)san_len < sizeof(san_value)) {
      ext = X509V3_EXT_conf_nid(NULL, &ctx, NID_subject_alt_name, san_value);
      if (!ext) {
        FIO_LOG_ERROR("OpenSSL: failed to create SAN extension");
        goto cleanup;
      }
      if (!X509_add_ext(cert, ext, -1)) {
        FIO_LOG_ERROR("OpenSSL: failed to add SAN extension");
        X509_EXTENSION_free(ext);
        goto cleanup;
      }
      X509_EXTENSION_free(ext);
      ext = NULL;
    }
  }

  ret = 0; /* success */

cleanup:
  return ret;
}

/*
 * Generate a cryptographically random 128-bit serial number.
 *
 * Security rationale:
 * - Sequential serial numbers are predictable and can leak information
 * - 128-bit random provides ~2^128 possible values (practically unique)
 * - Uses OpenSSL's CSPRNG which sources from /dev/urandom or equivalent
 * - Meets CAB Forum Baseline Requirements for serial number entropy
 *
 * Returns 0 on success, -1 on failure.
 */
FIO_SFUNC int fio___openssl_set_random_serial(X509 *cert) {
  BIGNUM *bn = NULL;
  ASN1_INTEGER *serial = NULL;
  int ret = -1;

  /* Generate 128-bit random number */
  bn = BN_new();
  if (!bn) {
    FIO_LOG_ERROR("OpenSSL: BN_new failed for serial number");
    goto cleanup;
  }

  /* Generate 128 random bits using OpenSSL's CSPRNG */
  if (!BN_rand(bn, 128, BN_RAND_TOP_ANY, BN_RAND_BOTTOM_ANY)) {
    FIO_LOG_ERROR("OpenSSL: BN_rand failed for serial number");
    goto cleanup;
  }

  /* Ensure the number is positive (required for X.509 serial numbers) */
  BN_set_negative(bn, 0);

  /* Convert to ASN1_INTEGER and set on certificate */
  serial = BN_to_ASN1_INTEGER(bn, NULL);
  if (!serial) {
    FIO_LOG_ERROR("OpenSSL: BN_to_ASN1_INTEGER failed");
    goto cleanup;
  }

  if (!X509_set_serialNumber(cert, serial)) {
    FIO_LOG_ERROR("OpenSSL: X509_set_serialNumber failed");
    goto cleanup;
  }

  ret = 0; /* success */

cleanup:
  if (serial)
    ASN1_INTEGER_free(serial);
  if (bn)
    BN_free(bn);
  return ret;
}

/*
 * Create a self-signed X.509 certificate for TLS.
 *
 * Certificate properties:
 * - Algorithm: ECDSA with P-256 curve
 * - Signature: SHA-256 (matched to P-256 security level)
 * - Validity: 180 days (15552000 seconds)
 * - Serial: 128-bit cryptographically random
 * - Extensions: Basic Constraints, Key Usage, Extended Key Usage, SAN
 *
 * The certificate is self-signed and suitable for development/testing.
 * For production, use properly issued certificates from a trusted CA.
 */
static X509 *fio_io_tls_create_self_signed(const char *server_name) {
  X509 *cert = NULL;
  X509_NAME *name = NULL;

  /* Validate server_name */
  if (!server_name || !server_name[0]) {
    server_name = "localhost";
  }

  /* Check server_name length to prevent overflow */
  size_t srv_name_len = FIO_STRLEN(server_name);
  if (srv_name_len > 255) {
    FIO_LOG_ERROR("server_name too long for certificate (max 255 bytes)");
    return NULL;
  }

  /* Ensure we have a private key */
  fio___openssl_make_root_key();
  if (!fio___openssl_pkey) {
    FIO_LOG_ERROR("No private key available for self-signed certificate");
    return NULL;
  }

  /* Allocate new X509 certificate structure */
  cert = X509_new();
  if (!cert) {
    FIO_LOG_ERROR("OpenSSL: X509_new failed to allocate certificate");
    return NULL;
  }

  /* Set certificate version to X.509v3 (version value is 0-indexed, so 2 = v3)
   */
  if (!X509_set_version(cert, 2)) {
    FIO_LOG_ERROR("OpenSSL: X509_set_version failed");
    goto error;
  }

  /* Set cryptographically random serial number */
  if (fio___openssl_set_random_serial(cert) != 0) {
    FIO_LOG_ERROR("OpenSSL: failed to set random serial number");
    goto error;
  }

  /*
   * Set validity period: 180 days
   * - notBefore: now
   * - notAfter: now + 180 days (15552000 seconds)
   *
   * Calculation: 180 days * 24 hours * 60 minutes * 60 seconds = 15552000
   */
  if (!X509_gmtime_adj(X509_get_notBefore(cert), 0)) {
    FIO_LOG_ERROR("OpenSSL: X509_gmtime_adj failed for notBefore");
    goto error;
  }
  if (!X509_gmtime_adj(X509_get_notAfter(cert), 15552000L)) {
    FIO_LOG_ERROR("OpenSSL: X509_gmtime_adj failed for notAfter");
    goto error;
  }

  /* Set the public key from our ECDSA key pair */
  if (!X509_set_pubkey(cert, fio___openssl_pkey)) {
    FIO_LOG_ERROR("OpenSSL: X509_set_pubkey failed");
    goto error;
  }

  /* Set subject name with Organization and Common Name */
  name = X509_get_subject_name(cert);
  if (!name) {
    FIO_LOG_ERROR("OpenSSL: X509_get_subject_name failed");
    goto error;
  }

  /* Add Organization (O) - identifies the certificate owner */
  if (!X509_NAME_add_entry_by_txt(name,
                                  "O",
                                  MBSTRING_ASC,
                                  (const unsigned char *)server_name,
                                  (int)srv_name_len,
                                  -1,
                                  0)) {
    FIO_LOG_ERROR("OpenSSL: failed to add Organization to certificate");
    goto error;
  }

  /* Add Common Name (CN) - the server's hostname */
  if (!X509_NAME_add_entry_by_txt(name,
                                  "CN",
                                  MBSTRING_ASC,
                                  (const unsigned char *)server_name,
                                  (int)srv_name_len,
                                  -1,
                                  0)) {
    FIO_LOG_ERROR("OpenSSL: failed to add Common Name to certificate");
    goto error;
  }

  /* Set issuer name (same as subject for self-signed) */
  if (!X509_set_issuer_name(cert, name)) {
    FIO_LOG_ERROR("OpenSSL: X509_set_issuer_name failed");
    goto error;
  }

  /* Add X.509v3 extensions for browser compatibility */
  if (fio___openssl_add_x509v3_extensions(cert, server_name) != 0) {
    FIO_LOG_ERROR("OpenSSL: failed to add X.509v3 extensions");
    goto error;
  }

  /*
   * Sign the certificate with SHA-256.
   * SHA-256 is matched to P-256's security level (both ~128-bit security).
   */
  if (!X509_sign(cert, fio___openssl_pkey, EVP_sha256())) {
    unsigned long err = ERR_get_error();
    char err_buf[256];
    ERR_error_string_n(err, err_buf, sizeof(err_buf));
    FIO_LOG_ERROR("OpenSSL: X509_sign failed: %s", err_buf);
    goto error;
  }

  FIO_LOG_DEBUG2("created self-signed certificate for '%s' (ECDSA P-256, "
                 "SHA-256, 180 days)",
                 server_name);
  return cert;

error:
  if (cert)
    X509_free(cert);
  return NULL;
}

/* *****************************************************************************
OpenSSL Context type wrappers
***************************************************************************** */

/* Context for all future connections */
typedef struct {
  SSL_CTX *ctx;
  fio_io_tls_s *tls;
} fio___openssl_context_s;

FIO_LEAK_COUNTER_DEF(fio___openssl_context_s)

/* *****************************************************************************
OpenSSL Callbacks
***************************************************************************** */

FIO_SFUNC int fio___openssl_pem_password_cb(char *buf,
                                            int size,
                                            int rwflag,
                                            void *u) {
  const char *password = (const char *)u;
  if (!password)
    return 0;
  size_t password_len = FIO_STRLEN(password);
  if (password_len > (size_t)size)
    return -1;
  FIO_MEMCPY(buf, password, password_len);
  return (int)password_len;
  (void)rwflag;
}

FIO_SFUNC int fio___openssl_alpn_selector_cb(SSL *ssl,
                                             const unsigned char **out,
                                             unsigned char *outlen,
                                             const unsigned char *in,
                                             unsigned int inlen,
                                             void *tls_) {
  fio_io_s *io = (fio_io_s *)SSL_get_ex_data(ssl, 0);
  fio___openssl_context_s *ctx = (fio___openssl_context_s *)tls_;

  const unsigned char *end = in + inlen;
  char buf[256];
  while (in < end) {
    uint8_t len = in[0];
    if (len == 0 || (size_t)in + 1 + len > (size_t)end)
      break;
    if (len < sizeof(buf) - 1) {
      FIO_MEMCPY(buf, in + 1, len);
      buf[len] = 0;
      if (!fio_io_tls_alpn_select(ctx->tls, buf, (size_t)len, io)) {
        *out = in + 1;
        *outlen = len;
        FIO_LOG_DDEBUG2("(%d) TLS ALPN set to: %s for %p",
                        (int)fio_thread_getpid(),
                        buf,
                        (void *)io);
        return SSL_TLSEXT_ERR_OK;
      }
    }
    in += len + 1;
  }
  FIO_LOG_DDEBUG2("(%d) ALPN Failed! No protocol name match for %p",
                  (int)fio_thread_getpid(),
                  (void *)io);
  return SSL_TLSEXT_ERR_ALERT_FATAL;
  (void)tls_;
}

/* *****************************************************************************
Public Context Builder
***************************************************************************** */

FIO_SFUNC int fio___openssl_each_cert(struct fio_io_tls_each_s *e,
                                      const char *server_name,
                                      const char *public_cert_file,
                                      const char *private_key_file,
                                      const char *pk_password) {
  fio___openssl_context_s *s = (fio___openssl_context_s *)e->udata;
  if (public_cert_file && private_key_file) { /* load certificate from files */
    SSL_CTX_set_default_passwd_cb(s->ctx, fio___openssl_pem_password_cb);
    SSL_CTX_set_default_passwd_cb_userdata(s->ctx, (void *)pk_password);
    FIO_LOG_DDEBUG2("loading TLS certificates: %s & %s",
                    public_cert_file,
                    private_key_file);
    /* Set the certificate */
    if (SSL_CTX_use_certificate_chain_file(s->ctx, public_cert_file) <= 0) {
      ERR_print_errors_fp(stderr);
      FIO_LOG_ERROR("OpenSSL couldn't load certificate file: %s",
                    public_cert_file);
      return -1;
    }
    /* Set the private key */
    if (SSL_CTX_use_PrivateKey_file(s->ctx,
                                    private_key_file,
                                    SSL_FILETYPE_PEM) <= 0) {
      ERR_print_errors_fp(stderr);
      FIO_LOG_ERROR("OpenSSL couldn't load private key file: %s",
                    private_key_file);
      return -1;
    }
    /* Verify key matches certificate */
    if (!SSL_CTX_check_private_key(s->ctx)) {
      FIO_LOG_ERROR("OpenSSL: private key doesn't match certificate");
      return -1;
    }
    SSL_CTX_set_default_passwd_cb(s->ctx, NULL);
    SSL_CTX_set_default_passwd_cb_userdata(s->ctx, NULL);
  } else { /* generate self-signed certificate */
    if (!server_name || !server_name[0])
      server_name = "localhost";
    X509 *cert = fio_io_tls_create_self_signed(server_name);
    if (!cert) {
      FIO_LOG_ERROR("failed to create self-signed certificate");
      return -1;
    }
    if (!SSL_CTX_use_certificate(s->ctx, cert)) {
      X509_free(cert);
      FIO_LOG_ERROR("OpenSSL: SSL_CTX_use_certificate failed");
      return -1;
    }
    X509_free(cert); /* SSL_CTX makes a copy */
    if (!SSL_CTX_use_PrivateKey(s->ctx, fio___openssl_pkey)) {
      FIO_LOG_ERROR("OpenSSL: SSL_CTX_use_PrivateKey failed");
      return -1;
    }
  }
  return 0;
}

FIO_SFUNC int fio___openssl_each_alpn(struct fio_io_tls_each_s *e,
                                      const char *protocol_name,
                                      void (*on_selected)(fio_io_s *)) {
  fio_str_info_s *str = (fio_str_info_s *)e->udata2;
  if (!protocol_name)
    return 0;
  size_t len = FIO_STRLEN(protocol_name);
  if (len == 0 || len > 255) {
    FIO_LOG_ERROR("ALPN protocol name invalid length: %zu", len);
    return -1;
  }
  if (len + str->len + 1 > str->capa) {
    FIO_LOG_ERROR("ALPN protocol list overflow.");
    return -1;
  }
  str->buf[str->len++] = (char)(len & 0xFF);
  FIO_MEMCPY(str->buf + str->len, protocol_name, len);
  str->len += len;
  return 0;
  (void)on_selected;
}

FIO_SFUNC int fio___openssl_each_trust(struct fio_io_tls_each_s *e,
                                       const char *public_cert_file) {
  X509_STORE *store = (X509_STORE *)e->udata2;
  if (!store)
    return -1;
  if (public_cert_file) { /* trust specific certificate */
    if (!X509_STORE_load_file(store, public_cert_file)) {
      FIO_LOG_ERROR("OpenSSL: failed to load trust certificate: %s",
                    public_cert_file);
      return -1;
    }
  } else { /* trust system's default trust store */
    const char *path = getenv(X509_get_default_cert_dir_env());
    if (!path)
      path = X509_get_default_cert_dir();
    if (path) {
      if (!X509_STORE_load_path(store, path)) {
        FIO_LOG_WARNING("OpenSSL: failed to load system trust store from: %s",
                        path);
      }
    }
  }
  return 0;
}

/** Helper that converts a `fio_io_tls_s` into the implementation's context. */
FIO_SFUNC void *fio___openssl_build_context(fio_io_tls_s *tls,
                                            uint8_t is_client) {
  fio___openssl_context_s *ctx =
      (fio___openssl_context_s *)FIO_MEM_REALLOC(NULL, 0, sizeof(*ctx), 0);
  if (!ctx) {
    FIO_LOG_ERROR("OpenSSL: memory allocation failed for context");
    return NULL;
  }
  FIO_LEAK_COUNTER_ON_ALLOC(fio___openssl_context_s);
  *ctx = (fio___openssl_context_s){
      .ctx = SSL_CTX_new((is_client ? TLS_client_method : TLS_server_method)()),
      .tls = fio_io_tls_dup(tls),
  };

  if (!ctx->ctx) {
    FIO_LOG_ERROR("OpenSSL: SSL_CTX_new failed");
    if (ctx->tls)
      fio_io_tls_free(ctx->tls);
    FIO_LEAK_COUNTER_ON_FREE(fio___openssl_context_s);
    FIO_MEM_FREE(ctx, sizeof(*ctx));
    return NULL;
  }

  /* Configure SSL context modes for non-blocking I/O */
  SSL_CTX_set_mode(ctx->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE);
  SSL_CTX_set_mode(ctx->ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
  SSL_CTX_clear_mode(ctx->ctx, SSL_MODE_AUTO_RETRY);

  /* Configure certificate verification */
  X509_STORE *store = NULL;
  if (fio_io_tls_trust_count(tls)) {
    SSL_CTX_set_verify(ctx->ctx, SSL_VERIFY_PEER, NULL);
    store = X509_STORE_new();
    if (!store) {
      FIO_LOG_ERROR("OpenSSL: X509_STORE_new failed");
      goto error;
    }
    SSL_CTX_set_cert_store(ctx->ctx, store); /* takes ownership of store */
  } else {
    SSL_CTX_set_verify(ctx->ctx, SSL_VERIFY_NONE, NULL);
    if (is_client)
      FIO_LOG_SECURITY("no trusted TLS certificates listed for client, using "
                       "SSL_VERIFY_NONE!");
  }

  /* Load certificates or generate self-signed */
  if (!fio_io_tls_cert_count(tls) && !is_client) {
    /* No certificates configured for server - use self-signed */
    X509 *cert = fio_io_tls_create_self_signed("localhost");
    if (!cert) {
      FIO_LOG_ERROR("OpenSSL: failed to create self-signed certificate");
      goto error;
    }
    if (!SSL_CTX_use_certificate(ctx->ctx, cert)) {
      X509_free(cert);
      FIO_LOG_ERROR("OpenSSL: SSL_CTX_use_certificate failed");
      goto error;
    }
    X509_free(cert); /* SSL_CTX makes a copy */
    if (!SSL_CTX_use_PrivateKey(ctx->ctx, fio___openssl_pkey)) {
      FIO_LOG_ERROR("OpenSSL: SSL_CTX_use_PrivateKey failed");
      goto error;
    }
  }

  /* Process each configured certificate */
  if (fio_io_tls_each(tls,
                      .udata = ctx,
                      .udata2 = store,
                      .each_cert = fio___openssl_each_cert,
                      .each_trust = fio___openssl_each_trust)) {
    FIO_LOG_ERROR("OpenSSL: failed to configure certificates or trust store");
    goto error;
  }

  /* Configure ALPN if protocols are registered */
  if (fio_io_tls_alpn_count(tls)) {
    FIO_STR_INFO_TMP_VAR(alpn_list, 1023);
    if (fio_io_tls_each(tls,
                        .udata = ctx,
                        .udata2 = &alpn_list,
                        .each_alpn = fio___openssl_each_alpn)) {
      FIO_LOG_ERROR("OpenSSL: failed to configure ALPN protocols");
      goto error;
    }
    if (alpn_list.len > 0) {
      if (SSL_CTX_set_alpn_protos(ctx->ctx,
                                  (const unsigned char *)alpn_list.buf,
                                  (unsigned int)alpn_list.len)) {
        FIO_LOG_ERROR("SSL_CTX_set_alpn_protos failed.");
        /* ALPN is optional, continue without it */
      } else {
        SSL_CTX_set_alpn_select_cb(ctx->ctx,
                                   fio___openssl_alpn_selector_cb,
                                   ctx);
        SSL_CTX_set_next_proto_select_cb(
            ctx->ctx,
            (int (*)(SSL *,
                     unsigned char **,
                     unsigned char *,
                     const unsigned char *,
                     unsigned int,
                     void *))fio___openssl_alpn_selector_cb,
            (void *)ctx);
      }
    }
  }
  return ctx;

error:
  if (ctx) {
    if (ctx->ctx)
      SSL_CTX_free(ctx->ctx);
    if (ctx->tls)
      fio_io_tls_free(ctx->tls);
    FIO_LEAK_COUNTER_ON_FREE(fio___openssl_context_s);
    FIO_MEM_FREE(ctx, sizeof(*ctx));
  }
  return NULL;
}

/* *****************************************************************************
IO functions
***************************************************************************** */

/** Called to perform a non-blocking `read`, same as the system call. */
FIO_SFUNC ssize_t fio___openssl_read(int fd,
                                     void *buf,
                                     size_t len,
                                     void *tls_ctx) {
  ssize_t r;
  SSL *ssl = (SSL *)tls_ctx;
  if (!ssl || !buf)
    return -1;
  errno = 0;
  if (len > INT_MAX)
    len = INT_MAX;
  r = SSL_read(ssl, buf, (int)len);
  if (r > 0)
    return r;
  if (errno == EWOULDBLOCK || errno == EAGAIN)
    return (ssize_t)-1;

  switch ((r = (ssize_t)SSL_get_error(ssl, (int)r))) {
  case SSL_ERROR_SSL:                                   /* fall through */
  case SSL_ERROR_SYSCALL:                               /* fall through */
  case SSL_ERROR_ZERO_RETURN: return (r = 0);           /* EOF */
  case SSL_ERROR_NONE:                                  /* fall through */
  case SSL_ERROR_WANT_CONNECT:                          /* fall through */
  case SSL_ERROR_WANT_ACCEPT:                           /* fall through */
  case SSL_ERROR_WANT_WRITE:                            /* fall through */
    r = SSL_write_ex(ssl, (void *)&r, 0, (size_t *)&r); /* fall through */
  case SSL_ERROR_WANT_X509_LOOKUP:                      /* fall through */
  case SSL_ERROR_WANT_READ:                             /* fall through */
#ifdef SSL_ERROR_WANT_ASYNC
  case SSL_ERROR_WANT_ASYNC:                            /* fall through */
#endif
  default: errno = EWOULDBLOCK; return (r = -1);
  }
  (void)fd;
}

/** Sends any unsent internal data. Returns 0 only if all data was sent. */
FIO_SFUNC int fio___openssl_flush(int fd, void *tls_ctx) {
  return 0;
  (void)fd, (void)tls_ctx;
}

/** Called to perform a non-blocking `write`, same as the system call. */
FIO_SFUNC ssize_t fio___openssl_write(int fd,
                                      const void *buf,
                                      size_t len,
                                      void *tls_ctx) {
  ssize_t r = -1;
  if (!buf || !len || !tls_ctx)
    return r;
  SSL *ssl = (SSL *)tls_ctx;
  errno = 0;
  if (len > INT_MAX)
    len = INT_MAX;
  r = SSL_write(ssl, buf, (int)len);
  if (r > 0)
    return r;
  if (errno == EWOULDBLOCK || errno == EAGAIN)
    return -1;

  switch ((r = (ssize_t)SSL_get_error(ssl, (int)r))) {
  case SSL_ERROR_SSL:                         /* fall through */
  case SSL_ERROR_SYSCALL:                     /* fall through */
  case SSL_ERROR_ZERO_RETURN: return (r = 0); /* EOF */
  case SSL_ERROR_NONE:                        /* fall through */
  case SSL_ERROR_WANT_CONNECT:                /* fall through */
  case SSL_ERROR_WANT_ACCEPT:                 /* fall through */
  case SSL_ERROR_WANT_X509_LOOKUP:            /* fall through */
  case SSL_ERROR_WANT_WRITE:                  /* fall through */
  case SSL_ERROR_WANT_READ:                   /* fall through */
#ifdef SSL_ERROR_WANT_ASYNC /* fall through */
  case SSL_ERROR_WANT_ASYNC:                  /* fall through */
#endif
  default: errno = EWOULDBLOCK; return (r = -1);
  }
  (void)fd;
}

/* *****************************************************************************
Per-Connection Builder
***************************************************************************** */

FIO_LEAK_COUNTER_DEF(fio___SSL)

/** called once the IO was attached and the TLS object was set. */
FIO_SFUNC void fio___openssl_start(fio_io_s *io) {
  fio___openssl_context_s *ctx_parent =
      (fio___openssl_context_s *)fio_io_tls(io);
  if (!ctx_parent || !ctx_parent->ctx) {
    FIO_LOG_ERROR("OpenSSL Context missing for connection!");
    return;
  }

  SSL *ssl = SSL_new(ctx_parent->ctx);
  if (!ssl) {
    FIO_LOG_ERROR("OpenSSL: SSL_new failed");
    return;
  }
  FIO_LEAK_COUNTER_ON_ALLOC(fio___SSL);
  fio_io_tls_set(io, (void *)ssl);

  /* attach socket */
  FIO_LOG_DDEBUG2("(%d) allocated new TLS context for %p.",
                  (int)fio_thread_getpid(),
                  (void *)io);
  BIO *bio = BIO_new_socket(fio_io_fd(io), 0);
  if (!bio) {
    FIO_LOG_ERROR("OpenSSL: BIO_new_socket failed");
    FIO_LEAK_COUNTER_ON_FREE(fio___SSL);
    SSL_free(ssl);
    fio_io_tls_set(io, NULL);
    return;
  }
  SSL_set_bio(ssl, bio, bio);
  SSL_set_ex_data(ssl, 0, (void *)io);
  if (SSL_is_server(ssl))
    SSL_accept(ssl);
  else
    SSL_connect(ssl);
}

/* *****************************************************************************
Closing Connections
***************************************************************************** */

/** Called when the IO object finished sending all data before closure. */
FIO_SFUNC void fio___openssl_finish(int fd, void *tls_ctx) {
  SSL *ssl = (SSL *)tls_ctx;
  if (ssl)
    SSL_shutdown(ssl);
  (void)fd;
}

/* *****************************************************************************
Per-Connection Cleanup
***************************************************************************** */

/** Called after the IO object is closed, used to cleanup its `tls` object. */
FIO_SFUNC void fio___openssl_cleanup(void *tls_ctx) {
  SSL *ssl = (SSL *)tls_ctx;
  if (ssl) {
    SSL_shutdown(ssl);
    FIO_LEAK_COUNTER_ON_FREE(fio___SSL);
    SSL_free(ssl);
  }
}

/* *****************************************************************************
Context Cleanup
***************************************************************************** */

static void fio___openssl_free_context_task(void *tls_ctx, void *ignr_) {
  fio___openssl_context_s *ctx = (fio___openssl_context_s *)tls_ctx;
  if (!ctx)
    return;
  FIO_LEAK_COUNTER_ON_FREE(fio___openssl_context_s);
  if (ctx->ctx)
    SSL_CTX_free(ctx->ctx);
  if (ctx->tls)
    fio_io_tls_free(ctx->tls);
  FIO_MEM_FREE(ctx, sizeof(*ctx));
  (void)ignr_;
}

/** Builds a local TLS context out of the fio_io_tls_s object. */
static void fio___openssl_free_context(void *tls_ctx) {
  fio_io_defer(fio___openssl_free_context_task, tls_ctx, NULL);
}

/* *****************************************************************************
IO Functions Structure
***************************************************************************** */

/* Returns the OpenSSL IO functions (implementation) */
SFUNC fio_io_functions_s fio_openssl_io_functions(void) {
  return (fio_io_functions_s){
      .build_context = fio___openssl_build_context,
      .free_context = fio___openssl_free_context,
      .start = fio___openssl_start,
      .read = fio___openssl_read,
      .write = fio___openssl_write,
      .flush = fio___openssl_flush,
      .cleanup = fio___openssl_cleanup,
      .finish = fio___openssl_finish,
  };
}

/* Setup OpenSSL as TLS IO default */
FIO_CONSTRUCTOR(fio___openssl_setup_default) {
  static fio_io_functions_s FIO___OPENSSL_IO_FUNCS;
  FIO___OPENSSL_IO_FUNCS = fio_openssl_io_functions();
  fio_io_tls_default_functions(&FIO___OPENSSL_IO_FUNCS);
#ifdef SIGPIPE
  fio_signal_monitor(.sig = SIGPIPE); /* avoid OpenSSL issue... */
#endif
}

/* *****************************************************************************
OpenSSL Helpers Cleanup
***************************************************************************** */
#endif /* defined(OPENSSL_VERSION_MAJOR) && OPENSSL_VERSION_MAJOR >= 3 */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* HAVE_OPENSSL */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_IO                 /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                  TLS 1.3 Implementation for IO Functions
                  (Drop-in replacement when OpenSSL unavailable)




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(H___FIO_IO___H) && defined(H___FIO_TLS13___H) &&                   \
    !defined(H___FIO_TLS13_IO___H) && !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_TLS13_IO___H 1
/* *****************************************************************************
TLS 1.3 IO Function Getter
***************************************************************************** */

/** Returns the TLS 1.3 IO functions. */
SFUNC fio_io_functions_s fio_tls13_io_functions(void);

/* *****************************************************************************
TLS 1.3 IO Functions Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
TLS 1.3 Context Types
***************************************************************************** */

/** Context for all future connections (built from fio_io_tls_s) */
typedef struct {
  fio_io_tls_s *tls;
  uint8_t is_client;
  /* Certificate chain (DER-encoded) for server */
  uint8_t *cert_der;
  size_t cert_der_len;
  /* Private key for server (P-256: 32-byte scalar, Ed25519: 32-byte seed) */
  uint8_t private_key[32];
  /* Public key for P-256 signing (65 bytes: 0x04 || x || y) */
  uint8_t public_key[65];
  size_t private_key_len;
  uint16_t private_key_type;
  /* SNI hostname for client connections */
  char server_name[256];
} fio___tls13_context_s;

FIO_LEAK_COUNTER_DEF(fio___tls13_context_s)

/** Per-connection TLS state */
typedef struct {
  union {
    fio_tls13_client_s client;
    fio_tls13_server_s server;
  } state;
  uint8_t is_client;
  uint8_t handshake_complete;
  /* Buffered incoming data (partial records) */
  uint8_t *recv_buf;
  size_t recv_buf_len; /* Total data length in recv_buf */
  size_t recv_buf_pos; /* Current read position (lazy compaction) */
  size_t recv_buf_cap;
  /* Buffered decrypted data (ready to read) */
  uint8_t *app_buf;
  size_t app_buf_len;
  size_t app_buf_cap;
  size_t app_buf_pos; /* Read position in app_buf */
  /* Buffered outgoing handshake data */
  uint8_t *send_buf;
  size_t send_buf_len;
  size_t send_buf_cap;
  size_t send_buf_pos; /* Write position in send_buf */
  /* Pre-allocated encryption buffer (avoids stack allocation in write path) */
  uint8_t enc_buf[FIO_TLS13_MAX_CIPHERTEXT_LEN + FIO_TLS13_RECORD_HEADER_LEN +
                  FIO_TLS13_TAG_LEN + 16];
  /* Parent context (for certificate chain) */
  fio___tls13_context_s *ctx;
  /* Certificate chain storage (for server - pointers must outlive handshake) */
  const uint8_t *cert_ptr;
  size_t cert_len;
} fio___tls13_connection_s;

FIO_LEAK_COUNTER_DEF(fio___tls13_connection_s)

/* *****************************************************************************
TLS 1.3 Context Builder - Self-Signed Certificate Generation
***************************************************************************** */

#if defined(H___FIO_X509___H)
/** Global P-256 keypair for self-signed certificates */
static fio_x509_keypair_s fio___tls13_self_signed_keypair;
static uint8_t *fio___tls13_self_signed_cert = NULL;
static size_t fio___tls13_self_signed_cert_len = 0;

/** Cleanup callback to free the self-signed certificate at exit */
FIO_SFUNC void fio___tls13_clear_self_signed(void *ignr_) {
  if (fio___tls13_self_signed_cert) {
    FIO_MEM_FREE(fio___tls13_self_signed_cert,
                 fio___tls13_self_signed_cert_len);
    fio___tls13_self_signed_cert = NULL;
    fio___tls13_self_signed_cert_len = 0;
  }
  fio_x509_keypair_clear(&fio___tls13_self_signed_keypair);
  (void)ignr_;
}

/** Generate self-signed certificate for TLS 1.3 server */
FIO_SFUNC int fio___tls13_make_self_signed(const char *server_name) {
  static fio_lock_i lock = FIO_LOCK_INIT;
  fio_lock(&lock);

  if (fio___tls13_self_signed_cert) {
    fio_unlock(&lock);
    return 0; /* Already generated */
  }

  FIO_LOG_DEBUG2("generating P-256 self-signed certificate for TLS 1.3...");

  /* Generate P-256 keypair (universally supported by browsers/curl) */
  if (fio_x509_keypair_p256(&fio___tls13_self_signed_keypair) != 0) {
    FIO_LOG_ERROR("TLS 1.3: failed to generate P-256 keypair");
    fio_unlock(&lock);
    return -1;
  }

  /* Set up certificate options */
  if (!server_name || !server_name[0])
    server_name = "localhost";

  const char *san_dns[] = {server_name};
  fio_x509_cert_options_s opts = {
      .subject_cn = server_name,
      .subject_cn_len = FIO_STRLEN(server_name),
      .subject_org = "facil.io",
      .subject_org_len = 8,
      .san_dns = san_dns,
      .san_dns_count = 1,
      .is_ca = 0,
  };

  /* Calculate certificate size */
  size_t cert_size = fio_x509_self_signed_cert(NULL,
                                               0,
                                               &fio___tls13_self_signed_keypair,
                                               &opts);
  if (cert_size == 0) {
    FIO_LOG_ERROR("TLS 1.3: failed to calculate certificate size");
    fio_x509_keypair_clear(&fio___tls13_self_signed_keypair);
    fio_unlock(&lock);
    return -1;
  }

  /* Allocate and generate certificate */
  fio___tls13_self_signed_cert =
      (uint8_t *)FIO_MEM_REALLOC(NULL, 0, cert_size, 0);
  if (!fio___tls13_self_signed_cert) {
    FIO_LOG_ERROR("TLS 1.3: failed to allocate certificate buffer");
    fio_x509_keypair_clear(&fio___tls13_self_signed_keypair);
    fio_unlock(&lock);
    return -1;
  }

  fio___tls13_self_signed_cert_len =
      fio_x509_self_signed_cert(fio___tls13_self_signed_cert,
                                cert_size,
                                &fio___tls13_self_signed_keypair,
                                &opts);

  if (fio___tls13_self_signed_cert_len == 0) {
    FIO_LOG_ERROR("TLS 1.3: failed to generate self-signed certificate");
    FIO_MEM_FREE(fio___tls13_self_signed_cert, cert_size);
    fio___tls13_self_signed_cert = NULL;
    fio_x509_keypair_clear(&fio___tls13_self_signed_keypair);
    fio_unlock(&lock);
    return -1;
  }

  /* Register cleanup callback */
  fio_state_callback_add(FIO_CALL_AT_EXIT, fio___tls13_clear_self_signed, NULL);

  FIO_LOG_DEBUG2("P-256 self-signed certificate generated successfully "
                 "(%zu bytes)",
                 fio___tls13_self_signed_cert_len);
  fio_unlock(&lock);
  return 0;
}
#endif /* H___FIO_X509___H */

/* *****************************************************************************
TLS 1.3 Context Builder
***************************************************************************** */

/** Callback for iterating certificates in fio_io_tls_s */
FIO_SFUNC int fio___tls13_each_cert(struct fio_io_tls_each_s *e,
                                    const char *server_name,
                                    const char *public_cert_file,
                                    const char *private_key_file,
                                    const char *pk_password) {
  fio___tls13_context_s *ctx = (fio___tls13_context_s *)e->udata;

#if defined(H___FIO_PEM___H) && defined(H___FIO_X509___H)
  /* Try to load certificate and key from PEM files */
  if (public_cert_file && private_key_file) {
    FIO_LOG_DEBUG2("TLS 1.3: loading certificate from %s", public_cert_file);
    FIO_LOG_DEBUG2("TLS 1.3: loading private key from %s", private_key_file);

    /* Read certificate file */
    char *cert_pem = fio_bstr_readfile(NULL, public_cert_file, 0, 0);
    if (!cert_pem) {
      FIO_LOG_ERROR("TLS 1.3: failed to read certificate file: %s",
                    public_cert_file);
      goto use_self_signed;
    }

    /* Read private key file */
    char *key_pem = fio_bstr_readfile(NULL, private_key_file, 0, 0);
    if (!key_pem) {
      FIO_LOG_ERROR("TLS 1.3: failed to read private key file: %s",
                    private_key_file);
      fio_bstr_free(cert_pem);
      goto use_self_signed;
    }

    /* Allocate buffer for DER-encoded certificate */
    size_t cert_pem_len = fio_bstr_len(cert_pem);
    size_t der_buf_len = cert_pem_len; /* Conservative estimate */
    ctx->cert_der = (uint8_t *)FIO_MEM_REALLOC(NULL, 0, der_buf_len, 0);
    if (!ctx->cert_der) {
      FIO_LOG_ERROR("TLS 1.3: failed to allocate certificate buffer");
      fio_bstr_free(cert_pem);
      fio_bstr_free(key_pem);
      return -1;
    }

    /* Extract DER from PEM */
    ctx->cert_der_len = fio_pem_get_certificate_der(ctx->cert_der,
                                                    der_buf_len,
                                                    cert_pem,
                                                    cert_pem_len);
    fio_bstr_free(cert_pem);

    if (ctx->cert_der_len == 0) {
      FIO_LOG_ERROR("TLS 1.3: failed to parse certificate PEM");
      FIO_MEM_FREE(ctx->cert_der, der_buf_len);
      ctx->cert_der = NULL;
      fio_bstr_free(key_pem);
      goto use_self_signed;
    }

    /* Parse private key */
    fio_pem_private_key_s pkey;
    size_t key_pem_len = fio_bstr_len(key_pem);
    if (fio_pem_parse_private_key(&pkey, key_pem, key_pem_len) != 0) {
      FIO_LOG_ERROR("TLS 1.3: failed to parse private key PEM");
      FIO_MEM_FREE(ctx->cert_der, der_buf_len);
      ctx->cert_der = NULL;
      ctx->cert_der_len = 0;
      fio_bstr_free(key_pem);
      goto use_self_signed;
    }
    fio_bstr_free(key_pem);

    /* Copy private key based on type */
    switch (pkey.type) {
    case FIO_PEM_KEY_ECDSA_P256:
      FIO_MEMCPY(ctx->private_key, pkey.ecdsa_p256.private_key, 32);
      if (pkey.ecdsa_p256.has_public_key) {
        FIO_MEMCPY(ctx->public_key, pkey.ecdsa_p256.public_key, 65);
      } else {
        /* Derive public key from private key */
#if defined(H___FIO_P256___H)
        uint8_t tmp_secret[32];
        FIO_MEMCPY(tmp_secret, pkey.ecdsa_p256.private_key, 32);
        fio_p256_keypair(tmp_secret, ctx->public_key);
        fio_secure_zero(tmp_secret, 32);
#else
        FIO_LOG_ERROR("TLS 1.3: P-256 module required for key derivation");
        fio_pem_private_key_clear(&pkey);
        FIO_MEM_FREE(ctx->cert_der, der_buf_len);
        ctx->cert_der = NULL;
        ctx->cert_der_len = 0;
        goto use_self_signed;
#endif
      }
      ctx->private_key_len = 32;
      ctx->private_key_type = FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256;
      FIO_LOG_DEBUG2("TLS 1.3: loaded P-256 private key from PEM");
      break;

    case FIO_PEM_KEY_ED25519:
      FIO_MEMCPY(ctx->private_key, pkey.ed25519.private_key, 32);
      ctx->private_key_len = 32;
      ctx->private_key_type = FIO_TLS13_SIG_ED25519;
      FIO_LOG_DEBUG2("TLS 1.3: loaded Ed25519 private key from PEM");
      break;

    case FIO_PEM_KEY_RSA:
      /* RSA signing not yet supported in TLS 1.3 implementation */
      FIO_LOG_WARNING(
          "TLS 1.3: RSA private keys not yet supported for signing");
      fio_pem_private_key_clear(&pkey);
      FIO_MEM_FREE(ctx->cert_der, der_buf_len);
      ctx->cert_der = NULL;
      ctx->cert_der_len = 0;
      goto use_self_signed;

    default:
      FIO_LOG_ERROR("TLS 1.3: unsupported private key type");
      fio_pem_private_key_clear(&pkey);
      FIO_MEM_FREE(ctx->cert_der, der_buf_len);
      ctx->cert_der = NULL;
      ctx->cert_der_len = 0;
      goto use_self_signed;
    }

    fio_pem_private_key_clear(&pkey);
    FIO_LOG_DEBUG2("TLS 1.3: certificate loaded successfully (%zu bytes)",
                   ctx->cert_der_len);
    (void)pk_password;
    (void)server_name;
    return 0;
  }

use_self_signed:
#endif /* H___FIO_PEM___H && H___FIO_X509___H */

#if defined(H___FIO_X509___H)
  /* Generate self-signed certificate if no PEM files provided or loading failed
   */
  if (public_cert_file && private_key_file) {
    FIO_LOG_WARNING(
        "TLS 1.3: PEM loading failed, using self-signed certificate");
  }

  if (fio___tls13_make_self_signed(server_name) != 0) {
    FIO_LOG_ERROR("TLS 1.3: failed to create self-signed certificate");
    return -1;
  }

  /* Copy certificate to context */
  if (fio___tls13_self_signed_cert && fio___tls13_self_signed_cert_len > 0) {
    ctx->cert_der = (uint8_t *)
        FIO_MEM_REALLOC(NULL, 0, fio___tls13_self_signed_cert_len, 0);
    if (!ctx->cert_der) {
      FIO_LOG_ERROR("TLS 1.3: failed to allocate certificate buffer");
      return -1;
    }
    FIO_MEMCPY(ctx->cert_der,
               fio___tls13_self_signed_cert,
               fio___tls13_self_signed_cert_len);
    ctx->cert_der_len = fio___tls13_self_signed_cert_len;

    /* Copy private key (P-256 scalar) */
    FIO_MEMCPY(ctx->private_key,
               fio___tls13_self_signed_keypair.secret_key,
               32);
    /* Copy public key (P-256 uncompressed point for signing) */
    FIO_MEMCPY(ctx->public_key, fio___tls13_self_signed_keypair.public_key, 65);
    ctx->private_key_len = 32;
    ctx->private_key_type = FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256;
  }
#else
  FIO_LOG_ERROR(
      "TLS 1.3: X509 module not available for certificate generation");
  return -1;
#endif

  (void)pk_password;
  return 0;
}

/** Helper that converts a `fio_io_tls_s` into the implementation's context. */
FIO_SFUNC void *fio___tls13_build_context(fio_io_tls_s *tls,
                                          uint8_t is_client) {
  fio___tls13_context_s *ctx =
      (fio___tls13_context_s *)FIO_MEM_REALLOC(NULL, 0, sizeof(*ctx), 0);
  if (!ctx) {
    FIO_LOG_ERROR("TLS 1.3: memory allocation failed for context");
    return NULL;
  }
  FIO_LEAK_COUNTER_ON_ALLOC(fio___tls13_context_s);
  FIO_MEMSET(ctx, 0, sizeof(*ctx));
  ctx->tls = fio_io_tls_dup(tls);
  ctx->is_client = is_client;

  /* For client, extract server name from TLS object for SNI */
  if (is_client) {
    FIO_IMAP_EACH(fio___io_tls_cert_map, &tls->cert, i) {
      fio_buf_info_s nm = fio_keystr_buf(&tls->cert.ary[i].nm);
      if (nm.buf && nm.len > 0 && nm.len < sizeof(ctx->server_name)) {
        FIO_MEMCPY(ctx->server_name, nm.buf, nm.len);
        ctx->server_name[nm.len] = '\0';
        FIO_LOG_DEBUG2("TLS 1.3: extracted SNI hostname: %s", ctx->server_name);
        break;
      }
    }
  } else { /* For server, load certificates */
    /* Check if certificates are configured */
    if (!fio_io_tls_cert_count(tls)) {
      /* No certificates configured - use self-signed */
#if defined(H___FIO_X509___H)
      if (fio___tls13_make_self_signed("localhost") != 0) {
        FIO_LOG_ERROR("TLS 1.3: failed to create self-signed certificate");
        goto error;
      }
      ctx->cert_der = (uint8_t *)
          FIO_MEM_REALLOC(NULL, 0, fio___tls13_self_signed_cert_len, 0);
      if (!ctx->cert_der) {
        FIO_LOG_ERROR("TLS 1.3: failed to allocate certificate buffer");
        goto error;
      }
      FIO_MEMCPY(ctx->cert_der,
                 fio___tls13_self_signed_cert,
                 fio___tls13_self_signed_cert_len);
      ctx->cert_der_len = fio___tls13_self_signed_cert_len;
      /* Copy private key (P-256 scalar) */
      FIO_MEMCPY(ctx->private_key,
                 fio___tls13_self_signed_keypair.secret_key,
                 32);
      /* Copy public key (P-256 uncompressed point for signing) */
      FIO_MEMCPY(ctx->public_key,
                 fio___tls13_self_signed_keypair.public_key,
                 65);
      ctx->private_key_len = 32;
      ctx->private_key_type = FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256;
#else
      FIO_LOG_ERROR("TLS 1.3: X509 module required for server certificates");
      goto error;
#endif
    } else {
      /* Process configured certificates */
      if (fio_io_tls_each(tls,
                          .udata = ctx,
                          .each_cert = fio___tls13_each_cert)) {
        FIO_LOG_ERROR("TLS 1.3: failed to configure certificates");
        goto error;
      }
    }
  }

  return ctx;

error:
  if (ctx) {
    if (ctx->cert_der)
      FIO_MEM_FREE(ctx->cert_der, ctx->cert_der_len);
    if (ctx->tls)
      fio_io_tls_free(ctx->tls);
    FIO_LEAK_COUNTER_ON_FREE(fio___tls13_context_s);
    FIO_MEM_FREE(ctx, sizeof(*ctx));
  }
  return NULL;
}

/* *****************************************************************************
TLS 1.3 Context Cleanup
***************************************************************************** */

FIO_SFUNC void fio___tls13_free_context_task(void *tls_ctx, void *ignr_) {
  fio___tls13_context_s *ctx = (fio___tls13_context_s *)tls_ctx;
  if (!ctx)
    return;
  FIO_LEAK_COUNTER_ON_FREE(fio___tls13_context_s);
  if (ctx->cert_der)
    FIO_MEM_FREE(ctx->cert_der, ctx->cert_der_len);
  fio_secure_zero(ctx->private_key, sizeof(ctx->private_key));
  if (ctx->tls)
    fio_io_tls_free(ctx->tls);
  FIO_MEM_FREE(ctx, sizeof(*ctx));
  (void)ignr_;
}

/** Helper to free the context built by build_context. */
FIO_SFUNC void fio___tls13_free_context(void *tls_ctx) {
  fio_io_defer(fio___tls13_free_context_task, tls_ctx, NULL);
}

/* *****************************************************************************
TLS 1.3 Per-Connection Management
***************************************************************************** */

/** Allocate connection state */
FIO_SFUNC fio___tls13_connection_s *fio___tls13_connection_new(
    fio___tls13_context_s *ctx) {
  fio___tls13_connection_s *conn =
      (fio___tls13_connection_s *)FIO_MEM_REALLOC(NULL, 0, sizeof(*conn), 0);
  if (!conn)
    return NULL;
  FIO_LEAK_COUNTER_ON_ALLOC(fio___tls13_connection_s);
  FIO_MEMSET(conn, 0, sizeof(*conn));
  conn->is_client = ctx->is_client;
  conn->ctx = ctx;

  /* Allocate buffers */
  conn->recv_buf_cap = FIO_TLS13_MAX_CIPHERTEXT_LEN + 256;
  conn->recv_buf = (uint8_t *)FIO_MEM_REALLOC(NULL, 0, conn->recv_buf_cap, 0);
  if (!conn->recv_buf)
    goto error;

  conn->app_buf_cap = FIO_TLS13_MAX_PLAINTEXT_LEN;
  conn->app_buf = (uint8_t *)FIO_MEM_REALLOC(NULL, 0, conn->app_buf_cap, 0);
  if (!conn->app_buf)
    goto error;

  conn->send_buf_cap = 8192;
  conn->send_buf = (uint8_t *)FIO_MEM_REALLOC(NULL, 0, conn->send_buf_cap, 0);
  if (!conn->send_buf)
    goto error;

  return conn;

error:
  if (conn->recv_buf)
    FIO_MEM_FREE(conn->recv_buf, conn->recv_buf_cap);
  if (conn->app_buf)
    FIO_MEM_FREE(conn->app_buf, conn->app_buf_cap);
  if (conn->send_buf)
    FIO_MEM_FREE(conn->send_buf, conn->send_buf_cap);
  FIO_LEAK_COUNTER_ON_FREE(fio___tls13_connection_s);
  FIO_MEM_FREE(conn, sizeof(*conn));
  return NULL;
}

/** Free connection state */
FIO_SFUNC void fio___tls13_connection_free(fio___tls13_connection_s *conn) {
  if (!conn)
    return;

  /* Destroy TLS state */
  if (conn->is_client)
    fio_tls13_client_destroy(&conn->state.client);
  else
    fio_tls13_server_destroy(&conn->state.server);

  /* Free buffers */
  if (conn->recv_buf)
    FIO_MEM_FREE(conn->recv_buf, conn->recv_buf_cap);
  if (conn->app_buf)
    FIO_MEM_FREE(conn->app_buf, conn->app_buf_cap);
  if (conn->send_buf)
    FIO_MEM_FREE(conn->send_buf, conn->send_buf_cap);

  FIO_LEAK_COUNTER_ON_FREE(fio___tls13_connection_s);
  FIO_MEM_FREE(conn, sizeof(*conn));
}

/* *****************************************************************************
TLS 1.3 IO Functions - Start
***************************************************************************** */

/** Called when a new IO is first attached to a valid protocol. */
FIO_SFUNC void fio___tls13_start(fio_io_s *io) {
  fio___tls13_context_s *ctx = (fio___tls13_context_s *)fio_io_tls(io);
  if (!ctx) {
    FIO_LOG_ERROR("TLS 1.3: Context missing for connection!");
    return;
  }

  /* Allocate connection state */
  fio___tls13_connection_s *conn = fio___tls13_connection_new(ctx);
  if (!conn) {
    FIO_LOG_ERROR("TLS 1.3: failed to allocate connection state");
    return;
  }

  /* Store connection state in IO */
  fio_io_tls_set(io, (void *)conn);

  FIO_LOG_DDEBUG2("(%d) TLS 1.3: allocated new connection for %p (%s)",
                  (int)fio_thread_getpid(),
                  (void *)io,
                  conn->is_client ? "client" : "server");

  if (conn->is_client) {
    /* Initialize client and start handshake with SNI */
    const char *sni = ctx->server_name[0] ? ctx->server_name : NULL;
    fio_tls13_client_init(&conn->state.client, sni);
    fio_tls13_client_skip_verification(&conn->state.client,
                                       1); /* TODO: proper verification */

    /* Generate ClientHello */
    int ch_len = fio_tls13_client_start(&conn->state.client,
                                        conn->send_buf,
                                        conn->send_buf_cap);
    if (ch_len < 0) {
      FIO_LOG_ERROR("TLS 1.3: failed to generate ClientHello");
      return;
    }
    conn->send_buf_len = (size_t)ch_len;
    conn->send_buf_pos = 0;
  } else {
    /* Initialize server */
    fio_tls13_server_init(&conn->state.server);

    /* Set certificate chain - use pointers stored in connection struct */
    if (ctx->cert_der && ctx->cert_der_len > 0) {
      /* Store cert pointer and length in connection for lifetime management */
      conn->cert_ptr = ctx->cert_der;
      conn->cert_len = ctx->cert_der_len;
      fio_tls13_server_set_cert_chain(&conn->state.server,
                                      &conn->cert_ptr,
                                      &conn->cert_len,
                                      1);
    }

    /* Set private key */
    if (ctx->private_key_len > 0) {
      fio_tls13_server_set_private_key(&conn->state.server,
                                       ctx->private_key,
                                       ctx->private_key_len,
                                       ctx->private_key_type);
      /* Copy public key for P-256 signing */
      if (ctx->private_key_type == FIO_TLS13_SIG_ECDSA_SECP256R1_SHA256) {
        FIO_MEMCPY(conn->state.server.public_key, ctx->public_key, 65);
      }
    }
  }
}

/* *****************************************************************************
TLS 1.3 IO Functions - Read
***************************************************************************** */

/** Called to perform a non-blocking `read`, same as the system call. */
FIO_SFUNC ssize_t fio___tls13_read(int fd,
                                   void *buf,
                                   size_t len,
                                   void *tls_ctx) {
  fio___tls13_connection_s *conn = (fio___tls13_connection_s *)tls_ctx;
  if (!conn || !buf)
    return -1;

  /* If we have buffered application data, return it first */
  if (conn->app_buf_len > conn->app_buf_pos) {
    size_t available = conn->app_buf_len - conn->app_buf_pos;
    size_t to_copy = (len < available) ? len : available;
    FIO_MEMCPY(buf, conn->app_buf + conn->app_buf_pos, to_copy);
    conn->app_buf_pos += to_copy;

    /* Reset buffer if fully consumed */
    if (conn->app_buf_pos >= conn->app_buf_len) {
      conn->app_buf_len = 0;
      conn->app_buf_pos = 0;
    }
    return (ssize_t)to_copy;
  }

  /* Calculate available space in recv_buf and compact if needed */
  size_t recv_data_len = conn->recv_buf_len - conn->recv_buf_pos;
  size_t recv_space = conn->recv_buf_cap - conn->recv_buf_len;

  /* Lazy compaction: only compact when buffer is >50% consumed AND
   * we don't have enough space for a new record */
  if (conn->recv_buf_pos > (conn->recv_buf_cap >> 1) &&
      recv_space < FIO_TLS13_MAX_CIPHERTEXT_LEN) {
    if (recv_data_len > 0) {
      FIO_MEMMOVE(conn->recv_buf,
                  conn->recv_buf + conn->recv_buf_pos,
                  recv_data_len);
    }
    conn->recv_buf_len = recv_data_len;
    conn->recv_buf_pos = 0;
    recv_space = conn->recv_buf_cap - conn->recv_buf_len;
  }

  /* Read raw data from socket */
  errno = 0;
  ssize_t raw_read =
      fio_sock_read(fd, conn->recv_buf + conn->recv_buf_len, recv_space);
  if (raw_read <= 0) {
    if (raw_read == 0)
      return 0; /* EOF */
    if (errno == EWOULDBLOCK || errno == EAGAIN)
      return -1;
    return raw_read;
  }
  conn->recv_buf_len += (size_t)raw_read;
  recv_data_len = conn->recv_buf_len - conn->recv_buf_pos;

  /* Process received data */
  uint8_t *recv_ptr = conn->recv_buf + conn->recv_buf_pos;
  while (recv_data_len >= FIO_TLS13_RECORD_HEADER_LEN) {
    /* Check if we have a complete record */
    uint16_t record_len = ((uint16_t)recv_ptr[3] << 8) | recv_ptr[4];
    size_t total_record_len = FIO_TLS13_RECORD_HEADER_LEN + record_len;

    if (recv_data_len < total_record_len)
      break; /* Need more data */

    if (!conn->handshake_complete) {
      /* Process handshake */
      uint8_t out_buf[8192];
      size_t out_len = 0;
      int consumed;

      if (conn->is_client) {
        consumed = fio_tls13_client_process(&conn->state.client,
                                            recv_ptr,
                                            recv_data_len,
                                            out_buf,
                                            sizeof(out_buf),
                                            &out_len);
      } else {
        consumed = fio_tls13_server_process(&conn->state.server,
                                            recv_ptr,
                                            recv_data_len,
                                            out_buf,
                                            sizeof(out_buf),
                                            &out_len);
      }

      if (consumed < 0) {
        FIO_LOG_DEBUG2("TLS 1.3: handshake processing error");
        errno = ECONNRESET;
        return -1;
      }

      /* Buffer any handshake response */
      if (out_len > 0) {
        if (conn->send_buf_len + out_len <= conn->send_buf_cap) {
          FIO_MEMCPY(conn->send_buf + conn->send_buf_len, out_buf, out_len);
          conn->send_buf_len += out_len;
        }
        /* Immediately try to send handshake response */
        while (conn->send_buf_pos < conn->send_buf_len) {
          errno = 0;
          ssize_t hs_written =
              fio_sock_write(fd,
                             conn->send_buf + conn->send_buf_pos,
                             conn->send_buf_len - conn->send_buf_pos);
          if (hs_written <= 0) {
            if (errno == EWOULDBLOCK || errno == EAGAIN)
              break; /* Will retry later */
            break;
          }
          conn->send_buf_pos += (size_t)hs_written;
        }
        if (conn->send_buf_pos >= conn->send_buf_len) {
          conn->send_buf_len = 0;
          conn->send_buf_pos = 0;
        }
      }

      /* Advance read position (lazy compaction) */
      if (consumed > 0 && (size_t)consumed <= recv_data_len) {
        conn->recv_buf_pos += (size_t)consumed;
        recv_ptr += consumed;
        recv_data_len -= (size_t)consumed;
      }

      /* Check if handshake is complete */
      if (conn->is_client) {
        if (fio_tls13_client_is_connected(&conn->state.client)) {
          conn->handshake_complete = 1;
          FIO_LOG_DEBUG2("TLS 1.3: client handshake complete");
        } else if (fio_tls13_client_is_error(&conn->state.client)) {
          FIO_LOG_DEBUG2("TLS 1.3: client handshake error");
          errno = ECONNRESET;
          return -1;
        }
      } else {
        if (fio_tls13_server_is_connected(&conn->state.server)) {
          conn->handshake_complete = 1;
          FIO_LOG_DEBUG2("TLS 1.3: server handshake complete");
        } else if (fio_tls13_server_is_error(&conn->state.server)) {
          FIO_LOG_DEBUG2("TLS 1.3: server handshake error");
          errno = ECONNRESET;
          return -1;
        }
      }
    } else {
      /* Decrypt application data */
      int dec_len;

      /* OPTIMIZATION: If user buffer is large enough and app_buf is empty,
       * decrypt directly into user buffer to avoid double copy */
      size_t expected_plaintext_len = record_len > (FIO_TLS13_TAG_LEN + 1)
                                          ? record_len - FIO_TLS13_TAG_LEN - 1
                                          : 0;
      uint8_t *decrypt_target;
      size_t decrypt_capacity;

      if (len >= expected_plaintext_len && conn->app_buf_len == 0 &&
          conn->app_buf_pos == 0) {
        /* Decrypt directly to user buffer */
        decrypt_target = (uint8_t *)buf;
        decrypt_capacity = len;
      } else {
        /* Use app_buf as intermediate buffer */
        decrypt_target = conn->app_buf + conn->app_buf_len;
        decrypt_capacity = conn->app_buf_cap - conn->app_buf_len;
      }

      if (conn->is_client) {
        dec_len = fio_tls13_client_decrypt(&conn->state.client,
                                           decrypt_target,
                                           decrypt_capacity,
                                           recv_ptr,
                                           total_record_len);
      } else {
        dec_len = fio_tls13_server_decrypt(&conn->state.server,
                                           decrypt_target,
                                           decrypt_capacity,
                                           recv_ptr,
                                           total_record_len);
      }

      if (dec_len < 0) {
        FIO_LOG_DEBUG2("TLS 1.3: decryption error");
        errno = ECONNRESET;
        return -1;
      }

      /* Advance read position (lazy compaction) */
      conn->recv_buf_pos += total_record_len;
      recv_ptr += total_record_len;
      recv_data_len -= total_record_len;

      /* If we decrypted directly to user buffer, return immediately */
      if (decrypt_target == (uint8_t *)buf && dec_len > 0) {
        return (ssize_t)dec_len;
      }

      if (dec_len > 0)
        conn->app_buf_len += (size_t)dec_len;
    }
  }

  /* Return buffered application data */
  if (conn->app_buf_len > conn->app_buf_pos) {
    size_t available = conn->app_buf_len - conn->app_buf_pos;
    size_t to_copy = (len < available) ? len : available;
    FIO_MEMCPY(buf, conn->app_buf + conn->app_buf_pos, to_copy);
    conn->app_buf_pos += to_copy;

    if (conn->app_buf_pos >= conn->app_buf_len) {
      conn->app_buf_len = 0;
      conn->app_buf_pos = 0;
    }
    return (ssize_t)to_copy;
  }

  /* No data available yet */
  errno = EWOULDBLOCK;
  return -1;
}

/* *****************************************************************************
TLS 1.3 IO Functions - Write
***************************************************************************** */

/** Called to perform a non-blocking `write`, same as the system call. */
FIO_SFUNC ssize_t fio___tls13_write(int fd,
                                    const void *buf,
                                    size_t len,
                                    void *tls_ctx) {
  fio___tls13_connection_s *conn = (fio___tls13_connection_s *)tls_ctx;
  if (!conn || !buf || len == 0)
    return -1;

  /* If handshake not complete, can't send application data */
  if (!conn->handshake_complete) {
    errno = EWOULDBLOCK;
    return -1;
  }

  /* Flush any pending handshake data (e.g., client Finished) before sending
   * application data. The server must receive the client Finished before it
   * can process application data encrypted with application keys. */
  while (conn->send_buf_pos < conn->send_buf_len) {
    errno = 0;
    ssize_t hs_written =
        fio_sock_write(fd,
                       conn->send_buf + conn->send_buf_pos,
                       conn->send_buf_len - conn->send_buf_pos);
    if (hs_written <= 0) {
      /* Can't send handshake data yet, so can't send app data either */
      errno = EWOULDBLOCK;
      return -1;
    }
    conn->send_buf_pos += (size_t)hs_written;
  }
  /* Reset send buffer after handshake data is fully sent */
  if (conn->send_buf_pos >= conn->send_buf_len) {
    conn->send_buf_len = 0;
    conn->send_buf_pos = 0;
  }

  /* Limit to max plaintext size */
  if (len > FIO_TLS13_MAX_PLAINTEXT_LEN)
    len = FIO_TLS13_MAX_PLAINTEXT_LEN;

  /* Encrypt data using pre-allocated buffer (avoids stack allocation) */
  int enc_len;
  if (conn->is_client) {
    enc_len = fio_tls13_client_encrypt(&conn->state.client,
                                       conn->enc_buf,
                                       sizeof(conn->enc_buf),
                                       (const uint8_t *)buf,
                                       len);
  } else {
    enc_len = fio_tls13_server_encrypt(&conn->state.server,
                                       conn->enc_buf,
                                       sizeof(conn->enc_buf),
                                       (const uint8_t *)buf,
                                       len);
  }

  if (enc_len < 0) {
    FIO_LOG_DEBUG2("TLS 1.3: encryption error");
    errno = ECONNRESET;
    return -1;
  }

  /* Write encrypted data to socket */
  errno = 0;
  ssize_t written = fio_sock_write(fd, conn->enc_buf, (size_t)enc_len);
  if (written <= 0) {
    if (errno == EWOULDBLOCK || errno == EAGAIN)
      return -1;
    return written;
  }

  /* If we wrote all encrypted data, report original plaintext length */
  if (written == enc_len)
    return (ssize_t)len;

  /* Partial write - this is tricky with TLS, report error */
  /* TODO: Buffer partial writes properly */
  errno = EWOULDBLOCK;
  return -1;
}

/* *****************************************************************************
TLS 1.3 IO Functions - Flush
***************************************************************************** */

/** Sends any unsent internal data. Returns 0 only if all data was sent. */
FIO_SFUNC int fio___tls13_flush(int fd, void *tls_ctx) {
  fio___tls13_connection_s *conn = (fio___tls13_connection_s *)tls_ctx;
  if (!conn)
    return 0;

  /* Send any buffered handshake data */
  while (conn->send_buf_pos < conn->send_buf_len) {
    errno = 0;
    ssize_t written = fio_sock_write(fd,
                                     conn->send_buf + conn->send_buf_pos,
                                     conn->send_buf_len - conn->send_buf_pos);
    if (written <= 0) {
      if (errno == EWOULDBLOCK || errno == EAGAIN)
        return -1; /* Would block, try again later */
      return -1;   /* Error */
    }
    conn->send_buf_pos += (size_t)written;
  }

  /* Reset send buffer if fully sent */
  if (conn->send_buf_pos >= conn->send_buf_len) {
    conn->send_buf_len = 0;
    conn->send_buf_pos = 0;
  }

  return (conn->send_buf_len > conn->send_buf_pos) ? -1 : 0;
}

/* *****************************************************************************
TLS 1.3 IO Functions - Finish
***************************************************************************** */

/** Called when the IO object finished sending all data before closure. */
FIO_SFUNC void fio___tls13_finish(int fd, void *tls_ctx) {
  fio___tls13_connection_s *conn = (fio___tls13_connection_s *)tls_ctx;
  if (!conn)
    return;

  /* Send close_notify alert */
  if (conn->handshake_complete) {
    uint8_t alert[32];
    /* Build close_notify alert: level=warning(1), description=close_notify(0)
     */
    uint8_t alert_data[2] = {1, 0};
    int enc_len;

    if (conn->is_client) {
      enc_len = fio_tls13_record_encrypt(alert,
                                         sizeof(alert),
                                         alert_data,
                                         2,
                                         FIO_TLS13_CONTENT_ALERT,
                                         &conn->state.client.client_app_keys);
    } else {
      enc_len = fio_tls13_record_encrypt(alert,
                                         sizeof(alert),
                                         alert_data,
                                         2,
                                         FIO_TLS13_CONTENT_ALERT,
                                         &conn->state.server.server_app_keys);
    }

    if (enc_len > 0) {
      /* Best effort send, ignore errors */
      (void)fio_sock_write(fd, alert, (size_t)enc_len);
    }
  }
  (void)fd;
}

/* *****************************************************************************
TLS 1.3 IO Functions - Cleanup
***************************************************************************** */

/** Called after the IO object is closed, used to cleanup its `tls` object. */
FIO_SFUNC void fio___tls13_cleanup(void *tls_ctx) {
  fio___tls13_connection_s *conn = (fio___tls13_connection_s *)tls_ctx;
  fio___tls13_connection_free(conn);
}

/* *****************************************************************************
TLS 1.3 IO Functions Structure
***************************************************************************** */

/** Returns the TLS 1.3 IO functions (implementation) */
SFUNC fio_io_functions_s fio_tls13_io_functions(void) {
  return (fio_io_functions_s){
      .build_context = fio___tls13_build_context,
      .free_context = fio___tls13_free_context,
      .start = fio___tls13_start,
      .read = fio___tls13_read,
      .write = fio___tls13_write,
      .flush = fio___tls13_flush,
      .cleanup = fio___tls13_cleanup,
      .finish = fio___tls13_finish,
  };
}

/* *****************************************************************************
TLS 1.3 Default Setup (when OpenSSL is not available)
***************************************************************************** */

#if !defined(HAVE_OPENSSL) && !defined(H___FIO_OPENSSL___H)
/** Setup TLS 1.3 as TLS IO default when OpenSSL is not available */
FIO_CONSTRUCTOR(fio___tls13_setup_default) {
  static fio_io_functions_s FIO___TLS13_IO_FUNCS;
  FIO___TLS13_IO_FUNCS = fio_tls13_io_functions();
  fio_io_tls_default_functions(&FIO___TLS13_IO_FUNCS);
  FIO_LOG_DEBUG2("TLS 1.3 registered as default TLS implementation");
}
#endif /* !HAVE_OPENSSL && !H___FIO_OPENSSL___H */

/* *****************************************************************************
TLS 1.3 IO Functions Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* H___FIO_IO___H && H___FIO_TLS13___H */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_PUBSUB             /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                Pub/Sub Services for IPC / Server applications




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_PUBSUB) && !defined(H___FIO_PUBSUB___H) &&                     \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_PUBSUB___H

/* *****************************************************************************
Pub/Sub - message format
***************************************************************************** */

/** Message structure, as received by the `on_message` subscription callback. */
struct fio_msg_s {
  /** A connection (if any) to which the subscription belongs. */
  fio_io_s *io;
  /** The `udata` argument associated with the subscription. */
  void *udata;
  /** Message ID. */
  uint64_t id;
  /** Milliseconds since epoch. */
  uint64_t published;
  /**
   * A channel name, allowing for pub/sub patterns.
   *
   * NOTE: this is a shared copy - do NOT mutate the channel name string.
   */
  fio_buf_info_s channel;
  /**
   * The actual message.
   *
   * NOTE: this is a shared copy - do NOT mutate the message payload string.
   **/
  fio_buf_info_s message;
  /** Channel name namespace. Negative values are reserved. */
  int16_t filter;
  /** flag indicating if the message is JSON data or binary/text. */
  uint8_t is_json;
};

/* *****************************************************************************
Pub/Sub - Subscribe / Unsubscribe
***************************************************************************** */

/** Possible arguments for the fio_subscribe method. */
typedef struct {
  /**
   * The subscription owner - if none, the subscription is owned by the system.
   *
   * Note:
   *
   * Both the system and the `io` objects each manage channel listing
   * which allows only a single subscription to the same channel.
   *
   * This means a single subscription per channel per IO and a single
   * subscription per channel for the global system unless managing the
   * subscription handle manually.
   */
  fio_io_s *io;
  /**
   * A named `channel` to which the message was sent.
   *
   * Subscriptions require a match by both channel name and namespace filter.
   */
  fio_buf_info_s channel;
  /**
   * The callback to be called for each message forwarded to the subscription.
   */
  void (*on_message)(fio_msg_s *msg);
  /** An optional callback for when a subscription is canceled. */
  void (*on_unsubscribe)(void *udata);
  /** The opaque udata value is ignored and made available to the callbacks. */
  void *udata;
  /** The queue to which the callbacks should be routed. May be NULL. */
  fio_queue_s *queue;
  /** Replay cached messages (if any) since supplied time in milliseconds. */
  uint64_t replay_since;
  /**
   * OPTIONAL: subscription handle return value - should be NULL when using
   * automatic memory management with the IO or global environment.
   *
   * When set, the `io` pointer will be ignored and the subscription object
   * handle will be written to the `subscription_handle_ptr` which MUST be
   * used when unsubscribing.
   *
   * NOTE: this could cause subscriptions and memory leaks unless properly
   * handled.
   */
  uintptr_t *subscription_handle_ptr;
  /**
   * A numerical namespace `filter` subscribers need to match.
   *
   * Negative values are reserved for facil.io framework extensions.
   *
   * Filer channels are bound to the processes and workers, they are NOT
   * forwarded to engines and can be used for inter process communication (IPC).
   */
  int16_t filter;
  /** If set, pattern matching will be used (name is a pattern). */
  uint8_t is_pattern;
  /** If set, subscription will be limited to the root / master process. */
  uint8_t master_only;
} fio_subscribe_args_s;

/**
 * Subscribes to a channel / filter pair.
 *
 * The on_unsubscribe callback will be called on failure.
 */
SFUNC void fio_subscribe(fio_subscribe_args_s args);

/**
 * Subscribes to a channel / filter pair.
 *
 * See `fio_subscribe_args_s` for details.
 */
#define fio_subscribe(...) fio_subscribe((fio_subscribe_args_s){__VA_ARGS__})

/**
 * Cancels an existing subscriptions.
 *
 * Accepts the same arguments as `fio_subscribe`, except the `udata` and
 * callback details are ignored (no need to provide `udata` or callback
 * details).
 *
 * If a `subscription_handle_ptr` was provided it should contain the value of
 * the subscription handle returned.
 *
 * Returns -1 if the subscription could not be found. Otherwise returns 0.
 */
SFUNC int fio_unsubscribe(fio_subscribe_args_s args);

/**
 * Cancels an existing subscriptions.
 *
 * Accepts the same arguments as `fio_subscribe`, except the `udata` and
 * callback details are ignored (no need to provide `udata` or callback
 * details).
 *
 * Returns -1 if the subscription could not be found. Otherwise returns 0.
 */
#define fio_unsubscribe(...)                                                   \
  fio_unsubscribe((fio_subscribe_args_s){__VA_ARGS__})

/* A callback for IO subscriptions - sends raw message data. */
FIO_SFUNC void FIO_ON_MESSAGE_SEND_MESSAGE(fio_msg_s *msg);

/* *****************************************************************************
Pub/Sub - Publish
***************************************************************************** */

/** A pub/sub engine data structure. See details later on. */
typedef struct fio_pubsub_engine_s fio_pubsub_engine_s;

/** Publishing and on_message callback arguments. */
typedef struct fio_publish_args_s {
  /** The pub/sub engine that should be used to forward this message. */
  fio_pubsub_engine_s const *engine;
  /** If `from` is specified, it will be skipped (won't receive message)
   *  UNLESS a non-native `engine` is specified. */
  fio_io_s *from;
  /** Message ID (if missing, a random ID will be generated). */
  uint64_t id;
  /** Milliseconds since epoch (if missing, defaults to "now"). */
  uint64_t published;
  /** The target named channel. */
  fio_buf_info_s channel;
  /** The message body / content. */
  fio_buf_info_s message;
  /** A numeral namespace for channel names. Negative values are reserved. */
  int16_t filter;
  /** A flag indicating if the message is JSON data or not. */
  uint8_t is_json;
} fio_publish_args_s;

/**
 * Publishes a message to the relevant subscribers (if any).
 *
 * By default the message is sent using the `FIO_PUBSUB_DEFAULT` engine (set by
 * default to `FIO_PUBSUB_LOCAL` which publishes to all processes, including the
 * calling process).
 *
 * To limit the message only to other processes (exclude the calling process),
 * use the `FIO_PUBSUB_SIBLINGS` engine.
 *
 * To limit the message only to the calling process, use the
 * `FIO_PUBSUB_PROCESS` engine.
 *
 * To limit the message only to the root process, use the `FIO_PUBSUB_ROOT`
 * engine.
 */
SFUNC void fio_publish(fio_publish_args_s args);
/**
 * Publishes a message to the relevant subscribers (if any).
 *
 * By default the message is sent using the `FIO_PUBSUB_DEFAULT` engine (set by
 * default to `FIO_PUBSUB_LOCAL` which publishes to all processes, including the
 * calling process).
 *
 * To limit the message only to other processes (exclude the calling process),
 * use the `FIO_PUBSUB_SIBLINGS` engine.
 *
 * To limit the message only to the calling process, use the
 * `FIO_PUBSUB_PROCESS` engine.
 *
 * To limit the message only to the root process, use the `FIO_PUBSUB_ROOT`
 * engine.
 */
#define fio_publish(...) fio_publish((fio_publish_args_s){__VA_ARGS__})

/**
 * Defers the current callback, so it will be called again for the message.
 *
 * After calling this function, the `msg` object must NOT be accessed again.
 */
SFUNC void fio_pubsub_message_defer(fio_msg_s *msg);

/* *****************************************************************************
Pub/Sub - History and Event Replay - TODO!!!
***************************************************************************** */

/** Sets the maximum number of messages to be stored in the history store. */
// SFUNC void fio_pubsub_store_limit(size_t messages);

/* *****************************************************************************
Pub/Sub - defaults and builtin pub/sub engines
***************************************************************************** */

/** Flag bits for internal usage (message exchange network format). */
typedef enum {
  /* pub/sub messages */
  FIO___PUBSUB_JSON = 1,
  FIO___PUBSUB_PROCESS = 2,
  FIO___PUBSUB_ROOT = 4,
  FIO___PUBSUB_SIBLINGS = 8,
  FIO___PUBSUB_WORKERS = (8 | 2),
  FIO___PUBSUB_LOCAL = (8 | 4 | 2),
  FIO___PUBSUB_REMOTE = 16,
  FIO___PUBSUB_CLUSTER = (16 | 8 | 4 | 2),
  FIO___PUBSUB_REPLAY = 32, /* history replay message */

  /* internal messages */
  FIO___PUBSUB_SPECIAL = 128,
  FIO___PUBSUB_SUB = (128 | 1),
  FIO___PUBSUB_UNSUB = (128 | 2),
  FIO___PUBSUB_IDENTIFY = (128 | 4),  /* identify remote connection */
  FIO___PUBSUB_FORWARDER = (128 | 8), /* forward to external engine */
  FIO___PUBSUB_PING = (128 | 16),

  FIO___PUBSUB_HISTORY_START = (128 | 32),
  FIO___PUBSUB_HISTORY_END = (128 | 64),
} fio___pubsub_msg_flags_e;

/** Used to publish the message exclusively to the root / master process. */
#define FIO_PUBSUB_ROOT ((fio_pubsub_engine_s *)FIO___PUBSUB_ROOT)
/** Used to publish the message only within the current process. */
#define FIO_PUBSUB_PROCESS ((fio_pubsub_engine_s *)FIO___PUBSUB_PROCESS)
/** Used to publish the message except within the current process. */
#define FIO_PUBSUB_SIBLINGS ((fio_pubsub_engine_s *)FIO___PUBSUB_SIBLINGS)
/** Used to publish the message for this process, its siblings and root. */
#define FIO_PUBSUB_LOCAL ((fio_pubsub_engine_s *)FIO___PUBSUB_LOCAL)
/** Used to publish the message to any possible publishers. */
#define FIO_PUBSUB_CLUSTER ((fio_pubsub_engine_s *)FIO___PUBSUB_CLUSTER)

#if defined(FIO_EXTERN) /* static definitions can't be easily repeated. */
/** The default engine (settable). Initial default is FIO_PUBSUB_CLUSTER. */
SFUNC const fio_pubsub_engine_s *FIO_PUBSUB_DEFAULT;

/**
 * The pattern matching callback used for pattern matching.
 *
 * Returns 1 on a match or 0 if the string does not match the pattern.
 *
 * By default, the value is set to `fio_glob_match` (see facil.io's C STL).
 */
SFUNC uint8_t (*FIO_PUBSUB_PATTERN_MATCH)(fio_str_info_s pattern,
                                          fio_str_info_s channel);
#endif

/* *****************************************************************************
Message metadata (advance usage API)
***************************************************************************** */

/**
 * The number of different metadata callbacks that can be attached.
 *
 * Effects performance.
 *
 * The default value should be enough for the following metadata objects:
 * - WebSocket server headers.
 * - WebSocket client (header + masked message copy).
 * - EventSource (SSE) encoded named channel and message.
 */
#ifndef FIO___PUBSUB_METADATA_STORE_LIMIT
#define FIO___PUBSUB_METADATA_STORE_LIMIT 4
#endif

/** Pub/Sub Metadata callback type. */
typedef void *(*fio_msg_metadata_fn)(fio_msg_s *);

/**
 * It's possible to attach metadata to facil.io pub/sub messages before they are
 * published.
 *
 * This allows, for example, messages to be encoded as network packets for
 * outgoing protocols (i.e., encoding for WebSocket transmissions), improving
 * performance in large network based broadcasting.
 *
 * Up to `FIO___PUBSUB_METADATA_STORE_LIMIT` metadata callbacks can be attached.
 *
 * The callback should return a `void *` pointer.
 *
 * To remove a callback, call `fio_message_metadata_remove` with the returned
 * value.
 *
 * The cluster messaging system allows some messages to be flagged as JSON and
 * this flag is available to the metadata callback.
 *
 * Returns zero (0) on success or -1 on failure.
 *
 * Multiple `fio_message_metadata_add` calls increase a reference count and
 * should be matched by the same number of `fio_message_metadata_remove`.
 */
SFUNC int fio_message_metadata_add(fio_msg_metadata_fn metadata_func,
                                   void (*cleanup)(void *));

/**
 * Removed the metadata callback.
 *
 * Removal might be delayed if live metatdata exists.
 */
SFUNC void fio_message_metadata_remove(fio_msg_metadata_fn metadata_func);

/** Finds the message's metadata, returning the data or NULL. */
SFUNC void *fio_message_metadata(fio_msg_s *msg,
                                 fio_msg_metadata_fn metadata_func);

/* *****************************************************************************
Pub/Sub Middleware and Extensions ("Engines")
***************************************************************************** */

/**
 * facil.io can be linked with external Pub/Sub services using "engines".
 *
 * Engines MUST provide the listed function pointers and should be attached
 * using the `fio_pubsub_attach` function.
 *
 * Engines that were connected / attached using `fio_pubsub_attach` MUST
 * disconnect / detach, before being destroyed, by using the `fio_pubsub_detach`
 * function.
 *
 * When an engine received a message to publish, it should call the
 * `fio_publish` function with the engine to which the message is forwarded.
 * i.e.:
 *
 *       fio_publish(
 *           .engine = FIO_PUBSUB_LOCAL,
 *           .channel = channel_name,
 *           .message = msg_body);
 *
 * IMPORTANT: The callbacks will be called by the main IO thread, so they should
 * never block. Long tasks should copy the data and scheduling an external task
 * (i.e., using `fio_io_defer`).
 */
struct fio_pubsub_engine_s {
  /** Called after the engine was detached, may be used for cleanup. */
  void (*detached)(const fio_pubsub_engine_s *eng);
  /** Subscribes to a channel. Called ONLY in the Root (master) process. */
  void (*subscribe)(const fio_pubsub_engine_s *eng,
                    fio_buf_info_s channel,
                    int16_t filter);
  /** Subscribes to a pattern. Called ONLY in the Root (master) process. */
  void (*psubscribe)(const fio_pubsub_engine_s *eng,
                     fio_buf_info_s channel,
                     int16_t filter);
  /** Unsubscribes to a channel. Called ONLY in the Root (master) process. */
  void (*unsubscribe)(const fio_pubsub_engine_s *eng,
                      fio_buf_info_s channel,
                      int16_t filter);
  /** Unsubscribe to a pattern. Called ONLY in the Root (master) process. */
  void (*punsubscribe)(const fio_pubsub_engine_s *eng,
                       fio_buf_info_s channel,
                       int16_t filter);
  /** Publishes a message through the engine. Called by any worker / thread. */
  void (*publish)(const fio_pubsub_engine_s *eng, fio_msg_s *msg);
};

/**
 * Attaches an engine, so it's callback can be called by facil.io.
 *
 * The `(p)subscribe` callback will be called for every existing channel.
 *
 * This can be called multiple times resulting in re-running the `(p)subscribe`
 * callbacks.
 *
 * NOTE: engines are automatically detached from child processes but can be
 * safely used even so - messages are always forwarded to the engine attached to
 * the root (master) process.
 *
 * NOTE: engines should publish events to `FIO_PUBSUB_LOCAL`.
 */
SFUNC void fio_pubsub_attach(fio_pubsub_engine_s *engine);

/** Schedules an engine for Detachment, so it could be safely destroyed. */
SFUNC void fio_pubsub_detach(fio_pubsub_engine_s *engine);

/* *****************************************************************************
Pub/Sub Clustering and Security
***************************************************************************** */

/** Sets the current IPC socket address (can't be changed while running). */
SFUNC int fio_pubsub_ipc_url_set(char *str, size_t len);

/** Returns a pointer to the current IPC socket address. */
SFUNC const char *fio_pubsub_ipc_url(void);

/** Auto-peer detection and pub/sub multi-machine clustering using `port`. */
SFUNC void fio_pubsub_broadcast_on_port(int16_t port);

/* *****************************************************************************



Pub/Sub Implementation



The implementation has a big number of interconnected modules:
- Distribution Channels (`fio_channel_s` and `FIO___PUBSUB_POSTOFFICE`)
- Subscriptions (`fio_subscription_s`)
- Metadata Management.
- External Distribution Engines (`fio_pubsub_engine_s`)
- Message format and their network exchange protocols (`fio___pubsub_message_s`)

Message wire format (as 64 bit numerals in little endien encoding):
[0] Message ID
[1] Publication time (milliseconds since epoch)
[2] 16 bit filter | 16 bit channel len | 24 bit message len | 8 bit flags
| --- encryption starts --- |
| X bytes - (channel name, + 1 NUL terminator) |
| Y bytes - (message data, + 1 NUL terminator) |
| --- encryption ends --- |
| 16 bytes - (optional) message MAC |
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

#undef FIO___PUBSUB_MESSAGE_HEADER
#define FIO___PUBSUB_MESSAGE_HEADER 24
/* header + 2 NUL bytes (message + channel) + 16 byte MAC */
#undef FIO___PUBSUB_MESSAGE_OVERHEAD
#define FIO___PUBSUB_MESSAGE_OVERHEAD (FIO___PUBSUB_MESSAGE_HEADER + 18)

/* *****************************************************************************
Pub/Sub - defaults and builtin pub/sub engines
***************************************************************************** */

/** The default engine (settable). Initial default is FIO_PUBSUB_CLUSTER. */
SFUNC const fio_pubsub_engine_s *FIO_PUBSUB_DEFAULT = FIO_PUBSUB_CLUSTER;

/**
 * The pattern matching callback used for pattern matching.
 *
 * Returns 1 on a match or 0 if the string does not match the pattern.
 *
 * By default, the value is set to `fio_glob_match` (see facil.io's C STL).
 */
SFUNC uint8_t (*FIO_PUBSUB_PATTERN_MATCH)(fio_str_info_s,
                                          fio_str_info_s) = fio_glob_match;

/* a mock callback for subscriptions */
FIO_SFUNC void fio___subscription_mock_cb(fio_msg_s *msg) { (void)msg; }

/* A callback for IO subscriptions. */
FIO_SFUNC void fio___subscription_call_protocol(fio_msg_s *msg) {
  if (!msg->io)
    return;
  fio_io_protocol_s *p = fio_io_protocol(msg->io);
  FIO_ASSERT_DEBUG(p, "every IO object should have a protocol, always");
  p->on_pubsub(msg);
}

#ifndef FIO___PUBSUB_CLUSTER_BACKLOG
#define FIO___PUBSUB_CLUSTER_BACKLOG (1UL << 12)
#endif

/* *****************************************************************************
PostOffice Distribution types - Channel and Subscription Core Types
***************************************************************************** */

/** The Distribution Channel: manages subscriptions to named channels. */
typedef struct fio_channel_s {
  FIO_LIST_HEAD subscriptions;
  FIO_LIST_HEAD history;
  uint32_t name_len;
  int16_t filter;
  uint8_t is_pattern;
  char name[];
} fio_channel_s;

/** The Channel Map: maps named channels. */
FIO_SFUNC void fio___channel_on_create(fio_channel_s *ch);
FIO_SFUNC void fio___channel_on_destroy(fio_channel_s *ch);

/**
 * Reference counting: `fio_channel_dup(ch)` / `fio_channel_free(ch)`
 */
#define FIO_REF_NAME             fio_channel
#define FIO_REF_FLEX_TYPE        char
#define FIO_REF_DESTROY(ch)      fio___channel_on_destroy(&(ch))
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO___RECURSIVE_INCLUDE  1
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

/** The Subscription: contains subscriber data. */
typedef struct fio_subscription_s {
  FIO_LIST_NODE node;
  FIO_LIST_NODE history;
  FIO_LIST_NODE history_active;
  uint64_t replay_since;
  fio_io_s *io;
  fio_channel_s *channel;
  fio_queue_s *queue;
  void (*on_message)(fio_msg_s *msg);
  void (*on_unsubscribe)(void *udata);
  void *udata;
} fio_subscription_s;

/**
 * Reference counting: `fio_subscription_dup(sb)` / `fio_subscription_free(sb)`
 */
FIO_SFUNC void fio___pubsub_subscription_on_destroy(fio_subscription_s *sub);
#define FIO_REF_NAME             fio___subscription
#define FIO_REF_TYPE             fio_subscription_s
#define FIO_REF_DESTROY(obj)     fio___pubsub_subscription_on_destroy(&(obj))
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO___RECURSIVE_INCLUDE  1
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

/** The Message Container */
typedef struct {
  fio_msg_s data;
  void *metadata[FIO___PUBSUB_METADATA_STORE_LIMIT];
  uint8_t metadata_is_initialized; /* to compact this we need to change all? */
  char buf[];
} fio___pubsub_message_s;

/* returns the internal message object. */
FIO_IFUNC fio___pubsub_message_s *fio___pubsub_msg2internal(fio_msg_s *msg);

/** Callback called when a message is destroyed (reference counting). */
FIO_SFUNC void fio___pubsub_message_on_destroy(fio___pubsub_message_s *m);

/* Message reference counting */
#define FIO_REF_NAME             fio___pubsub_message
#define FIO_REF_DESTROY(obj)     fio___pubsub_message_on_destroy(&(obj))
#define FIO_REF_FLEX_TYPE        char
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO___RECURSIVE_INCLUDE  1
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

typedef struct {
  size_t len;
  uint64_t uuid[2];
  fio___pubsub_message_s *msg;
  char buf[];
} fio___pubsub_message_parser_s;

FIO_LEAK_COUNTER_DEF(fio___pubsub_message_parser_s)

FIO_IFUNC fio___pubsub_message_parser_s *fio___pubsub_message_parser(
    fio_io_s *io) {
  return io ? (fio___pubsub_message_parser_s *)fio_io_buffer(io) : NULL;
}

FIO_SFUNC void fio___pubsub_message_parser_init(
    fio___pubsub_message_parser_s *p) {
  FIO_LEAK_COUNTER_ON_ALLOC(fio___pubsub_message_parser_s);
  *p = (fio___pubsub_message_parser_s){0};
}

FIO_SFUNC void fio___pubsub_message_parser_destroy(
    fio___pubsub_message_parser_s *p) {
  fio___pubsub_message_free(p->msg);
  FIO_LEAK_COUNTER_ON_FREE(fio___pubsub_message_parser_s);
}

/* *****************************************************************************
PostOffice Distribution types - The Distribution Channel Map
***************************************************************************** */

#define FIO___PUBSUB_CHANNEL_ENCODE_CAPA(filter_, is_pattern_)                 \
  (((size_t)(is_pattern_) << 16) | (size_t)(uint16_t)(filter_))

#define FIO___PUBSUB_CHANNEL2STR(ch)                                           \
  FIO_STR_INFO3(ch->name,                                                      \
                ch->name_len,                                                  \
                FIO___PUBSUB_CHANNEL_ENCODE_CAPA(ch->filter, ch->is_pattern))

FIO_IFUNC int fio___channel_cmp(fio_channel_s *ch, fio_str_info_s s) {
  fio_str_info_s c = FIO___PUBSUB_CHANNEL2STR(ch);
  return FIO_STR_INFO_IS_EQ(c, s);
}

FIO_IFUNC fio_channel_s *fio___channel_new_for_map(fio_str_info_s s) {
  fio_channel_s *ch = fio_channel_new(s.len + 1);
  FIO_ASSERT_ALLOC(ch);
  *ch = (fio_channel_s){
      .subscriptions = FIO_LIST_INIT(ch->subscriptions),
      .history = FIO_LIST_INIT(ch->history),
      .name_len = (uint32_t)s.len,
      .filter = (int16_t)(s.capa & 0xFFFFUL),
      .is_pattern = (uint8_t)(s.capa >> 16),
  };
  if (s.buf && s.len) /* avoid UB: memcpy with NULL src even when len==0 */
    FIO_MEMCPY(ch->name, s.buf, s.len);
  ch->name[s.len] = 0;
  fio___channel_on_create(ch);
  return ch;
}

#define FIO_MAP_NAME                  fio___channel_map
#define FIO_MAP_KEY                   fio_str_info_s
#define FIO_MAP_KEY_INTERNAL          fio_channel_s *
#define FIO_MAP_KEY_FROM_INTERNAL(k_) FIO___PUBSUB_CHANNEL2STR(k_)
#define FIO_MAP_KEY_COPY(dest, src)   ((dest) = fio___channel_new_for_map((src)))
#define FIO_MAP_KEY_CMP(a, b)         fio___channel_cmp((a), (b))
#define FIO_MAP_HASH_FN(str)          fio_risky_hash(str.buf, str.len, str.capa)
#define FIO_MAP_KEY_DESTROY(key)      fio_channel_free((key))
#define FIO_MAP_KEY_DISCARD(key)
#define FIO___RECURSIVE_INCLUDE 1
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

/* *****************************************************************************
Pub/Sub Subscription destruction
***************************************************************************** */

/* calls the on_unsubscribe callback. */
FIO_SFUNC void fio___pubsub_subscription_on_destroy__task(void *fnp,
                                                          void *udata) {
  union {
    void *p;
    void (*fn)(void *udata);
  } u = {.p = fnp};
  u.fn(udata);
}

FIO_SFUNC void fio___pubsub_subscription_on_destroy(fio_subscription_s *s) {
  if (s->on_unsubscribe) {
    union {
      void *p;
      void (*fn)(void *udata);
    } u = {.fn = s->on_unsubscribe};
    fio_queue_push(fio_io_queue(),
                   fio___pubsub_subscription_on_destroy__task,
                   u.p,
                   s->udata);
  }
}
/* *****************************************************************************
Pub/Sub Subscription map (for mapping Master only subscriptions)
***************************************************************************** */

/** Performs Housekeeping and defers the on_unsubscribe callback. */
FIO_IFUNC void fio___pubsub_subscription_unsubscribe(fio_subscription_s *s);

/* define a helper map to manage master only subscription. */
#define FIO_MAP_KEY_KSTR
#define FIO_MAP_NAME             fio___postoffice_msmap
#define FIO_MAP_VALUE            fio_subscription_s *
#define FIO_MAP_VALUE_DESTROY(s) fio___pubsub_subscription_unsubscribe(s)
#define FIO___RECURSIVE_INCLUDE
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

/* *****************************************************************************
Pub/Sub Remote Connection Uniqueness
***************************************************************************** */

/* Managing Remote Connection Uniqueness */
#define FIO_MAP_NAME fio___pubsub_broadcast_connected
#define FIO_MAP_KEY  uint64_t
#define FIO___RECURSIVE_INCLUDE
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

/* *****************************************************************************
Pub/Sub Engine Map
***************************************************************************** */

/* Managing Remote Connection Uniqueness */
#define FIO_MAP_NAME        fio___pubsub_engines
#define FIO_MAP_KEY         fio_pubsub_engine_s *
#define FIO_MAP_HASH_FN(e)  fio_risky_ptr(e)
#define FIO_MAP_RECALC_HASH 1
#define FIO_MAP_KEY_DESTROY(e)                                                 \
  do {                                                                         \
    e->detached(e);                                                            \
    e = NULL;                                                                  \
  } while (0)
#define FIO_MAP_KEY_DISCARD(e)
#define FIO___RECURSIVE_INCLUDE
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

/* *****************************************************************************
Message Uniqueness Map for filtering remote connection broadcasts
***************************************************************************** */

/* Managing Remote Connection Uniqueness */
#define FIO_MAP_NAME             fio___pubsub_message_map
#define FIO_MAP_KEY              fio___pubsub_message_s *
#define FIO_MAP_KEY_COPY(d_, e_) (d_ = fio___pubsub_message_dup(e_))
#define FIO_MAP_KEY_CMP(a, b)                                                  \
  (a->data.id == b->data.id && a->data.published == b->data.published)
#define FIO_MAP_KEY_DESTROY(e) fio___pubsub_message_free(e)
#define FIO_MAP_HASH_FN(m)     fio_risky_num(m->data.id, m->data.published)
#define FIO_MAP_RECALC_HASH    1
#define FIO_MAP_LRU            FIO___PUBSUB_CLUSTER_BACKLOG
#define FIO_MAP_KEY_DISCARD(e)
#define FIO___RECURSIVE_INCLUDE
#include FIO_INCLUDE_FILE
#undef FIO___RECURSIVE_INCLUDE

/* *****************************************************************************
Pub/Sub Post Office State
***************************************************************************** */
#ifndef FIO___IPC_LEN
#define FIO___IPC_LEN 256
#endif

FIO_SFUNC void fio___pubsub_protocol_on_attach(fio_io_s *io);
FIO_SFUNC void fio___pubsub_protocol_on_data_master(fio_io_s *io);
FIO_SFUNC void fio___pubsub_protocol_on_data_worker(fio_io_s *io);
FIO_SFUNC void fio___pubsub_protocol_on_data_remote(fio_io_s *io);
FIO_SFUNC void fio___pubsub_protocol_on_close(void *buffer, void *udata);
FIO_SFUNC void fio___pubsub_protocol_on_timeout(fio_io_s *io);

static struct FIO___PUBSUB_POSTOFFICE {
  fio_u128 uuid;
  fio___channel_map_s channels;
  fio___channel_map_s patterns;
  struct {
    uint8_t publish;
    uint8_t local;
    uint8_t remote;
  } filter;
  uint8_t crush_on_close;
  FIO___LOCK_TYPE lock;
  fio___pubsub_engines_s engines;
  FIO_LIST_NODE history_active;
  FIO_LIST_NODE history_waiting;
  fio___postoffice_msmap_s master_subscriptions;
  fio___postoffice_msmap_s global_subscriptions;
  fio___pubsub_broadcast_connected_s remote_uuids;
  fio___pubsub_message_map_s remote_messages;
  fio___pubsub_message_map_s history_messages;
  struct {
    fio_io_protocol_s ipc;
    fio_io_protocol_s remote;
  } protocol;
  fio_io_s *broadcaster;
  struct {
    fio_msg_metadata_fn build;
    void (*cleanup)(void *);
    size_t ref;
  } metadata[FIO___PUBSUB_METADATA_STORE_LIMIT];
  char ipc_url[FIO___IPC_LEN];
} FIO___PUBSUB_POSTOFFICE = {
    .filter =
        {
            .publish = (FIO___PUBSUB_PROCESS | FIO___PUBSUB_ROOT),
            .local = (FIO___PUBSUB_SIBLINGS),
            .remote = FIO___PUBSUB_REMOTE,
        },
    .lock = FIO___LOCK_INIT,
    .protocol =
        {
            .ipc =
                {
                    .on_attach = fio___pubsub_protocol_on_attach,
                    .on_data = fio___pubsub_protocol_on_data_master,
                    .on_close = fio___pubsub_protocol_on_close,
                    .on_timeout = fio_io_touch,
                    .buffer_size = sizeof(fio___pubsub_message_parser_s) +
                                   FIO___PUBSUB_MESSAGE_OVERHEAD,
                },
            .remote =
                {
                    .on_attach = fio___pubsub_protocol_on_attach,
                    .on_data = fio___pubsub_protocol_on_data_remote,
                    .on_close = fio___pubsub_protocol_on_close,
                    .on_timeout = fio___pubsub_protocol_on_timeout,
                    .buffer_size = sizeof(fio___pubsub_message_parser_s) +
                                   FIO___PUBSUB_MESSAGE_OVERHEAD,
                },
        },
};

/** Returns the secret key for a message with stated `rndm` value. */
FIO_IFUNC const void *fio___pubsub_secret_key(fio_u256 *dest, uint64_t rndm) {
  fio_u512 s = fio_secret();
  fio_memcpy32(dest->u8, s.u8 + (rndm & 15));
  return (void *)dest;
}

/* *****************************************************************************
PostOffice Helpers
***************************************************************************** */

/** Sets the current IPC socket address (shouldn't be changed while running). */
SFUNC int fio_pubsub_ipc_url_set(char *str, size_t len) {
  if (fio_io_is_running() || len >= FIO___IPC_LEN)
    return -1;
  fio_str_info_s url =
      FIO_STR_INFO3(FIO___PUBSUB_POSTOFFICE.ipc_url, 0, FIO___IPC_LEN);
  fio_string_write2(&url, NULL, FIO_STRING_WRITE_STR2(str, len));
  return 0;
}
/** Returns the current IPC socket address (shouldn't be changed). */
SFUNC const char *fio_pubsub_ipc_url(void) {
  return FIO___PUBSUB_POSTOFFICE.ipc_url;
}

/* *****************************************************************************
Postoffice History Control
***************************************************************************** */

FIO_SFUNC void fio___pubub_on_history_start(void *ignr_1, void *ignr_2) {
  (void)ignr_1, (void)ignr_2;
  if (!FIO_LIST_IS_EMPTY(&FIO___PUBSUB_POSTOFFICE.history_active))
    return;
  FIO_LIST_EACH(fio_subscription_s,
                history_active,
                &FIO___PUBSUB_POSTOFFICE.history_active,
                s) {
    FIO_LIST_REMOVE(&s->history);
    FIO_LIST_REMOVE(&s->history_active);
    FIO_LIST_PUSH(&s->channel->history, &s->history);
    FIO_LIST_PUSH(&FIO___PUBSUB_POSTOFFICE.history_active, &s->history_active);
  }
}

FIO_SFUNC void fio___pubub_on_history_end(void *ignr_1, void *ignr_2) {
  (void)ignr_1, (void)ignr_2;
  FIO_LIST_EACH(fio_subscription_s,
                history_active,
                &FIO___PUBSUB_POSTOFFICE.history_active,
                s) {
    FIO_LIST_REMOVE(&s->history);
    FIO_LIST_REMOVE(&s->history_active);
  }
}

/* *****************************************************************************
Postoffice Metadata Control
***************************************************************************** */

/* Returns zero (0) on success or -1 on failure. */
SFUNC int fio_message_metadata_add(fio_msg_metadata_fn metadata_func,
                                   void (*cleanup)(void *)) {
  for (size_t i = 0; i < FIO___PUBSUB_METADATA_STORE_LIMIT;
       ++i) { /* test existing */
    if (fio_atomic_add(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1) &&
        metadata_func == FIO___PUBSUB_POSTOFFICE.metadata[i].build)
      return 0;
    fio_atomic_sub(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1);
  }
  for (size_t i = 0; i < FIO___PUBSUB_METADATA_STORE_LIMIT;
       ++i) { /* insert if available */
    if (fio_atomic_add(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1)) {
      fio_atomic_sub(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1);
      continue;
    }
    FIO___PUBSUB_POSTOFFICE.metadata[i].build = metadata_func;
    FIO___PUBSUB_POSTOFFICE.metadata[i].cleanup = cleanup;
    return 0;
  }
  return -1;
}

/**
 * Removed the metadata callback.
 *
 * Removal might be delayed if live metatdata
 * exists.
 */
SFUNC void fio_message_metadata_remove(fio_msg_metadata_fn metadata_func) {
  for (size_t i = 0; i < FIO___PUBSUB_METADATA_STORE_LIMIT;
       ++i) { /* test existing */
    if (fio_atomic_add(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1) &&
        metadata_func == FIO___PUBSUB_POSTOFFICE.metadata[i].build) {
      fio_atomic_sub(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1);
    }
    fio_atomic_sub(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1);
  }
}

/** Finds the message's metadata, returning the data or NULL. */
SFUNC void *fio_message_metadata(fio_msg_s *msg,
                                 fio_msg_metadata_fn metadata_func) {
  for (size_t i = 0; i < FIO___PUBSUB_METADATA_STORE_LIMIT;
       ++i) { /* test existing */
    if (FIO___PUBSUB_POSTOFFICE.metadata[i].ref &&
        metadata_func == FIO___PUBSUB_POSTOFFICE.metadata[i].build) {
      return fio___pubsub_msg2internal(msg)->metadata[i];
    }
  }
  return NULL;
}

/* *****************************************************************************
Listening to Local Connections (IPC)
***************************************************************************** */

#if defined(DEBUG)
#define FIO___PUBSUB_HIDE_FROM_LOG 0
#else
#define FIO___PUBSUB_HIDE_FROM_LOG 1
#endif
/** Starts listening to IPC connections on a local socket. */
FIO_IFUNC void fio___pubsub_ipc_listen(void *ignr_) {
  (void)ignr_;
  if (fio_io_is_worker()) {
    FIO_LOG_DEBUG2("(%d) pub/sub IPC socket skipped - no workers are spawned.",
                   fio_io_pid());
    return;
  }
  FIO_ASSERT(fio_io_listen(.url = FIO___PUBSUB_POSTOFFICE.ipc_url,
                           .protocol = &FIO___PUBSUB_POSTOFFICE.protocol.ipc,
                           .on_root = 1,
                           .hide_from_log = FIO___PUBSUB_HIDE_FROM_LOG),
             "(%d) pub/sub couldn't open a socket for IPC\n\t\t%s",
             fio_io_pid(),
             FIO___PUBSUB_POSTOFFICE.ipc_url);
}
#undef FIO___PUBSUB_HIDE_FROM_LOG

/* *****************************************************************************
Postoffice Constructor / Destructor
***************************************************************************** */

/* listens for IPC connections. */
FIO_SFUNC void fio___pubsub_ipc_listen(void *);
/* protocol functions. */
FIO_SFUNC void fio___pubsub_protocol_on_attach(fio_io_s *io);
FIO_SFUNC void fio___pubsub_protocol_on_data_master(fio_io_s *io);
FIO_SFUNC void fio___pubsub_protocol_on_data_worker(fio_io_s *io);
FIO_SFUNC void fio___pubsub_protocol_on_data_remote(fio_io_s *io);
FIO_SFUNC void fio___pubsub_protocol_on_close(void *buffer, void *udata);

FIO_SFUNC void fio___pubsub_at_exit(void *ignr_) {
  (void)ignr_;
  fio_queue_perform_all(fio_io_queue());
  fio___postoffice_msmap_destroy(&FIO___PUBSUB_POSTOFFICE.master_subscriptions);
  fio___postoffice_msmap_destroy(&FIO___PUBSUB_POSTOFFICE.global_subscriptions);
  fio___pubsub_broadcast_connected_destroy(
      &FIO___PUBSUB_POSTOFFICE.remote_uuids);
  fio___pubsub_message_map_destroy(&FIO___PUBSUB_POSTOFFICE.remote_messages);
  fio___pubsub_message_map_destroy(&FIO___PUBSUB_POSTOFFICE.history_messages);
  fio___pubsub_engines_destroy(&FIO___PUBSUB_POSTOFFICE.engines);
  FIO___LOCK_DESTROY(FIO___PUBSUB_POSTOFFICE.lock);
  fio_queue_perform_all(fio_io_queue());
}

/** Callback called by the letter protocol entering a child processes. */
FIO_SFUNC void fio___pubsub_on_enter_child(void *ignr_) {
  (void)ignr_;
  FIO___PUBSUB_POSTOFFICE.protocol.ipc.on_data =
      fio___pubsub_protocol_on_data_worker;

  FIO___PUBSUB_POSTOFFICE.crush_on_close = !fio_io_is_master();

  FIO___PUBSUB_POSTOFFICE.filter.publish = FIO___PUBSUB_PROCESS;
  FIO___PUBSUB_POSTOFFICE.filter.local =
      (FIO___PUBSUB_SIBLINGS | FIO___PUBSUB_ROOT);
  FIO___PUBSUB_POSTOFFICE.filter.remote = 0;
  fio___postoffice_msmap_destroy(&FIO___PUBSUB_POSTOFFICE.master_subscriptions);
  fio___pubsub_engines_destroy(&FIO___PUBSUB_POSTOFFICE.engines);
  if (!fio_io_attach_fd(fio_sock_open2(FIO___PUBSUB_POSTOFFICE.ipc_url,
                                       FIO_SOCK_CLIENT | FIO_SOCK_NONBLOCK),
                        &FIO___PUBSUB_POSTOFFICE.protocol.ipc,
                        NULL,
                        NULL)) {
    FIO_LOG_FATAL("(%d) couldn't connect to pub/sub socket @ %s",
                  fio_io_pid(),
                  FIO___PUBSUB_POSTOFFICE.ipc_url);
    fio_thread_kill(fio_io_root_pid(), SIGINT);
    FIO_ASSERT(0, "fatal error encountered");
  }
}

FIO_CONSTRUCTOR(fio_postoffice_init) {
  FIO___PUBSUB_POSTOFFICE.engines = (fio___pubsub_engines_s)FIO_MAP_INIT;
  for (size_t i = 0; i < sizeof(FIO___PUBSUB_POSTOFFICE.uuid) / 8; ++i)
    FIO___PUBSUB_POSTOFFICE.uuid.u64[i] = fio_rand64();
  fio_str_info_s url =
      FIO_STR_INFO3(FIO___PUBSUB_POSTOFFICE.ipc_url, 0, FIO___IPC_LEN);

  fio_string_write2(&url,
                    NULL,
                    FIO_STRING_WRITE_STR1((char *)"priv://facil_io_tmp_"),
                    FIO_STRING_WRITE_HEX(fio_rand64()),
                    FIO_STRING_WRITE_STR1((char *)".sock"));
  fio_state_callback_add(FIO_CALL_PRE_START, fio___pubsub_ipc_listen, NULL);
  fio_state_callback_add(FIO_CALL_IN_CHILD, fio___pubsub_on_enter_child, NULL);
  fio_state_callback_add(FIO_CALL_AT_EXIT, fio___pubsub_at_exit, NULL);
  /* TODO!!! */
  FIO___PUBSUB_POSTOFFICE.protocol.ipc = (fio_io_protocol_s){
      .on_attach = fio___pubsub_protocol_on_attach,
      .on_data = fio___pubsub_protocol_on_data_master,
      .on_close = fio___pubsub_protocol_on_close,
      .on_timeout = fio_io_touch,
      .buffer_size =
          sizeof(fio___pubsub_message_parser_s) + FIO___PUBSUB_MESSAGE_OVERHEAD,
  };
  FIO___PUBSUB_POSTOFFICE.protocol.remote = (fio_io_protocol_s){
      .on_attach = fio___pubsub_protocol_on_attach,
      .on_data = fio___pubsub_protocol_on_data_remote,
      .on_close = fio___pubsub_protocol_on_close,
      .on_timeout = fio_io_touch,
      .buffer_size =
          sizeof(fio___pubsub_message_parser_s) + FIO___PUBSUB_MESSAGE_OVERHEAD,
  };
  for (char *tmp = getenv("PUBSUB_PORT"); tmp; tmp = NULL) {
    uint64_t port = (uint64_t)fio_atol(&tmp);
    if (port < 0xFFFFU)
      fio_pubsub_broadcast_on_port(port);
    else
      FIO_LOG_ERROR("(%d) (pub/sub) PUBSUB_PORT is out of range: %zu",
                    fio_getpid(),
                    (size_t)port);
  }
}

/* *****************************************************************************
Subscription Setup
***************************************************************************** */

/** Completes the subscription request. */
FIO_IFUNC void fio___pubsub_subscribe_task(void *sub_, void *ignr_) {
  fio_subscription_s *sub = (fio_subscription_s *)sub_;
  union {
    FIO_LIST_HEAD *ls;
    fio_str_info_s *str;
  } uptr = {.ls = &sub->node};
  const fio_str_info_s ch_name = *uptr.str;
  fio_channel_s **ch_ptr =
      fio___channel_map_node2key_ptr(fio___channel_map_set_ptr(
          &FIO___PUBSUB_POSTOFFICE.channels + (ch_name.capa >> 16),
          ch_name));
  fio_bstr_free(ch_name.buf);
  sub->node = FIO_LIST_INIT(sub->node);
  sub->history = FIO_LIST_INIT(sub->history);
  sub->history_active = FIO_LIST_INIT(sub->history_active);
  if (FIO_UNLIKELY(!ch_ptr))
    goto no_channel;
  sub->channel = ch_ptr[0];
  FIO_LIST_PUSH(&(ch_ptr[0]->subscriptions), &sub->node);
  if (sub->replay_since) {
    FIO_LIST_PUSH(&FIO___PUBSUB_POSTOFFICE.history_waiting, &sub->history);
    /* TODO: publish history request event to the cluster. */
  }
  return;
no_channel:
  fio___pubsub_subscription_unsubscribe(sub);
  (void)ignr_;
}

/** Unsubscribes a node and destroys the channel if no more subscribers. */
FIO_IFUNC void fio___pubsub_unsubscribe_task(void *sub_, void *ignr_) {
  fio_subscription_s *sub = (fio_subscription_s *)sub_;
  fio_channel_s *ch = sub->channel;
  fio___channel_map_s *map;
  FIO_LIST_REMOVE(&sub->node);
  FIO_LIST_REMOVE(&sub->history);
  FIO_LIST_REMOVE(&sub->history_active);
  if (FIO_UNLIKELY(!ch))
    goto no_channel;

  if (FIO_LIST_IS_EMPTY(&ch->subscriptions)) {
    map = &FIO___PUBSUB_POSTOFFICE.channels + ch->is_pattern;
    fio___channel_map_remove(map, FIO___PUBSUB_CHANNEL2STR(ch), NULL);
    if (!fio___channel_map_count(map))
      fio___channel_map_destroy(map);
  }
  sub->channel = NULL;

no_channel:
  fio___subscription_free(sub);
  return;
  (void)ignr_;
}

/** Performs Housekeeping and defers the on_unsubscribe callback. */
FIO_IFUNC void fio___pubsub_subscription_unsubscribe(fio_subscription_s *s) {
  if (!s)
    return;
  s->on_message = fio___subscription_mock_cb;
  fio_queue_push(fio_io_queue(),
                 fio___pubsub_unsubscribe_task,
                 (void *)s,
                 NULL);
}

/** Subscribes to a named channel in the numerical filter's namespace. */
void fio_subscribe___(void); /* sublimetext marker */
SFUNC void fio_subscribe FIO_NOOP(fio_subscribe_args_s args) {
  fio_subscription_s *s = NULL;
  union {
    FIO_LIST_HEAD *ls;
    fio_str_info_s *str;
  } uptr;
  if (args.channel.len > 0xFFFFUL)
    goto sub_error;
  s = fio___subscription_new();
  if (!s)
    goto sub_error;
  if (!args.queue || !args.on_message)
    args.queue = fio_io_queue();
  *s = (fio_subscription_s){
      .replay_since = args.replay_since,
      .io = args.io,
      .on_message =
          (args.on_message ? args.on_message
                           : (args.io ? fio___subscription_call_protocol
                                      : fio___subscription_mock_cb)),
      .on_unsubscribe = args.on_unsubscribe,
      .udata = args.udata,
      .queue = args.queue,
  };
  args.is_pattern = !!args.is_pattern; /* make sure this is either 1 or zero */
  uptr.ls = &s->node;
  *uptr.str = FIO_STR_INFO3(
      (args.channel.len
           ? fio_bstr_write(NULL, args.channel.buf, args.channel.len)
           : NULL),
      args.channel.len,
      FIO___PUBSUB_CHANNEL_ENCODE_CAPA(args.filter, args.is_pattern));

  if (args.subscription_handle_ptr)
    goto has_handle;
  if (args.master_only)
    goto is_master_only;
  if (!args.io)
    goto is_global;

  fio_io_defer(fio___pubsub_subscribe_task, (void *)s, NULL);
  fio_io_env_set(
      args.io,
      .type = (intptr_t)(0LL - (((2ULL | (!!args.is_pattern)) << 16) |
                                (uint16_t)args.filter)),
      .name = args.channel,
      .udata = s,
      .on_close = (void (*)(void *))fio___pubsub_subscription_unsubscribe);
  return;

has_handle:
  fio_io_defer(fio___pubsub_subscribe_task, (void *)s, NULL);
  *args.subscription_handle_ptr = (uintptr_t)s;
  return;

is_master_only:
  if (!fio_io_is_master())
    goto error_not_on_master;
is_global:
  if (1) { /* so C++ can jump even though there's a new var here */
    fio_io_defer(fio___pubsub_subscribe_task, (void *)s, NULL);
    uint64_t hashed_value =
        fio_risky_hash(args.channel.buf,
                       args.channel.len,
                       args.filter | ((size_t)args.is_pattern << 20));
    FIO___LOCK_LOCK(FIO___PUBSUB_POSTOFFICE.lock);
    fio___postoffice_msmap_set(
        &FIO___PUBSUB_POSTOFFICE.master_subscriptions + (!args.master_only),
        hashed_value,
        FIO_STR_INFO2(args.channel.buf, args.channel.len),
        s,
        NULL);
    FIO___LOCK_UNLOCK(FIO___PUBSUB_POSTOFFICE.lock);
  }
  return;

error_not_on_master:
  fio_bstr_free(uptr.str->buf);
  s->node = FIO_LIST_INIT(s->node);
  s->history = FIO_LIST_INIT(s->history);
  fio___subscription_free(s);
  FIO_LOG_WARNING(
      "(%d) master-only subscription attempt on a non-master process: %.*s",
      fio_io_pid(),
      (int)args.channel.len,
      (args.channel.buf ? args.channel.buf : (char *)""));
  return;

sub_error:
  FIO_LOG_ERROR("(%d) pub/sub subscription/channel cannot be created?"
                "\n\t%zu bytes long\n\t%.*s...",
                fio_io_pid(),
                args.channel.len,
                (int)(args.channel.len > 10 ? 7 : args.channel.len),
                (args.channel.buf ? args.channel.buf : (char *)""));
  FIO_LOG_ERROR("failed to allocate a new subscription");
  if (args.on_unsubscribe) {
    union {
      void *p;
      void (*fn)(void *udata);
    } u = {.fn = args.on_unsubscribe};
    fio_queue_push(fio_io_queue(),
                   fio___pubsub_subscription_on_destroy__task,
                   u.p,
                   args.udata);
  }
  return;
}

/** Cancels an existing subscriptions. */
void fio_unsubscribe___(void); /* sublimetext marker */
int fio_unsubscribe FIO_NOOP(fio_subscribe_args_s args) {
  if (args.subscription_handle_ptr)
    goto has_handle;
  if (args.master_only || !args.io)
    goto is_global;

  return fio_io_env_remove(
      args.io,
      .type = (intptr_t)(0LL - (((2ULL | (!!args.is_pattern)) << 16) |
                                (uint16_t)args.filter)),
      .name = args.channel);

has_handle:
  fio___pubsub_subscription_unsubscribe(
      *(fio_subscription_s **)args.subscription_handle_ptr);
  return 0;

is_global:
  if (1) {
    int r;
    uint64_t hashed_value =
        fio_risky_hash(args.channel.buf,
                       args.channel.len,
                       args.filter | ((size_t)args.is_pattern << 20));
    FIO___LOCK_LOCK(FIO___PUBSUB_POSTOFFICE.lock);
    r = fio___postoffice_msmap_remove(
        &FIO___PUBSUB_POSTOFFICE.master_subscriptions + (!args.master_only),
        hashed_value,
        FIO_STR_INFO3(args.channel.buf, args.channel.len, (size_t)-1),
        NULL);
    FIO___LOCK_UNLOCK(FIO___PUBSUB_POSTOFFICE.lock);
    return r;
  }
}

/* *****************************************************************************
Pub/Sub Message Distribution (local process)
***************************************************************************** */

static void fio___subscription_after_on_message_task(void *s, void *m) {
  fio___subscription_free((fio_subscription_s *)s);
  fio___pubsub_message_free((fio___pubsub_message_s *)m);
}

/* performs the subscription callback */
FIO_IFUNC void fio___subscription_on_message_task(void *s_, void *m_) {
  fio_subscription_s *s = (fio_subscription_s *)s_;
  fio___pubsub_message_s *m = (fio___pubsub_message_s *)m_;
  struct {
    fio_msg_s msg;
    fio___pubsub_message_s *m;
    uintptr_t flag;
  } container = {
      .msg = m->data,
      .m = m,
  };
  container.msg.io = s->io;
  container.msg.udata = s->udata;
  container.msg.is_json = !!(container.msg.is_json & FIO___PUBSUB_JSON);
  s->on_message(&container.msg);
  s->udata = container.msg.udata;
  if (container.flag)
    goto reschedule;
  fio_queue_push(fio_io_queue(),
                 fio___subscription_after_on_message_task,
                 s,
                 m);
  return;
reschedule:
  fio_queue_push(s->queue, fio___subscription_on_message_task, s_, m_);
}

/* returns the internal message object. */
FIO_IFUNC fio___pubsub_message_s *fio___pubsub_msg2internal(fio_msg_s *msg) {
  return *(fio___pubsub_message_s **)(msg + 1);
}

/** Defers the current callback, so it will be called again for the message. */
SFUNC void fio_pubsub_message_defer(fio_msg_s *msg) {
  ((uintptr_t *)(msg + 1))[1] = 1;
}

/* distributes a message to all of a channel's subscribers */
FIO_SFUNC void fio___pubsub_channel_deliver_task(void *ch_, void *m_) {
  fio_channel_s *ch = (fio_channel_s *)ch_;
  fio___pubsub_message_s *m = (fio___pubsub_message_s *)m_;
  FIO_LIST_HEAD *head = (&ch->subscriptions);
  _Bool is_history = !!(m->data.is_json & FIO___PUBSUB_REPLAY);
  head += is_history;
  if (m->data.io) { /* move as many `if` statements as possible out of loops. */
    if (is_history) {
      FIO_LIST_EACH(fio_subscription_s, node, head, s) {
        if (m->data.io != s->io && m->data.published >= s->replay_since)
          fio_queue_push(
              s->queue,
              (void (*)(void *, void *))fio___subscription_on_message_task,
              fio___subscription_dup(s),
              fio___pubsub_message_dup(m));
      }
    } else {
      FIO_LIST_EACH(fio_subscription_s, node, head, s) {
        if (m->data.io != s->io)
          fio_queue_push(
              s->queue,
              (void (*)(void *, void *))fio___subscription_on_message_task,
              fio___subscription_dup(s),
              fio___pubsub_message_dup(m));
      }
    }
  } else {
    if (is_history) {
      FIO_LIST_EACH(fio_subscription_s, node, head, s) {
        if (m->data.published >= s->replay_since)
          fio_queue_push(
              s->queue,
              (void (*)(void *, void *))fio___subscription_on_message_task,
              fio___subscription_dup(s),
              fio___pubsub_message_dup(m));
      }
    } else {
      FIO_LIST_EACH(fio_subscription_s, node, head, s) {
        fio_queue_push(
            s->queue,
            (void (*)(void *, void *))fio___subscription_on_message_task,
            fio___subscription_dup(s),
            fio___pubsub_message_dup(m));
      }
    }
  }
  fio___pubsub_message_free(m);
  fio_channel_free(ch);
}

/** Callback called when a letter is destroyed (reference counting). */
FIO_SFUNC void fio___pubsub_message_metadata_init(fio___pubsub_message_s *m);
/** distributes a message to all matching channels */
FIO_SFUNC void fio___pubsub_message_deliver(fio___pubsub_message_s *m) {
  fio___pubsub_message_metadata_init(m); /* metadata initialization */
  fio_str_info_s ch_name =
      FIO_STR_INFO3(m->data.channel.buf,
                    m->data.channel.len,
                    FIO___PUBSUB_CHANNEL_ENCODE_CAPA(m->data.filter, 0));
  fio_channel_s **ch_ptr = fio___channel_map_node2key_ptr(
      fio___channel_map_get_ptr(&FIO___PUBSUB_POSTOFFICE.channels, ch_name));
  if (ch_ptr)
    fio_queue_push(fio_io_queue(),
                   fio___pubsub_channel_deliver_task,
                   fio_channel_dup(ch_ptr[0]),
                   fio___pubsub_message_dup(m));
  FIO_MAP_EACH(fio___channel_map, &FIO___PUBSUB_POSTOFFICE.patterns, i) {
    if (i.node->key->filter == m->data.filter &&
        FIO_PUBSUB_PATTERN_MATCH(i.key, ch_name))
      fio_queue_push(fio_io_queue(),
                     fio___pubsub_channel_deliver_task,
                     fio_channel_dup(i.node->key),
                     fio___pubsub_message_dup(m));
  }
}

FIO_SFUNC void fio___pubsub_message_deliver_task(void *m_, void *ignr_) {
  fio___pubsub_message_deliver((fio___pubsub_message_s *)m_);
  fio___pubsub_message_free((fio___pubsub_message_s *)m_);
  (void)ignr_;
}

/* *****************************************************************************
Pub/Sub Message Type (internal data carrying structure)
***************************************************************************** */

/** Callback called when a letter is destroyed (reference counting). */
FIO_SFUNC void fio___pubsub_message_metadata_init(fio___pubsub_message_s *m) {
  if (fio_atomic_or(&m->metadata_is_initialized, 1)) {
    return;
  }
  fio_msg_s msg = m->data;
  msg.is_json &= FIO___PUBSUB_JSON;
  for (size_t i = 0; i < FIO___PUBSUB_METADATA_STORE_LIMIT; ++i) {
    if (fio_atomic_add(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1)) {
      m->metadata[i] = FIO___PUBSUB_POSTOFFICE.metadata[i].build(&msg);
      continue;
    }
    fio_atomic_sub(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1);
  }
}

/** Callback called when a letter is destroyed (reference counting). */
FIO_SFUNC void fio___pubsub_message_metadata_free(fio___pubsub_message_s *m) {
  if (!m->metadata_is_initialized)
    return;
  for (size_t i = 0; i < FIO___PUBSUB_METADATA_STORE_LIMIT; ++i) {
    if (fio_atomic_add(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1)) {
      FIO___PUBSUB_POSTOFFICE.metadata[i].cleanup(m->metadata[i]);
      fio_atomic_sub(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1);
    }
    fio_atomic_sub(&FIO___PUBSUB_POSTOFFICE.metadata[i].ref, 1);
  }
  m->metadata_is_initialized = 0;
}

/** Callback called when a letter is destroyed (reference counting). */
FIO_SFUNC void fio___pubsub_message_on_destroy(fio___pubsub_message_s *m) {
  fio___pubsub_message_metadata_free(m);
}

FIO_IFUNC fio___pubsub_message_s *fio___pubsub_message_alloc(void *header) {
  fio___pubsub_message_s *m;
  const size_t channel_len = fio_buf2u16_le((char *)header + 18);
  const size_t message_len = fio_buf2u24_le((char *)header + 20);
  m = fio___pubsub_message_new(((channel_len + message_len) << 1) +
                               (FIO___PUBSUB_MESSAGE_OVERHEAD + 2));
  FIO_ASSERT_ALLOC(m);
  *m = (fio___pubsub_message_s){
      .data =
          (fio_msg_s){
              .udata = m->buf + channel_len + message_len + 2,
              .channel = FIO_BUF_INFO2(m->buf, channel_len),
              .message = FIO_BUF_INFO2(m->buf + channel_len + 1, message_len),
          },
  };
  return m;
}

FIO_IFUNC fio___pubsub_message_s *fio___pubsub_message_author(
    fio_publish_args_s args) {
  fio___pubsub_message_s *m =
      fio___pubsub_message_new(((args.message.len + args.channel.len) << 1) +
                               (FIO___PUBSUB_MESSAGE_OVERHEAD + 2));
  FIO_ASSERT_ALLOC(m);
  *m = (fio___pubsub_message_s){
      .data =
          (fio_msg_s){
              .io = args.from,
              .id = args.id ? args.id : fio_rand64(),
              .published = args.published
                               ? args.published
                               : (uint64_t)fio_time2milli(fio_time_real()),
              .channel = FIO_BUF_INFO2(m->buf, args.channel.len),
              .message = FIO_BUF_INFO2(m->buf + args.channel.len + 1,
                                       args.message.len),
              .filter = args.filter,
              .is_json = args.is_json,
          },
  };
  if (args.channel.buf && args.channel.len)
    FIO_MEMCPY(m->data.channel.buf, args.channel.buf, args.channel.len);
  m->data.channel.buf[args.channel.len] = 0;
  if (args.message.buf && args.message.len)
    FIO_MEMCPY(m->data.message.buf, args.message.buf, args.message.len);
  m->data.message.buf[args.message.len] = 0;
  return m;
}

FIO_SFUNC void fio___pubsub_message_encrypt(fio___pubsub_message_s *m) {
  if (m->data.udata)
    return;
  fio_u256 key_buf;
  const void *k = fio___pubsub_secret_key(&key_buf, m->data.id);
  const uint64_t nonce[2] = {fio_risky_num(m->data.id, 0), m->data.published};
  uint8_t *pos = (uint8_t *)(m->data.message.buf + m->data.message.len + 1);
  uint8_t *dest = pos;
  m->data.udata = (void *)pos;
  fio_u2buf64_le(pos, m->data.id);
  pos += 8;
  fio_u2buf64_le(pos, m->data.published);
  pos += 8;
  fio_u2buf16_le(pos, (uint16_t)m->data.filter);
  pos += 2;
  fio_u2buf16_le(pos, (uint16_t)m->data.channel.len);
  pos += 2;
  fio_u2buf24_le(pos, (uint32_t)m->data.message.len);
  pos += 3;
  *(pos++) = m->data.is_json;
  const size_t enc_len = m->data.channel.len + m->data.message.len + 2;
  FIO_MEMCPY(pos, m->data.channel.buf, enc_len);
  if (enc_len == 2)
    return;
  pos += enc_len;
  fio_chacha20_poly1305_enc(pos,
                            (void *)(dest + FIO___PUBSUB_MESSAGE_HEADER),
                            m->data.channel.len + m->data.message.len + 2,
                            m->data.udata,
                            FIO___PUBSUB_MESSAGE_HEADER,
                            k,
                            nonce);
}

FIO_SFUNC int fio___pubsub_message_decrypt(fio___pubsub_message_s *m) {
  if (m->data.id)
    return 0;
  if (!m->data.udata)
    return -1;
  fio_u256 key_buf;
  uint8_t *pos = (uint8_t *)(m->data.message.buf + m->data.message.len + 1);
  uint8_t *const dest = pos;
  m->data.id = fio_buf2u64_le(pos);
  pos += 8;
  m->data.published = fio_buf2u64_le(pos);
  pos += 8;
  m->data.filter = fio_buf2u16_le(pos);
  pos += 2;
  m->data.channel = FIO_BUF_INFO2(m->buf, fio_buf2u16_le(pos));
  pos += 2;
  m->data.message =
      FIO_BUF_INFO2(m->buf + m->data.channel.len + 1, fio_buf2u24_le(pos));
  pos += 3;
  m->data.is_json = *(pos++);
  const void *k = fio___pubsub_secret_key(&key_buf, m->data.id);
  uint64_t nonce[2] = {fio_risky_num(m->data.id, 0), m->data.published};
  const size_t enc_len = m->data.channel.len + m->data.message.len + 2;
  FIO_MEMCPY(m->buf, pos, enc_len);
  if (enc_len == 2)
    return 0;
  pos += enc_len;
  return fio_chacha20_poly1305_dec(pos,
                                   m->buf,
                                   m->data.channel.len + m->data.message.len +
                                       2,
                                   dest,
                                   FIO___PUBSUB_MESSAGE_HEADER,
                                   k,
                                   nonce);
}

FIO_IFUNC void fio___pubsub_message_is_dirty(fio___pubsub_message_s *m) {
  m->data.udata = NULL;
}

/* *****************************************************************************
Pub/Sub Message Object - IO helpers
***************************************************************************** */

FIO_IFUNC void fio___pubsub_message_write2io(fio_io_s *io, void *m_) {
  fio___pubsub_message_s *m = (fio___pubsub_message_s *)m_;
  if (io == m->data.io)
    return;
  FIO_LOG_DDEBUG2("(%d) pub/sub sending IPC/peer message: %zu bytes",
                  fio_io_pid(),
                  m->data.message.len + m->data.channel.len +
                      FIO___PUBSUB_MESSAGE_OVERHEAD);
  fio___pubsub_message_encrypt(m);
  fio_io_write2(io,
                .buf = fio___pubsub_message_dup(m),
                .len = (m->data.message.len + m->data.channel.len +
                        FIO___PUBSUB_MESSAGE_OVERHEAD),
                .offset = ((uintptr_t)(m->data.udata) - (uintptr_t)(m)),
                .dealloc = (void (*)(void *))fio___pubsub_message_free);
}

/* A callback for IO subscriptions - sends raw message data. */
FIO_SFUNC void FIO_ON_MESSAGE_SEND_MESSAGE(fio_msg_s *msg) {
  if (!msg || !msg->message.len)
    return;
  fio___pubsub_message_s *m = fio___pubsub_msg2internal(msg);
  fio_io_write2(msg->io,
                .buf = fio___pubsub_message_dup(m),
                .len = msg->message.len,
                .offset = (size_t)(msg->message.buf - (char *)m),
                .dealloc = (void (*)(void *))fio___pubsub_message_free);
}

/* *****************************************************************************
Pub/Sub Message Routing
***************************************************************************** */

FIO_SFUNC void fio___pubsub_message_route(fio___pubsub_message_s *m) {
  fio___pubsub_message_parser_s *p;
  unsigned flags = m->data.is_json;
  FIO_LOG_DDEBUG2("(%d) pub/sub routing message (%x)",
                  fio_io_pid(),
                  (int)m->data.is_json);

  if (flags & FIO___PUBSUB_SPECIAL)
    goto is_special_message;

  if ((FIO___PUBSUB_POSTOFFICE.filter.local & flags))
    fio_io_protocol_each(&FIO___PUBSUB_POSTOFFICE.protocol.ipc,
                         fio___pubsub_message_write2io,
                         m);

  if ((FIO___PUBSUB_POSTOFFICE.filter.remote & flags))
    fio_io_protocol_each(&FIO___PUBSUB_POSTOFFICE.protocol.remote,
                         fio___pubsub_message_write2io,
                         m);

  if ((FIO___PUBSUB_POSTOFFICE.filter.publish & flags))
    fio_queue_push(fio_io_queue(),
                   fio___pubsub_message_deliver_task,
                   fio___pubsub_message_dup(m));

  return;

is_special_message:
  FIO_LOG_DDEBUG2("(%d) pub/sub internal subscription/ID message received",
                  fio_io_pid());
  switch (flags) {
  case FIO___PUBSUB_SPECIAL: /* TODO: run generic command on root */ break;
  case FIO___PUBSUB_SUB:
    fio_subscribe(.io = m->data.io,
                  .channel = m->data.channel,
                  .on_message = fio___subscription_mock_cb,
                  .filter = m->data.filter,
                  .is_pattern = (uint8_t)(m->data.id - 1));
    return;
  case FIO___PUBSUB_UNSUB:
    fio_unsubscribe(.io = m->data.io,
                    .channel = m->data.channel,
                    .on_message = fio___subscription_mock_cb,
                    .filter = m->data.filter,
                    .is_pattern = (uint8_t)(m->data.id - 1));
    return;

  case FIO___PUBSUB_IDENTIFY:
    p = fio___pubsub_message_parser(m->data.io);
    if (p) {
      p->uuid[0] = m->data.id;
      p->uuid[1] = m->data.published;
      fio___pubsub_broadcast_connected_set(
          &FIO___PUBSUB_POSTOFFICE.remote_uuids,
          p->uuid[0],
          p->uuid[1]);
    }
    FIO_LOG_INFO("(%d - cluster) identified new peer (%zu connections)",
                 fio_io_pid(),
                 fio___pubsub_broadcast_connected_count(
                     &FIO___PUBSUB_POSTOFFICE.remote_uuids));
    return;
  case FIO___PUBSUB_FORWARDER: /* fall through */
  case (FIO___PUBSUB_FORWARDER | FIO___PUBSUB_JSON):
    if (FIO___PUBSUB_POSTOFFICE.filter.remote) { /* root process */
      fio___pubsub_message_is_dirty(m);
      m->data.message.len -= 8;
      m->data.is_json &= FIO___PUBSUB_JSON;
      fio_pubsub_engine_s *e = (fio_pubsub_engine_s *)(uintptr_t)fio_buf2u64u(
          m->data.message.buf + m->data.message.len);
      m->data.message.buf[m->data.message.len] = 0;
      e->publish(e, &m->data);
    } else { /* child process */
      fio_io_protocol_each(&FIO___PUBSUB_POSTOFFICE.protocol.ipc,
                           fio___pubsub_message_write2io,
                           m);
    }
    return;

  case FIO___PUBSUB_HISTORY_START:
    FIO_LOG_DDEBUG2("(%d) pub/sub internal history start message received",
                    fio_io_pid());
    /* TODO! */
    return;
  case FIO___PUBSUB_HISTORY_END:
    FIO_LOG_DDEBUG2("(%d) pub/sub internal history end message received",
                    fio_io_pid());
    /* TODO! */
    return;
  }
  return;
}

/* *****************************************************************************
Pub/Sub - Publish
***************************************************************************** */

FIO_SFUNC void fio___publish_message_task(void *m_, void *ignr_) {
  (void)ignr_;
  fio___pubsub_message_s *m = (fio___pubsub_message_s *)m_;
  fio___pubsub_message_route(m);
  fio___pubsub_message_free(m);
}

/** Publishes a message to the relevant subscribers (if any). */
void fio_publish___(void); /* SublimeText marker*/
void fio_publish FIO_NOOP(fio_publish_args_s args) {
  if (FIO_UNLIKELY(args.channel.len > 0xFFFFUL)) {
    FIO_LOG_ERROR("(%d) pub/sub channel name too long (%zu bytes)",
                  fio_io_pid(),
                  args.channel.len);
    return;
  }
  if (FIO_UNLIKELY(args.message.len > 0xFFFFFFUL)) {
    FIO_LOG_ERROR("(%d) pub/sub message payload too large (%zu bytes)",
                  fio_io_pid(),
                  args.message.len);
    return;
  }
  fio___pubsub_message_s *m;
  fio_msg_s msg;

  if (!args.engine) {
    args.engine = FIO_PUBSUB_DEFAULT;
    if (!args.engine)
      args.engine = FIO_PUBSUB_DEFAULT = FIO_PUBSUB_CLUSTER;
    if (args.filter < 0)
      args.engine = FIO_PUBSUB_LOCAL;
  }
  if ((uintptr_t)args.engine > 0xFFUL)
    goto external_engine;

  m = fio___pubsub_message_author(args);
  m->data.is_json = ((!!args.is_json) | ((uint8_t)(uintptr_t)args.engine));

  FIO_LOG_DDEBUG2("(%d) publishing pub/sub message (scheduling)", fio_io_pid());
  fio_io_defer(fio___publish_message_task, m, NULL);
  return;

external_engine:

  msg.message = args.message;
  args.message.buf = NULL;
  args.message.len += 8;

  m = fio___pubsub_message_author(args);
  m->data.is_json = ((!!args.is_json) | ((uint8_t)FIO___PUBSUB_FORWARDER));
  FIO_MEMCPY(m->data.message.buf, msg.message.buf, msg.message.len);
  fio_u2buf64u(m->data.message.buf + msg.message.len, (uintptr_t)args.engine);
  fio_io_defer(fio___publish_message_task, m, NULL);
}

/* *****************************************************************************
Pub/Sub Message on-the-wire parsing
***************************************************************************** */

FIO_IFUNC void fio___pubsub_message_parse(
    fio_io_s *io,
    void (*cb)(fio_io_s *, fio___pubsub_message_s *)) {
  fio___pubsub_message_parser_s *parser = fio___pubsub_message_parser(io);
  if (!parser)
    return;
  size_t existing = parser->len;
  if (!parser->msg) {
    while (existing < FIO___PUBSUB_MESSAGE_HEADER) { /* get message length */
      size_t consumed = fio_io_read(io,
                                    parser->buf + existing,
                                    FIO___PUBSUB_MESSAGE_OVERHEAD - existing);
      if (!consumed) {
        parser->len = existing;
        return;
      }
      existing += consumed;
    }
    parser->msg = fio___pubsub_message_alloc(parser->buf);
    FIO_MEMCPY(parser->msg->data.udata, parser->buf, existing);
  }
  /* known message length, read to end and publish */
  fio___pubsub_message_s *m = parser->msg;
  const size_t needed =
      m->data.channel.len + m->data.message.len + FIO___PUBSUB_MESSAGE_OVERHEAD;
  // FIO_LOG_DDEBUG2("(%d) pub/sub parsing IPC/peer message %p (%zu/%zu bytes)",
  //                 fio_io_pid(),
  //                 (void *)fio_buf2u64_le(m->data.udata),
  //                 existing,
  //                 needed);
  while (existing < needed) {
    size_t consumed =
        fio_io_read(io, (char *)m->data.udata + existing, needed - existing);
    if (!consumed) {
      parser->len = existing;
      return;
    }
    existing += consumed;
  }
  parser->msg = NULL;
  parser->len = 0;
  m->data.io = io;
  if (fio___pubsub_message_decrypt(m)) {
    FIO_LOG_SECURITY("(%d) pub/sub message decryption error", fio_io_pid());
    fio_io_close_now(io);
  } else {
    cb(io, m);
  }
  fio___pubsub_message_free(m);
  return; /* consume no more than 1 message at a time */
}

/* *****************************************************************************
Pub/Sub Protocols
***************************************************************************** */

FIO_SFUNC void fio___pubsub_on_message_master(fio_io_s *io,
                                              fio___pubsub_message_s *msg) {
  fio___pubsub_message_route(msg);
  (void)io;
}
FIO_SFUNC void fio___pubsub_on_message_worker(fio_io_s *io,
                                              fio___pubsub_message_s *msg) {
  fio___pubsub_message_route(msg);
  (void)io;
}
FIO_SFUNC void fio___pubsub_on_message_remote(fio_io_s *io,
                                              fio___pubsub_message_s *msg) {
  fio___pubsub_message_map_s *map = &FIO___PUBSUB_POSTOFFICE.remote_messages;
  map += !!(msg->data.is_json & FIO___PUBSUB_REPLAY);
  fio___pubsub_message_s *existing = fio___pubsub_message_map_set(map, msg);
  if (existing != msg)
    return; /* already received */
  fio___pubsub_message_route(msg);
  (void)io;
}
FIO_SFUNC void fio___pubsub_protocol_on_attach(fio_io_s *io) {
  fio___pubsub_message_parser_init(fio___pubsub_message_parser(io));
}
FIO_SFUNC void fio___pubsub_protocol_on_data_master(fio_io_s *io) {
  fio___pubsub_message_parse(io, fio___pubsub_on_message_master);
}
FIO_SFUNC void fio___pubsub_protocol_on_data_worker(fio_io_s *io) {
  fio___pubsub_message_parse(io, fio___pubsub_on_message_worker);
}
FIO_SFUNC void fio___pubsub_protocol_on_data_remote(fio_io_s *io) {
  fio___pubsub_message_parse(io, fio___pubsub_on_message_remote);
}

FIO_SFUNC void fio___pubsub_protocol_on_close(void *p_, void *udata) {
  fio___pubsub_message_parser_s *p = (fio___pubsub_message_parser_s *)p_;
  if (p->uuid[0] || p->uuid[1]) {
    // TODO!: fio___pubsub_broadcast_hello(fio_io_s *io) ?
    fio___pubsub_broadcast_connected_remove(
        &FIO___PUBSUB_POSTOFFICE.remote_uuids,
        p->uuid[0],
        p->uuid[1],
        NULL);
    FIO_LOG_INFO(
        "(%d) (pub/sub cluster) lost peer connection (%zu connections)",
        fio_io_pid(),
        fio___pubsub_broadcast_connected_count(
            &FIO___PUBSUB_POSTOFFICE.remote_uuids));
  }
  fio___pubsub_message_parser_destroy(p);
  if (FIO___PUBSUB_POSTOFFICE.crush_on_close) {
    if (fio_io_is_running())
      FIO_LOG_FATAL("(%d) pub/sub connection lost unexpectedly.", fio_io_pid());
    fio_io_stop();
  }
  (void)udata;
}

static void fio___pubsub_protocol_on_timeout(fio_io_s *io) {
  static const uint8_t ping_msg[FIO___PUBSUB_MESSAGE_OVERHEAD] = {
      [23] = FIO___PUBSUB_PING};
  fio_io_write2(io,
                .buf = (void *)ping_msg,
                .len = FIO___PUBSUB_MESSAGE_OVERHEAD);
}

/* *****************************************************************************
Pub/Sub Engine Support Implementation
***************************************************************************** */

static void fio___pubsub_mock_detached(const fio_pubsub_engine_s *eng) {
  (void)eng;
}
static void fio___pubsub_mock_sub_unsub(const fio_pubsub_engine_s *eng,
                                        fio_buf_info_s channel,
                                        int16_t filter) {
  (void)eng, (void)channel, (void)filter;
}
static void fio___pubsub_mock_publish(const fio_pubsub_engine_s *eng,
                                      fio_msg_s *msg) {
  (void)eng, (void)msg; /* TODO:? sensible default? publish to cluster? */
}

static void fio___pubsub_attach_task(void *engine_, void *ignr_) {
  (void)ignr_;
  fio_pubsub_engine_s *engine = (fio_pubsub_engine_s *)engine_;
  if (!engine->detached)
    engine->detached = fio___pubsub_mock_detached;
  if (!engine->subscribe)
    engine->subscribe = fio___pubsub_mock_sub_unsub;
  if (!engine->unsubscribe)
    engine->unsubscribe = fio___pubsub_mock_sub_unsub;
  if (!engine->psubscribe)
    engine->psubscribe = fio___pubsub_mock_sub_unsub;
  if (!engine->punsubscribe)
    engine->punsubscribe = fio___pubsub_mock_sub_unsub;
  if (!engine->publish)
    engine->publish = fio___pubsub_mock_publish;
  fio___pubsub_engines_set(&FIO___PUBSUB_POSTOFFICE.engines, engine);
  FIO_MAP_EACH(fio___channel_map, &FIO___PUBSUB_POSTOFFICE.channels, i) {
    engine->subscribe(engine,
                      FIO_BUF_INFO2(i.key.buf, i.key.len),
                      (i.key.capa >> 16));
  }
  FIO_MAP_EACH(fio___channel_map, &FIO___PUBSUB_POSTOFFICE.patterns, i) {
    engine->psubscribe(engine,
                       FIO_BUF_INFO2(i.key.buf, i.key.len),
                       (i.key.capa >> 16));
  }
}

FIO_SFUNC void fio___pubsub_detach_task(void *engine, void *ignr_) {
  (void)ignr_;
  fio_pubsub_engine_s *e = (fio_pubsub_engine_s *)engine;
  fio___pubsub_engines_remove(&FIO___PUBSUB_POSTOFFICE.engines, e, NULL);
}

/** Attaches an engine, so it's callback can be called by facil.io. */
SFUNC void fio_pubsub_attach(fio_pubsub_engine_s *engine) {
  if (!engine)
    return;
  fio_io_defer(fio___pubsub_attach_task, engine, NULL);
}

/** Schedules an engine for Detachment, so it could be safely destroyed. */
SFUNC void fio_pubsub_detach(fio_pubsub_engine_s *engine) {
  fio_queue_push(fio_io_queue(), fio___pubsub_detach_task, engine, NULL);
}

/* *****************************************************************************
Channel Creation / Destruction Callback (notifying engines)
***************************************************************************** */

/** Callback for when a channel is created. */
FIO_IFUNC void fio___channel_on_create(fio_channel_s *ch) {
  fio_buf_info_s name = FIO_BUF_INFO2(ch->name, ch->name_len);
  FIO_LOG_DDEBUG2("(%d) pub/sub %s created, filter %d, length %zu bytes: %s",
                  fio_io_pid(),
                  (ch->is_pattern ? "pattern" : "channel"),
                  (int)ch->filter,
                  (size_t)ch->name_len,
                  name.buf);
  FIO_MAP_EACH(fio___pubsub_engines, &FIO___PUBSUB_POSTOFFICE.engines, i) {
    (&i.key->subscribe + ch->is_pattern)[0](i.key, name, ch->filter);
  }
  if (!FIO___PUBSUB_POSTOFFICE.filter.remote) { /* inform root process */
    FIO_LOG_DDEBUG2("(%d) informing root process of new channel.",
                    fio_io_pid());
    fio___pubsub_message_s *m =
        fio___pubsub_message_author((fio_publish_args_s){
            .id = (uint64_t)(ch->is_pattern + 1),
            .channel = FIO_BUF_INFO2(ch->name, ch->name_len),
            .filter = ch->filter,
            .is_json = FIO___PUBSUB_SUB,
        });
    fio_io_protocol_each(&FIO___PUBSUB_POSTOFFICE.protocol.ipc,
                         fio___pubsub_message_write2io,
                         m);
    fio___pubsub_message_free(m);
  }
}
/** Callback for when a channel is destroy. */
FIO_IFUNC void fio___channel_on_destroy(fio_channel_s *ch) {
  fio_buf_info_s name = FIO_BUF_INFO2(ch->name, ch->name_len);

  FIO_MAP_EACH(fio___pubsub_engines, &FIO___PUBSUB_POSTOFFICE.engines, i) {
    (&i.key->unsubscribe + ch->is_pattern)[0](i.key, name, ch->filter);
  }

  if (!FIO___PUBSUB_POSTOFFICE.filter.remote) { /* inform root process */
    fio___pubsub_message_s *m =
        fio___pubsub_message_author((fio_publish_args_s){
            .id = (uint64_t)(ch->is_pattern + 1),
            .channel = FIO_BUF_INFO2(ch->name, ch->name_len),
            .filter = ch->filter,
            .is_json = FIO___PUBSUB_UNSUB,
        });
    if (m) {
      fio_io_protocol_each(&FIO___PUBSUB_POSTOFFICE.protocol.ipc,
                           fio___pubsub_message_write2io,
                           m);
      fio___pubsub_message_free(m);
    }
  }

  FIO_LOG_DDEBUG2("(%d) pub/sub %s destroyed, filter %d, length %zu bytes: %s",
                  fio_io_pid(),
                  (ch->is_pattern ? "pattern" : "channel"),
                  (int)ch->filter,
                  (size_t)ch->name_len,
                  name.buf);
}

/* *****************************************************************************
Broadcasting for remote connections
***************************************************************************** */

FIO_IFUNC fio_u512 fio___pubsub_broadcast_compose(uint64_t tick) {
  /* [0-1]  Sender's 128 bit UUID
   * [2]    Random nonce
   * [3]    Timestamp in milliseconds
   * [4-5]  MAC
   */
  fio_u512 u = {0};
  fio_u256 key_buf;
  uint64_t hello_rand = fio_rand64();
  const void *k = fio___pubsub_secret_key(&key_buf, hello_rand);
  u.u64[0] = FIO___PUBSUB_POSTOFFICE.uuid.u64[0];
  u.u64[1] = FIO___PUBSUB_POSTOFFICE.uuid.u64[1];
  u.u64[2] = fio_ltole64(hello_rand); /* persistent endienes required for k */
  u.u64[3] = fio_ltole64(tick);
  fio_poly1305_auth(u.u64 + 4, u.u64, 32, NULL, 0, k);
  return u;
}

FIO_SFUNC void fio___pubsub_broadcast_hello(fio_io_s *io) {

  if (!fio_io_is_running() || !(io = FIO___PUBSUB_POSTOFFICE.broadcaster))
    return;
  static int64_t last_hello = 0;
  int64_t this_hello = fio_io_last_tick();
  if (last_hello == this_hello)
    return;
  fio_u512 u = fio___pubsub_broadcast_compose((last_hello = this_hello));
  struct sockaddr_in addr = (struct sockaddr_in){
      .sin_family = AF_INET,
      .sin_port = fio_lton16((uint16_t)(uintptr_t)fio_io_udata(io)),
      .sin_addr.s_addr = INADDR_BROADCAST, // inet_addr("255.255.255.255"),
  };
  FIO_LOG_DEBUG2("(%d) pub/sub sending broadcast.", fio_io_pid());
  sendto(fio_io_fd(io),
         (const char *)u.u8,
         48,
         0,
         (struct sockaddr *)&addr,
         sizeof(addr));
}

FIO_SFUNC void fio___pubsub_broadcast_hello_task_done(void *io_, void *ignr_) {
  (void)ignr_;
  fio_io_s *io = (fio_io_s *)io_;
  fio_io_free(io);
}

FIO_SFUNC int fio___pubsub_broadcast_hello_task(void *io_, void *ignr_) {
  (void)ignr_;
  fio_io_s *io = (fio_io_s *)io_;
  fio___pubsub_broadcast_hello(io);
  return 0;
}

FIO_SFUNC int fio___pubsub_broadcast_hello_validate(uint64_t *hello) {
  fio_u256 key_buf;
  uint64_t mac[2] = {0};
  /* test server UUID (ignore self generated messages) */
  if (hello[0] == FIO___PUBSUB_POSTOFFICE.uuid.u64[0] &&
      hello[1] == FIO___PUBSUB_POSTOFFICE.uuid.u64[1])
    return -1;
  /* test time window */
  mac[0] = fio_io_last_tick();
  if (mac[0] > fio_ltole64(hello[3]) + 8192 ||
      mac[0] + 8192 < fio_ltole64(hello[3])) {
    FIO_LOG_SECURITY(
        "(%d) pub/sub-broadcast timing error - possible replay attack?",
        fio_io_pid());
    return -1;
  }
  /* test for duplicate connections */
  if (fio___pubsub_broadcast_connected_get(
          &FIO___PUBSUB_POSTOFFICE.remote_uuids,
          hello[0],
          hello[1])) {
    FIO_LOG_DEBUG2("(%d) pub/sub-broadcast Prevented duplicate connection!",
                   fio_io_pid());
    return -1;
  }
  /* test MAC */
  const void *k = fio___pubsub_secret_key(&key_buf, fio_ltole64(hello[2]));
  fio_poly1305_auth(mac, hello, 32, NULL, 0, k);
  if (mac[0] != hello[4] || mac[1] != hello[5]) {
    FIO_LOG_SECURITY("(%d) pub/sub-broadcast MAC failure - under attack?",
                     fio_io_pid());
    return -1;
  }
  return 0;
}
/* *****************************************************************************
Letter Listening to Remote Connections - TODO!
***************************************************************************** */
FIO_SFUNC void fio___pubsub_broadcast_on_attach(fio_io_s *io) {
  fio___pubsub_broadcast_hello((FIO___PUBSUB_POSTOFFICE.broadcaster = io));
  fio_io_run_every(.fn = fio___pubsub_broadcast_hello_task,
                   .udata1 = fio_io_dup(io),
                   .on_finish = fio___pubsub_broadcast_hello_task_done,
                   .every =
                       (uint32_t)(1024 |
                                  (1023 & FIO___PUBSUB_POSTOFFICE.uuid.u64[0])),
                   .repetitions = 2);
}
FIO_SFUNC void fio___pubsub_broadcast_on_close(void *ignr1_, void *ignr2_) {
  FIO___PUBSUB_POSTOFFICE.broadcaster = NULL;
  (void)ignr1_, (void)ignr2_;
}

FIO_SFUNC void fio___pubsub_broadcast_on_data(fio_io_s *io) {
  uint64_t buf[16];
  struct sockaddr from[2];
  socklen_t from_len = sizeof(from);
  ssize_t len;
  int should_say_hello = 0;
  fio___pubsub_message_s *m = fio___pubsub_message_author(
      (fio_publish_args_s){.id = FIO___PUBSUB_POSTOFFICE.uuid.u64[0],
                           .published = FIO___PUBSUB_POSTOFFICE.uuid.u64[1],
                           .is_json = FIO___PUBSUB_IDENTIFY});

  while ((len = recvfrom(fio_io_fd(io), (char *)buf, 128, 0, from, &from_len)) >
         0) {
    if (len != 48) {
      FIO_LOG_WARNING(
          "(%d) pub/sub peer detection received invalid packet (%zu bytes)!",
          fio_io_pid(),
          len);
      continue;
    }
    if (fio___pubsub_broadcast_hello_validate(buf)) {
      FIO_LOG_WARNING(
          "(%d) pub/sub peer detection received invalid packet payload!",
          fio_io_pid());
      continue;
    }
    if (fio___pubsub_broadcast_connected_get(
            &FIO___PUBSUB_POSTOFFICE.remote_uuids,
            buf[0],
            buf[1]) == buf[1]) {
      FIO_LOG_DDEBUG2("(%d) skipping peer connection - already exists",
                      fio_io_pid());
      continue; /* skip connection, already exists. */
    }
    should_say_hello |= 1;
    FIO_LOG_DDEBUG2("(%d) detected peer, should now connect", fio_io_pid());

    /* TODO: fixme! */
    char addr_buf[128];
    if (getnameinfo(from,
                    from_len,
                    addr_buf,
                    64,
                    addr_buf + 64,
                    64,
                    (NI_NUMERICHOST | NI_NUMERICHOST))) {
      FIO_LOG_ERROR("(%d) couldn't resolve peer address", fio_io_pid());
      continue;
    }
    int fd = fio_sock_open(addr_buf,
                           addr_buf + 64,
                           FIO_SOCK_NONBLOCK | FIO_SOCK_CLIENT | FIO_SOCK_TCP);
    if (fd == -1) {
      FIO_LOG_ERROR("couldn't connect to cluster peer: %s", strerror(errno));
      continue;
    }
    fio___pubsub_broadcast_connected_set(&FIO___PUBSUB_POSTOFFICE.remote_uuids,
                                         addr_buf[0],
                                         addr_buf[1]);
    fio_io_s *peer = fio_io_attach_fd(fd,
                                      &FIO___PUBSUB_POSTOFFICE.protocol.remote,
                                      NULL,
                                      NULL);
    fio___pubsub_message_write2io(peer, m);
    FIO_LOG_INFO("(%d) pub/sub-cluster connecting to peer (%zu connections).",
                 fio_io_pid(),
                 fio___pubsub_broadcast_connected_count(
                     &FIO___PUBSUB_POSTOFFICE.remote_uuids));
  }
  fio___pubsub_message_free(m);
  if (should_say_hello)
    fio_io_run_every(.fn = fio___pubsub_broadcast_hello_task,
                     .udata1 = fio_io_dup(io),
                     .on_finish = fio___pubsub_broadcast_hello_task_done,
                     .every =
                         (uint32_t)(1024 |
                                    (1023 &
                                     FIO___PUBSUB_POSTOFFICE.uuid.u64[0])));
}

FIO_SFUNC void fio___pubsub_broadcast_on_incoming(fio_io_s *io) {
  int fd;
  while ((fd = accept(fio_io_fd(io), NULL, NULL)) != -1) {
    FIO_LOG_DDEBUG2("(%d) accepting a cluster peer connection", fio_io_pid());
    fio_io_attach_fd(fd, &FIO___PUBSUB_POSTOFFICE.protocol.remote, NULL, NULL);
  }
  FIO_LOG_INFO("(%d) (cluster) accepted new peer(s) (%zu connections).",
               fio_io_pid(),
               fio___pubsub_broadcast_connected_count(
                   &FIO___PUBSUB_POSTOFFICE.remote_uuids));
}

SFUNC void fio___pubsub_broadcast_on_port(void *port_) {
  int16_t port = (int16_t)(uintptr_t)port_;
  static fio_io_protocol_s broadcast = {
      .on_attach = fio___pubsub_broadcast_on_attach,
      .on_data = fio___pubsub_broadcast_on_data,
      .on_close = fio___pubsub_broadcast_on_close,
      .on_timeout = fio_io_touch,
  };
  static fio_io_protocol_s accept_remote = {
      .on_data = fio___pubsub_broadcast_on_incoming,
      .on_timeout = fio_io_touch,
  };
  if (fio_secret_is_random()) {
    FIO_LOG_ERROR(
        "(%d) Listening to cluster peer connections failed!"
        "\n\tUsing a random (non-shared) secret, cannot validate peers.",
        fio_io_pid());
    return;
  }
  if (!port || port < 0)
    port = 3333;
  FIO_STR_INFO_TMP_VAR(url, 32);
  url.buf[0] = ':';
  url.len = 1;
  fio_string_write_u(&url, NULL, (uint64_t)port);

  int fd_udp =
      fio_sock_open(NULL,
                    url.buf + 1,
                    FIO_SOCK_UDP | FIO_SOCK_NONBLOCK | FIO_SOCK_SERVER);
  FIO_ASSERT(fd_udp != -1, "couldn't open broadcast socket!");
  int fd_tcp =
      fio_sock_open(NULL,
                    url.buf + 1,
                    FIO_SOCK_TCP | FIO_SOCK_NONBLOCK | FIO_SOCK_SERVER);
  FIO_ASSERT(fd_tcp != -1, "couldn't open cluster-peer listening socket!");
  {
#if FIO_OS_WIN
    char enabled = 1;
#else
    int enabled = 1;
#endif
    setsockopt(fd_udp, SOL_SOCKET, SO_BROADCAST, &enabled, sizeof(enabled));
    enabled = 1;
    setsockopt(fd_udp, SOL_SOCKET, SO_REUSEADDR, &enabled, sizeof(enabled));
  }
  fio_io_attach_fd(fd_udp, &broadcast, port_, NULL);
  fio_io_attach_fd(fd_tcp, &accept_remote, NULL, NULL);
  FIO_LOG_INFO("(pub/sub) broadcasting and listening on port %zu",
               (size_t)port);
  return;
}

/** Auto-peer detection and pub/sub multi-machine clustering using `port`. */
SFUNC void fio_pubsub_broadcast_on_port(int16_t port) {
  fio_state_callback_add(FIO_CALL_PRE_START,
                         fio___pubsub_broadcast_on_port,
                         (void *)(uintptr_t)port);
}

/* *****************************************************************************
Pub/Sub Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_PUBSUB
#endif /* FIO_PUBSUB */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_REDIS              /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                          Redis Pub/Sub Engine Module




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_REDIS) && !defined(FIO___RECURSIVE_INCLUDE) &&                 \
    !defined(H___FIO_REDIS___H)
#define H___FIO_REDIS___H

/* *****************************************************************************
Redis Engine - Overview

This module provides a Redis engine that can be used either as:
1. A standalone database client (for GET/SET/INCR/etc. commands)
2. A pub/sub engine when attached to facil.io's pub/sub system

Features:
- Command queue with callbacks for arbitrary Redis commands
- Authentication support
- Automatic reconnection on connection loss
- Ping/pong keepalive
- Optional pub/sub integration with SUBSCRIBE/PSUBSCRIBE/PUBLISH

Thread Safety Model:
====================
The Redis engine is thread-safe. All internal state modifications are delegated
to the IO queue using fio_io_defer(), ensuring single-threaded execution of
state changes. This prevents race conditions without requiring locks.

Public API thread safety:
- fio_redis_new():   Thread-safe (defers connection to IO thread)
- fio_redis_dup():   Thread-safe (uses atomic reference counting)
- fio_redis_free():  Thread-safe (defers cleanup to IO thread)
- fio_redis_send():  Thread-safe (defers command queuing to IO thread)

Internal operations that run on the IO thread:
- Command queue management (add, remove, send)
- Connection state changes (connect, disconnect, reconnect)
- Protocol callbacks (on_attach, on_data, on_close, on_timeout)
- Pub/sub engine callbacks (subscribe, publish, etc.)

Reference Counting Ownership Model:
====================================
The Redis engine uses reference counting for memory management:

- fio_redis_new():   Creates engine with ref=1 (caller's reference)
- fio_redis_dup():   Increments ref, returns engine
- fio_redis_free():  Decrements ref, destroys when ref reaches 0

Important: fio_pubsub_attach/detach do NOT affect reference counts.
The caller is responsible for calling fio_redis_free() when done.

Internal reference management:
- Deferred tasks (connect, callbacks) increment ref before scheduling
  and decrement after the task completes
- Connection on_close callbacks decrement ref (balancing connect's ref)
- The on_detached callback does NOT free memory; it only marks the
  engine as detached

Usage 1 - Database Only:
    // Create engine - only the publishing connection is established
    fio_pubsub_engine_s *redis = fio_redis_new(
        .url = "redis://localhost:6379",
        .auth = "password",  // optional
        .ping_interval = 30  // seconds, optional
    );

    // Send database commands
    FIOBJ cmd = fiobj_array_new();
    fiobj_array_push(cmd, fiobj_str_new_cstr("GET", 3));
    fiobj_array_push(cmd, fiobj_str_new_cstr("mykey", 5));
    fio_redis_send(redis, cmd, my_callback, my_udata);
    fiobj_free(cmd);

    // Cleanup
    fio_redis_free(redis);

Usage 2 - With Pub/Sub:
    fio_pubsub_engine_s *redis = fio_redis_new(
        .url = "localhost:6379"
    );

    // Explicitly attach to pub/sub system - this starts the subscription
    // connection and enables SUBSCRIBE/PSUBSCRIBE/PUBLISH functionality
    fio_pubsub_attach(redis);

    // ... use pub/sub ...

    // Explicitly detach before destroying if attached
    fio_pubsub_detach(redis);
    fio_redis_free(redis);

Note: When used as a sub-engine for clustering, do NOT attach to pub/sub.
The cluster engine will manage the Redis engine directly.

***************************************************************************** */

/* *****************************************************************************
Redis Engine Settings
***************************************************************************** */

#ifndef FIO_REDIS_READ_BUFFER
/** Size of the read buffer for Redis connections */
#define FIO_REDIS_READ_BUFFER 32768
#endif

/* *****************************************************************************
Redis Engine Types
***************************************************************************** */

/** Arguments for creating a Redis engine */
typedef struct {
  /**
   * Redis server URL.
   *
   * Supported formats:
   * - "redis://host:port"
   * - "redis://host" (default port 6379)
   * - "host:port" (no scheme)
   * - "host" (no scheme, default port 6379)
   * - NULL or empty  defaults to "localhost:6379"
   */
  const char *url;
  /** Redis server's password, if any (for AUTH command) */
  const char *auth;
  /** Length of auth string (0 = auto-detect with strlen) */
  size_t auth_len;
  /** Ping interval in seconds (0 = default 300 seconds) */
  uint8_t ping_interval;
} fio_redis_args_s;

/**
 * Creates a Redis pub/sub engine with reference count = 1.
 *
 * The engine is active only after the IO reactor starts running.
 *
 * The caller owns the returned reference and must call fio_redis_free()
 * when done. Attaching to pub/sub does NOT transfer ownership.
 *
 * Returns a pointer to the engine or NULL on error.
 */
SFUNC fio_pubsub_engine_s *fio_redis_new(fio_redis_args_s args);

/** Creates a Redis pub/sub engine (named arguments helper macro). */
#define fio_redis_new(...) fio_redis_new((fio_redis_args_s){__VA_ARGS__})

/**
 * Increments the reference count and returns the engine.
 *
 * Use this when you need to share the engine across multiple owners.
 * Each call to fio_redis_dup() must be balanced with fio_redis_free().
 */
SFUNC fio_pubsub_engine_s *fio_redis_dup(fio_pubsub_engine_s *engine);

/**
 * Decrements the reference count. When count reaches 0, destroys the engine.
 *
 * This function:
 * - Decrements the reference count
 * - If ref reaches 0:
 *   - Closes all connections
 *   - Frees all queued commands
 *   - Frees the engine memory
 *
 * IMPORTANT: If the engine was attached to pub/sub via fio_pubsub_attach(),
 * you MUST call fio_pubsub_detach() before calling fio_redis_free().
 *
 * Safe to call with NULL (no-op).
 */
SFUNC void fio_redis_free(fio_pubsub_engine_s *engine);

/**
 * Sends a Redis command through the engine's connection.
 *
 * The response will be sent back using the optional callback. `udata` is passed
 * along untouched.
 *
 * The `command` should be a FIOBJ array containing the command and arguments.
 *
 * Note: NEVER call Pub/Sub commands (SUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE,
 * PUNSUBSCRIBE) using this function, as it will violate the Redis connection's
 * protocol.
 *
 * Returns 0 on success, -1 on error.
 */
SFUNC int fio_redis_send(fio_pubsub_engine_s *engine,
                         FIOBJ command,
                         void (*callback)(fio_pubsub_engine_s *e,
                                          FIOBJ reply,
                                          void *udata),
                         void *udata);

/* *****************************************************************************




Redis Engine Implementation




***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Internal Types
***************************************************************************** */

/** Command queue node */
typedef struct fio_redis_cmd_s {
  FIO_LIST_NODE node;
  void (*callback)(fio_pubsub_engine_s *e, FIOBJ reply, void *udata);
  void *udata;
  size_t cmd_len;
  uint8_t cmd[];
} fio_redis_cmd_s;

/** Internal connection state */
typedef struct fio_redis_connection_s {
  fio_io_s *io;
  fio_resp3_parser_s parser;
  FIOBJ building;   /* Object being built during parsing */
  uint16_t buf_pos; /* Position in read buffer */
  uint8_t is_sub;   /* Is this the subscription connection? */
} fio_redis_connection_s;

/**
 * Redis engine structure.
 *
 * Reference counting ownership model:
 * - fio_redis_new():  ref = 1 (caller owns this reference)
 * - fio_redis_dup():  ref += 1 (returns engine)
 * - fio_redis_free(): ref -= 1, if ref==0 calls fio___redis_destroy()
 *
 * Internal reference management:
 * - fio_io_defer(fio___redis_connect, ...): ref += 1 before, ref -= 1 after
 * - fio_io_defer(fio___redis_perform_callback, ...): ref += 1 before, ref -= 1
 * after
 * - on_close callbacks: ref -= 1 (balances the connect ref)
 *
 * Pub/Sub integration (NO ref changes):
 * - fio_pubsub_attach(): does NOT increment ref
 * - fio_pubsub_detach(): does NOT decrement ref
 * - on_detached callback: only marks engine as detached, does NOT free
 */
typedef struct fio_redis_engine_s {
  fio_pubsub_engine_s engine;      /* Must be first for casting */
  fio_redis_connection_s pub_conn; /* Publishing connection */
  fio_redis_connection_s sub_conn; /* Subscription connection */
  char *address;
  char *port;
  char *auth_cmd; /* Pre-formatted AUTH command */
  size_t auth_cmd_len;
  FIOBJ last_channel;      /* Last received channel (dedup) */
  FIO_LIST_HEAD cmd_queue; /* Command queue - accessed only from IO thread */
  volatile size_t ref;     /* Reference counter - uses atomic operations */
  uint8_t ping_interval;
  volatile uint8_t pub_sent; /* Flag: command sent, awaiting reply */
  volatile uint8_t running;  /* Flag: engine is active (for reconnection) */
  volatile uint8_t attached; /* Flag: attached to pub/sub system */
  uint8_t
      buf[FIO_REDIS_READ_BUFFER * 2]; /* Read buffers for both connections */
} fio_redis_engine_s;

FIO_LEAK_COUNTER_DEF(fio___redis_engine)
FIO_LEAK_COUNTER_DEF(fio___redis_cmd)

/* *****************************************************************************
RESP3 Callbacks for FIOBJ Building
***************************************************************************** */

FIO_SFUNC void *fio___redis_on_null(void *udata) {
  (void)udata;
  return (void *)fiobj_null();
}

FIO_SFUNC void *fio___redis_on_bool(void *udata, int is_true) {
  (void)udata;
  return (void *)(is_true ? fiobj_true() : fiobj_false());
}

FIO_SFUNC void *fio___redis_on_number(void *udata, int64_t num) {
  (void)udata;
  return (void *)fiobj_num_new((intptr_t)num);
}

FIO_SFUNC void *fio___redis_on_double(void *udata, double num) {
  (void)udata;
  return (void *)fiobj_float_new(num);
}

FIO_SFUNC void *fio___redis_on_bignum(void *udata,
                                      const void *data,
                                      size_t len) {
  (void)udata;
  /* Store big numbers as strings */
  return (void *)fiobj_str_new_cstr((const char *)data, len);
}

FIO_SFUNC void *fio___redis_on_string(void *udata,
                                      const void *data,
                                      size_t len,
                                      uint8_t type) {
  (void)udata;
  (void)type;
  return (void *)fiobj_str_new_cstr((const char *)data, len);
}

/**
 * Called when a blob string starts.
 * Pre-allocate FIOBJ string buffer if length is known.
 */
FIO_SFUNC void *fio___redis_on_start_string(void *udata,
                                            size_t len,
                                            uint8_t type) {
  (void)udata;
  (void)type;
  /* Pre-allocate if length known, otherwise create empty string */
  if (len != (size_t)-1 && len > 0)
    return (void *)fiobj_str_new_buf(len);
  return (void *)fiobj_str_new();
}

/**
 * Called with partial string data - append to FIOBJ string.
 */
FIO_SFUNC int fio___redis_on_string_write(void *udata,
                                          void *ctx,
                                          const void *data,
                                          size_t len) {
  (void)udata;
  fiobj_str_write((FIOBJ)ctx, (const char *)data, len);
  return 0;
}

/**
 * Called when string is complete - return the FIOBJ string.
 */
FIO_SFUNC void *fio___redis_on_string_done(void *udata,
                                           void *ctx,
                                           uint8_t type) {
  (void)udata;
  (void)type;
  return ctx; /* Return the completed FIOBJ string */
}

FIO_SFUNC void *fio___redis_on_error(void *udata,
                                     const void *data,
                                     size_t len,
                                     uint8_t type) {
  (void)udata;
  (void)type;
  /* Store errors as strings - caller can check context */
  FIOBJ err = fiobj_str_new_cstr((const char *)data, len);
  FIO_LOG_WARNING("(redis) error response: %.*s", (int)len, (const char *)data);
  return (void *)err;
}

FIO_SFUNC void *fio___redis_on_array(void *udata,
                                     void *parent_ctx,
                                     int64_t len) {
  (void)udata;
  (void)parent_ctx;
  (void)len;
  return (void *)fiobj_array_new();
}

FIO_SFUNC void *fio___redis_on_map(void *udata, void *parent_ctx, int64_t len) {
  (void)udata;
  (void)parent_ctx;
  (void)len;
  return (void *)fiobj_hash_new();
}

FIO_SFUNC void *fio___redis_on_push(void *udata,
                                    void *parent_ctx,
                                    int64_t len) {
  /* Push messages are treated as arrays */
  return fio___redis_on_array(udata, parent_ctx, len);
}

FIO_SFUNC int fio___redis_array_push(void *udata, void *ctx, void *value) {
  (void)udata;
  fiobj_array_push((FIOBJ)ctx, (FIOBJ)value);
  return 0;
}

FIO_SFUNC int fio___redis_map_push(void *udata,
                                   void *ctx,
                                   void *key,
                                   void *value) {
  (void)udata;
  fiobj_hash_set((FIOBJ)ctx, (FIOBJ)key, (FIOBJ)value, NULL);
  if (key != value) /* in a set, both key and value are same and owned by set */
    fiobj_free((FIOBJ)key);
  return 0;
}

FIO_SFUNC void fio___redis_free_unused(void *udata, void *obj) {
  (void)udata;
  fiobj_free((FIOBJ)obj);
}

FIO_SFUNC void *fio___redis_on_error_protocol(void *udata) {
  (void)udata;
  FIO_LOG_ERROR("(redis) RESP protocol error");
  return NULL;
}

/** RESP3 callbacks for building FIOBJ objects */
static const fio_resp3_callbacks_s FIO___REDIS_RESP3_CALLBACKS = {
    .on_null = fio___redis_on_null,
    .on_bool = fio___redis_on_bool,
    .on_number = fio___redis_on_number,
    .on_double = fio___redis_on_double,
    .on_bignum = fio___redis_on_bignum,
    .on_string = fio___redis_on_string,
    .on_error = fio___redis_on_error,
    .on_array = fio___redis_on_array,
    .on_map = fio___redis_on_map,
    .on_push = fio___redis_on_push,
    .array_push = fio___redis_array_push,
    .push_push = fio___redis_array_push,
    .map_push = fio___redis_map_push,
    .free_unused = fio___redis_free_unused,
    .on_error_protocol = fio___redis_on_error_protocol,
    /* Streaming string callbacks for efficient large string handling */
    .on_start_string = fio___redis_on_start_string,
    .on_string_write = fio___redis_on_string_write,
    .on_string_done = fio___redis_on_string_done,
};

/* *****************************************************************************
RESP Formatting Helpers
***************************************************************************** */

/** Writes a FIOBJ to RESP format into a string */
FIO_SFUNC void fio___redis_fiobj2resp(FIOBJ dest, FIOBJ obj) {
  fio_str_info_s s;
  switch (FIOBJ_TYPE(obj)) {
  case FIOBJ_T_NULL: fiobj_str_write(dest, "$-1\r\n", 5); break;
  case FIOBJ_T_TRUE: fiobj_str_write(dest, "$4\r\ntrue\r\n", 10); break;
  case FIOBJ_T_FALSE: fiobj_str_write(dest, "$5\r\nfalse\r\n", 11); break;
  case FIOBJ_T_ARRAY:
    fiobj_str_write(dest, "*", 1);
    fiobj_str_write_i(dest, (int64_t)fiobj_array_count(obj));
    fiobj_str_write(dest, "\r\n", 2);
    for (size_t i = 0; i < fiobj_array_count(obj); ++i) {
      fio___redis_fiobj2resp(dest, fiobj_array_get(obj, (int32_t)i));
    }
    break;
  case FIOBJ_T_HASH:
    fiobj_str_write(dest, "*", 1);
    fiobj_str_write_i(dest, (int64_t)(fiobj_hash_count(obj) * 2));
    fiobj_str_write(dest, "\r\n", 2);
    FIO_MAP_EACH(fiobj_hash, obj, pos) {
      fio___redis_fiobj2resp(dest, pos.key);
      fio___redis_fiobj2resp(dest, pos.value);
    }
    break;
  case FIOBJ_T_NUMBER:
  case FIOBJ_T_FLOAT:
  case FIOBJ_T_STRING:
  default:
    s = fiobj2cstr(obj);
    fiobj_str_write(dest, "$", 1);
    fiobj_str_write_i(dest, (int64_t)s.len);
    fiobj_str_write(dest, "\r\n", 2);
    fiobj_str_write(dest, s.buf, s.len);
    fiobj_str_write(dest, "\r\n", 2);
    break;
  }
}

/* *****************************************************************************
Reference Counting and Cleanup

Reference counting ownership model:
- fio_redis_new():  ref = 1 (caller's reference)
- fio_redis_dup():  ref += 1
- fio_redis_free(): ref -= 1, if ref==0 calls fio___redis_destroy()

Internal reference management:
- fio_io_defer(fio___redis_connect, ...): ref += 1 before, ref -= 1 after
- fio_io_defer(fio___redis_perform_callback, ...): ref += 1 before, ref -= 1
after
- on_close callbacks: ref -= 1 (balances the connect ref)

Pub/Sub integration (NO ref changes):
- fio_pubsub_attach(): does NOT increment ref
- fio_pubsub_detach(): does NOT decrement ref
- on_detached callback: only marks engine as detached, does NOT free
***************************************************************************** */

FIO_SFUNC void fio___redis_connection_reset(fio_redis_connection_s *conn) {
  conn->buf_pos = 0;
  /* Clean up any partially parsed streaming string */
  if (conn->parser.streaming_string && conn->parser.streaming_string_ctx) {
    fiobj_free((FIOBJ)conn->parser.streaming_string_ctx);
  }
  /* Clean up any partially built containers in the parser stack */
  while (conn->parser.depth > 0) {
    fio_resp3_frame_s *f = &conn->parser.stack[conn->parser.depth - 1];
    if (f->key)
      fiobj_free((FIOBJ)f->key);
    if (f->ctx)
      fiobj_free((FIOBJ)f->ctx);
    --conn->parser.depth;
  }
  conn->parser = (fio_resp3_parser_s){0};
  fiobj_free(conn->building);
  conn->building = FIOBJ_INVALID;
  conn->io = NULL;
}

/**
 * Internal: Increment reference count.
 * Called before scheduling deferred tasks.
 */
FIO_SFUNC void fio___redis_dup(fio_redis_engine_s *r) {
  if (r)
    fio_atomic_add(&r->ref, 1);
}

/**
 * Internal: Decrement reference count and destroy if zero.
 * Called after deferred tasks complete and from fio_redis_free().
 */
FIO_SFUNC void fio___redis_free(fio_redis_engine_s *r) {
  if (!r)
    return;
  size_t old_ref = fio_atomic_sub(&r->ref, 1);
  if (old_ref != 1)
    return; /* ref was > 1, so after subtraction it's still > 0 */
  /* ref reached 0 - perform actual cleanup */
  FIO_LOG_DEBUG("(redis) destroying engine for %s:%s", r->address, r->port);

  /* Free remaining resources */
  fiobj_free(r->last_channel);
  while (!FIO_LIST_IS_EMPTY(&r->cmd_queue)) {
    fio_redis_cmd_s *cmd;
    FIO_LIST_POP(fio_redis_cmd_s, node, cmd, &r->cmd_queue);
    FIO_MEM_FREE(cmd, sizeof(*cmd) + cmd->cmd_len);
    FIO_LEAK_COUNTER_ON_FREE(fio___redis_cmd);
  }
  FIO_MEM_FREE(r,
               sizeof(*r) + strlen(r->address) + 1 + strlen(r->port) + 1 +
                   r->auth_cmd_len + (FIO_REDIS_READ_BUFFER * 2));
  FIO_LEAK_COUNTER_ON_FREE(fio___redis_engine);
}

/**
 * Internal: Deferred task to close connections and release reference.
 * Runs on IO thread to ensure thread-safety.
 */
FIO_SFUNC void fio___redis_free_task(void *engine_, void *ignr_) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)engine_;
  (void)ignr_;

  /* Close connections - this will trigger on_close callbacks which will
   * release the connection references and eventually free the engine */
  if (r->pub_conn.io)
    fio_io_close_now(r->pub_conn.io);
  if (r->sub_conn.io)
    fio_io_close_now(r->sub_conn.io);

  /* Release the reference held for this deferred task */
  fio___redis_free(r);
}

/* *****************************************************************************
Command Queue Management

NOTE: All command queue operations MUST run on the IO thread to prevent race
conditions. Use fio___redis_attach_cmd_task() via fio_io_defer() for thread-safe
command queuing from any thread.
***************************************************************************** */

/**
 * Internal: Send the next command in the queue if ready.
 * MUST be called from the IO thread only.
 */
FIO_SFUNC void fio___redis_send_next_cmd(fio_redis_engine_s *r) {
  if (!r->pub_sent && !FIO_LIST_IS_EMPTY(&r->cmd_queue) && r->pub_conn.io) {
    r->pub_sent = 1;
    fio_redis_cmd_s *cmd =
        FIO_PTR_FROM_FIELD(fio_redis_cmd_s, node, r->cmd_queue.next);
    fio_io_write(r->pub_conn.io, cmd->cmd, cmd->cmd_len);
  }
}

/**
 * Internal: Deferred task to attach a command to the queue.
 * Runs on the IO thread to ensure thread-safety.
 */
FIO_SFUNC void fio___redis_attach_cmd_task(void *engine_, void *cmd_) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)engine_;
  fio_redis_cmd_s *cmd = (fio_redis_cmd_s *)cmd_;

  /* Check if engine is still running */
  if (!r->running) {
    /* Engine is shutting down, invoke callback with NULL reply */
    if (cmd->callback)
      cmd->callback((fio_pubsub_engine_s *)r, FIOBJ_INVALID, cmd->udata);
    FIO_MEM_FREE(cmd, sizeof(*cmd) + cmd->cmd_len);
    FIO_LEAK_COUNTER_ON_FREE(fio___redis_cmd);
    fio___redis_free(r);
    return;
  }

  /* Add command to queue and try to send */
  FIO_LIST_PUSH(&r->cmd_queue, &cmd->node);
  fio___redis_send_next_cmd(r);
  fio___redis_free(r); /* Release the reference held for this deferred task */
}

/**
 * Internal: Queue a command for execution.
 * Thread-safe - defers the actual queue manipulation to the IO thread.
 */
FIO_SFUNC void fio___redis_attach_cmd(fio_redis_engine_s *r,
                                      fio_redis_cmd_s *cmd) {
  fio___redis_dup(r); /* Hold reference for deferred task */
  fio_io_defer(fio___redis_attach_cmd_task, r, cmd);
}

/* *****************************************************************************
Callback Task for Command Replies
***************************************************************************** */

FIO_SFUNC void fio___redis_perform_callback(void *engine_, void *cmd_) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)engine_;
  fio_redis_cmd_s *cmd = (fio_redis_cmd_s *)cmd_;
  FIOBJ reply = (FIOBJ)cmd->node.next;
  if (cmd->callback)
    cmd->callback((fio_pubsub_engine_s *)engine_, reply, cmd->udata);
  fiobj_free(reply);
  FIO_MEM_FREE(cmd, sizeof(*cmd) + cmd->cmd_len);
  FIO_LEAK_COUNTER_ON_FREE(fio___redis_cmd);
  fio___redis_free(r); /* Release the reference held for this deferred task */
}

/* *****************************************************************************
Message Handlers

NOTE: These handlers are called from the IO thread via protocol callbacks
(on_data), so they don't need locks for accessing engine state.
***************************************************************************** */

/**
 * Handle reply on publishing connection.
 * Called from IO thread via on_data callback - no lock needed.
 */
FIO_SFUNC void fio___redis_on_pub_message(fio_redis_engine_s *r, FIOBJ msg) {
  /* Dequeue the command that this reply is for */
  FIO_LIST_NODE *node = r->cmd_queue.next;
  if (node != &r->cmd_queue) {
    FIO_LIST_REMOVE(node);
  } else {
    node = NULL;
  }
  r->pub_sent = 0;
  fio___redis_send_next_cmd(r);

  if (!node) {
    FIO_LOG_WARNING("(redis) received reply with no pending command");
    return;
  }

  fio_redis_cmd_s *cmd = FIO_PTR_FROM_FIELD(fio_redis_cmd_s, node, node);
  cmd->node.next = (FIO_LIST_NODE *)fiobj_dup(msg);
  fio___redis_dup(r); /* Hold reference for deferred callback */
  fio_io_defer(fio___redis_perform_callback, r, cmd);
}

/**
 * Handle message on subscription connection.
 * Called from IO thread via on_data callback - no lock needed.
 */
FIO_SFUNC void fio___redis_on_sub_message(fio_redis_engine_s *r, FIOBJ msg) {
  if (FIOBJ_TYPE(msg) != FIOBJ_T_ARRAY) {
    /* Likely a PONG or status response */
    fio_str_info_s s = fiobj2cstr(msg);
    if (s.len != 4 || s.buf[0] != 'P') {
      FIO_LOG_WARNING("(redis) unexpected subscription data: %.*s",
                      (int)s.len,
                      s.buf);
    }
    return;
  }

  size_t count = fiobj_array_count(msg);
  if (count < 3)
    return;

  fio_str_info_s type = fiobj2cstr(fiobj_array_get(msg, 0));

  if (type.len == 7 && !FIO_MEMCMP(type.buf, "message", 7)) {
    /* Regular message: ["message", channel, data] */
    FIOBJ channel = fiobj_array_get(msg, 1);
    FIOBJ data = fiobj_array_get(msg, 2);
    fiobj_free(r->last_channel);
    r->last_channel = fiobj_dup(channel);
    fio_str_info_s ch = fiobj2cstr(channel);
    fio_str_info_s m = fiobj2cstr(data);
    fio_publish(.channel = FIO_BUF_INFO2(ch.buf, ch.len),
                .message = FIO_BUF_INFO2(m.buf, m.len),
                .engine = FIO_PUBSUB_LOCAL);
  } else if (type.len == 8 && !FIO_MEMCMP(type.buf, "pmessage", 8) &&
             count >= 4) {
    /* Pattern message: ["pmessage", pattern, channel, data] */
    FIOBJ channel = fiobj_array_get(msg, 2);
    FIOBJ data = fiobj_array_get(msg, 3);
    /* Deduplicate if same channel as last message */
    if (!fiobj_is_eq(r->last_channel, channel)) {
      fio_str_info_s ch = fiobj2cstr(channel);
      fio_str_info_s m = fiobj2cstr(data);
      fio_publish(.channel = FIO_BUF_INFO2(ch.buf, ch.len),
                  .message = FIO_BUF_INFO2(m.buf, m.len),
                  .engine = FIO_PUBSUB_LOCAL);
    }
  }
  /* Ignore subscribe/unsubscribe confirmations */
}

/* *****************************************************************************
Protocol Callbacks
***************************************************************************** */

FIO_SFUNC void fio___redis_on_attach(fio_io_s *io);
FIO_SFUNC void fio___redis_on_data(fio_io_s *io);
FIO_SFUNC void fio___redis_on_close_pub(void *buffer, void *udata);
FIO_SFUNC void fio___redis_on_close_sub(void *buffer, void *udata);
FIO_SFUNC void fio___redis_on_timeout(fio_io_s *io);
FIO_SFUNC void fio___redis_connect(void *engine_, void *conn_);

/** Protocol for publishing connection */
static fio_io_protocol_s FIO___REDIS_PUB_PROTOCOL = {
    .on_attach = fio___redis_on_attach,
    .on_data = fio___redis_on_data,
    .on_close = fio___redis_on_close_pub,
    .on_timeout = fio___redis_on_timeout,
    .timeout = 300000, /* 5 minutes default */
};

/** Protocol for subscription connection */
static fio_io_protocol_s FIO___REDIS_SUB_PROTOCOL = {
    .on_attach = fio___redis_on_attach,
    .on_data = fio___redis_on_data,
    .on_close = fio___redis_on_close_sub,
    .on_timeout = fio___redis_on_timeout,
    .timeout = 300000,
};

/**
 * Called when connection is attached to the protocol (connection ready).
 * Runs on IO thread - no lock needed.
 */
FIO_SFUNC void fio___redis_on_attach(fio_io_s *io) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)fio_io_udata(io);
  if (!r)
    return;

  /* Determine which connection this is based on protocol */
  fio_io_protocol_s *pr = fio_io_protocol(io);
  int is_sub = (pr == &FIO___REDIS_SUB_PROTOCOL);
  fio_redis_connection_s *conn = is_sub ? &r->sub_conn : &r->pub_conn;

  /* Store the IO handle now that connection is ready */
  conn->io = io;
  conn->is_sub = (uint8_t)is_sub;

  /* Send AUTH if configured */
  if (r->auth_cmd_len) {
    fio_io_write(io, r->auth_cmd, r->auth_cmd_len);
  }

  if (is_sub) {
    FIO_LOG_DEBUG("(redis) subscription connection established to %s:%s",
                  r->address,
                  r->port);
    /* If attached to pub/sub, re-attach to trigger resubscription */
    if (r->attached)
      fio_pubsub_attach(&r->engine);
  } else {
    FIO_LOG_DEBUG("(redis) publishing connection established to %s:%s",
                  r->address,
                  r->port);
    /* Send any queued commands - no lock needed, we're on IO thread */
    r->pub_sent = 0;
    fio___redis_send_next_cmd(r);

    /* Start subscription connection only if attached to pub/sub */
    if (r->attached && !r->sub_conn.io) {
      fio___redis_dup(r); /* Increment ref for deferred task */
      fio_io_defer(fio___redis_connect, r, &r->sub_conn);
    }
  }
}

FIO_SFUNC void fio___redis_on_data(fio_io_s *io) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)fio_io_udata(io);
  if (!r)
    return;

  fio_redis_connection_s *conn;
  uint8_t *buf;
  int is_sub;

  if (io == r->sub_conn.io) {
    conn = &r->sub_conn;
    buf = r->buf + FIO_REDIS_READ_BUFFER;
    is_sub = 1;
  } else {
    conn = &r->pub_conn;
    buf = r->buf;
    is_sub = 0;
  }

  /* Read data */
  size_t available = FIO_REDIS_READ_BUFFER - conn->buf_pos;
  size_t len = fio_io_read(io, buf + conn->buf_pos, available);
  if (!len)
    return;

  conn->buf_pos += (uint16_t)len;

  /* Parse RESP data - loop to process all complete messages in buffer */
  for (;;) {
    fio_resp3_result_s result = fio_resp3_parse(&conn->parser,
                                                &FIO___REDIS_RESP3_CALLBACKS,
                                                buf,
                                                conn->buf_pos);

    if (result.err) {
      FIO_LOG_ERROR("(redis) parser error - closing connection");
      fio_io_close_now(io);
      return;
    }

    /* Move unconsumed data to start of buffer */
    if (result.consumed && result.consumed < conn->buf_pos) {
      size_t remaining = conn->buf_pos - result.consumed;
      FIO_MEMMOVE(buf, buf + result.consumed, remaining);
      conn->buf_pos = (uint16_t)remaining;
    } else if (result.consumed) {
      conn->buf_pos = 0;
    }

    if (result.obj) {
      FIOBJ msg = (FIOBJ)result.obj;
      if (is_sub) {
        fio___redis_on_sub_message(r, msg);
      } else {
        fio___redis_on_pub_message(r, msg);
      }
      fiobj_free(msg);
      /* Reset parser for next message and continue processing */
      conn->parser = (fio_resp3_parser_s){0};
      continue;
    }

    /* No complete message available, exit loop */
    break;
  }
}

/** Internal helper for connection close handling */
FIO_SFUNC void fio___redis_on_close_internal(fio_redis_engine_s *r,
                                             fio_redis_connection_s *conn,
                                             int is_sub) {
  fio___redis_connection_reset(conn);

  if (r->running && fio_io_is_running()) {
    FIO_LOG_WARNING("(redis) %s connection lost, reconnecting...",
                    is_sub ? "subscription" : "publishing");
    /* Increment ref for deferred reconnect task */
    fio___redis_dup(r);
    fio_io_defer(fio___redis_connect, r, conn);
  }
  /* Release the reference held by this connection */
  fio___redis_free(r);
}

FIO_SFUNC void fio___redis_on_close_pub(void *buffer, void *udata) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)udata;
  (void)buffer;
  if (!r)
    return;
  fio___redis_on_close_internal(r, &r->pub_conn, 0);
}

FIO_SFUNC void fio___redis_on_close_sub(void *buffer, void *udata) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)udata;
  (void)buffer;
  if (!r)
    return;
  fio___redis_on_close_internal(r, &r->sub_conn, 1);
}

/**
 * Handle connection timeout.
 * Runs on IO thread - no lock needed for cmd_queue access.
 */
FIO_SFUNC void fio___redis_on_timeout(fio_io_s *io) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)fio_io_udata(io);
  if (!r)
    return;

  if (io == r->sub_conn.io) {
    /* Subscription connection - just send PING */
    fio_io_write(io, "*1\r\n$4\r\nPING\r\n", 14);
  } else {
    /* Publishing connection - check for stuck commands */
    if (!FIO_LIST_IS_EMPTY(&r->cmd_queue)) {
      FIO_LOG_WARNING("(redis) server unresponsive, disconnecting");
      fio_io_close_now(io);
      return;
    }
    /* Queue a PING command */
    fio_redis_cmd_s *cmd =
        (fio_redis_cmd_s *)FIO_MEM_REALLOC(NULL, 0, sizeof(*cmd) + 15, 0);
    if (cmd) {
      FIO_LEAK_COUNTER_ON_ALLOC(fio___redis_cmd);
      *cmd = (fio_redis_cmd_s){.cmd_len = 14};
      FIO_MEMCPY(cmd->cmd, "*1\r\n$4\r\nPING\r\n", 15);
      fio___redis_attach_cmd(r, cmd);
    }
  }
}

/* *****************************************************************************
Connection Management
***************************************************************************** */

/** Timer callback wrapper for fio___redis_connect (returns int as required) */
FIO_SFUNC int fio___redis_connect_timer(void *engine_, void *conn_);

FIO_SFUNC void fio___redis_connect(void *engine_, void *conn_) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)engine_;
  fio_redis_connection_s *conn = (fio_redis_connection_s *)conn_;

  if (!r->running || conn->io) {
    fio___redis_free(r);
    return;
  }

  int is_sub = (conn == &r->sub_conn);
  conn->is_sub = is_sub;
  fio_io_protocol_s *protocol =
      is_sub ? &FIO___REDIS_SUB_PROTOCOL : &FIO___REDIS_PUB_PROTOCOL;

  /* Build URL */
  char url[512];
  size_t url_len = 0;
  url_len += (size_t)snprintf(url + url_len,
                              sizeof(url) - url_len,
                              "tcp://%s:%s",
                              r->address,
                              r->port);

  FIO_LOG_DEBUG("(redis) connecting to %s:%s (%s)",
                r->address,
                r->port,
                is_sub ? "subscription" : "publishing");

  /* Start async connection - on_attach will be called when ready */
  conn->io =
      fio_io_connect(url, .protocol = protocol, .udata = r, .timeout = 30000);
  if (!conn->io) {
    FIO_LOG_ERROR("(redis) failed to initiate connection to %s:%s",
                  r->address,
                  r->port);
    /* Retry after delay using proper timer callback signature */
    fio_io_run_every(.fn = fio___redis_connect_timer,
                     .udata1 = r,
                     .udata2 = conn,
                     .every = 1000,
                     .repetitions = 1);
    return;
  }
  /* Connection initiated - the ref added before connect is now held by the
   * connection. It will be released in on_close when the connection closes. */
}

/** Timer callback wrapper - calls fio___redis_connect and returns 0 to stop */
FIO_SFUNC int fio___redis_connect_timer(void *engine_, void *conn_) {
  fio___redis_connect(engine_, conn_);
  return 0; /* Don't repeat - fio___redis_connect handles its own retry */
}

/* *****************************************************************************
Pub/Sub Engine Callbacks

NOTE: All pub/sub engine callbacks are called from the IO thread by the pub/sub
system, so they don't need locks for accessing engine state.
***************************************************************************** */

/**
 * Called when engine is detached from pub/sub.
 * Runs on IO thread - no lock needed.
 *
 * IMPORTANT: This callback does NOT free memory. It only marks the engine
 * as detached. Memory is freed by fio_redis_free() when ref reaches 0.
 */
FIO_SFUNC void fio___redis_detached(const fio_pubsub_engine_s *eng) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)eng;
  FIO_LOG_DEBUG("(redis) engine detached from pub/sub");
  r->attached = 0;
  /* Close subscription connection since we're no longer attached */
  if (r->sub_conn.io) {
    fio_io_close_now(r->sub_conn.io);
  }
  /* Do NOT free here - memory is managed by reference counting */
}

/**
 * Subscribe to a channel.
 * Runs on IO thread - no lock needed.
 */
FIO_SFUNC void fio___redis_subscribe(const fio_pubsub_engine_s *eng,
                                     fio_buf_info_s channel,
                                     int16_t filter) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)eng;
  (void)filter;

  /* Mark as attached and start subscription connection if needed */
  if (!r->attached) {
    r->attached = 1;
    if (r->running && !r->sub_conn.io) {
      fio___redis_dup(r);
      fio_io_defer(fio___redis_connect, r, &r->sub_conn);
    }
  }

  if (!r->sub_conn.io)
    return;

  /* Build SUBSCRIBE command */
  FIOBJ cmd = fiobj_str_new_buf(32 + channel.len);
  fiobj_str_write(cmd, "*2\r\n$9\r\nSUBSCRIBE\r\n$", 20);
  fiobj_str_write_i(cmd, (int64_t)channel.len);
  fiobj_str_write(cmd, "\r\n", 2);
  fiobj_str_write(cmd, channel.buf, channel.len);
  fiobj_str_write(cmd, "\r\n", 2);

  fio_str_info_s s = fiobj2cstr(cmd);
  fio_io_write(r->sub_conn.io, s.buf, s.len);
  fiobj_free(cmd);
}

/**
 * Subscribe to a pattern.
 * Runs on IO thread - no lock needed.
 */
FIO_SFUNC void fio___redis_psubscribe(const fio_pubsub_engine_s *eng,
                                      fio_buf_info_s channel,
                                      int16_t filter) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)eng;
  (void)filter;

  /* Mark as attached and start subscription connection if needed */
  if (!r->attached) {
    r->attached = 1;
    if (r->running && !r->sub_conn.io) {
      fio___redis_dup(r);
      fio_io_defer(fio___redis_connect, r, &r->sub_conn);
    }
  }

  if (!r->sub_conn.io)
    return;

  /* Build PSUBSCRIBE command */
  FIOBJ cmd = fiobj_str_new_buf(32 + channel.len);
  fiobj_str_write(cmd, "*2\r\n$10\r\nPSUBSCRIBE\r\n$", 22);
  fiobj_str_write_i(cmd, (int64_t)channel.len);
  fiobj_str_write(cmd, "\r\n", 2);
  fiobj_str_write(cmd, channel.buf, channel.len);
  fiobj_str_write(cmd, "\r\n", 2);

  fio_str_info_s s = fiobj2cstr(cmd);
  fio_io_write(r->sub_conn.io, s.buf, s.len);
  fiobj_free(cmd);
}

/**
 * Unsubscribe from a channel.
 * Runs on IO thread - no lock needed.
 */
FIO_SFUNC void fio___redis_unsubscribe(const fio_pubsub_engine_s *eng,
                                       fio_buf_info_s channel,
                                       int16_t filter) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)eng;
  (void)filter;

  /* Skip if not attached or no connection */
  if (!r->attached || !r->sub_conn.io)
    return;

  /* Build UNSUBSCRIBE command */
  FIOBJ cmd = fiobj_str_new_buf(32 + channel.len);
  fiobj_str_write(cmd, "*2\r\n$11\r\nUNSUBSCRIBE\r\n$", 23);
  fiobj_str_write_i(cmd, (int64_t)channel.len);
  fiobj_str_write(cmd, "\r\n", 2);
  fiobj_str_write(cmd, channel.buf, channel.len);
  fiobj_str_write(cmd, "\r\n", 2);

  fio_str_info_s s = fiobj2cstr(cmd);
  fio_io_write(r->sub_conn.io, s.buf, s.len);
  fiobj_free(cmd);
}

/**
 * Unsubscribe from a pattern.
 * Runs on IO thread - no lock needed.
 */
FIO_SFUNC void fio___redis_punsubscribe(const fio_pubsub_engine_s *eng,
                                        fio_buf_info_s channel,
                                        int16_t filter) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)eng;
  (void)filter;

  /* Skip if not attached or no connection */
  if (!r->attached || !r->sub_conn.io)
    return;

  /* Build PUNSUBSCRIBE command */
  FIOBJ cmd = fiobj_str_new_buf(32 + channel.len);
  fiobj_str_write(cmd, "*2\r\n$12\r\nPUNSUBSCRIBE\r\n$", 24);
  fiobj_str_write_i(cmd, (int64_t)channel.len);
  fiobj_str_write(cmd, "\r\n", 2);
  fiobj_str_write(cmd, channel.buf, channel.len);
  fiobj_str_write(cmd, "\r\n", 2);

  fio_str_info_s s = fiobj2cstr(cmd);
  fio_io_write(r->sub_conn.io, s.buf, s.len);
  fiobj_free(cmd);
}

/**
 * Publish a message to Redis.
 * Runs on IO thread - command queuing is thread-safe via
 * fio___redis_attach_cmd.
 */
FIO_SFUNC void fio___redis_publish(const fio_pubsub_engine_s *eng,
                                   fio_msg_s *msg) {
  fio_redis_engine_s *r = (fio_redis_engine_s *)eng;

  /* Build PUBLISH command */
  size_t cmd_size =
      sizeof(fio_redis_cmd_s) + 64 + msg->channel.len + msg->message.len;
  fio_redis_cmd_s *cmd =
      (fio_redis_cmd_s *)FIO_MEM_REALLOC(NULL, 0, cmd_size, 0);
  if (!cmd)
    return;
  FIO_LEAK_COUNTER_ON_ALLOC(fio___redis_cmd);

  *cmd = (fio_redis_cmd_s){0};

  char *buf = (char *)cmd->cmd;
  size_t pos = 0;

  /* *3\r\n$7\r\nPUBLISH\r\n$<channel_len>\r\n<channel>\r\n$<msg_len>\r\n<msg>\r\n
   */
  FIO_MEMCPY(buf + pos, "*3\r\n$7\r\nPUBLISH\r\n$", 18);
  pos += 18;
  pos += (size_t)fio_ltoa(buf + pos, (int64_t)msg->channel.len, 10);
  buf[pos++] = '\r';
  buf[pos++] = '\n';
  FIO_MEMCPY(buf + pos, msg->channel.buf, msg->channel.len);
  pos += msg->channel.len;
  buf[pos++] = '\r';
  buf[pos++] = '\n';
  buf[pos++] = '$';
  pos += (size_t)fio_ltoa(buf + pos, (int64_t)msg->message.len, 10);
  buf[pos++] = '\r';
  buf[pos++] = '\n';
  FIO_MEMCPY(buf + pos, msg->message.buf, msg->message.len);
  pos += msg->message.len;
  buf[pos++] = '\r';
  buf[pos++] = '\n';
  buf[pos] = 0;

  cmd->cmd_len = pos;
  fio___redis_attach_cmd(r, cmd);
}

/* *****************************************************************************
Public API
***************************************************************************** */

void fio_redis_new____(void); /* IDE marker */
/**
 * Creates a Redis pub/sub engine with reference count = 1.
 *
 * The caller owns the returned reference and must call fio_redis_free()
 * when done. Attaching to pub/sub does NOT transfer ownership.
 */
SFUNC fio_pubsub_engine_s *fio_redis_new FIO_NOOP(fio_redis_args_s args) {
  /* Default URL if not provided */
  static const char *default_host = "localhost";
  static const char *default_port = "6379";

  /* Parse URL to extract host and port */
  const char *host = default_host;
  size_t host_len = 9; /* strlen("localhost") */
  const char *port = default_port;
  size_t port_len = 4; /* strlen("6379") */

  if (args.url && args.url[0]) {
    fio_url_s u = fio_url_parse(args.url, strlen(args.url));
    if (u.host.buf && u.host.len) {
      host = u.host.buf;
      host_len = u.host.len;
    }
    if (u.port.buf && u.port.len) {
      port = u.port.buf;
      port_len = u.port.len;
    }
  }

  if (!args.ping_interval)
    args.ping_interval = 30;

  size_t auth_len = args.auth_len;
  if (args.auth && !auth_len)
    auth_len = strlen(args.auth);

  /* Calculate AUTH command size if needed */
  size_t auth_cmd_len = 0;
  if (auth_len) {
    /* *2\r\n$4\r\nAUTH\r\n$<len>\r\n<password>\r\n */
    auth_cmd_len = 18 + 20 + auth_len; /* generous estimate */
  }

  /* Allocate engine */
  size_t alloc_size = sizeof(fio_redis_engine_s) + host_len + 1 + port_len + 1 +
                      auth_cmd_len + (FIO_REDIS_READ_BUFFER * 2);
  fio_redis_engine_s *r =
      (fio_redis_engine_s *)FIO_MEM_REALLOC(NULL, 0, alloc_size, 0);
  if (!r) {
    FIO_LOG_ERROR("(redis) failed to allocate engine");
    return NULL;
  }
  FIO_LEAK_COUNTER_ON_ALLOC(fio___redis_engine);

  /* Initialize with ref = 1 (caller's reference) */
  *r = (fio_redis_engine_s){
      .engine =
          {
              .detached = fio___redis_detached,
              .subscribe = fio___redis_subscribe,
              .psubscribe = fio___redis_psubscribe,
              .unsubscribe = fio___redis_unsubscribe,
              .punsubscribe = fio___redis_punsubscribe,
              .publish = fio___redis_publish,
          },
      .cmd_queue = FIO_LIST_INIT(r->cmd_queue),
      .ref = 1, /* Caller's reference */
      .ping_interval = args.ping_interval,
      .running = 1,
  };

  /* Set up string pointers after the struct */
  char *str_ptr = (char *)(r + 1) + (FIO_REDIS_READ_BUFFER * 2);
  r->address = str_ptr;
  FIO_MEMCPY(r->address, host, host_len);
  r->address[host_len] = '\0';
  str_ptr += host_len + 1;

  r->port = str_ptr;
  FIO_MEMCPY(r->port, port, port_len);
  r->port[port_len] = '\0';
  str_ptr += port_len + 1;

  /* Build AUTH command if needed */
  if (auth_len) {
    r->auth_cmd = str_ptr;
    size_t pos = 0;
    FIO_MEMCPY(r->auth_cmd + pos, "*2\r\n$4\r\nAUTH\r\n$", 15);
    pos += 15;
    pos += (size_t)fio_ltoa(r->auth_cmd + pos, (int64_t)auth_len, 10);
    r->auth_cmd[pos++] = '\r';
    r->auth_cmd[pos++] = '\n';
    FIO_MEMCPY(r->auth_cmd + pos, args.auth, auth_len);
    pos += auth_len;
    r->auth_cmd[pos++] = '\r';
    r->auth_cmd[pos++] = '\n';
    r->auth_cmd[pos] = 0;
    r->auth_cmd_len = pos;
  }

  /* Set timeout based on ping interval */
  uint32_t timeout_ms = (uint32_t)args.ping_interval * 1000;
  if (timeout_ms > FIO_IO_TIMEOUT_MAX)
    timeout_ms = FIO_IO_TIMEOUT_MAX;
  FIO___REDIS_PUB_PROTOCOL.timeout = timeout_ms;
  FIO___REDIS_SUB_PROTOCOL.timeout = timeout_ms;

  /* Start connection - increment ref for deferred task */
  fio___redis_dup(r);
  fio_io_defer(fio___redis_connect, r, &r->pub_conn);

  FIO_LOG_DEBUG("(redis) engine created for %s:%s (ref=1)",
                r->address,
                r->port);
  return &r->engine;
}

/**
 * Increments the reference count and returns the engine.
 */
SFUNC fio_pubsub_engine_s *fio_redis_dup(fio_pubsub_engine_s *engine) {
  if (!engine)
    return NULL;
  fio_redis_engine_s *r = (fio_redis_engine_s *)engine;
  fio___redis_dup(r);
  return engine;
}

/**
 * Decrements the reference count. When count reaches 0, destroys the engine.
 * Thread-safe - defers connection closure to the IO thread.
 */
SFUNC void fio_redis_free(fio_pubsub_engine_s *engine) {
  if (!engine)
    return;
  fio_redis_engine_s *r = (fio_redis_engine_s *)engine;

  /* Mark as not running to prevent reconnection attempts.
   * This is safe to do from any thread as it's a simple flag. */
  r->running = 0;

  /* Defer connection closure to IO thread for thread-safety */
  fio___redis_dup(r); /* Hold reference for deferred task */
  fio_io_defer(fio___redis_free_task, r, NULL);

  /* Release caller's reference */
  fio___redis_free(r);
}

/**
 * Sends a Redis command.
 * Thread-safe - command queuing is deferred to the IO thread.
 */
SFUNC int fio_redis_send(fio_pubsub_engine_s *engine,
                         FIOBJ command,
                         void (*callback)(fio_pubsub_engine_s *e,
                                          FIOBJ reply,
                                          void *udata),
                         void *udata) {
  if (!engine || FIOBJ_TYPE(command) != FIOBJ_T_ARRAY)
    return -1;

  fio_redis_engine_s *r = (fio_redis_engine_s *)engine;

  /* Convert command to RESP format */
  FIOBJ resp = fiobj_str_new_buf(256);
  fio___redis_fiobj2resp(resp, command);
  fio_str_info_s s = fiobj2cstr(resp);

  /* Allocate command node */
  fio_redis_cmd_s *cmd =
      (fio_redis_cmd_s *)FIO_MEM_REALLOC(NULL, 0, sizeof(*cmd) + s.len + 1, 0);
  if (!cmd) {
    fiobj_free(resp);
    return -1;
  }
  FIO_LEAK_COUNTER_ON_ALLOC(fio___redis_cmd);

  *cmd = (fio_redis_cmd_s){
      .callback = callback,
      .udata = udata,
      .cmd_len = s.len,
  };
  FIO_MEMCPY(cmd->cmd, s.buf, s.len + 1);
  fiobj_free(resp);

  /* Queue command - thread-safe via fio_io_defer */
  fio___redis_attach_cmd(r, cmd);
  return 0;
}

/* *****************************************************************************
Redis Module Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_REDIS
#endif /* FIO_REDIS && !H___FIO_REDIS___H */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_HTTP_HANDLE        /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                      An HTTP connection Handle helper

See also:
https://www.rfc-editor.org/rfc/rfc9110.html



Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_HTTP_HANDLE) && !defined(H___FIO_HTTP_HANDLE___H) &&           \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_HTTP_HANDLE___H

/* *****************************************************************************
HTTP Handle Settings
***************************************************************************** */
#ifndef FIO_HTTP_EXACT_LOGGING
/**
 * By default, facil.io logs the HTTP request cycle using a fuzzy starting and
 * ending point for the time stamp.
 *
 * The fuzzy timestamp includes delays that aren't related to the HTTP request
 * and may ignore time passed due to timestamp caching.
 *
 * On the other hand, `FIO_HTTP_EXACT_LOGGING` collects exact time stamps to
 * measure the time it took to process the HTTP request (excluding time spent
 * reading / writing the data from the network).
 *
 * Due to the preference to err on the side of higher performance, fuzzy
 * time-stamping is the default.
 */
#define FIO_HTTP_EXACT_LOGGING 0
#ifndef H___FIO_IO___H
#undef FIO_HTTP_EXACT_LOGGING
#define FIO_HTTP_EXACT_LOGGING 1
#endif
#endif

#ifndef FIO_HTTP_BODY_RAM_LIMIT
/**
 * The HTTP handle automatically switches between RAM storage and file storage
 * once the HTTP body (payload) reaches a certain size. This control this point
 * of transition
 */
#define FIO_HTTP_BODY_RAM_LIMIT (1 << 17)
#endif

#ifndef FIO_HTTP_CACHE_LIMIT
/** Each of the HTTP String Caches will be limited to this String count. */
#define FIO_HTTP_CACHE_LIMIT 0 /* ((1UL << 6) + (1UL << 5)) */
#endif

#ifndef FIO_HTTP_CACHE_STR_MAX_LEN
/** The HTTP handle will avoid caching strings longer than this value. */
#define FIO_HTTP_CACHE_STR_MAX_LEN (1 << 12)
#endif

#ifndef FIO_HTTP_CACHE_USES_MUTEX
/** The HTTP cache will use a mutex to allow headers to be set concurrently. */
#define FIO_HTTP_CACHE_USES_MUTEX 1
#endif

#ifndef FIO_HTTP_PRE_CACHE_KNOWN_HEADERS
/** Adds a static cache for common HTTP header names. */
#define FIO_HTTP_PRE_CACHE_KNOWN_HEADERS 1
#endif

#ifndef FIO_HTTP_DEFAULT_INDEX_FILENAME
/** The default file name when a static file response points to a folder. */
#define FIO_HTTP_DEFAULT_INDEX_FILENAME "index"
#endif

#ifndef FIO_HTTP_STATIC_FILE_COMPLETION
/** Attempts to auto-complete static file paths with missing extensions. */
#define FIO_HTTP_STATIC_FILE_COMPLETION 1
#endif

#ifndef FIO_HTTP_LOG_X_REQUEST_START
#define FIO_HTTP_LOG_X_REQUEST_START 1
#endif

#ifndef FIO_HTTP_ENFORCE_LOWERCASE_HEADERS
/** If true, the HTTP handle will copy input header names to lower case. */
#define FIO_HTTP_ENFORCE_LOWERCASE_HEADERS 0
#endif

/* *****************************************************************************
HTTP Handle Type
***************************************************************************** */

/**
 * The HTTP Handle type.
 *
 * Note that the type is NOT designed to be thread-safe.
 */
typedef struct fio_http_s fio_http_s;

/**
 * The HTTP Controller points to all the callbacks required by the HTTP Handler.
 *
 * This allows the HTTP Handler to be somewhat protocol agnostic.
 *
 * Note: if the controller callbacks aren't thread-safe, than the `http_write`
 * function MUST NOT be called from any thread except the thread that the
 * controller is expecting.
 */
typedef struct fio_http_controller_s fio_http_controller_s;

/* *****************************************************************************
Constructor / Destructor
***************************************************************************** */

/** Create a new fio_http_s handle. */
SFUNC fio_http_s *fio_http_new(void);

/** Creates a copy of an existing handle, copying only its request data. */
SFUNC fio_http_s *fio_http_new_copy_request(fio_http_s *old);

/** Reduces an fio_http_s handle's reference count or frees it. */
SFUNC void fio_http_free(fio_http_s *);

/** Increases an fio_http_s handle's reference count. */
SFUNC fio_http_s *fio_http_dup(fio_http_s *);

/** Destroyed the HTTP handle object, freeing all allocated resources. */
SFUNC fio_http_s *fio_http_destroy(fio_http_s *h);

/** Collects an updated timestamp for logging purposes. */
SFUNC void fio_http_start_time_set(fio_http_s *);

/** Clears any response data. */
SFUNC fio_http_s *fio_http_clear_response(fio_http_s *h, bool clear_body);

/* *****************************************************************************
Opaque User and Controller Data
***************************************************************************** */

/** Gets the opaque user pointer associated with the HTTP handle. */
FIO_IFUNC void *fio_http_udata(fio_http_s *);

/** Sets the opaque user pointer associated with the HTTP handle. */
FIO_IFUNC void *fio_http_udata_set(fio_http_s *, void *);

/** Gets the second opaque user pointer associated with the HTTP handle. */
FIO_IFUNC void *fio_http_udata2(fio_http_s *);

/** Sets a second opaque user pointer associated with the HTTP handle. */
FIO_IFUNC void *fio_http_udata2_set(fio_http_s *, void *);

/** Gets the HTTP Controller associated with the HTTP handle. */
FIO_IFUNC fio_http_controller_s *fio_http_controller(fio_http_s *h);

/** Gets the HTTP Controller associated with the HTTP handle. */
FIO_IFUNC fio_http_controller_s *fio_http_controller_set(
    fio_http_s *h,
    fio_http_controller_s *controller);

/** Returns the existing controller data (`void *` pointer). */
FIO_IFUNC void *fio_http_cdata(fio_http_s *h);

/** Sets a new controller data (`void *` pointer). */
FIO_IFUNC void *fio_http_cdata_set(fio_http_s *h, void *cdata);

/* *****************************************************************************
Data associated with the Request (usually set by the HTTP protocol)
***************************************************************************** */

/** Gets the status associated with the HTTP handle (response). */
SFUNC size_t fio_http_status(fio_http_s *);

/** Sets the status associated with the HTTP handle (response). */
SFUNC size_t fio_http_status_set(fio_http_s *, size_t status);

/** Gets the method information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_method(fio_http_s *);

/** Sets the method information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_method_set(fio_http_s *, fio_str_info_s);

/** Gets the original / first path associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_opath(fio_http_s *);

/** Sets the original / first path associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_opath_set(fio_http_s *, fio_str_info_s);

/** Gets the path information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_path(fio_http_s *);

/** Sets the path information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_path_set(fio_http_s *, fio_str_info_s);

/** Gets the query information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_query(fio_http_s *);

/** Sets the query information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_query_set(fio_http_s *, fio_str_info_s);

/** Gets the version information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_version(fio_http_s *);

/** Sets the version information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_version_set(fio_http_s *, fio_str_info_s);

/** Gets the received_at timestamp (ms) associated with the HTTP handle. */
SFUNC int64_t fio_http_received_at(fio_http_s *);

/** Sets the received_at timestamp (ms) associated with the HTTP handle. */
SFUNC int64_t fio_http_received_at_set(fio_http_s *, int64_t);

/**
 * Gets the header information associated with the HTTP handle.
 *
 * Since more than a single value may be associated with a header name, the
 * index may be used to collect subsequent values.
 *
 * An empty value is returned if no header value is available (or index is
 * exceeded).
 */
SFUNC fio_str_info_s fio_http_request_header(fio_http_s *,
                                             fio_str_info_s name,
                                             size_t index);

/**
 * Returns the number of headers named `name` that were received.
 *
 * If `name` buffer is `NULL`, returns the number of unique headers (not the
 * number of unique values).
 */
SFUNC size_t fio_http_request_header_count(fio_http_s *, fio_str_info_s name);

/** Sets the header information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_request_header_set(fio_http_s *,
                                                 fio_str_info_s name,
                                                 fio_str_info_s value);

/** Sets the header information associated with the HTTP handle. */
SFUNC fio_str_info_s
fio_http_request_header_set_if_missing(fio_http_s *,
                                       fio_str_info_s name,
                                       fio_str_info_s value);

/** Adds to the header information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_request_header_add(fio_http_s *,
                                                 fio_str_info_s name,
                                                 fio_str_info_s value);

/**
 * Iterates through all request headers (except cookies!).
 *
 * A non-zero return will stop iteration.
 *
 * Returns the number of iterations performed. If `callback` is `NULL`, returns
 * the number of headers available (multi-value headers are counted as 1).
 * */
SFUNC size_t fio_http_request_header_each(fio_http_s *,
                                          int (*callback)(fio_http_s *,
                                                          fio_str_info_s name,
                                                          fio_str_info_s value,
                                                          void *udata),
                                          void *udata);

/** Gets the body (payload) length associated with the HTTP handle. */
SFUNC size_t fio_http_body_length(fio_http_s *);

/**
 * Adjusts the body's reading position. Negative values start at the end.
 *
 * If `pos == SSIZE_MAX`, returns `fio_http_body_pos`.
 */
SFUNC size_t fio_http_body_seek(fio_http_s *, ssize_t pos);

/** Returns the body's reading position. */
SFUNC size_t fio_http_body_pos(fio_http_s *h);

/** Reads up to `length` of data from the body, returns nothing on EOF. */
SFUNC fio_str_info_s fio_http_body_read(fio_http_s *, size_t length);

/**
 * Reads from the body until finding `token`, reaching `limit` or EOF.
 *
 * Note: `limit` is ignored if zero or if the remaining data is lower than
 * limit.
 */
SFUNC fio_str_info_s fio_http_body_read_until(fio_http_s *,
                                              char token,
                                              size_t limit);

/** Allocates a body (payload) of (at least) the `expected_length`. */
SFUNC void fio_http_body_expect(fio_http_s *, size_t expected_length);

/** Writes `data` to the body (payload) associated with the HTTP handle. */
SFUNC void fio_http_body_write(fio_http_s *, const void *data, size_t len);

/**
 * If the body is stored in a temporary file, returns the file's handle.
 *
 * Otherwise returns -1.
 */
SFUNC int fio_http_body_fd(fio_http_s *);

/* *****************************************************************************
Path Section Looping
***************************************************************************** */

/**
 * Loops over each section of the path, decrypting percent encoding as
 * necessary.
 *
 * The macro accepts the following:
 *
 * - `path`: the path string - accessible using fio_http_path(h).
 * - `pos` : the name of the variable to use for accessing the section.
 *
 * The variable `pos` is a `fio_buf_info_s`.
 *
 * **Note**: the macro will break if a path's section length is greater than
 *           (about) 4063 bytes.
 */
#define FIO_HTTP_PATH_EACH(path, pos)

/* *****************************************************************************
Cookies
***************************************************************************** */

/**
 * Possible values for the `same_site` property in the cookie settings.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie
 */
typedef enum fio_http_cookie_same_site_e {
  /** allow the browser to dictate this property */
  FIO_HTTP_COOKIE_SAME_SITE_BROWSER_DEFAULT = 0,
  /** The browser sends the cookie with cross-site and same-site requests. */
  FIO_HTTP_COOKIE_SAME_SITE_NONE,
  /**
   * The cookie is withheld on cross-site sub-requests.
   *
   * The cookie is sent when a user navigates to the URL from an external
   * site.
   */
  FIO_HTTP_COOKIE_SAME_SITE_LAX,
  /** The browser sends the cookie only for same-site requests. */
  FIO_HTTP_COOKIE_SAME_SITE_STRICT,
} fio_http_cookie_same_site_e;

/**
 * This is a helper for setting cookie data.
 *
 * This struct is used together with the `fio_http_cookie_set` macro. i.e.:
 *
 *       fio_http_set_cookie(h,
 *                      .name = FIO_STR_INFO1("my_cookie"),
 *                      .value = FIO_STR_INFO1("data"));
 *
 */
typedef struct fio_http_cookie_args_s {
  /** The cookie's name. */
  fio_str_info_s name;
  /** The cookie's value (leave blank to delete cookie). */
  fio_str_info_s value;
  /** The cookie's domain (optional). */
  fio_str_info_s domain;
  /** The cookie's path (optional). */
  fio_str_info_s path;
  /** Max Age (how long should the cookie persist), in seconds (0 == session).*/
  int max_age;
  /** SameSite value. */
  fio_http_cookie_same_site_e same_site;
  /** Limit cookie to secure connections.*/
  unsigned secure : 1;
  /** Limit cookie to HTTP (intended to prevent JavaScript access/hijacking).*/
  unsigned http_only : 1;
  /**
   * Set the Partitioned (third party) cookie flag:
   * https://developer.mozilla.org/en-US/docs/Web/Privacy/Partitioned_cookies
   */
  unsigned partitioned : 1;
} fio_http_cookie_args_s;

/**
 * Sets a response cookie.
 *
 * Returns -1 on error and 0 on success.
 *
 * Note: Long cookie names and long cookie values will be considered a security
 * violation and an error will be returned. Many browsers and proxies impose
 * limits on headers and cookies, cookies often limited to 4Kb in total for both
 * name and value.
 */
SFUNC int fio_http_cookie_set(fio_http_s *h, fio_http_cookie_args_s);

/** Named arguments helper. See fio_http_cookie_args_s for details. */
#define fio_http_cookie_set(http___handle, ...)                                \
  fio_http_cookie_set((http___handle), (fio_http_cookie_args_s){__VA_ARGS__})

/** Returns a cookie value (either received of newly set), if any. */
SFUNC fio_str_info_s fio_http_cookie(fio_http_s *,
                                     const char *name,
                                     size_t name_len);

/** Iterates through all cookies. A non-zero return will stop iteration. */
SFUNC size_t fio_http_cookie_each(fio_http_s *,
                                  int (*callback)(fio_http_s *,
                                                  fio_str_info_s name,
                                                  fio_str_info_s value,
                                                  void *udata),
                                  void *udata);

/**
 * Iterates through all response set cookies.
 *
 * A non-zero return value from the callback will stop iteration.
 */
SFUNC size_t
fio_http_set_cookie_each(fio_http_s *h,
                         int (*callback)(fio_http_s *,
                                         fio_str_info_s set_cookie_header,
                                         fio_str_info_s value,
                                         void *udata),
                         void *udata);

/* *****************************************************************************
Responding to an HTTP event.
***************************************************************************** */

/** Returns true if no HTTP headers / data was sent (a clean slate). */
SFUNC int fio_http_is_clean(fio_http_s *);

/** Returns true if the HTTP handle's response was sent. */
SFUNC int fio_http_is_finished(fio_http_s *);

/** Returns true if the HTTP handle's response is streaming. */
SFUNC int fio_http_is_streaming(fio_http_s *);

/** Returns true if the HTTP connection was (or should have been) upgraded. */
SFUNC int fio_http_is_upgraded(fio_http_s *h);

/** Returns true if the HTTP handle refers to a WebSocket connection. */
SFUNC int fio_http_is_websocket(fio_http_s *);

/** Returns true if the HTTP handle refers to an EventSource connection. */
SFUNC int fio_http_is_sse(fio_http_s *);

/** Returns true if handle is in the process of freeing itself. */
SFUNC int fio_http_is_freeing(fio_http_s *);

/**
 * Gets the header information associated with the HTTP handle.
 *
 * Since more than a single value may be associated with a header name, the
 * index may be used to collect subsequent values.
 *
 * An empty value is returned if no header value is available (or index is
 * exceeded).
 *
 * If the response headers were already sent, the returned value is always
 * empty.
 */
SFUNC fio_str_info_s fio_http_response_header(fio_http_s *,
                                              fio_str_info_s name,
                                              size_t index);
/**
 * Returns the number of headers named `name` in the response.
 *
 * If `name` buffer is `NULL`, returns the number of unique headers (not the
 * number of unique values).
 */
SFUNC size_t fio_http_response_header_count(fio_http_s *, fio_str_info_s name);

/**
 * Sets the header information associated with the HTTP handle.
 *
 * If the response headers were already sent, the returned value is always
 * empty.
 */
SFUNC fio_str_info_s fio_http_response_header_set(fio_http_s *,
                                                  fio_str_info_s name,
                                                  fio_str_info_s value);
/**
 * Sets the header information associated with the HTTP handle.
 *
 * If the response headers were already sent, the returned value is always
 * empty.
 */
SFUNC fio_str_info_s
fio_http_response_header_set_if_missing(fio_http_s *,
                                        fio_str_info_s name,
                                        fio_str_info_s value);

/**
 * Adds to the header information associated with the HTTP handle.
 *
 * If the response headers were already sent, the returned value is always
 * empty.
 */
SFUNC fio_str_info_s fio_http_response_header_add(fio_http_s *,
                                                  fio_str_info_s name,
                                                  fio_str_info_s value);

/**
 * Iterates through all response headers (except cookies!).
 *
 * A non-zero return will stop iteration.
 * */
SFUNC size_t fio_http_response_header_each(fio_http_s *,
                                           int (*callback)(fio_http_s *,
                                                           fio_str_info_s name,
                                                           fio_str_info_s value,
                                                           void *udata),
                                           void *udata);

/** Arguments for the fio_http_write function. */
typedef struct fio_http_write_args_s {
  /** The data to be written. */
  const void *buf;
  /** The length of the data to be written. */
  size_t len;
  /** The offset at which writing should begin. */
  size_t offset;
  /** If streaming a file, set this value. The file is always closed. */
  int fd;
  /** If the data is a buffer, this callback may be set to free it once sent. */
  void (*dealloc)(void *);
  /** If the data is a buffer / a file - should it be copied? */
  int copy;
  /**
   * If `finish` is set, this data marks the end of the response.
   *
   * Otherwise the response will stream the data.
   */
  int finish;
} fio_http_write_args_s;

/**
 * Writes `data` to the response body associated with the HTTP handle after
 * sending all headers (no further headers may be sent).
 */
SFUNC void fio_http_write(fio_http_s *, fio_http_write_args_s args);

/** Named arguments helper. See fio_http_write and fio_http_write_args_s. */
#define fio_http_write(http_handle, ...)                                       \
  fio_http_write(http_handle, (fio_http_write_args_s){__VA_ARGS__})
#define fio_http_finish(http_handle) fio_http_write(http_handle, .finish = 1)

/** Closes a persistent HTTP connection (i.e., if upgraded). */
SFUNC void fio_http_close(fio_http_s *h);

/* *****************************************************************************
WebSocket / SSE Helpers
***************************************************************************** */

/** Returns non-zero if request headers ask for a WebSockets Upgrade.*/
SFUNC int fio_http_websocket_requested(fio_http_s *);

/** Returns non-zero if the response accepts a WebSocket upgrade request. */
SFUNC int fio_http_websocket_accepted(fio_http_s *h);

/** Sets response data to agree to a WebSockets Upgrade.*/
SFUNC void fio_http_upgrade_websocket(fio_http_s *);

/** Sets request data to request a WebSockets Upgrade.*/
SFUNC void fio_http_websocket_set_request(fio_http_s *);

/** Returns non-zero if request headers ask for an EventSource (SSE) Upgrade.*/
SFUNC int fio_http_sse_requested(fio_http_s *);

/** Returns non-zero if the response accepts an SSE request. */
SFUNC int fio_http_sse_accepted(fio_http_s *h);

/** Sets response data to agree to an EventSource (SSE) Upgrade.*/
SFUNC void fio_http_upgrade_sse(fio_http_s *);

/** Sets request data to request an EventSource (SSE) Upgrade.*/
SFUNC void fio_http_sse_set_request(fio_http_s *);

/* *****************************************************************************
MIME File Type Helpers - NOT thread safe!
***************************************************************************** */

/** Registers a Mime-Type to be associated with the file extension. */
SFUNC int fio_http_mimetype_register(char *file_ext,
                                     size_t file_ext_len,
                                     fio_str_info_s mime_type);

/** Finds the Mime-Type associated with the file extension (if registered). */
SFUNC fio_str_info_s fio_http_mimetype(char *file_ext, size_t file_ext_len);

/* *****************************************************************************
HTTP Body Parsing Helpers
***************************************************************************** */

/**
 * HTTP body parser callbacks.
 *
 * All callbacks receive `udata` as first parameter.
 * Primitive callbacks return the created object as `void *`.
 * Container callbacks return a context for that container.
 */
typedef struct {
  /* ===== Primitives ===== */

  /** NULL / nil was detected. Returns new object. */
  void *(*on_null)(void *udata);
  /** TRUE was detected. Returns new object. */
  void *(*on_true)(void *udata);
  /** FALSE was detected. Returns new object. */
  void *(*on_false)(void *udata);
  /** Number was detected. Returns new object. */
  void *(*on_number)(void *udata, int64_t num);
  /** Float was detected. Returns new object. */
  void *(*on_float)(void *udata, double num);
  /** String was detected. Returns new object. */
  void *(*on_string)(void *udata, const void *data, size_t len);

  /* ===== Containers ===== */

  /** Array was detected. Returns context for this array. */
  void *(*on_array)(void *udata, void *parent);
  /** Map / Object was detected. Returns context for this map. */
  void *(*on_map)(void *udata, void *parent);
  /** Push value to array. Returns non-zero on error. */
  int (*array_push)(void *udata, void *array, void *value);
  /** Set key-value pair in map. Returns non-zero on error. */
  int (*map_set)(void *udata, void *map, void *key, void *value);
  /** Called when array parsing is complete. */
  void (*array_done)(void *udata, void *array);
  /** Called when map parsing is complete. */
  void (*map_done)(void *udata, void *map);

  /* ===== File Uploads (multipart) ===== */

  /**
   * Called when a file upload starts.
   *
   * Return context for this file (e.g., fd, stream, buffer).
   * Return NULL to skip this file (on_file_data/on_file_done won't be called).
   */
  void *(*on_file)(void *udata,
                   fio_str_info_s name,
                   fio_str_info_s filename,
                   fio_str_info_s content_type);
  /** Called for each chunk of file data. Return non-zero to abort. */
  int (*on_file_data)(void *udata, void *file, fio_buf_info_s data);
  /** Called when file upload is complete. */
  void (*on_file_done)(void *udata, void *file);

  /* ===== Error Handling ===== */

  /** Called on parse error. `partial` is the incomplete result, if any. */
  void *(*on_error)(void *udata, void *partial);
  /** Called to free an unused object (e.g., key when map_set fails). */
  void (*free_unused)(void *udata, void *obj);

} fio_http_body_parse_callbacks_s;

/** HTTP body parse result. */
typedef struct {
  /** Top-level parsed object (caller responsible for freeing). */
  void *result;
  /** Number of bytes consumed from body. */
  size_t consumed;
  /** Error code: 0 = success. */
  int err;
} fio_http_body_parse_result_s;

/**
 * Parses the HTTP request body, auto-detecting content type.
 *
 * Supports JSON, URL-encoded, and multipart/form-data bodies.
 * Calls the appropriate callbacks for each element found.
 *
 * @param h         The HTTP handle.
 * @param callbacks Parser callbacks (designed to be static const).
 * @param udata     User context passed to all callbacks.
 * @return          Parse result with top-level object and status.
 */
SFUNC fio_http_body_parse_result_s
fio_http_body_parse(fio_http_s *h,
                    const fio_http_body_parse_callbacks_s *callbacks,
                    void *udata);

/* *****************************************************************************
Header Parsing Helpers
***************************************************************************** */

/**
 * Copies all header data, from possibly an array of identical response headers,
 * resulting in a parsed format outputted to `buf_parsed`.
 *
 * Returns 0 on success or -1 on error (i.e., `buf_parsed.capa` wasn't enough
 * for the parsed output).
 *
 * Note that the parsed output isn't readable as a string, but is designed to
 * work with the `FIO_HTTP_PARSED_HEADER_EACH` and
 * `FIO_HTTP_HEADER_VALUE_EACH_PROPERTY` property.
 *
 * See also `fio_http_response_header_parse`.
 */
SFUNC int fio_http_response_header_parse(fio_http_s *h,
                                         fio_str_info_s *buf_parsed,
                                         fio_str_info_s header_name);

/**
 * Copies all header data, from possibly an array of identical response headers,
 * resulting in a parsed format outputted to `buf_parsed`.
 *
 * Returns 0 on success or -1 on error (i.e., `buf_parsed.capa` wasn't enough
 * for the parsed output).
 *
 * Note that the parsed output isn't readable as a string, but is designed to
 * work with the `FIO_HTTP_PARSED_HEADER_EACH` and
 * `FIO_HTTP_HEADER_VALUE_EACH_PROPERTY` property.
 *
 * i.e.:
 *
 * ```c
 *  FIO_STR_INFO_TMP_VAR(buf, 1023); // tmp buffer for the parsed output
 *  fio_http_s *h = fio_http_new();  // using a mock HTTP handle
 *  fio_http_request_header_add(
 *      h,
 *      FIO_STR_INFO2("accept", 6),
 *      FIO_STR_INFO1("text/html, application/json;q=0.9; d=500, image/png"));
 *  fio_http_request_header_add(h,
 *                              FIO_STR_INFO2("accept", 6),
 *                              FIO_STR_INFO1("text/yaml"));
 *  FIO_ASSERT(  // in production do NOT assert, but route to error instead!
 *      !fio_http_request_header_parse(h, &buf, FIO_STR_INFO2("accept", 6)),
 *      "parse returned error!");
 *  FIO_HTTP_PARSED_HEADER_EACH(buf, value) {
 *    printf("* processing value (%zu bytes): %s\n", value.len, value.buf);
 *    FIO_HTTP_HEADER_VALUE_EACH_PROPERTY(value, prop) {
 *      printf("* for value %s: (%zu,%zu bytes) %s = %s\n",
 *             value.buf,
 *             prop.name.len,
 *             prop.value.len,
 *             prop.name.buf,
 *             prop.value.buf);
 *    }
 *  }
 * ```
 */
SFUNC int fio_http_request_header_parse(fio_http_s *h,
                                        fio_str_info_s *buf_parsed,
                                        fio_str_info_s header_name);

/**
 * Parses header for multiple values and properties and iterates over all
 * values.
 *
 * This MACRO will allocate 2048 bytes on the stack for parsing the header
 * values and properties, if more space is necessary dig deeper.
 *
 * Use FIO_HTTP_HEADER_VALUE_EACH_PROPERTY to iterate over a value's properties.
 */
#define FIO_HTTP_HEADER_EACH_VALUE(/* fio_http_s */ http_handle,               \
                                   /* int / bool */ is_request,                \
                                   /* fio_str_info_s */ header_name,           \
                                   /* chosen var named */ value)               \
  for (char fio___buf__##value##__[2048], /* allocate buffer on stack */       \
           *fio___buf__##value##_ptr = NULL;                                   \
       !fio___buf__##value##_ptr;                                              \
       fio___buf__##value##_ptr = fio___buf__##value##__)                      \
    for (fio_str_info_s fio___buf__##value##__str = /* declare buffer var */   \
         FIO_STR_INFO3(fio___buf__##value##__, 0, 2048);                       \
         fio___buf__##value##__str.buf == fio___buf__##value##__;              \
         fio___buf__##value##__str.buf = fio___buf__##value##__ + 1)           \
      if (!((is_request ? fio_http_request_header_parse                        \
                        : fio_http_response_header_parse)(                     \
              http_handle, /* parse headers */                                 \
              &fio___buf__##value##__str,                                      \
              header_name)))                                                   \
  FIO_HTTP_PARSED_HEADER_EACH(fio___buf__##value##__str, value) /* loop        \
                                                                 */

/** Iterated through the properties associated with a parsed header values. */
#define FIO_HTTP_HEADER_VALUE_EACH_PROPERTY(/* fio_str_info_s   */ value,      \
                                            /* chosen var named */ property)

/** Used internally to iterate over a parsed header buffer. */
#define FIO_HTTP_PARSED_HEADER_EACH(/* fio_str_info_s   */ buf_parsed,         \
                                    /* chosen var named */ value)

/* *****************************************************************************
General Helpers
***************************************************************************** */

/** Sends the requested error message and finishes the response. */
SFUNC int fio_http_send_error_response(fio_http_s *h, size_t status);

/** Returns true (1) if the ETag response matches an if-none-match request. */
SFUNC int fio_http_etag_is_match(fio_http_s *h);

/**
 * Attempts to send a static file from the `root` folder. On success the
 * response is complete and 0 is returned. Otherwise returns -1.
 */
SFUNC int fio_http_static_file_response(fio_http_s *h,
                                        fio_str_info_s root_folder,
                                        fio_str_info_s file_name,
                                        size_t max_age);

/** Returns a human readable string related to the HTTP status number. */
SFUNC fio_str_info_s fio_http_status2str(size_t status);

/** Logs an HTTP (response) to STDOUT. */
SFUNC void fio_http_write_log(fio_http_s *h);

/**
 * Writes peer address to `dest` starting with the `forwarded` header, with a
 * fallback to actual socket address and a final fallback to `"[unknown]"`.
 *
 * If `unknown` is returned, the function returns -1. if `dest` capacity is too
 * small, the number of bytes required will be returned.
 *
 * If all goes well, this function returns 0.
 */
SFUNC int fio_http_from(fio_str_info_s *dest, const fio_http_s *h);

/* date/time string caching for HTTP date header */
SFUNC fio_str_info_s fio_http_date(uint64_t now_in_seconds);

/* date/time string caching for HTTP logging */
SFUNC fio_str_info_s fio_http_log_time(uint64_t now_in_seconds);
/* *****************************************************************************
The HTTP Controller
***************************************************************************** */

/**
 * The HTTP Controller manages all the callbacks required by the HTTP Handler in
 * order for HTTP responses and requests to be sent.
 */
struct fio_http_controller_s {
  /* MUST be initialized to zero, used internally by the HTTP Handle. */
  uintptr_t private_flags;
  /** Called when an HTTP handle is freed. */
  void (*on_destroyed)(fio_http_s *h);
  /** Informs the controller that request / response headers must be sent. */
  void (*send_headers)(fio_http_s *h);
  /** called by the HTTP handle for each body chunk, or to finish a response. */
  void (*write_body)(fio_http_s *h, fio_http_write_args_s args);
  /** called once a request / response had finished */
  void (*on_finish)(fio_http_s *h);
  /** called to close an HTTP connection */
  void (*close_io)(fio_http_s *h);
  /** called when the file descriptor is directly required */
  int (*get_fd)(fio_http_s *h);
};

/* *****************************************************************************
HTTP Handle Implementation - inlined static functions
***************************************************************************** */

#define FIO___HTTP_GETSET_PTR(type, name, index_, pre_set_code)                \
  /** Used internally to set / get the propecrty at its known pointer index.   \
   */                                                                          \
  FIO_IFUNC type *fio_http_##name(fio_http_s *h) {                             \
    return ((type **)h)[index_];                                               \
  }                                                                            \
  /** Used internally to set / get the propercty at its known pointer index.   \
   */                                                                          \
  FIO_IFUNC type *fio_http_##name##_set(fio_http_s *h, type *ptr) {            \
    pre_set_code;                                                              \
    return (((type **)h)[index_] = ptr);                                       \
  }

SFUNC fio_http_controller_s *fio___http_controller_validate(
    fio_http_controller_s *c);

/* Create fio_http_udata_(get|set) functions */
FIO___HTTP_GETSET_PTR(void, udata, 0, (void)0)
/* Create fio_http_pdata_(get|set) functions */
FIO___HTTP_GETSET_PTR(void, udata2, 1, (void)0)
/* Create fio_http_cdata_(get|set) functions */
FIO___HTTP_GETSET_PTR(void, cdata, 2, (void)0)
/* Create fio_http_controller_(get|set) functions */
FIO___HTTP_GETSET_PTR(fio_http_controller_s,
                      controller,
                      3,
                      ptr = fio___http_controller_validate(ptr))

#undef FIO___HTTP_GETSET_PTR
/*
REMEMBER:
========

All memory allocations should use:
* FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)
* FIO_MEM_FREE_(ptr, size)

*/

/* *****************************************************************************
Header Parsing Helpers - inlined helpers
***************************************************************************** */

#define FIO___HTTP_PARSED_HEADER_VALUE              0
#define FIO___HTTP_PARSED_HEADER_PROPERTY_BLOCK_LEN 1
#define FIO___HTTP_PARSED_HEADER_PROPERTY_DATA      2

typedef struct {
  fio_str_info_s name;
  fio_str_info_s value;
} fio___http_header_property_s;

/**
 * Assumes a Buffer of bytes containing length info and string data as such:
 *   [ NUL byte - 1 byte at head of format ]
 *   repeat
 *   [ 2 byte info: (type | (len << 2)) ]
 *   [ Optional 2 byte info: (len << 2) (if type was 1)]
 *   [ String of `len` bytes][ NUL byte (not counted in `len`)]
 */

FIO_IFUNC fio_str_info_s fio___http_parsed_headers_next(fio_str_info_s value) {
  for (;;) {
    const size_t coded = (size_t)fio_buf2u16u(value.buf + value.len + 1U);
    if (!coded)
      return (value = (fio_str_info_s){0});
    const size_t block_len = coded >> 2;
    value.buf += value.len + 3;
    value.len = block_len;
    if (!(coded & 3))
      return value;
    value.buf -= 3; /* reposition to read NUL + value rather than text start */
  }
}

FIO_IFUNC fio___http_header_property_s
fio___http_parsed_property_next(fio___http_header_property_s property) {
  for (;;) {
    size_t coded =
        (size_t)fio_buf2u16u(property.value.buf + property.value.len + 1);
    if (!(coded & 3))
      return (property = (fio___http_header_property_s){{0}, {0}});
    if ((coded & 3) == FIO___HTTP_PARSED_HEADER_PROPERTY_BLOCK_LEN) {
      property.value.buf += 2;
      coded = (size_t)fio_buf2u16u(property.value.buf + property.value.len + 1);
    }
    if ((coded & 3) != 2)
      return (property = (fio___http_header_property_s){{0}, {0}});
    coded >>= 2;
    property.name.buf = property.value.buf + property.value.len + 3;
    property.name.len = coded;
    coded = (size_t)fio_buf2u16u(property.name.buf + property.name.len + 1);
    FIO_ASSERT_DEBUG((coded & 3) == 2,
                     "header property value parsing format error");
    property.value.buf = property.name.buf + property.name.len + 3;
    property.value.len = coded >> 2;
    return property;
  }
}

#undef FIO_HTTP_PARSED_HEADER_EACH
#define FIO_HTTP_PARSED_HEADER_EACH(buf_parsed, value)                         \
  for (fio_str_info_s value =                                                  \
           fio___http_parsed_headers_next(FIO_STR_INFO2(buf_parsed.buf, 0));   \
       value.len;                                                              \
       value = fio___http_parsed_headers_next(value))

#undef FIO_HTTP_HEADER_VALUE_EACH_PROPERTY
#define FIO_HTTP_HEADER_VALUE_EACH_PROPERTY(value_, property)                  \
  for (fio___http_header_property_s property =                                 \
           fio___http_parsed_property_next(                                    \
               (fio___http_header_property_s){.value = value_});               \
       property.name.len;                                                      \
       property = fio___http_parsed_property_next(property))

/* *****************************************************************************
Path Section Looping
***************************************************************************** */

#undef FIO_HTTP_PATH_EACH

/**
 * Loops over each section of the path, decrypting percent encoding as
 * necessary.
 *
 * The macro accepts the following:
 *
 * - `path`: the path string - accessible using fio_http_path(h).
 * - `pos` : the name of the variable to use for accessing the section.
 *
 * The variable `pos` is a `fio_buf_info_s`. This uses 4096 bytes on the stack.
 * The variable `pos_reminder` is a `fio_buf_info_s` pointing to the rest of the
 * path.
 *
 * **Note**: the macro will break if a path's section length is greater than
 *           (about) 4063 bytes.
 */
#define FIO_HTTP_PATH_EACH(path, pos)                                          \
  for (fio_buf_info_s pos##_reminder = FIO_STR2BUF_INFO(path),                 \
                      pos,                                                     \
                      buf[(4096 / sizeof(fio_buf_info_s)) - 2];                \
       fio___http_path_each_next(&pos, &pos##_reminder, buf);)

/* used internally for the macro FIO_HTTP_PATH_EACH */
FIO_IFUNC bool fio___http_path_each_next(fio_buf_info_s *restrict section,
                                         fio_buf_info_s *restrict path,
                                         void *restrict mem) {
  if (path->len < 2)
    return 0;
  const char *p = path->buf;
  const char *e = p + path->len;
  char *w = (char *)mem;
  const char *w_start = w;
  const char *w_end = w + (4096 - ((sizeof(fio_buf_info_s) * 2) + 1));
  p += (*p == '/');
  while (p < e && *p != '/' && w < w_end) {
    while (p < e && *p != '%' && *p != '/' && w < w_end)
      *(w++) = *(p++);
    if (p == e || *p == '/')
      break;
    uint8_t hi, lo;
    if (p + 4 > e || ((hi = fio_c2i((unsigned char)p[1])) > 15) ||
        ((lo = fio_c2i((unsigned char)p[2])) > 15)) {
      *(w++) = *(p++);
      continue;
    }
    p += 3;
    *(w++) = (char)((hi << 4) | lo);
  }
  *w = 0;
  *section = FIO_BUF_INFO2((char *)w_start, (size_t)(w - w_start));
  *path = FIO_BUF_INFO2((char *)p, (size_t)(e - p));
  return (p == e || *p == '/');
}

/* *****************************************************************************
HTTP Handle Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Helpers - reading time
***************************************************************************** */

#if FIO_HTTP_EXACT_LOGGING
#define FIO___HTTP_TIME_DIV  1000000
#define FIO___HTTP_TIME_UNIT "us"
FIO_IFUNC int64_t fio_http_get_timestump(void) {
  return fio_time2micro(fio_time_real());
}
#else
#define FIO___HTTP_TIME_DIV      1000
#define FIO___HTTP_TIME_UNIT     "ms"
#define fio_http_get_timestump() fio_io_last_tick()
#endif

/* date/time string caching for HTTP date header */
SFUNC fio_str_info_s fio_http_date(uint64_t now_in_seconds) {
  static char date_buf[128];
  static size_t date_len;
  static uint64_t date_buf_val;
  if (date_buf_val == now_in_seconds)
    return FIO_STR_INFO2(date_buf, date_len);
  date_len = fio_time2rfc7231(date_buf, now_in_seconds);
  date_buf[date_len] = 0;
  date_buf_val = now_in_seconds;
  return FIO_STR_INFO2(date_buf, date_len);
}

/* date/time string caching for HTTP logging */
SFUNC fio_str_info_s fio_http_log_time(uint64_t now_in_seconds) {
  static char date_buf[128];
  static size_t date_len;
  static uint64_t date_buf_val;
  if (date_buf_val == now_in_seconds)
    return FIO_STR_INFO2(date_buf, date_len);
  date_len = fio_time2log(date_buf, now_in_seconds);
  date_buf[date_len] = 0;
  date_buf_val = now_in_seconds;
  return FIO_STR_INFO2(date_buf, date_len);
}

/* *****************************************************************************
Helpers - fio_keystr_s memory allocation callbacks
***************************************************************************** */

FIO_LEAK_COUNTER_DEF(fio___http_keystr_allocator)

FIO_SFUNC void fio___http_keystr_free(void *ptr, size_t len) {
  if (!ptr)
    return;
  FIO_LEAK_COUNTER_ON_FREE(fio___http_keystr_allocator);
  FIO_MEM_FREE_(ptr, len);
  (void)len; /* if unused */
}
FIO_SFUNC void *fio___http_keystr_alloc(size_t capa) {
  FIO_LEAK_COUNTER_ON_ALLOC(fio___http_keystr_allocator);
  return FIO_MEM_REALLOC_(NULL, 0, capa, 0);
}

/* *****************************************************************************
Helper Types
***************************************************************************** */
#define FIO___RECURSIVE_INCLUDE 1
/* *****************************************************************************
String Cache
***************************************************************************** */

#define FIO_MAP_NAME fio___http_str_cache
#define FIO_MAP_LRU  FIO_HTTP_CACHE_LIMIT
#define FIO_MAP_KEY_BSTR
#include FIO_INCLUDE_FILE

static struct {
  fio___http_str_cache_s cache;
  FIO___LOCK_TYPE lock;
} FIO___HTTP_STRING_CACHE[2] = {{.lock = FIO___LOCK_INIT},
                                {.lock = FIO___LOCK_INIT}};
#define FIO___HTTP_STR_CACHE_COOKIE 0
#define FIO___HTTP_STR_CACHE_VALUE  1

#if FIO_HTTP_PRE_CACHE_KNOWN_HEADERS

#define FIO___HTTP_STATIC_CACHE_CAPA_BITS  7
#define FIO___HTTP_STATIC_CACHE_CAPA       (1U << FIO___HTTP_STATIC_CACHE_CAPA_BITS)
#define FIO___HTTP_STATIC_CACHE_MASK       (FIO___HTTP_STATIC_CACHE_CAPA - 1)
#define FIO___HTTP_STATIC_CACHE_STEP_LIMIT 4

typedef struct FIO___HTTP_STATIC_CACHE_T {
  fio___bstr_meta_s meta;
  char str[32];
} FIO___HTTP_STATIC_CACHE_T;
static FIO___HTTP_STATIC_CACHE_T FIO___HTTP_STATIC_CACHE[] = {
#define FIO___HTTP_STATIC_CACHE_SET(s)                                         \
  {                                                                            \
    .meta = {.len = (uint32_t)(sizeof(s) - 1), .ref = ((uint32_t)(~0) >> 8)},  \
    .str = s                                                                   \
  }
    FIO___HTTP_STATIC_CACHE_SET("a-im"),
    FIO___HTTP_STATIC_CACHE_SET("accept"),
    FIO___HTTP_STATIC_CACHE_SET("accept-charset"),
    FIO___HTTP_STATIC_CACHE_SET("accept-datetime"),
    FIO___HTTP_STATIC_CACHE_SET("accept-encoding"),
    FIO___HTTP_STATIC_CACHE_SET("accept-language"),
    FIO___HTTP_STATIC_CACHE_SET("accept-ranges"),
    FIO___HTTP_STATIC_CACHE_SET("access-control-allow-origin"),
    FIO___HTTP_STATIC_CACHE_SET("access-control-request-headers"),
    FIO___HTTP_STATIC_CACHE_SET("access-control-request-method"),
    FIO___HTTP_STATIC_CACHE_SET("age"),
    FIO___HTTP_STATIC_CACHE_SET("allow"),
    FIO___HTTP_STATIC_CACHE_SET("authorization"),
    FIO___HTTP_STATIC_CACHE_SET("cache-control"),
    FIO___HTTP_STATIC_CACHE_SET("connection"),
    FIO___HTTP_STATIC_CACHE_SET("content-disposition"),
    FIO___HTTP_STATIC_CACHE_SET("content-encoding"),
    FIO___HTTP_STATIC_CACHE_SET("content-language"),
    FIO___HTTP_STATIC_CACHE_SET("content-length"),
    FIO___HTTP_STATIC_CACHE_SET("content-location"),
    FIO___HTTP_STATIC_CACHE_SET("content-range"),
    FIO___HTTP_STATIC_CACHE_SET("content-type"),
    FIO___HTTP_STATIC_CACHE_SET("cookie"),
    FIO___HTTP_STATIC_CACHE_SET("date"),
    FIO___HTTP_STATIC_CACHE_SET("dnt"),
    FIO___HTTP_STATIC_CACHE_SET("etag"),
    FIO___HTTP_STATIC_CACHE_SET("expect"),
    FIO___HTTP_STATIC_CACHE_SET("expires"),
    FIO___HTTP_STATIC_CACHE_SET("forwarded"),
    FIO___HTTP_STATIC_CACHE_SET("from"),
    FIO___HTTP_STATIC_CACHE_SET("host"),
    FIO___HTTP_STATIC_CACHE_SET("if-match"),
    FIO___HTTP_STATIC_CACHE_SET("if-modified-since"),
    FIO___HTTP_STATIC_CACHE_SET("if-none-match"),
    FIO___HTTP_STATIC_CACHE_SET("if-range"),
    FIO___HTTP_STATIC_CACHE_SET("if-unmodified-since"),
    FIO___HTTP_STATIC_CACHE_SET("last-modified"),
    FIO___HTTP_STATIC_CACHE_SET("link"),
    FIO___HTTP_STATIC_CACHE_SET("location"),
    FIO___HTTP_STATIC_CACHE_SET("max-forwards"),
    FIO___HTTP_STATIC_CACHE_SET("origin"),
    FIO___HTTP_STATIC_CACHE_SET("pragma"),
    FIO___HTTP_STATIC_CACHE_SET("proxy-authenticate"),
    FIO___HTTP_STATIC_CACHE_SET("proxy-authorization"),
    FIO___HTTP_STATIC_CACHE_SET("range"),
    FIO___HTTP_STATIC_CACHE_SET("referer"),
    FIO___HTTP_STATIC_CACHE_SET("refresh"),
    FIO___HTTP_STATIC_CACHE_SET("retry-after"),
    FIO___HTTP_STATIC_CACHE_SET("sec-ch-ua"),
    FIO___HTTP_STATIC_CACHE_SET("sec-ch-ua-mobile"),
    FIO___HTTP_STATIC_CACHE_SET("sec-ch-ua-platform"),
    FIO___HTTP_STATIC_CACHE_SET("sec-fetch-dest"),
    FIO___HTTP_STATIC_CACHE_SET("sec-fetch-mode"),
    FIO___HTTP_STATIC_CACHE_SET("sec-fetch-site"),
    FIO___HTTP_STATIC_CACHE_SET("sec-fetch-user"),
    FIO___HTTP_STATIC_CACHE_SET("server"),
    FIO___HTTP_STATIC_CACHE_SET("set-cookie"),
    FIO___HTTP_STATIC_CACHE_SET("strict-transport-security"),
    FIO___HTTP_STATIC_CACHE_SET("te"),
    FIO___HTTP_STATIC_CACHE_SET("transfer-encoding"),
    FIO___HTTP_STATIC_CACHE_SET("upgrade"),
    FIO___HTTP_STATIC_CACHE_SET("upgrade-insecure-requests"),
    FIO___HTTP_STATIC_CACHE_SET("user-agent"),
    FIO___HTTP_STATIC_CACHE_SET("vary"),
    FIO___HTTP_STATIC_CACHE_SET("via"),
    FIO___HTTP_STATIC_CACHE_SET("warning"),
    FIO___HTTP_STATIC_CACHE_SET("www-authenticate"),
    FIO___HTTP_STATIC_CACHE_SET("x-csrf-token"),
    FIO___HTTP_STATIC_CACHE_SET("x-forwarded-for"),
    FIO___HTTP_STATIC_CACHE_SET("x-forwarded-host"),
    FIO___HTTP_STATIC_CACHE_SET("x-forwarded-proto"),
    FIO___HTTP_STATIC_CACHE_SET("x-requested-with"),
    {{0}}};

static uint32_t FIO___HTTP_STATIC_CACHE_IMAP[FIO___HTTP_STATIC_CACHE_CAPA];

static uint64_t fio___http_str_cached_hash(char *str, size_t len) {
  /* use low-case hash specific for the HTTP handle (change resilient) */
  const fio_u256 primes = fio_u256_init64(((uint64_t)0x84B56B93C869EA0F),
                                          ((uint64_t)0x613A19F5CB0D98D5),
                                          ((uint64_t)0x48644F7B3959621F),
                                          ((uint64_t)0x39664DEECA23D825));
  uint64_t hash = 0;
  if (len > 32)
    return hash;
  fio_u512 s = {0};
  fio_memcpy63x(s.u8, str, len);
  for (size_t i = 0; i < 4; ++i)
    s.u64[i] = fio_ltole64(s.u64[i]);
#if 0
  fio_u256_cor64(s.u256, s.u256, 0x2020202020202020ULL); /* lower case hash */
  fio_u256_cadd16(s.u256, s.u256, len);
  for (size_t i = 0; i < 4; ++i)
    s.u64[i] = fio_math_mulc64(s.u64[i], primes.u64[i], s.u64 + 4 + i);
  hash = fio_u256_reduce_add64(s.u256 + 1);
  hash ^= fio_u256_reduce_add64(s.u256);
  fio_u256_cxor64(s.u256, s.u256, hash);
  hash += fio_u256_reduce_add64(s.u256);
#else
  FIO_MATH_UXXX_COP(s.u256[0], s.u256[0], 0x2020202020202020ULL, 64, |);
  FIO_MATH_UXXX_COP(s.u256[0], s.u256[0], (uint16_t)len, 16, +);
  for (size_t i = 0; i < 4; ++i) {
    s.u64[i] = fio_math_mulc64(s.u64[i], primes.u64[i], s.u64 + 4 + i);
  }
  uint64_t tmp;
  FIO_MATH_UXXX_REDUCE(hash, s.u256[1], 64, +);
  FIO_MATH_UXXX_REDUCE(tmp, s.u256[0], 64, +);
  hash ^= tmp;
  FIO_MATH_UXXX_COP(s.u256[0], s.u256[0], hash, 64, ^);
  FIO_MATH_UXXX_REDUCE(tmp, s.u256[0], 64, +);
  hash += tmp;
#endif
  // hash += hash >> 4;
  hash += hash >> 5;
  return hash;
}

#ifndef FIO___HTTP_STATIC_CACHE_CMP_SECURE
#define FIO___HTTP_STATIC_CACHE_CMP_SECURE 0
#endif
static bool fio___http_str_cached_cmp(void *arry, void *obj, uint32_t indx) {
  FIO___HTTP_STATIC_CACHE_T *ary = (FIO___HTTP_STATIC_CACHE_T *)arry;
  if (indx >
      ((sizeof(FIO___HTTP_STATIC_CACHE) / sizeof(FIO___HTTP_STATIC_CACHE[0])) -
       1))
    return 0;
  fio_buf_info_s *s = (fio_buf_info_s *)obj;
  fio_buf_info_s t = FIO_BUF_INFO2(ary[indx].str, ary[indx].meta.len);
#if FIO___HTTP_STATIC_CACHE_CMP_SECURE
  return FIO_BUF_INFO_IS_EQ((*s), t);
#else
  return s[0].len == t.len && s[0].buf[0] == (t.buf[0] | 32);
#endif
}
#undef FIO___HTTP_STATIC_CACHE_CMP_SECURE

static char *fio___http_str_cached_static(char *str, size_t len) {
  if (len >= 32)
    return NULL;
  fio_buf_info_s obj = FIO_BUF_INFO2(str, len);
  uint64_t hash = fio___http_str_cached_hash(obj.buf, obj.len);
  fio___imap32_seeker_s pos =
      fio___imap32_seek((void *)FIO___HTTP_STATIC_CACHE,
                        FIO___HTTP_STATIC_CACHE_IMAP,
                        FIO___HTTP_STATIC_CACHE_CAPA_BITS,
                        (void *)&obj,
                        (uint32_t)hash,
                        fio___http_str_cached_cmp,
                        FIO___HTTP_STATIC_CACHE_STEP_LIMIT);
  if (!pos.is_valid)
    return NULL;
  ++FIO___HTTP_STATIC_CACHE[pos.pos].meta.ref;
  return FIO___HTTP_STATIC_CACHE[pos.pos].str;
}

static void fio___http_str_cached_init(void) {
  FIO_MEMSET(FIO___HTTP_STATIC_CACHE_IMAP,
             0,
             sizeof(FIO___HTTP_STATIC_CACHE_IMAP));

  for (size_t i = 0; FIO___HTTP_STATIC_CACHE[i].meta.ref; ++i) {
    fio_buf_info_s obj = FIO_BUF_INFO2(FIO___HTTP_STATIC_CACHE[i].str,
                                       FIO___HTTP_STATIC_CACHE[i].meta.len);
    uint64_t hash = fio___http_str_cached_hash(obj.buf, obj.len);
    fio___imap32_seeker_s pos =
        fio___imap32_seek((void *)FIO___HTTP_STATIC_CACHE,
                          FIO___HTTP_STATIC_CACHE_IMAP,
                          FIO___HTTP_STATIC_CACHE_CAPA_BITS,
                          (void *)&obj,
                          (uint32_t)hash,
                          fio___http_str_cached_cmp,
                          FIO___HTTP_STATIC_CACHE_STEP_LIMIT);
    FIO_ASSERT(!pos.is_valid && pos.ipos < FIO___HTTP_STATIC_CACHE_CAPA &&
                   !FIO___HTTP_STATIC_CACHE_IMAP[pos.ipos],
               "HTTP static cache collision / overflow @ %zu (%s)",
               i,
               obj.buf);

    pos.set_val |= i;
    fio___imap32_set(FIO___HTTP_STATIC_CACHE_IMAP, pos.ipos, pos.set_val);

    FIO_ASSERT(fio___http_str_cached_static(obj.buf, obj.len) == obj.buf,
               "HTTP static cache initialization round-trip error @ %zu (%s)",
               i,
               obj.buf);
  }
}

#undef FIO___HTTP_STATIC_CACHE_CAPA_BITS
#undef FIO___HTTP_STATIC_CACHE_CAPA
#undef FIO___HTTP_STATIC_CACHE_MASK
#undef FIO___HTTP_STATIC_CACHE_STEP_LIMIT
#else
#define fio___http_str_cached_init() (void)0
#endif /* FIO_HTTP_PRE_CACHE_KNOWN_HEADERS */

FIO_IFUNC char *fio___http_str_cached_inner(size_t group,
                                            uint64_t hash,
                                            fio_str_info_s s) {
#if !FIO_HTTP_CACHE_LIMIT
  return fio_bstr_write(NULL, s.buf, s.len);
#endif
  fio_str_info_s cached;
  hash ^= (uint64_t)(uintptr_t)fio_http_new;
#if FIO_HTTP_CACHE_USES_MUTEX
  FIO___LOCK_LOCK(FIO___HTTP_STRING_CACHE[group].lock);
#endif
  cached =
      fio___http_str_cache_set_if_missing(&FIO___HTTP_STRING_CACHE[group].cache,
                                          hash,
                                          s);
#if FIO_HTTP_CACHE_USES_MUTEX
  FIO___LOCK_UNLOCK(FIO___HTTP_STRING_CACHE[group].lock);
#endif
  return fio_bstr_copy(cached.buf);
}
FIO_IFUNC char *fio___http_str_cached(size_t group, fio_str_info_s s) {
#if !FIO_HTTP_CACHE_LIMIT
  return fio_bstr_write(NULL, s.buf, s.len);
#endif
  if (!s.len)
    return NULL;
  if (s.len > FIO_HTTP_CACHE_STR_MAX_LEN)
    goto avoid_caching;
  return fio___http_str_cached_inner(group, fio_risky_hash(s.buf, s.len, 0), s);
avoid_caching:
  return fio_bstr_write(NULL, s.buf, s.len);
}

FIO_IFUNC char *fio___http_str_cached_with_static(fio_str_info_s s) {
#if FIO_HTTP_PRE_CACHE_KNOWN_HEADERS
  char *tmp;
  if (!s.len)
    return NULL;
  if (s.len > FIO_HTTP_CACHE_STR_MAX_LEN)
    goto skip_cache_test;
  tmp = fio___http_str_cached_static(s.buf, s.len);
  if (tmp) {
    FIO_LOG_DDEBUG2("(%d) using statically cached header: %s",
                    fio_io_pid(),
                    tmp);
    return tmp; /* reference count increased by fio___http_str_cached_static */
  }
skip_cache_test:
#endif /* FIO_HTTP_PRE_CACHE_KNOWN_HEADERS */
  return fio_bstr_write(NULL, s.buf, s.len);
}

/* *****************************************************************************
Headers Maps
***************************************************************************** */

#define FIO_ARRAY_NAME              fio___http_sary
#define FIO_ARRAY_TYPE              char *
#define FIO_ARRAY_TYPE_DESTROY(obj) fio_bstr_free(obj)

#define FIO_MAP_NAME                 fio___http_hmap
#define FIO_MAP_KEY                  fio_str_info_s
#define FIO_MAP_KEY_INTERNAL         char *
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_bstr_info((k))
#define FIO_MAP_KEY_CMP(a, b)        fio_bstr_is_eq2info((a), (b))
#define FIO_MAP_KEY_DESTROY(key)     fio_bstr_free((key))
#define FIO_MAP_KEY_COPY(dest, src)                                            \
  (dest) = fio___http_str_cached_with_static((src))
#define FIO_MAP_KEY_DISCARD(key)
#define FIO_MAP_VALUE fio___http_sary_s
#define FIO_MAP_VALUE_COPY(a, b)                                               \
  do {                                                                         \
    (a) = (fio___http_sary_s)FIO_ARRAY_INIT;                                   \
    (void)(b);                                                                 \
  } while (0) /*no-op*/
#define FIO_MAP_VALUE_DESTROY(o) fio___http_sary_destroy(&(o))
#define FIO_MAP_HASH_FN(k)                                                     \
  fio_risky_hash((k).buf, (k).len, (uint64_t)(uintptr_t)fio___http_sary_destroy)
#include FIO_INCLUDE_FILE

#if FIO_HTTP_ENFORCE_LOWERCASE_HEADERS
#define FIO___HTTP_ENFORCE_LOWERCASE(var_name, inpute_var)                     \
  FIO_STR_INFO_TMP_VAR(var_name, 4096);                                        \
  fio___http_hmap_key_to_lower(&var_name, &inpute_var);

/** Converts a Header key to lower-case */
FIO_IFUNC void fio___http_hmap_key_to_lower(fio_str_info_s *t,
                                            fio_str_info_s *k) {
  if (k->len >= t->capa)
    goto too_big;
  for (size_t i = 0; i < k->len; ++i) {
    uint8_t c = (uint8_t)k->buf[i];
    c |= (uint8_t)(c >= 'A' || c <= 'Z') << 5;
    t->buf[i] = c;
  }
  t->len = k->len;
  return;
too_big:
  *t = *k;
}

#else
#define FIO___HTTP_ENFORCE_LOWERCASE(var_name, inpute_var)                     \
  fio_str_info_s var_name = inpute_var;
#endif

/** set `add` to positive to add multiple values or negative to overwrite. */
FIO_IFUNC fio_str_info_s fio___http_hmap_set2(fio___http_hmap_s *map,
                                              fio_str_info_s key_input,
                                              fio_str_info_s val,
                                              int add) {
  fio_str_info_s r = {0};
  if (!key_input.buf || !key_input.len || !map)
    return r;
  /* make sure key is all lower-case? */
  FIO___HTTP_ENFORCE_LOWERCASE(key, key_input);
  fio___http_sary_s *o;
  if (!val.buf || !val.len)
    goto remove_key;
  o = fio___http_hmap_node2val_ptr(fio___http_hmap_get_ptr(map, key));
  if (!o) {
    fio___http_sary_s va = {0};
    o = fio___http_hmap_node2val_ptr(
        fio___http_hmap_set_ptr(map, key, va, NULL, 1));
    add = 1;
  }
  if (FIO_UNLIKELY(!o)) {
    FIO_LOG_ERROR("Couldn't add value to header: %.*s:%.*s",
                  (int)key.len,
                  key.buf,
                  (int)val.len,
                  val.buf);
    return r;
  }
  if (add) {
    if (add < 0) {
      fio___http_sary_destroy(o);
    }
    r = fio_bstr_info(fio___http_str_cached(FIO___HTTP_STR_CACHE_VALUE, val));
    fio___http_sary_push(o, r.buf);
    return r;
  }
  r = fio_bstr_info(fio___http_sary_get(o, -1));
  return r;

remove_key:
  if (add < 1)
    fio___http_hmap_remove(map, key, NULL);
  return r;
}

FIO_IFUNC fio_str_info_s fio___http_hmap_get2(fio___http_hmap_s *map,
                                              fio_str_info_s key_input,
                                              int32_t index) {
  fio_str_info_s r = {0};
  FIO___HTTP_ENFORCE_LOWERCASE(key, key_input);
  fio___http_sary_s *a =
      fio___http_hmap_node2val_ptr(fio___http_hmap_get_ptr(map, key));
  if (!a)
    return r;
  const uint32_t count = fio___http_sary_count(a);
  if (!count)
    return r;
  if (index < 0) {
    index += count;
    if (index < 0)
      index = 0;
  }
  if ((uint32_t)index >= count)
    return r;
  r = fio_bstr_info(fio___http_sary_get(a, index));
  return r;
}

FIO_IFUNC size_t fio___http_hmap_count2(fio___http_hmap_s *map,
                                        fio_str_info_s key) {
  size_t r = 0;
  fio___http_sary_s *a =
      fio___http_hmap_node2val_ptr(fio___http_hmap_get_ptr(map, key));
  if (!a)
    return r;
  r = fio___http_sary_count(a);
  return r;
}

/* *****************************************************************************
Header iteration Task
***************************************************************************** */

typedef struct {
  fio_http_s *h;
  int (*callback)(fio_http_s *, fio_str_info_s, fio_str_info_s, void *);
  void *udata;
} fio___http_hmap_each_info_s;

FIO_SFUNC int fio___http_h_each_task_wrapper(fio___http_hmap_each_s *e) {
  fio___http_hmap_each_info_s *data = (fio___http_hmap_each_info_s *)(e->udata);
  FIO_ARRAY_EACH(fio___http_sary, &e->value, pos) {
    if (data->callback(data->h, e->key, fio_bstr_info(*pos), data->udata) == -1)
      return -1;
  }
  return 0;
}

/* *****************************************************************************
Cookie Maps
***************************************************************************** */

#define FIO_MAP_NAME                 fio___http_cmap /* cached names */
#define FIO_MAP_KEY                  fio_str_info_s
#define FIO_MAP_KEY_INTERNAL         char *
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_bstr_info((k))
#define FIO_MAP_KEY_CMP(a, b)        fio_bstr_is_eq2info((a), (b))
#define FIO_MAP_KEY_DESTROY(key)     fio_bstr_free((key))
#define FIO_MAP_KEY_COPY(dest, src)                                            \
  (dest) = fio___http_str_cached(FIO___HTTP_STR_CACHE_COOKIE, (src))
#define FIO_MAP_KEY_DISCARD(key)

#define FIO_MAP_VALUE_BSTR /* not cached */
#define FIO_MAP_HASH_FN(k)                                                     \
  fio_risky_hash((k).buf, (k).len, (uint64_t)(uintptr_t)fio___http_cmap_destroy)
#include FIO_INCLUDE_FILE

/* *****************************************************************************
Controller Validation
***************************************************************************** */

FIO_SFUNC int fio___mock_controller_get_fd_cb(fio_http_s *h) {
  return -1;
  (void)h;
}
FIO_SFUNC void fio___mock_controller_cb(fio_http_s *h) { (void)h; }
FIO_SFUNC void fio___mock_c_write_body(fio_http_s *h,
                                       fio_http_write_args_s args) {
  if (args.buf) {
    if (args.dealloc)
      args.dealloc((void *)args.buf);
  } else if ((unsigned)(args.fd + 1) > 1U && !args.copy &&
             args.fd != fio_http_body_fd(h)) {
    close(args.fd);
  }
  (void)h;
}

static fio_http_controller_s FIO___MOCK_CONTROLLER = {
    .on_destroyed = fio___mock_controller_cb,
    .send_headers = fio___mock_controller_cb,
    .write_body = fio___mock_c_write_body,
    .on_finish = fio___mock_controller_cb,
    .close_io = fio___mock_controller_cb,
    .get_fd = fio___mock_controller_get_fd_cb,
};

SFUNC fio_http_controller_s *fio___http_controller_validate(
    fio_http_controller_s *c) {
  if (!c)
    c = &FIO___MOCK_CONTROLLER;
  if (c->private_flags)
    return c;
  if (!c->on_destroyed)
    c->on_destroyed = fio___mock_controller_cb;
  if (!c->send_headers)
    c->send_headers = fio___mock_controller_cb;
  if (!c->write_body)
    c->write_body = fio___mock_c_write_body;
  if (!c->on_finish)
    c->on_finish = fio___mock_controller_cb;
  if (!c->close_io)
    c->close_io = fio___mock_controller_cb;
  if (!c->get_fd)
    c->get_fd = fio___mock_controller_get_fd_cb;
  return c;
}

/* *****************************************************************************
HTTP Handle Type
***************************************************************************** */

#define FIO_HTTP_STATE_STREAMING      1
#define FIO_HTTP_STATE_FINISHED       2
#define FIO_HTTP_STATE_UPGRADED       4
#define FIO_HTTP_STATE_WEBSOCKET      8
#define FIO_HTTP_STATE_SSE            16
#define FIO_HTTP_STATE_COOKIES_PARSED 32
#define FIO_HTTP_STATE_FREEING        64

FIO_SFUNC int fio____http_write_start(fio_http_s *, fio_http_write_args_s *);
FIO_SFUNC int fio____http_write_cont(fio_http_s *, fio_http_write_args_s *);

struct fio_http_s {
  void *udata;
  void *udata2;
  void *cdata;
  fio_http_controller_s *controller;
  int (*writer)(fio_http_s *, fio_http_write_args_s *);
  int64_t received_at;
  size_t sent;
  uint32_t state;
  uint32_t status;
  fio_keystr_s method;
  fio_keystr_s opath;
  fio_keystr_s path;
  fio_keystr_s query;
  fio_keystr_s version;
  fio___http_hmap_s headers[2]; /* request, response */
  fio___http_cmap_s cookies[2]; /* read, write */
  struct {
    char *buf;
    size_t len;
    size_t pos;
    int fd;
  } body;
};

#define HTTP_HDR_REQUEST(h)  (h->headers + 0)
#define HTTP_HDR_RESPONSE(h) (h->headers + 1)

#define FIO_REF_NAME fio_http
#define FIO_REF_INIT(h)                                                        \
  h = (fio_http_s) {                                                           \
    .controller = &FIO___MOCK_CONTROLLER, .writer = fio____http_write_start,   \
    .received_at = fio_http_get_timestump(), .body.fd = -1                     \
  }
#define FIO_REF_DESTROY(h) fio_http_destroy(&(h))
SFUNC fio_http_s *fio_http_destroy(fio_http_s *h) {
  if (!h)
    return h;
  h->state |= FIO_HTTP_STATE_FREEING;
  h->controller->on_destroyed(h);

  fio_keystr_destroy(&h->method, fio___http_keystr_free);
  fio_keystr_destroy(&h->opath, fio___http_keystr_free);
  fio_keystr_destroy(&h->path, fio___http_keystr_free);
  fio_keystr_destroy(&h->query, fio___http_keystr_free);
  fio_keystr_destroy(&h->version, fio___http_keystr_free);
  fio___http_hmap_destroy(h->headers);
  fio___http_hmap_destroy(h->headers + 1);
  fio___http_cmap_destroy(h->cookies);
  fio___http_cmap_destroy(h->cookies + 1);
  fio_bstr_free(h->body.buf);
  if (h->body.fd != -1)
    close(h->body.fd);
  FIO_REF_INIT(*h);
  return h;
}
#include FIO_INCLUDE_FILE

/** Clears any response data. */
SFUNC fio_http_s *fio_http_clear_response(fio_http_s *h, bool clear_body) {
  fio___http_hmap_destroy(HTTP_HDR_RESPONSE(h));
  h->state = 0;
  h->writer = fio____http_write_start;
  h->received_at = fio_http_get_timestump();
  h->status = 0;
  if (!clear_body)
    return h;
  fio_bstr_free(h->body.buf);
  if (h->body.fd != -1)
    close(h->body.fd);
  h->body.buf = NULL;
  h->body.len = h->body.pos = 0;
  h->body.fd = -1;
  return h;
}

/** Create a new http_s handle. */
SFUNC fio_http_s *fio_http_new(void) { return fio_http_new2(); }

/** Reduces an http_s handle's reference count or frees it. */
SFUNC void fio_http_free(fio_http_s *h) { fio_http_free2(h); }

/** Increases an http_s handle's reference count. */
SFUNC fio_http_s *fio_http_dup(fio_http_s *h) { return fio_http_dup2(h); }

/** Collects an updated timestamp for logging purposes. */
SFUNC void fio_http_start_time_set(fio_http_s *h) {
  h->received_at = fio_http_get_timestump();
}

/** Closes a persistent HTTP connection (i.e., if upgraded). */
SFUNC void fio_http_close(fio_http_s *h) { h->controller->close_io(h); }

/** Creates a copy of an existing handle, copying only its request data. */
SFUNC fio_http_s *fio_http_new_copy_request(fio_http_s *o) {
  fio_http_s *h = fio_http_new();
  FIO_ASSERT_ALLOC(h);
  fio_http_opath_set(h, fio_http_opath(o));
  fio_http_path_set(h, fio_http_path(o));
  fio_http_method_set(h, fio_http_method(o));
  fio_http_query_set(h, fio_http_query(o));
  fio_http_version_set(h, fio_http_version(o));
  /* copy headers */
  fio___http_hmap_reserve(h->headers, fio___http_hmap_count(o->headers));
  FIO_MAP_EACH(fio___http_hmap, o->headers, i) {
    fio___http_sary_s *a = fio___http_hmap_node2val_ptr(
        fio___http_hmap_set_ptr(h->headers,
                                i.key,
                                (fio___http_sary_s){0},
                                NULL,
                                0));
    FIO_ARRAY_EACH(fio___http_sary, &i.value, v) {
      fio___http_sary_push(a, fio_bstr_copy(*v));
    }
  }
  /* copy cookies */
  FIO_MAP_EACH(fio___http_cmap, o->cookies, i) {
    fio___http_cmap_set(h->cookies, i.key, i.value, NULL);
  }
  return h;
}

#undef FIO___RECURSIVE_INCLUDE
/* *****************************************************************************
Simple Property Set / Get
***************************************************************************** */

#define FIO___HTTP_MAKE_GET_SET(property)                                      \
  SFUNC fio_str_info_s fio_http_##property(fio_http_s *h) {                    \
    FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");                                 \
    return fio_keystr_info(&h->property);                                      \
  }                                                                            \
                                                                               \
  SFUNC fio_str_info_s fio_http_##property##_set(fio_http_s *h,                \
                                                 fio_str_info_s value) {       \
    FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");                                 \
    fio_keystr_s old = h->property; /* delay destroy in case of copy/edit. */  \
    h->property = fio_keystr_init(value, fio___http_keystr_alloc);             \
    fio_keystr_destroy(&old, fio___http_keystr_free);                          \
    return fio_keystr_info(&h->property);                                      \
  }

FIO___HTTP_MAKE_GET_SET(method)
FIO___HTTP_MAKE_GET_SET(path)
FIO___HTTP_MAKE_GET_SET(opath)
FIO___HTTP_MAKE_GET_SET(query)
FIO___HTTP_MAKE_GET_SET(version)

#undef FIO___HTTP_MAKE_GET_SET

FIO_DEF_GET_FUNC(SFUNC, fio_http, fio_http_s, size_t, status)
/* clang-format off */
FIO_DEF_GETSET_FUNC(SFUNC, fio_http, fio_http_s, int64_t, received_at, FIO_NOOP_FN)
/* clang-format on */

/** Sets the status associated with the HTTP handle (response). */
SFUNC size_t fio_http_status_set(fio_http_s *h, size_t status) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  if (status > 1023)
    status = 500;
  if (!status)
    status = 200;
  return (h->status = (uint32_t)status);
}
/* *****************************************************************************
Handler State
***************************************************************************** */

SFUNC int fio_http_is_clean(fio_http_s *h) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return !(h->state & (~FIO_HTTP_STATE_COOKIES_PARSED));
}

/** Returns true if the HTTP handle's response was sent. */
SFUNC int fio_http_is_finished(fio_http_s *h) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return (!!(h->state & FIO_HTTP_STATE_FINISHED));
}

/** Returns true if handle is in the process of freeing itself. */
SFUNC int fio_http_is_freeing(fio_http_s *h) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return (!!(h->state & FIO_HTTP_STATE_FREEING));
}

/** Returns true if the HTTP handle's response is streaming. */
SFUNC int fio_http_is_streaming(fio_http_s *h) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return (!!(h->state & FIO_HTTP_STATE_STREAMING));
}

/** Returns true if the HTTP connection was (or should have been) upgraded. */
SFUNC int fio_http_is_upgraded(fio_http_s *h) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return (!!(h->state & FIO_HTTP_STATE_UPGRADED));
}

/** Returns true if the HTTP handle establishes a WebSocket Upgrade. */
SFUNC int fio_http_is_websocket(fio_http_s *h) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return (!!(h->state & FIO_HTTP_STATE_WEBSOCKET));
}

/** Returns true if the HTTP handle establishes an EventSource connection. */
SFUNC int fio_http_is_sse(fio_http_s *h) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return (!!(h->state & FIO_HTTP_STATE_SSE));
}

/* *****************************************************************************
Header Data Management
***************************************************************************** */

#define FIO___HTTP_HEADER_SET_FN(category, name_, headers, add_val)            \
  /** Sets the header information associated with the HTTP handle. */          \
  fio_str_info_s fio_http_##category##_header_##name_(fio_http_s *h,           \
                                                      fio_str_info_s name,     \
                                                      fio_str_info_s value) {  \
    FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");                                  \
    return fio___http_hmap_set2(headers(h), name, value, add_val);             \
  }
FIO___HTTP_HEADER_SET_FN(request, set, HTTP_HDR_REQUEST, -1)
FIO___HTTP_HEADER_SET_FN(request, set_if_missing, HTTP_HDR_REQUEST, 0)
FIO___HTTP_HEADER_SET_FN(request, add, HTTP_HDR_REQUEST, 1)
FIO___HTTP_HEADER_SET_FN(response, set, HTTP_HDR_RESPONSE, -1)
FIO___HTTP_HEADER_SET_FN(response, set_if_missing, HTTP_HDR_RESPONSE, 0)
FIO___HTTP_HEADER_SET_FN(response, add, HTTP_HDR_RESPONSE, 1)
#undef FIO___HTTP_HEADER_SET_FN

fio_str_info_s fio_http_request_header(fio_http_s *h,
                                       fio_str_info_s name,
                                       size_t index) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  return fio___http_hmap_get2(HTTP_HDR_REQUEST(h), name, (int32_t)index);
}
fio_str_info_s fio_http_response_header(fio_http_s *h,
                                        fio_str_info_s name,
                                        size_t index) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  return fio___http_hmap_get2(HTTP_HDR_RESPONSE(h), name, (int32_t)index);
}

/** Returns the number of headers named `name` that were received. */
SFUNC size_t fio_http_request_header_count(fio_http_s *h, fio_str_info_s name) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  if (!name.buf)
    return fio___http_hmap_count(HTTP_HDR_REQUEST(h));
  return fio___http_hmap_count2(HTTP_HDR_REQUEST(h), name);
}
/** Returns the number of headers named `name` that were received. */
SFUNC size_t fio_http_response_header_count(fio_http_s *h,
                                            fio_str_info_s name) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  if (!name.buf)
    return fio___http_hmap_count(HTTP_HDR_RESPONSE(h));
  return fio___http_hmap_count2(HTTP_HDR_RESPONSE(h), name);
}

/** Iterates through all headers. A non-zero return will stop iteration. */
size_t fio_http_request_header_each(fio_http_s *h,
                                    int (*callback)(fio_http_s *,
                                                    fio_str_info_s name,
                                                    fio_str_info_s value,
                                                    void *udata),
                                    void *udata) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  if (!callback)
    return fio___http_hmap_count(HTTP_HDR_REQUEST(h));
  fio___http_hmap_each_info_s d = {.h = h,
                                   .callback = callback,
                                   .udata = udata};
  return fio___http_hmap_each(HTTP_HDR_REQUEST(h),
                              fio___http_h_each_task_wrapper,
                              &d,
                              0);
}

/** Iterates through all headers. A non-zero return will stop iteration. */
size_t fio_http_response_header_each(
    fio_http_s *h,
    int (*callback)(fio_http_s *, fio_str_info_s, fio_str_info_s, void *),
    void *udata) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  if (!callback)
    return fio___http_hmap_count(HTTP_HDR_RESPONSE(h));
  fio___http_hmap_each_info_s d = {.h = h,
                                   .callback = callback,
                                   .udata = udata};
  return fio___http_hmap_each(HTTP_HDR_RESPONSE(h),
                              fio___http_h_each_task_wrapper,
                              &d,
                              0);
}

/* *****************************************************************************
Cookies
***************************************************************************** */

FIO_IFUNC void fio___http_cookie_set_if_missing_encoded(fio_http_s *h,
                                                        fio_str_info_s k,
                                                        fio_str_info_s v) {
  char *div = NULL;
  FIO_STR_INFO_TMP_VAR(dec, 8192);
  /* test for percent encoding */
  if ((div = (char *)FIO_MEMCHR(k.buf, '%', k.len))) {
    if (div + 2 < (k.buf + k.len) && fio_c2i(div[1]) < 16 &&
        fio_c2i(div[2]) < 16 &&
        !fio_string_write_path_dec(&dec, FIO_STRING_ALLOC_COPY, k.buf, k.len))
      k = dec;
  }
  if ((div = (char *)FIO_MEMCHR(v.buf, '%', v.len))) {
    fio_str_info_s old = dec;
    if (div + 2 < (v.buf + v.len) && fio_c2i(div[1]) < 16 &&
        fio_c2i(div[2]) < 16 &&
        !fio_string_write_path_dec(&dec,
                                   FIO_STR_INFO_TMP_IS_REALLOCATED(dec)
                                       ? FIO_STRING_REALLOC
                                       : FIO_STRING_ALLOC_COPY,
                                   v.buf,
                                   v.len)) {
      v = dec;
      v.buf += old.len;
      v.len -= old.len;
    }
  }
  fio___http_cmap_set_if_missing(h->cookies, k, v);
  if (FIO_STR_INFO_TMP_IS_REALLOCATED(dec))
    FIO_STRING_FREE2(dec);
}

/** (Helper) HTTP Cookie Parser */
FIO_IFUNC void fio___http_cookie_parse_cookie(fio_http_s *h, fio_str_info_s s) {
  /* loop and read Cookie: name=value; name2=value2; name3=value3 */
  while (s.len) {
    fio_str_info_s k = {0}, v = {0};
    /* remove white-space */
    while ((s.buf[0] == ' ' || s.buf[0] == '\t') && s.len) {
      ++s.buf;
      --s.len;
    }
    if (!s.len)
      return;
    char *div = (char *)FIO_MEMCHR(s.buf, '=', s.len);
    char *end = (char *)FIO_MEMCHR(s.buf, ';', s.len);
    if (!end)
      end = s.buf + s.len;
    v.buf = s.buf;
    if (div) {
      /* cookie name may be an empty string */
      k.buf = s.buf;
      k.len = div - s.buf;
      v.buf = div + 1;
    }
    v.len = end - v.buf;
    s.len = (s.buf + s.len) - end;
    s.buf = end;
    /* skip the ';' if exists (if len is not zero, !!s.len == 1). */
    s.buf += !!s.len;
    s.len -= !!s.len;
    fio___http_cookie_set_if_missing_encoded(h, k, v);
  }
}

/** (Helper) HTTP Cookie Parser */
FIO_IFUNC void fio___http_cookie_parse_set_cookie(fio_http_s *h,
                                                  fio_str_info_s s) {
  /* TODO! */
  fio_str_info_s k = {0}, v = {0};
  /* remove white-space */
  while ((s.buf[0] == ' ' || s.buf[0] == '\t') && s.len) {
    ++s.buf;
    --s.len;
  }
  if (!s.len)
    return;
  char *div = (char *)FIO_MEMCHR(s.buf, '=', s.len);
  char *end = (char *)FIO_MEMCHR(s.buf, ';', s.len);
  if (div == s.buf || !div)
    return;
  if (!end)
    end = s.buf + s.len;
  const uint64_t prefix_secure = fio_buf2u64u("_Secure-");
  const uint32_t prefix_host = fio_buf2u32u("Host");
  uint32_t cont;
  k.buf = s.buf;
  k.len = div - s.buf;
  v.buf = div + 1;
  v.len = end - v.buf;
  do { /* loop to clear away cookie prefixes in any order */
    cont = 0;
    if (k.len > 8 && k.buf[0] == '_' &&
        fio_buf2u64u(k.buf + 1) == prefix_secure) {
      cont = 1;
      k.len -= 9;
      k.buf += 9;
    }
    if (k.len > 6 && k.buf[0] == '_' && k.buf[1] == '_' && k.buf[6] == '-' &&
        fio_buf2u32u(k.buf + 2) == prefix_host) {
      cont = 1;
      k.len -= 7;
      k.buf += 7;
    }
  } while (cont);
  if (k.len)
    fio___http_cookie_set_if_missing_encoded(h, k, v);
}

/** (Helper) Parses all HTTP Cookies */
FIO_SFUNC void fio___http_cookie_collect(fio_http_s *h) {
  fio___http_sary_s *header = NULL;
  header = fio___http_hmap_node2val_ptr(
      fio___http_hmap_get_ptr(h->headers, FIO_STR_INFO1((char *)"cookie")));
  if (header) {
    FIO_ARRAY_EACH(fio___http_sary, header, pos) {
      fio___http_cookie_parse_cookie(h, fio_bstr_info(*pos));
    }
  }
  /* if headers were sent, set-cookie data might belong to the handle */
  if (h->writer != fio____http_write_start)
    return;
  header = fio___http_hmap_node2val_ptr(
      fio___http_hmap_get_ptr(h->headers + 1,
                              FIO_STR_INFO1((char *)"set-cookie")));
  if (!header)
    return;
  FIO_ARRAY_EACH(fio___http_sary, header, pos) {
    fio___http_cookie_parse_set_cookie(h, fio_bstr_info(*pos));
  }
  return;
}

int fio_http_cookie_set___(void); /* IDE Marker */
/* Sets a response cookie. */
SFUNC int fio_http_cookie_set FIO_NOOP(fio_http_s *h,
                                       fio_http_cookie_args_s cookie) {
  FIO_ASSERT_DEBUG(h, "Can't set cookie for NULL HTTP handler!");
  if (!h || ((h->state & (FIO_HTTP_STATE_FINISHED | FIO_HTTP_STATE_STREAMING)) |
             (h->writer != fio____http_write_start)))
    return -1;
  /* promises that some warnings print only once. */
  static unsigned int warn_illegal = 0;
  size_t need2warn = 0;

  /* valid / invalid characters in cookies, create with Ruby using:
      a = []
      256.times {|i| a[i] = 1;}
      ('a'.ord..'z'.ord).each {|i| a[i] = 0;}
      ('A'.ord..'Z'.ord).each {|i| a[i] = 0;}
      ('0'.ord..'9'.ord).each {|i| a[i] = 0;}
      "!#$%&'*+-.^_`|~".bytes.each {|i| a[i] = 0;}
      puts "static const char invalid_cookie_name_char[256] = {"
      puts "#{ a.map {|i| i.to_s } .join(', ') }};"
      "!#$%&'()*+-./:<=>?@[]^_`{|}~".bytes.each {|i| a[i] = 0;} # for values
      ",\"\\".bytes.each {|i| a[i] = 0;} # commonly used, though not allowed
      puts "static const char invalid_cookie_value_char[256] = {"
      puts "#{ a.map {|i| i.to_s } .join(', ') }};"
  */
  static const char invalid_cookie_name_char[256] = {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
  static const char invalid_cookie_value_char[256] = {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
  /* write name and value while auto-correcting encoding issues */
  if ((cookie.name.len + cookie.value.len + cookie.domain.len +
       cookie.path.len + 128) > 5119) {
    FIO_LOG_ERROR("cookie data too long!");
  }
  char tmp_buf[5120];
  fio_str_info_s t = FIO_STR_INFO3(tmp_buf, 0, 5119);

#define fio___http_h_copy_cookie_ch(ch_var)                                    \
  if (t.capa <= t.len + 3) {                                                   \
    ((t.buf == tmp_buf)                                                        \
         ? FIO_STRING_ALLOC_COPY                                               \
         : FIO_STRING_REALLOC)(&t, fio_string_capa4len(t.len + 3));            \
  }                                                                            \
  if (!invalid_cookie_##ch_var##_char[(uint8_t)cookie.ch_var.buf[tmp]]) {      \
    t.buf[t.len++] = cookie.ch_var.buf[tmp];                                   \
  } else {                                                                     \
    need2warn = tmp + 1;                                                       \
    t.buf[t.len++] = '%';                                                      \
    t.buf[t.len++] = fio_i2c(((uint8_t)cookie.ch_var.buf[tmp] >> 4) & 0x0F);   \
    t.buf[t.len++] = fio_i2c((uint8_t)cookie.ch_var.buf[tmp] & 0x0F);          \
  }                                                                            \
  tmp += 1;

  if (cookie.name.buf) {
    size_t tmp = 0;
    if (cookie.name.len) {
      while (tmp < cookie.name.len) {
        fio___http_h_copy_cookie_ch(name);
      }
    } else {
      while (cookie.name.buf[tmp]) {
        fio___http_h_copy_cookie_ch(name);
      }
    }
    if (need2warn && !warn_illegal) {
      warn_illegal |= 1;
      FIO_LOG_WARNING("illegal char 0x%.2x in cookie name (in %s)\n"
                      "         automatic %% encoding applied",
                      cookie.name.buf[need2warn - 1],
                      cookie.name.buf);
    }
  }
  t.buf[t.len++] = '=';
  if (cookie.value.buf) {
    size_t tmp = 0;
    if (cookie.value.len) {
      while (tmp < cookie.value.len) {
        fio___http_h_copy_cookie_ch(value);
      }
    } else {
      while (cookie.value.buf[tmp]) {
        fio___http_h_copy_cookie_ch(value);
      }
    }
    if (need2warn && !warn_illegal) {
      warn_illegal |= 1;
      FIO_LOG_WARNING("illegal char 0x%.2x in cookie value (in %s)\n"
                      "         automatic %% encoding applied",
                      cookie.value.buf[need2warn - 1],
                      cookie.value.buf);
    }
  } else
    cookie.max_age = -1;
#undef fio___http_h_copy_cookie_ch

  /* server cookie data */
  t.buf[t.len++] = ';';
  t.buf[t.len++] = ' ';

  if (cookie.max_age) {
    fio_string_write2(
        &t,
        ((t.buf == tmp_buf) ? FIO_STRING_ALLOC_COPY : FIO_STRING_REALLOC),
        FIO_STRING_WRITE_STR2((char *)"Max-Age=", 8),
        FIO_STRING_WRITE_NUM(cookie.max_age),
        FIO_STRING_WRITE_STR2((char *)"; ", 2));
  }

  if (cookie.domain.buf && cookie.domain.len) {
    fio_string_write2(
        &t,
        ((t.buf == tmp_buf) ? FIO_STRING_ALLOC_COPY : FIO_STRING_REALLOC),
        FIO_STRING_WRITE_STR2((char *)"domain=", 7),
        FIO_STRING_WRITE_STR2((char *)cookie.domain.buf, cookie.domain.len),
        FIO_STRING_WRITE_STR2((char *)"; ", 2));
  }
  if (cookie.path.buf && cookie.path.len) {
    fio_string_write2(
        &t,
        ((t.buf == tmp_buf) ? FIO_STRING_ALLOC_COPY : FIO_STRING_REALLOC),
        FIO_STRING_WRITE_STR2((char *)"path=", 5),
        FIO_STRING_WRITE_STR2((char *)cookie.path.buf, cookie.path.len),
        FIO_STRING_WRITE_STR2((char *)"; ", 2));
  }
  if (cookie.http_only) {
    fio_string_write(
        &t,
        ((t.buf == tmp_buf) ? FIO_STRING_ALLOC_COPY : FIO_STRING_REALLOC),
        "HttpOnly; ",
        10);
  }
  if (cookie.secure) {
    fio_string_write(
        &t,
        ((t.buf == tmp_buf) ? FIO_STRING_ALLOC_COPY : FIO_STRING_REALLOC),
        "secure; ",
        8);
  }
  if (cookie.partitioned) {
    fio_string_write(
        &t,
        ((t.buf == tmp_buf) ? FIO_STRING_ALLOC_COPY : FIO_STRING_REALLOC),
        "partitioned; ",
        13);
  }
  switch (cookie.same_site) {
  case FIO_HTTP_COOKIE_SAME_SITE_BROWSER_DEFAULT: /* fall through */
  default: break;
  case FIO_HTTP_COOKIE_SAME_SITE_NONE:
    fio_string_write(
        &t,
        ((t.buf == tmp_buf) ? FIO_STRING_ALLOC_COPY : FIO_STRING_REALLOC),
        "SameSite=None;",
        14);
    break;
  case FIO_HTTP_COOKIE_SAME_SITE_LAX:
    fio_string_write(
        &t,
        ((t.buf == tmp_buf) ? FIO_STRING_ALLOC_COPY : FIO_STRING_REALLOC),
        "SameSite=Lax;",
        13);
    break;
  case FIO_HTTP_COOKIE_SAME_SITE_STRICT:
    fio_string_write(
        &t,
        ((t.buf == tmp_buf) ? FIO_STRING_ALLOC_COPY : FIO_STRING_REALLOC),
        "SameSite=Strict;",
        16);
    break;
  }
  if (t.buf[t.len - 1] == ' ')
    --t.len;

  /* set the "write" cookie store data */
  fio___http_cmap_set(h->cookies + 1, cookie.name, t, NULL);
  /* set the "read" cookie store data */
  fio___http_cmap_set(h->cookies, cookie.name, cookie.value, NULL);
  if (t.buf != tmp_buf)
    FIO_STRING_FREE2(t);
  return 0;
}

/** Returns a cookie value (either received of newly set), if any. */
SFUNC fio_str_info_s fio_http_cookie(fio_http_s *h,
                                     const char *name,
                                     size_t name_len) {
  if (!(fio_atomic_or(&h->state, FIO_HTTP_STATE_COOKIES_PARSED) &
        FIO_HTTP_STATE_COOKIES_PARSED))
    fio___http_cookie_collect(h);
  fio_str_info_s r =
      fio___http_cmap_get(h->cookies, FIO_STR_INFO2((char *)name, name_len));
  return r;
}

/** Iterates through all cookies. A non-zero return will stop iteration. */
SFUNC size_t fio_http_cookie_each(fio_http_s *h,
                                  int (*callback)(fio_http_s *,
                                                  fio_str_info_s name,
                                                  fio_str_info_s value,
                                                  void *udata),
                                  void *udata) {
  if (!(fio_atomic_or(&h->state, FIO_HTTP_STATE_COOKIES_PARSED) &
        FIO_HTTP_STATE_COOKIES_PARSED))
    fio___http_cookie_collect(h);
  size_t i = 0;
  FIO_MAP_EACH(fio___http_cmap, h->cookies, pos) {
    ++i;
    if (callback(h, pos.key, pos.value, udata))
      return i;
  }
  return i;
}

/**
 * Iterates through all response set cookies.
 *
 * A non-zero return value from the callback will stop iteration.
 */
SFUNC size_t
fio_http_set_cookie_each(fio_http_s *h,
                         int (*callback)(fio_http_s *h,
                                         fio_str_info_s set_cookie_header,
                                         fio_str_info_s value,
                                         void *udata),
                         void *udata) {
  size_t i = 0;
  fio___http_cmap_s *set_cookies = h->cookies + 1;
  fio_str_info_s header_name = FIO_STR_INFO2((char *)"set-cookie", 10);
  FIO_MAP_EACH(fio___http_cmap, set_cookies, pos) {
    ++i;
    if (callback(h, header_name, pos.value, udata))
      return i;
  }
  return i;
}

/* *****************************************************************************
Peer Address
***************************************************************************** */

/**
 * Writes peer address to `dest` starting with the `forwarded` header, with a
 * fallback to actual socket address and a final fallback to `"[unknown]"`.
 *
 * If `unknown` is returned, the function returns -1. if `dest` capacity is too
 * small, the number of bytes required will be returned.
 *
 * If all goes well, this function returns 0.
 */
SFUNC int fio_http_from(fio_str_info_s *dest, const fio_http_s *h) {
  int r = 0;
  /* Guess IP address from headers (forwarded) where possible */
  fio_str_info_s forwarded =
      fio_http_request_header((fio_http_s *)h,
                              FIO_STR_INFO2((char *)"forwarded", 9),
                              -1);
  fio_buf_info_s buf;
  char *end;
  if (forwarded.len) {
    forwarded.len &= 1023; /* limit possible attack surface */
    for (; forwarded.len > 5;) {
      if ((forwarded.buf[0] | 32) != 'f' || (forwarded.buf[1] | 32) != 'o' ||
          (forwarded.buf[2] | 32) != 'r' || forwarded.buf[3] != '=') {
        ++forwarded.buf;
        --forwarded.len;
        continue;
      }
      forwarded.buf += 4 + (forwarded.buf[4] == '"');
      break;
    }
  client_address_found:
    buf.buf = end = forwarded.buf;
    while (*end && *end != '"' && *end != ',' && *end != ' ' && *end != ';' &&
           (end - forwarded.buf) < 48)
      ++end;
    buf.len = (size_t)(end - forwarded.buf);
  } else {
    forwarded =
        fio_http_request_header((fio_http_s *)h,
                                FIO_STR_INFO2((char *)"x-forwarded-for", 15),
                                -1);
    if (forwarded.len) {
      forwarded.buf += (forwarded.buf[0] == '"');
      goto client_address_found;
    }
#if defined(H___FIO_SOCK___H)
    if (!(buf = fio_sock_peer_addr(
              fio_http_controller((fio_http_s *)h)->get_fd((fio_http_s *)h)))
             .len)
#endif
      buf = FIO_BUF_INFO1((char *)"[unknown]");
    r = -1;
  }
  if (dest->capa > dest->len + buf.len) { /* enough space? */
    FIO_MEMCPY(dest->buf + dest->len, buf.buf, buf.len);
    dest->len += buf.len;
    dest->buf[dest->len] = 0;
  } else
    r = (int)buf.len - (!buf.len);
  return r;
}

/* *****************************************************************************
Body Management - file descriptor
***************************************************************************** */

FIO_SFUNC fio_str_info_s fio___http_body_read_fd(fio_http_s *h, size_t len) {
  h->body.buf = fio_bstr_len_set(h->body.buf, 0);
  h->body.buf = fio_bstr_readfd(h->body.buf, h->body.fd, h->body.pos, len);
  fio_str_info_s r = fio_bstr_info(h->body.buf);
  h->body.pos += r.len;
  return r;
}
FIO_SFUNC fio_str_info_s fio___http_body_read_until_fd(fio_http_s *h,
                                                       char token,
                                                       size_t limit) {
  h->body.buf = fio_bstr_len_set(h->body.buf, 0);
  h->body.buf =
      fio_bstr_getdelim_fd(h->body.buf, h->body.fd, h->body.pos, token, limit);
  fio_str_info_s r = fio_bstr_info(h->body.buf);
  h->body.pos += r.len;
  return r;
}
FIO_SFUNC void fio___http_body_expect_fd(fio_http_s *h, size_t len) {
  (void)h, (void)len;
}
FIO_SFUNC void fio___http_body_write_fd(fio_http_s *h,
                                        const void *data,
                                        size_t len) {
  ssize_t written = fio_fd_write(h->body.fd, data, len);
  if (written > 0)
    h->body.len += written;
}

/* *****************************************************************************
Body Management - buffer
***************************************************************************** */

FIO_SFUNC int fio___http_body___move_buf2fd(fio_http_s *h) {
  h->body.fd = fio_filename_tmp();
  if (h->body.fd == -1) {
#if 1
    static int error_printed = 0;
    if (!error_printed) {
      error_printed = 1;
      FIO_LOG_ERROR("fio_http_s couldn't open temporary file! (%d) %s",
                    errno,
                    strerror(errno));
    }
#endif
    return -1;
  }
  fio_buf_info_s b = fio_bstr_buf(h->body.buf);
  if (!b.len)
    return 0;
  ssize_t written = fio_fd_write(h->body.fd, b.buf, b.len);
  if (written == (ssize_t)b.len)
    return 0;
  close(h->body.fd);
  FIO_LOG_ERROR("fio_http_s couldn't transfer data to temporary file "
                "(transferred %zd / %zu)",
                written,
                b.len);
  return (h->body.fd = -1);
}
FIO_SFUNC fio_str_info_s fio___http_body_read_buf(fio_http_s *h, size_t len) {
  fio_str_info_s r = FIO_STR_INFO2((h->body.buf + h->body.pos), len);
  h->body.pos += len;
  return r;
}
FIO_SFUNC fio_str_info_s fio___http_body_read_until_buf(fio_http_s *h,
                                                        char token,
                                                        size_t limit) {
  fio_str_info_s r = FIO_STR_INFO2((h->body.buf + h->body.pos), limit);
  char *end = (char *)FIO_MEMCHR(r.buf, token, limit);
  if (end) {
    ++end;
    r.len = end - r.buf;
    h->body.pos = end - h->body.buf;
  } else
    h->body.pos = h->body.len;
  return r;
}
FIO_SFUNC void fio___http_body_expect_buf(fio_http_s *h, size_t len) {
  if (len + h->body.len > FIO_HTTP_BODY_RAM_LIMIT) {
    fio___http_body___move_buf2fd(h);
    return;
  }
  h->body.buf = fio_bstr_reserve(h->body.buf, len);
}
FIO_SFUNC void fio___http_body_write_buf(fio_http_s *h,
                                         const void *data,
                                         size_t len) {
  if (len + h->body.len > FIO_HTTP_BODY_RAM_LIMIT)
    goto switch_to_fd;
write_to_buf:
  h->body.buf = fio_bstr_write(h->body.buf, data, len);
  h->body.len += len;
  return;
switch_to_fd:
  if (fio___http_body___move_buf2fd(h))
    goto write_to_buf;
  fio___http_body_write_fd(h, data, len);
}

/* *****************************************************************************
Body Management - Public API
***************************************************************************** */

/** Gets the body (payload) length associated with the HTTP handle. */
SFUNC size_t fio_http_body_length(fio_http_s *h) { return h->body.len; }

/**
 * If the body is stored in a temporary file, returns the file's handle.
 *
 * Otherwise returns -1.
 */
SFUNC int fio_http_body_fd(fio_http_s *h) { return h->body.fd; }

/** Adjusts the body's reading position. Negative values start at the end. */
SFUNC size_t fio_http_body_seek(fio_http_s *h, ssize_t pos) {
  if (pos == SSIZE_MAX)
    pos = h->body.pos;
  if (pos < 0) {
    pos += h->body.len;
    if (pos < 0)
      pos = 0;
  }
  if ((size_t)pos >= h->body.len)
    pos = h->body.len;
  h->body.pos = pos;
  return pos;
}

/** Returns the body's reading position. */
SFUNC size_t fio_http_body_pos(fio_http_s *h) { return h->body.pos; }

/** Reads up to `length` of data from the body, returns nothing on EOF. */
SFUNC fio_str_info_s fio_http_body_read(fio_http_s *h, size_t length) {
  fio_str_info_s r = {0};
  if (h->body.pos == h->body.len)
    return r;
  if (h->body.pos + length > h->body.len)
    length = h->body.len - h->body.pos;
  r = ((h->body.fd == -1) ? fio___http_body_read_buf
                          : fio___http_body_read_fd)(h, length);
  return r;
}

/**
 * Reads from the body until finding `token`, reaching `limit` or EOF.
 *
 * Note: `limit` is ignored if zero or larger than remaining data.
 */
SFUNC fio_str_info_s fio_http_body_read_until(fio_http_s *h,
                                              char token,
                                              size_t limit) {
  fio_str_info_s r = {0};
  if (h->body.pos >= h->body.len)
    return r;
  if (!limit || limit > h->body.len || limit > (h->body.len - h->body.pos))
    limit = h->body.len - h->body.pos;
  if (!limit)
    return r;
  r = ((h->body.fd == -1) ? fio___http_body_read_until_buf
                          : fio___http_body_read_until_fd)(h, token, limit);
  if (!r.len)
    r.buf = NULL;
  return r;
}

/** Allocates a body (payload) of (at least) the `expected_length`. */
SFUNC void fio_http_body_expect(fio_http_s *h, size_t expected_length) {
  ((h->body.fd == -1) ? fio___http_body_expect_buf
                      : fio___http_body_expect_fd)(h, expected_length);
}

/** Writes `data` to the body (payload) associated with the HTTP handle. */
SFUNC void fio_http_body_write(fio_http_s *h, const void *data, size_t len) {
  if (!data || !len)
    return;
  ((h->body.fd == -1) ? fio___http_body_write_buf
                      : fio___http_body_write_fd)(h, data, len);
}

/* *****************************************************************************
A Response Payload
***************************************************************************** */

/** ETag Helper */
FIO_IFUNC int fio___http_response_etag_if_none_match(fio_http_s *h);

FIO_SFUNC int fio____http_write_done(fio_http_s *h,
                                     fio_http_write_args_s *args) {
  return -1;
  (void)h, (void)args;
}

FIO_SFUNC int fio____http_write_upgraded(fio_http_s *h,
                                         fio_http_write_args_s *args) {
  h->controller->write_body(h, *args);
  h->sent += args->len;
  return 0;
}

FIO_SFUNC int fio____http_write_start(fio_http_s *h,
                                      fio_http_write_args_s *args) {
  /* if response has an `etag` header matching `if-none-match`, skip */
  fio___http_hmap_s *hdrs = h->headers + (!!h->status);
  if (h->status) {
    if (args->len && fio___http_response_etag_if_none_match(h))
      return -1;
    if (!args->len && args->finish && h->status >= 400) {
      fio_http_send_error_response(h, h->status);
      return 0;
    }
    /* validate Date header */
    fio___http_hmap_set2(
        hdrs,
        FIO_STR_INFO2((char *)"date", 4),
        fio_http_date(fio_http_get_timestump() / FIO___HTTP_TIME_DIV),
        0);
  }
  /* test if streaming / single body response */
  if (!fio___http_hmap_get_ptr(hdrs,
                               FIO_STR_INFO2((char *)"content-length", 14))) {
    if (args->finish) {
      /* validate / set Content-Length (not streaming) */
      char ibuf[32];
      fio_str_info_s k = FIO_STR_INFO2((char *)"content-length", 14);
      fio_str_info_s v = FIO_STR_INFO3(ibuf, 0, 32);
      v.len = fio_digits10u(args->len);
      fio_ltoa10u(v.buf, args->len, v.len);
      fio___http_hmap_set2(hdrs, k, v, -1);
    } else {
      h->state |= FIO_HTTP_STATE_STREAMING;
    }
  }

  /* start a response, unless status == 0 (which starts a request). */
  h->controller->send_headers(h);
  return (h->writer = fio____http_write_cont)(h, args);
}

FIO_SFUNC int fio____http_write_cont(fio_http_s *h,
                                     fio_http_write_args_s *args) {
  int r = (int)0 - (int)((unsigned)(h->status == 204) | (h->status == 205) |
                         (h->status == 304));
  if (!r) {
    h->controller->write_body(h, *args);
    h->sent += args->len;
  }
  if (args->finish) {
    h->state |= FIO_HTTP_STATE_FINISHED;
    h->writer = (h->state & FIO_HTTP_STATE_UPGRADED)
                    ? fio____http_write_upgraded
                    : fio____http_write_done;
    h->controller->on_finish(h);
  }
  return r;
}

void fio_http_write___(void); /* IDE Marker */
/**
 * Writes `data` to the response body associated with the HTTP handle after
 * sending all headers (no further headers may be sent).
 */
SFUNC void fio_http_write FIO_NOOP(fio_http_s *h, fio_http_write_args_s args) {
  if (!h || !h->controller)
    goto handle_error;
  if (h->writer(h, &args))
    goto handle_error;
  return;

handle_error:
  if (args.fd)
    close(args.fd);
  if (args.dealloc && args.buf)
    args.dealloc((void *)args.buf);
}

/** ETag Helper */
FIO_IFUNC int fio___http_response_etag_if_none_match(fio_http_s *h) {
  if (!fio_http_etag_is_match(h))
    return 0;
  h->status = 304;
  fio___http_hmap_set2(HTTP_HDR_RESPONSE(h),
                       FIO_STR_INFO2((char *)"content-length", 14),
                       FIO_STR_INFO0,
                       -1);

  h->controller->send_headers(h);
  h->state |= FIO_HTTP_STATE_FINISHED;
  h->writer = fio____http_write_done;
  h->controller->on_finish(h);
  return -1;
}

/* *****************************************************************************
WebSocket / SSE Helpers
***************************************************************************** */

/** Returns non-zero if request headers ask for a WebSockets Upgrade.*/
SFUNC int fio_http_websocket_requested(fio_http_s *h) {
  fio_str_info_s val =
      fio_http_request_header(h, FIO_STR_INFO2((char *)"connection", 10), 0);
  /* test for "Connection: Upgrade" (TODO? allow for multi-value?) */
  if (val.len < 7 ||
      !(((fio_buf2u32u(val.buf) | 0x20202020UL) == fio_buf2u32u("upgr")) ||
        ((fio_buf2u32u(val.buf + 3) | 0x20202020) == fio_buf2u32u("rade"))))
    return 0;
  /* test for "Upgrade: websocket" (TODO? allow for multi-value?) */
  val = fio_http_request_header(h, FIO_STR_INFO2((char *)"upgrade", 7), 0);
  if (val.len < 7 ||
      !(((fio_buf2u64u(val.buf) | 0x2020202020202020ULL) ==
         fio_buf2u64u("websocke")) ||
        ((fio_buf2u32u(val.buf + 5) | 0x20202020UL) == fio_buf2u32u("cket"))))
    return 0;
  val = fio_http_request_header(h,
                                FIO_STR_INFO2((char *)"sec-websocket-key", 17),
                                0);
  if (val.len != 24)
    return 0;
  /* test for version value */
  val = fio_http_request_header(
      h,
      FIO_STR_INFO2((char *)"sec-websocket-version", 21),
      0);
  if (val.len != 2 || (val.buf[0] != '1' || val.buf[1] != '3'))
    return -1; /* note the error value is still true, requested WebSocket... */
  return 1;
}

/** Sets response data to agree to a WebSockets Upgrade.*/
SFUNC void fio_http_upgrade_websocket(fio_http_s *h) {
  { /* validate WebSocket version */
    fio_str_info_s val = fio_http_request_header(
        h,
        FIO_STR_INFO2((char *)"sec-websocket-version", 21),
        0);
    if (val.len != 2 || (val.buf[0] != '1' || val.buf[1] != '3')) {
      fio_http_response_header_set(
          h,
          FIO_STR_INFO2((char *)"sec-websocket-version", 21),
          FIO_STR_INFO2((char *)"13", 2));
      fio_http_send_error_response(h, 400);
    }
  }
  h->status = 101;
  fio_http_response_header_set(h,
                               FIO_STR_INFO2((char *)"connection", 10),
                               FIO_STR_INFO2((char *)"Upgrade", 7));
  fio_http_response_header_set(h,
                               FIO_STR_INFO2((char *)"upgrade", 7),
                               FIO_STR_INFO2((char *)"websocket", 9));
  { /* Sec-WebSocket-Accept */
    fio_str_info_s k =
        fio_http_request_header(h,
                                FIO_STR_INFO2((char *)"sec-websocket-key", 17),
                                0);
    FIO_STR_INFO_TMP_VAR(accept_val, 63);
    if (k.len != 24)
      goto handshake_error;
    fio_string_write(&accept_val, NULL, k.buf, k.len);
    fio_string_write(&accept_val,
                     NULL,
                     "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
                     36);
    fio_sha1_s sha = fio_sha1(accept_val.buf, accept_val.len);
    fio_sha1_digest(&sha);
    accept_val.len = 0;
    fio_string_write_base64enc(&accept_val,
                               NULL,
                               fio_sha1_digest(&sha),
                               fio_sha1_len(),
                               0);
    fio_http_response_header_set(
        h,
        FIO_STR_INFO2((char *)"sec-websocket-accept", 20),
        accept_val);
  }
  { /* finish up */
    h->state |= FIO_HTTP_STATE_UPGRADED | FIO_HTTP_STATE_WEBSOCKET;
    fio_http_write_args_s args = {.finish = 1};
    fio_http_write FIO_NOOP(h, args);
  }
  return;
handshake_error:
  fio_http_send_error_response(h, 403);
  return;
}

/** Sets request data to request a WebSockets Upgrade.*/
SFUNC void fio_http_websocket_set_request(fio_http_s *h) {
  fio_http_request_header_set(h,
                              FIO_STR_INFO2((char *)"connection", 10),
                              FIO_STR_INFO2((char *)"Upgrade", 7));
  fio_http_request_header_set(h,
                              FIO_STR_INFO2((char *)"pragma", 6),
                              FIO_STR_INFO2((char *)"no-cache", 8));
  fio_http_request_header_set(h,
                              FIO_STR_INFO2((char *)"cache-control", 13),
                              FIO_STR_INFO2((char *)"no-cache", 8));
  fio_http_request_header_set(h,
                              FIO_STR_INFO2((char *)"upgrade", 7),
                              FIO_STR_INFO2((char *)"websocket", 9));
  {
    fio_http_request_header_set_if_missing(
        h,
        FIO_STR_INFO2((char *)"origin", 6),
        fio_http_request_header(h, FIO_STR_INFO2((char *)"host", 4), 0));
  }
  fio_http_request_header_set(
      h,
      FIO_STR_INFO2((char *)"sec-websocket-version", 21),
      FIO_STR_INFO2((char *)"13", 2));

  {
    uint64_t tmp[2] = {fio_rand64(), fio_rand64()};
    FIO_STR_INFO_TMP_VAR(key, 64);
    fio_string_write_base64enc(&key, NULL, tmp, 16, 0);
    fio_http_request_header_set(h,
                                FIO_STR_INFO2((char *)"sec-websocket-key", 17),
                                key);
  }
  /* sec-websocket-extensions ? */
  /* send request? */
}

/** Returns non-zero if the response accepts a WebSocket upgrade request. */
SFUNC int fio_http_websocket_accepted(fio_http_s *h) {
  if (h->status != 101)
    return 0;
  if (!fio_http_websocket_requested(h))
    return 0;
  fio_str_info_s tst =
      fio_http_response_header(h, FIO_STR_INFO2((char *)"connection", 10), 0);
  if (tst.len < 7 ||
      (fio_buf2u64_le(tst.buf) | (uint64_t)0x20202020202020FFULL) !=
          (fio_buf2u64_le("upgrade") | (uint64_t)0x20202020202020FFULL))
    return 0;
  tst = fio_http_response_header(h, FIO_STR_INFO2((char *)"upgrade", 7), 0);
  if (tst.len < 9 || (tst.buf[0] | 32) != 'w' ||
      (fio_buf2u64u(tst.buf + 1) | (uint64_t)0x2020202020202020ULL) !=
          fio_buf2u64u("ebsocket"))
    return 0;
  { /* Sec-WebSocket-Accept */
    tst = fio_http_response_header(
        h,
        FIO_STR_INFO2((char *)"sec-websocket-accept", 20),
        0);
    if (!tst.len)
      return 0;

    fio_str_info_s k =
        fio_http_request_header(h,
                                FIO_STR_INFO2((char *)"sec-websocket-key", 17),
                                0);
    FIO_STR_INFO_TMP_VAR(accept_val, 63);
    if (k.len != 24)
      return 0;
    fio_string_write(&accept_val, NULL, k.buf, k.len);
    fio_string_write(&accept_val,
                     NULL,
                     "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
                     36);
    fio_sha1_s sha = fio_sha1(accept_val.buf, accept_val.len);
    fio_sha1_digest(&sha);
    accept_val.len = 0;
    fio_string_write_base64enc(&accept_val,
                               NULL,
                               fio_sha1_digest(&sha),
                               fio_sha1_len(),
                               0);
    if (!FIO_STR_INFO_IS_EQ(tst, accept_val)) {
      FIO_LOG_DDEBUG2(
          "(%d) sec-websocket-key invalid, WebSocket handshake failed.\n\t"
          "%s != %s",
          getpid(),
          tst.buf,
          accept_val.buf);
      return 0;
    }
  }
  h->state |= (FIO_HTTP_STATE_UPGRADED | FIO_HTTP_STATE_WEBSOCKET |
               FIO_HTTP_STATE_FINISHED);
  h->writer = fio____http_write_upgraded;
  return 1;
}

/** Returns non-zero if request headers ask for an EventSource (SSE) Upgrade.*/
SFUNC int fio_http_sse_requested(fio_http_s *h) {
  fio_str_info_s val =
      fio_http_request_header(h, FIO_STR_INFO2((char *)"accept", 6), 0);
  if (val.len < 17)
    return 0;
  if ((val.buf[0] | 32) != 't')
    return 0;
  uint64_t t0 = fio_buf2u64u(val.buf + 1) | (uint64_t)0x2020202020202020ULL;
  uint64_t t1 = fio_buf2u64u(val.buf + 9) | (uint64_t)0x2020202020202020ULL;
  if ((t0 != fio_buf2u64u("ext/even")) || (t1 != fio_buf2u64u("t-stream")))
    return 0; /* note that '/' and '-' both have 32 (bit[5]) set */
  FIO_LOG_DDEBUG2("(%d) EventSource connection requested.",
                  fio_thread_getpid());
  return 1;
}

/** Returns non-zero if the response accepts an SSE request. */
SFUNC int fio_http_sse_accepted(fio_http_s *h) {
  if (!fio_http_sse_requested(h))
    return 0;
  if (h->status != 200)
    return 0;
  fio_str_info_s val =
      fio_http_request_header(h, FIO_STR_INFO2((char *)"accept", 6), 0);
  for (size_t i = 0; i < 2; ++i) {
    if (val.len < 17)
      return 0;
    if ((val.buf[0] | 32) != 't')
      return 0;
    uint64_t t0 = fio_buf2u64u(val.buf + 1) | (uint64_t)0x2020202020202020ULL;
    uint64_t t1 = fio_buf2u64u(val.buf + 9) | (uint64_t)0x2020202020202020ULL;
    if ((t0 != fio_buf2u64u("ext/even")) || (t1 != fio_buf2u64u("t-stream")))
      return 0; /* note that '/' and '-' both have 32 (bit[5]) set */
    val = fio_http_response_header(h,
                                   FIO_STR_INFO2((char *)"content-type", 12),
                                   0);
  }
  h->state |=
      (FIO_HTTP_STATE_UPGRADED | FIO_HTTP_STATE_SSE | FIO_HTTP_STATE_FINISHED);
  h->writer = fio____http_write_upgraded;
  FIO_LOG_DDEBUG2("EventSource connection accepted.");
  return 1;
}

/** Sets response data to agree to an EventSource (SSE) Upgrade.*/
SFUNC void fio_http_upgrade_sse(fio_http_s *h) {
  if (h->state)
    return;
  fio_http_response_header_set(h,
                               FIO_STR_INFO2((char *)"content-type", 12),
                               FIO_STR_INFO2((char *)"text/event-stream", 17));
  fio_http_response_header_set(h,
                               FIO_STR_INFO2((char *)"cache-control", 13),
                               FIO_STR_INFO2((char *)"no-store", 8));
  fio___http_hmap_remove(HTTP_HDR_RESPONSE(h),
                         FIO_STR_INFO2((char *)"content-length", 14),
                         NULL);
  h->state |=
      FIO_HTTP_STATE_FINISHED | FIO_HTTP_STATE_UPGRADED | FIO_HTTP_STATE_SSE;
  h->controller->send_headers(h);
  h->writer = fio____http_write_upgraded;
  h->controller->on_finish(h);
}

/** Sets request data to request an EventSource (SSE) Upgrade.*/
SFUNC void fio_http_sse_set_request(fio_http_s *h) {
  fio_http_request_header_set(h,
                              FIO_STR_INFO2((char *)"accept", 6),
                              FIO_STR_INFO2((char *)"text/event-stream", 17));
  fio_http_request_header_set(h,
                              FIO_STR_INFO2((char *)"connection", 10),
                              FIO_STR_INFO2((char *)"keep-alive", 10));
  fio_http_request_header_set(h,
                              FIO_STR_INFO2((char *)"cache-control", 13),
                              FIO_STR_INFO2((char *)"no-cache", 8));
}

/* *****************************************************************************
Header Parsing Helpers - Implementation
***************************************************************************** */

/**
 * Assumes a Buffer of bytes containing length info and string data as such:
 *
 *   [ 2 byte info: (type | (len << 2)) ]
 *   [ Optional 2 byte info: (len << 2) (if type was 1)]
 *   [ String of `len` bytes][ NUL byte (not counted in `len`)]
 */

FIO_SFUNC int fio___http_header_parse_properties(fio_str_info_s *dst,
                                                 char *start,
                                                 char *const end) {
  for (;;) {
    char *nxt = (char *)FIO_MEMCHR(start, ';', end - start);
    if (!nxt)
      nxt = end;
    char *eq = (char *)FIO_MEMCHR(start, '=', nxt - start);
    if (!eq)
      eq = nxt;
    /* write value to dst */
    size_t len = eq - start;
    if ((len & (~(size_t)0x3FFF)) | (dst->len + len + 3 > dst->capa))
      return -1; /* too long */
    fio_u2buf16u(dst->buf + dst->len,
                 ((len << 2) | FIO___HTTP_PARSED_HEADER_PROPERTY_DATA));
    dst->len += 2;
    if (len)
      FIO_MEMCPY(dst->buf + dst->len, start, len);
    dst->len += len;
    dst->buf[dst->len++] = 0;

    eq += (eq[0] == '=');
    eq += (eq[0] == ' ' || eq[0] == '\t');
    len = nxt - eq;
    if ((len & (~(size_t)0x3FFF)) | (dst->len + len + 3 > dst->capa))
      return -1; /* too long */
    fio_u2buf16u(dst->buf + dst->len,
                 ((len << 2) | FIO___HTTP_PARSED_HEADER_PROPERTY_DATA));
    dst->len += 2;
    if (len)
      FIO_MEMCPY(dst->buf + dst->len, eq, len);
    dst->len += len;
    dst->buf[dst->len++] = 0;

    if (nxt == end)
      return 0;
    nxt += (*nxt == ';');
    while (*nxt == ' ' || *nxt == '\t')
      ++nxt;
    start = nxt;
  }
  return 0;
}

FIO_IFUNC int fio___http_header_parse(fio___http_hmap_s *map,
                                      fio_str_info_s *dst,
                                      fio_str_info_s header_name) {
  fio___http_sary_s *a =
      fio___http_hmap_node2val_ptr(fio___http_hmap_get_ptr(map, header_name));
  if (!a)
    return -1;
  dst->len = 0;
  if (dst->capa < 3)
    return -1;
  dst->buf[dst->len++] = 0; /* first byte is a pretend NUL */
  FIO_ARRAY_EACH(fio___http_sary, a, pos) {
    fio_buf_info_s i = fio_bstr_buf(*pos);
    if (!i.len)
      continue;
    char *const end = i.buf + i.len;
    char *sep;
    do {
      sep = (char *)FIO_MEMCHR(i.buf, ',', end - i.buf);
      if (!sep)
        sep = end;
      char *prop = (char *)FIO_MEMCHR(i.buf, ';', sep - i.buf);
      if (!prop)
        prop = sep;
      size_t len = prop - i.buf;
      if ((len & (~(size_t)0x3FFF)) | (dst->len + len + 3 > dst->capa))
        return -1; /* too long */
      fio_u2buf16u(dst->buf + dst->len, (len << 2));
      dst->len += 2;
      FIO_MEMCPY(dst->buf + dst->len, i.buf, len);
      dst->len += len;
      dst->buf[dst->len++] = 0;
      if (prop != sep) { /* parse properties */
        ++prop;
        len = sep - prop;
        if ((len & (~(size_t)0x3FFF)) | (dst->len + len + 3 > dst->capa))
          return -1;
        const size_t old_len = dst->len;
        dst->len += 2;
        if (fio___http_header_parse_properties(dst, prop, sep))
          return -1;
        len = dst->len - old_len;
        if ((len & (~(size_t)0x3FFF)) | (dst->len + len + 3 > dst->capa))
          return -1;
        fio_u2buf16u(
            dst->buf + old_len,
            ((len << 2) | FIO___HTTP_PARSED_HEADER_PROPERTY_BLOCK_LEN));
      }
      sep += (*sep == ',');
      while (*sep == ' ' || *sep == '\t')
        ++sep;
      i.buf = sep;
    } while (sep < end);
  }
  if (dst->len + 2 > dst->capa)
    return -1;
  /* last u16 must be zero (end marker) */
  dst->buf[dst->len++] = 0;
  dst->buf[dst->len++] = 0;
  return 0;
}

SFUNC int fio_http_response_header_parse(fio_http_s *h,
                                         fio_str_info_s *buf_parsed,
                                         fio_str_info_s header_name) {
  return fio___http_header_parse(HTTP_HDR_RESPONSE(h), buf_parsed, header_name);
}

SFUNC int fio_http_request_header_parse(fio_http_s *h,
                                        fio_str_info_s *buf_parsed,
                                        fio_str_info_s header_name) {
  return fio___http_header_parse(HTTP_HDR_REQUEST(h), buf_parsed, header_name);
}

/* *****************************************************************************
Error Handling
***************************************************************************** */

/** Sends the requested error message and finishes the response. */
SFUNC int fio_http_send_error_response(fio_http_s *h, size_t status) {
  if (!h || h->writer != fio____http_write_start)
    return -1;
  if (!status || status > 1000)
    status = 404;
  h->status = (uint32_t)status;
  FIO_STR_INFO_TMP_VAR(filename, 127);
  /* read static error code file */
  fio_string_write2(&filename,
                    NULL,
                    FIO_STRING_WRITE_UNUM(status),
                    FIO_STRING_WRITE_STR2(".html", 5));
  char *body = fio_bstr_readfile(NULL, filename.buf, 0, 0);
  fio_http_write_args_s args = {.buf = body,
                                .len = fio_bstr_len(body),
                                .dealloc = (void (*)(void *))fio_bstr_free,
                                .finish = 1};
  fio_http_response_header_set(h,
                               FIO_STR_INFO2((char *)"content-type", 12),
                               body ? FIO_STR_INFO2((char *)"text/html", 9)
                                    : FIO_STR_INFO2((char *)"text/plain", 10));
  if (!body) { /* write a short error response (plain text fallback) */
    fio_str_info_s status_str = fio_http_status2str(status);
    filename.len = 0;
    fio_string_write2(&filename,
                      NULL,
                      FIO_STRING_WRITE_STR2("Error ", 6),
                      FIO_STRING_WRITE_UNUM(status),
                      FIO_STRING_WRITE_STR2(": ", 2),
                      FIO_STRING_WRITE_STR_INFO(status_str),
                      FIO_STRING_WRITE_STR2(".", 1));
    args.buf = filename.buf;
    args.len = filename.len;
    args.copy = 1;
    args.dealloc = NULL;
  }
  fio_http_write FIO_NOOP(h, args);
  return 0;
}

/* *****************************************************************************
HTTP Logging
***************************************************************************** */

SFUNC void fio___http_write_pid(fio_str_info_s *dest) {
  static int last_pid = 0;
  static char buf[64];
  static size_t len = 0;
#ifdef H___FIO_SERVER___H
  int pid = fio_srv_pid();
#else
  int pid = fio_thread_getpid();
#endif
  if (last_pid != pid)
    goto rewrite;
copy:
  if (len)
    FIO_MEMCPY(dest->buf + dest->len, buf, len);
  dest->len += len;
  return;
rewrite:
  len = 0;
  buf[len++] = '[';
  if (pid > 0) {
    size_t d = fio_digits10u((uint64_t)pid);
    fio_ltoa10u(buf + 1, (uint64_t)pid, d);
    len += d;
  }
  buf[len++] = ']';
  last_pid = pid;
  goto copy;
}
/** Logs an HTTP (response) to STDOUT. */
SFUNC void fio_http_write_log(fio_http_s *h) {
  FIO_STR_INFO_TMP_VAR(buf, 1023);
  intptr_t bytes_sent = h->sent;
  uint64_t time_start, time_end, time_proxy = 0;
  time_start = h->received_at;
  time_end = fio_http_get_timestump();
  fio_str_info_s date = fio_http_log_time(time_end / FIO___HTTP_TIME_DIV);
  fio_string_write_s to_write[16] = {
      FIO_STRING_WRITE_STR_INFO(fio_keystr_info(&h->method)),
      FIO_STRING_WRITE_STR2((const char *)" ", 1),
      FIO_STRING_WRITE_STR_INFO(fio_keystr_info(&h->opath)),
      FIO_STRING_WRITE_STR2((const char *)" ", 1),
      FIO_STRING_WRITE_STR_INFO(fio_keystr_info(&h->version)),
      FIO_STRING_WRITE_STR2((const char *)"\" ", 2),
      FIO_STRING_WRITE_NUM(h->status),
      FIO_STRING_WRITE_STR2(" ", 1),
      ((bytes_sent > 0) ? (FIO_STRING_WRITE_UNUM(bytes_sent))
                        : (FIO_STRING_WRITE_STR2((const char *)"---", 3))),
      FIO_STRING_WRITE_STR2((const char *)" ", 1),
      FIO_STRING_WRITE_NUM(time_end - time_start),
      FIO_STRING_WRITE_STR2((const char *)(FIO___HTTP_TIME_UNIT "\r\n"), 4),
  };
  if (FIO_HTTP_LOG_X_REQUEST_START) {
    /* log request wait time using x-request-start header */
    fio_str_info_s xstart =
        fio_http_request_header(h,
                                FIO_STR_INFO2((char *)"x-request-start", 15),
                                0);
    unsigned step =
        (xstart.len > 1 && (xstart.buf[0] | 32) == 't' && xstart.buf[1] == '=');
    step <<= 1;
    xstart.buf += step;
    xstart.len -= step;
    time_proxy = fio_atol(&xstart.buf);
    time_proxy *= (FIO___HTTP_TIME_DIV / 1000); /* assumes info in ms */
    time_proxy = time_start - time_proxy;
    if (time_proxy < (512 * FIO___HTTP_TIME_DIV)) { /* was ms? */
      to_write[11] =
          FIO_STRING_WRITE_STR2((const char *)(FIO___HTTP_TIME_UNIT " (wait "),
                                9);
      to_write[12] = FIO_STRING_WRITE_NUM(time_proxy);
      to_write[13] =
          FIO_STRING_WRITE_STR2((const char *)(FIO___HTTP_TIME_UNIT ")\r\n"),
                                5);
    }
  }

  /* Write log line to buffer */
  fio___http_write_pid(&buf);
  buf.buf[buf.len++] = ' ';
  fio_http_from(&buf, h);
  FIO_MEMCPY(buf.buf + buf.len, " - - ", 5);
  FIO_MEMCPY(buf.buf + buf.len + 5, date.buf, date.len);
  buf.len += date.len + 5;
  buf.buf[buf.len++] = ' ';
  buf.buf[buf.len++] = '\"';
  fio_string_write2 FIO_NOOP(&buf, NULL, to_write);

  if (buf.buf[buf.len - 1] != '\n')
    buf.buf[buf.len++] = '\n'; /* log was truncated, data too long */

  /* Write log line to STDOUT */
  fwrite(buf.buf, 1, buf.len, stdout);
  h->received_at = time_end;
}

/* *****************************************************************************
ETag helper
***************************************************************************** */

/** Returns true (1) if the ETag response matches an if-none-match request. */
SFUNC int fio_http_etag_is_match(fio_http_s *h) {
  fio_str_info_s method = fio_keystr_info(&h->method);
  if ((method.len < 3) | (method.len > 4))
    return 0;
  if (!(((method.buf[0] | 32) == 'g') & ((method.buf[1] | 32) == 'e') &
        ((method.buf[2] | 32) == 't')) &&
      !(((method.buf[0] | 32) == 'h') & ((method.buf[1] | 32) == 'e') &
        ((method.buf[2] | 32) == 'a') & ((method.buf[3] | 32) == 'd')))
    return 0;
  fio_str_info_s etag = fio___http_hmap_get2(HTTP_HDR_RESPONSE(h),
                                             FIO_STR_INFO2((char *)"etag", 4),
                                             0);
  if (!etag.len)
    return 0;
  fio_str_info_s cond =
      fio___http_hmap_get2(HTTP_HDR_REQUEST(h),
                           FIO_STR_INFO2((char *)"if-none-match", 13),
                           0);
  if (!cond.len)
    return 0;
  char *end = cond.buf + cond.len;
  for (;;) {
    cond.buf += (cond.buf[0] == ',');
    while (cond.buf[0] == ' ')
      ++cond.buf;
    if (cond.buf > end || (size_t)(end - cond.buf) < (size_t)etag.len)
      return 0;
    if (FIO_MEMCMP(cond.buf, etag.buf, etag.len)) {
      cond.buf = (char *)FIO_MEMCHR(cond.buf, ',', end - cond.buf);
      if (!cond.buf)
        return 0;
      continue;
    }
    return 1;
  }
}

/* *****************************************************************************
Param Parsing (TODO! - parse query, parse mime/multipart parse text/json)
***************************************************************************** */

/* *****************************************************************************
HTTP Body Parsing - Primitive Type Detection
***************************************************************************** */

/** Primitive type enum for value identification. */
typedef enum {
  FIO___HTTP_BODY_PRIM_STRING = 0, /* Not a recognized primitive */
  FIO___HTTP_BODY_PRIM_NULL,       /* "null" or "nil" */
  FIO___HTTP_BODY_PRIM_TRUE,       /* "true" */
  FIO___HTTP_BODY_PRIM_FALSE,      /* "false" */
  FIO___HTTP_BODY_PRIM_NUMBER,     /* Integer like "123", "-456" */
  FIO___HTTP_BODY_PRIM_FLOAT,      /* Float like "1.5", "-3.14", "1e10" */
} fio___http_body_primitive_e;

/**
 * Identifies if a string represents a primitive value.
 *
 * Returns the primitive type and optionally parses the value.
 * If `i_out` is not NULL and type is NUMBER, stores parsed int64_t.
 * If `f_out` is not NULL and type is FLOAT, stores parsed double.
 */
FIO_SFUNC fio___http_body_primitive_e
fio___http_body_identify_primitive(fio_buf_info_s str,
                                   int64_t *i_out,
                                   double *f_out) {
  if (!str.len || !str.buf)
    return FIO___HTTP_BODY_PRIM_STRING;

  /* Check for "null" (4 chars) - case insensitive */
  if (str.len == 4) {
    uint32_t w = fio_buf2u32u(str.buf) | 0x20202020UL;
    if (w == (fio_buf2u32u("null") | 0x20202020UL))
      return FIO___HTTP_BODY_PRIM_NULL;
    if (w == (fio_buf2u32u("true") | 0x20202020UL))
      return FIO___HTTP_BODY_PRIM_TRUE;
  }

  /* Check for "nil" (3 chars) - case insensitive */
  if (str.len == 3) {
    uint32_t w = (fio_buf2u16u(str.buf) | 0x2020) |
                 ((uint32_t)(str.buf[2] | 0x20) << 16);
    uint32_t nil = (fio_buf2u16u("ni") | 0x2020) | ((uint32_t)('l') << 16);
    if (w == nil)
      return FIO___HTTP_BODY_PRIM_NULL;
  }

  /* Check for "false" (5 chars) - case insensitive */
  if (str.len == 5) {
    uint32_t w0 = fio_buf2u32u(str.buf) | 0x20202020UL;
    if (w0 == (fio_buf2u32u("fals") | 0x20202020UL) &&
        ((str.buf[4] | 0x20) == 'e'))
      return FIO___HTTP_BODY_PRIM_FALSE;
  }

  /* Check for numeric values */
  {
    const char *p = str.buf;
    const char *end = str.buf + str.len;
    size_t is_neg = (p[0] == '-');

    /* Must start with digit or '-' followed by digit */
    if (!(((size_t)(p[0] - '0') < 10) ||
          (is_neg && str.len > 1 && ((size_t)(p[1] - '0') < 10))))
      return FIO___HTTP_BODY_PRIM_STRING;

    /* Scan to determine if integer or float */
    size_t has_dot = 0, has_exp = 0;
    p += is_neg;

    /* Scan integer part */
    while (p < end && ((size_t)(*p - '0') < 10))
      ++p;

    /* Check for decimal point */
    if (p < end && *p == '.') {
      has_dot = 1;
      ++p;
      /* Must have at least one digit after dot */
      if (p >= end || ((size_t)(*p - '0') >= 10))
        return FIO___HTTP_BODY_PRIM_STRING;
      while (p < end && ((size_t)(*p - '0') < 10))
        ++p;
    }

    /* Check for exponent */
    if (p < end && ((*p | 0x20) == 'e')) {
      has_exp = 1;
      ++p;
      /* Optional sign */
      p += (p < end && (*p == '+' || *p == '-'));
      /* Must have at least one digit in exponent */
      if (p >= end || ((size_t)(*p - '0') >= 10))
        return FIO___HTTP_BODY_PRIM_STRING;
      while (p < end && ((size_t)(*p - '0') < 10))
        ++p;
    }

    /* If we didn't consume all characters, it's not a valid number */
    if (p != end)
      return FIO___HTTP_BODY_PRIM_STRING;

    /* Parse and return appropriate type */
    if (has_dot || has_exp) {
      if (f_out) {
        char *parse_ptr = str.buf;
        *f_out = fio_atof(&parse_ptr);
      }
      return FIO___HTTP_BODY_PRIM_FLOAT;
    }

    /* Integer */
    if (i_out) {
      char *parse_ptr = str.buf;
      *i_out = fio_atol10(&parse_ptr);
    }
    return FIO___HTTP_BODY_PRIM_NUMBER;
  }
}

/* *****************************************************************************
HTTP Body Parsing - Content-Type Detection
***************************************************************************** */

/** Content-type enum for body parsing. */
typedef enum {
  FIO___HTTP_BODY_CONTENT_TYPE_UNKNOWN = 0,
  FIO___HTTP_BODY_CONTENT_TYPE_JSON,
  FIO___HTTP_BODY_CONTENT_TYPE_URLENCODED,
  FIO___HTTP_BODY_CONTENT_TYPE_MULTIPART,
} fio___http_body_content_type_e;

/** Detects the content type from the Content-Type header. */
FIO_SFUNC fio___http_body_content_type_e
fio___http_body_detect_content_type(fio_http_s *h) {
  fio_str_info_s ct =
      fio_http_request_header(h, FIO_STR_INFO2((char *)"content-type", 12), 0);
  if (!ct.len)
    return FIO___HTTP_BODY_CONTENT_TYPE_UNKNOWN;

  /* application/json */
  if (ct.len >= 16) {
    /* Check for "application/json" (case-insensitive for "application") */
    uint64_t w0 = fio_buf2u64u(ct.buf) | 0x2020202020202020ULL;
    uint64_t w1 = fio_buf2u64u(ct.buf + 8) | 0x2020202020202020ULL;
    if (w0 == (fio_buf2u64u("applicat") | 0x2020202020202020ULL) &&
        w1 == (fio_buf2u64u("ion/json") | 0x2020202020202020ULL))
      return FIO___HTTP_BODY_CONTENT_TYPE_JSON;
  }

  /* application/x-www-form-urlencoded */
  if (ct.len >= 33) {
    uint64_t w0 = fio_buf2u64u(ct.buf) | 0x2020202020202020ULL;
    uint64_t w1 = fio_buf2u64u(ct.buf + 8) | 0x2020202020202020ULL;
    uint64_t w2 = fio_buf2u64u(ct.buf + 16) | 0x2020202020202020ULL;
    uint64_t w3 = fio_buf2u64u(ct.buf + 24) | 0x2020202020202020ULL;
    if (w0 == (fio_buf2u64u("applicat") | 0x2020202020202020ULL) &&
        w1 == (fio_buf2u64u("ion/x-ww") | 0x2020202020202020ULL) &&
        w2 == (fio_buf2u64u("w-form-u") | 0x2020202020202020ULL) &&
        w3 == (fio_buf2u64u("rlencod") | 0x2020202020202020ULL))
      return FIO___HTTP_BODY_CONTENT_TYPE_URLENCODED;
  }

  /* multipart/form-data */
  if (ct.len >= 19) {
    uint64_t w0 = fio_buf2u64u(ct.buf) | 0x2020202020202020ULL;
    uint64_t w1 = fio_buf2u64u(ct.buf + 8) | 0x2020202020202020ULL;
    if (w0 == (fio_buf2u64u("multipar") | 0x2020202020202020ULL) &&
        w1 == (fio_buf2u64u("t/form-d") | 0x2020202020202020ULL) &&
        ((fio_buf2u16u(ct.buf + 16) | 0x2020) ==
         (fio_buf2u16u("at") | 0x2020)) &&
        ((ct.buf[18] | 0x20) == 'a'))
      return FIO___HTTP_BODY_CONTENT_TYPE_MULTIPART;
  }

  return FIO___HTTP_BODY_CONTENT_TYPE_UNKNOWN;
}

/* *****************************************************************************
HTTP Body Parsing - Stub Implementations
***************************************************************************** */

/* *****************************************************************************
JSON Body Parsing - Adapter Implementation
***************************************************************************** */

/**
 * Wrapper struct to hold HTTP body parse context for JSON adapter callbacks.
 * We use a thread-local to pass context since JSON callbacks don't have udata.
 */
typedef struct {
  const fio_http_body_parse_callbacks_s *callbacks;
  void *udata;
} fio___http_json_adapter_s;

/** Thread-local adapter context - the JSON parser callbacks don't have udata */
static __thread fio___http_json_adapter_s *fio___http_json_adapter_ctx;

/* --- JSON to HTTP body adapter callbacks --- */

FIO_SFUNC void *fio___http_json_on_null(void) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->on_null)
    return NULL;
  return a->callbacks->on_null(a->udata);
}

FIO_SFUNC void *fio___http_json_on_true(void) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->on_true)
    return NULL;
  return a->callbacks->on_true(a->udata);
}

FIO_SFUNC void *fio___http_json_on_false(void) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->on_false)
    return NULL;
  return a->callbacks->on_false(a->udata);
}

FIO_SFUNC void *fio___http_json_on_number(int64_t i) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->on_number)
    return NULL;
  return a->callbacks->on_number(a->udata, i);
}

FIO_SFUNC void *fio___http_json_on_float(double f) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->on_float)
    return NULL;
  return a->callbacks->on_float(a->udata, f);
}

/** Escaped string - needs unescaping before passing to callback */
FIO_SFUNC void *fio___http_json_on_string(const void *start, size_t len) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->on_string)
    return NULL;
  /* Unescape JSON string */
  fio_str_info_s unescaped = {0};
  fio_string_write_unescape(&unescaped, FIO_STRING_REALLOC, start, len);
  void *result =
      a->callbacks->on_string(a->udata, unescaped.buf, unescaped.len);
  FIO_STRING_FREE(unescaped.buf);
  return result;
}

/** Simple (unescaped) string - pass through directly */
FIO_SFUNC void *fio___http_json_on_string_simple(const void *start,
                                                 size_t len) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->on_string)
    return NULL;
  return a->callbacks->on_string(a->udata, start, len);
}

/**
 * Note: The JSON parser manages parent-child relationships via map_push/
 * array_push callbacks. The `parent` parameter is passed as NULL since the
 * JSON parser handles nesting internally and will call map_set/array_push
 * with the correct container.
 */
FIO_SFUNC void *fio___http_json_on_map(void *ctx, void *at) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->on_map)
    return NULL;
  return a->callbacks->on_map(a->udata, NULL);
  (void)ctx;
  (void)at;
}

FIO_SFUNC void *fio___http_json_on_array(void *ctx, void *at) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->on_array)
    return NULL;
  return a->callbacks->on_array(a->udata, NULL);
  (void)ctx;
  (void)at;
}

FIO_SFUNC int fio___http_json_map_push(void *ctx, void *key, void *value) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->map_set)
    return -1;
  return a->callbacks->map_set(a->udata, ctx, key, value);
}

FIO_SFUNC int fio___http_json_array_push(void *ctx, void *value) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (!a || !a->callbacks->array_push)
    return -1;
  return a->callbacks->array_push(a->udata, ctx, value);
}

FIO_SFUNC int fio___http_json_array_finished(void *ctx) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (a && a->callbacks->array_done)
    a->callbacks->array_done(a->udata, ctx);
  return 0;
}

FIO_SFUNC int fio___http_json_map_finished(void *ctx) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (a && a->callbacks->map_done)
    a->callbacks->map_done(a->udata, ctx);
  return 0;
}

FIO_SFUNC void fio___http_json_free_unused(void *ctx) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (a && a->callbacks->free_unused)
    a->callbacks->free_unused(a->udata, ctx);
}

FIO_SFUNC void *fio___http_json_on_error(void *ctx) {
  fio___http_json_adapter_s *a = fio___http_json_adapter_ctx;
  if (a && a->callbacks->on_error)
    return a->callbacks->on_error(a->udata, ctx);
  return NULL;
}

/** Static callback adapter mapping JSON parser to HTTP body parse callbacks */
static fio_json_parser_callbacks_s fio___http_json_adapter_callbacks = {
    .on_null = fio___http_json_on_null,
    .on_true = fio___http_json_on_true,
    .on_false = fio___http_json_on_false,
    .on_number = fio___http_json_on_number,
    .on_float = fio___http_json_on_float,
    .on_string = fio___http_json_on_string,
    .on_string_simple = fio___http_json_on_string_simple,
    .on_map = fio___http_json_on_map,
    .on_array = fio___http_json_on_array,
    .map_push = fio___http_json_map_push,
    .array_push = fio___http_json_array_push,
    .array_finished = fio___http_json_array_finished,
    .map_finished = fio___http_json_map_finished,
    .free_unused_object = fio___http_json_free_unused,
    .on_error = fio___http_json_on_error,
};

FIO_SFUNC fio_http_body_parse_result_s
fio___http_body_parse_json(fio_http_s *h,
                           const fio_http_body_parse_callbacks_s *callbacks,
                           void *udata) {
  fio_http_body_parse_result_s result = {.result = NULL,
                                         .consumed = 0,
                                         .err = 0};

  /* Seek to body start */
  fio_http_body_seek(h, 0);

  /* Read entire body */
  fio_str_info_s body = fio_http_body_read(h, (size_t)-1);
  if (!body.len || !body.buf) {
    /* Empty body - not necessarily an error, but nothing to parse */
    return result;
  }

  /* Set up thread-local adapter context */
  fio___http_json_adapter_s adapter = {
      .callbacks = callbacks,
      .udata = udata,
  };
  fio___http_json_adapter_s *old_ctx = fio___http_json_adapter_ctx;
  fio___http_json_adapter_ctx = &adapter;

  /* Parse JSON */
  fio_json_result_s json_result =
      fio_json_parse(&fio___http_json_adapter_callbacks, body.buf, body.len);

  /* Restore old context */
  fio___http_json_adapter_ctx = old_ctx;

  /* Map results */
  result.result = json_result.ctx;
  result.consumed = json_result.stop_pos;
  result.err = json_result.err;

  return result;
}

/* *****************************************************************************
URL-Encoded Body Parsing - Adapter Implementation
***************************************************************************** */

/** Adapter context for URL-encoded parsing. */
typedef struct {
  const fio_http_body_parse_callbacks_s *callbacks;
  void *udata;
  void *map;
  int err;
} fio___http_urlenc_adapter_s;

/** Adapter callback for URL-encoded on_pair. */
FIO_SFUNC void *fio___http_urlenc_on_pair(void *udata_,
                                          fio_buf_info_s name,
                                          fio_buf_info_s value) {
  fio___http_urlenc_adapter_s *a = (fio___http_urlenc_adapter_s *)udata_;
  if (!a || a->err || !a->callbacks)
    return NULL;

  const fio_http_body_parse_callbacks_s *cb = a->callbacks;

  /* Decode name */
  FIO_STR_INFO_TMP_VAR(decoded_name, 1024);
  fio_string_write_url_dec(&decoded_name,
                           FIO_STRING_REALLOC,
                           name.buf,
                           name.len);

  /* Decode value */
  FIO_STR_INFO_TMP_VAR(decoded_value, 4096);
  fio_string_write_url_dec(&decoded_value,
                           FIO_STRING_REALLOC,
                           value.buf,
                           value.len);

  /* Create key string object */
  void *key_obj = NULL;
  if (cb->on_string) {
    key_obj = cb->on_string(a->udata, decoded_name.buf, decoded_name.len);
  }

  /* Create value object - attempt primitive detection */
  void *value_obj = NULL;
  int64_t i_val = 0;
  double f_val = 0.0;
  fio___http_body_primitive_e prim =
      fio___http_body_identify_primitive(FIO_STR2BUF_INFO(decoded_value),
                                         &i_val,
                                         &f_val);

  switch (prim) {
  case FIO___HTTP_BODY_PRIM_NULL:
    if (cb->on_null)
      value_obj = cb->on_null(a->udata);
    break;
  case FIO___HTTP_BODY_PRIM_TRUE:
    if (cb->on_true)
      value_obj = cb->on_true(a->udata);
    break;
  case FIO___HTTP_BODY_PRIM_FALSE:
    if (cb->on_false)
      value_obj = cb->on_false(a->udata);
    break;
  case FIO___HTTP_BODY_PRIM_NUMBER:
    if (cb->on_number)
      value_obj = cb->on_number(a->udata, i_val);
    break;
  case FIO___HTTP_BODY_PRIM_FLOAT:
    if (cb->on_float)
      value_obj = cb->on_float(a->udata, f_val);
    break;
  case FIO___HTTP_BODY_PRIM_STRING: /* fall through */
  default:
    if (cb->on_string)
      value_obj = cb->on_string(a->udata, decoded_value.buf, decoded_value.len);
    break;
  }

  /* Insert into map */
  if (a->map && cb->map_set) {
    int set_err = cb->map_set(a->udata, a->map, key_obj, value_obj);
    if (set_err) {
      /* On error, free unused objects if possible */
      if (cb->free_unused) {
        if (key_obj)
          cb->free_unused(a->udata, key_obj);
        if (value_obj)
          cb->free_unused(a->udata, value_obj);
      }
      a->err = 1;
    }
  } else {
    /* No map or no map_set - free created objects */
    if (cb->free_unused) {
      if (key_obj)
        cb->free_unused(a->udata, key_obj);
      if (value_obj)
        cb->free_unused(a->udata, value_obj);
    }
  }

  /* Free decoded buffers if they were reallocated */
  if (FIO_STR_INFO_TMP_IS_REALLOCATED(decoded_name))
    FIO_STRING_FREE(decoded_name.buf);
  if (FIO_STR_INFO_TMP_IS_REALLOCATED(decoded_value))
    FIO_STRING_FREE(decoded_value.buf);

  /* Return non-NULL to continue parsing, NULL to stop */
  return a->err ? NULL : a;
}

/** Adapter callback for URL-encoded on_error (optional). */
FIO_SFUNC void fio___http_urlenc_on_error(void *udata_) {
  fio___http_urlenc_adapter_s *a = (fio___http_urlenc_adapter_s *)udata_;
  if (a)
    a->err = 1;
}

/** Static adapter callbacks for URL-encoded parsing. */
static const fio_url_encoded_parser_callbacks_s
    fio___http_urlenc_adapter_callbacks = {
        .on_pair = fio___http_urlenc_on_pair,
        .on_error = fio___http_urlenc_on_error,
};

FIO_SFUNC fio_http_body_parse_result_s fio___http_body_parse_urlencoded(
    fio_http_s *h,
    const fio_http_body_parse_callbacks_s *callbacks,
    void *udata) {
  fio_http_body_parse_result_s result = {.result = NULL,
                                         .consumed = 0,
                                         .err = 0};

  if (!callbacks) {
    result.err = -1;
    return result;
  }

  /* Seek to body start */
  fio_http_body_seek(h, 0);

  /* Read entire body */
  fio_str_info_s body = fio_http_body_read(h, (size_t)-1);
  if (!body.len || !body.buf) {
    /* Empty body - return empty map or nothing */
    if (callbacks->on_map) {
      result.result = callbacks->on_map(udata, NULL);
      if (result.result && callbacks->map_done)
        callbacks->map_done(udata, result.result);
    }
    return result;
  }

  /* Create the top-level map container */
  void *map = NULL;
  if (callbacks->on_map) {
    map = callbacks->on_map(udata, NULL);
    if (!map) {
      result.err = -1;
      return result;
    }
  }

  /* Set up adapter context */
  fio___http_urlenc_adapter_s adapter = {
      .callbacks = callbacks,
      .udata = udata,
      .map = map,
      .err = 0,
  };

  /* Parse URL-encoded data */
  fio_url_encoded_result_s urlenc_result =
      fio_url_encoded_parse(&fio___http_urlenc_adapter_callbacks,
                            &adapter,
                            body.buf,
                            body.len);

  /* Map results */
  result.consumed = urlenc_result.consumed;
  result.err = adapter.err ? -1 : urlenc_result.err;

  /* Finalize the map */
  if (map) {
    if (result.err && callbacks->on_error) {
      result.result = callbacks->on_error(udata, map);
    } else {
      if (callbacks->map_done)
        callbacks->map_done(udata, map);
      result.result = map;
    }
  }

  return result;
}

/* *****************************************************************************
Multipart Body Parsing - Adapter Context
***************************************************************************** */

/** Context passed to multipart parser callbacks. */
typedef struct {
  const fio_http_body_parse_callbacks_s *callbacks;
  void *udata;
  void *map;         /* The result map being built */
  void *current_key; /* Key for current field (string object) */
  int err;           /* Error flag */
} fio___http_multipart_adapter_s;

/* *****************************************************************************
Multipart Body Parsing - Adapter Callbacks
***************************************************************************** */

/** Called for each regular form field (complete value). */
FIO_SFUNC void *fio___http_multipart_on_field(void *udata,
                                              fio_buf_info_s name,
                                              fio_buf_info_s value,
                                              fio_buf_info_s content_type) {
  fio___http_multipart_adapter_s *a = (fio___http_multipart_adapter_s *)udata;
  if (!a || a->err || !a->callbacks)
    return NULL;

  /* Create key string from field name */
  void *key = NULL;
  if (a->callbacks->on_string)
    key = a->callbacks->on_string(a->udata, name.buf, name.len);
  if (!key)
    return NULL;

  /* Create value string */
  void *val = NULL;
  if (a->callbacks->on_string)
    val = a->callbacks->on_string(a->udata, value.buf, value.len);

  if (!val) {
    if (a->callbacks->free_unused)
      a->callbacks->free_unused(a->udata, key);
    return NULL;
  }

  /* Insert into map */
  if (a->map && a->callbacks->map_set) {
    if (a->callbacks->map_set(a->udata, a->map, key, val)) {
      a->err = -1;
      if (a->callbacks->free_unused) {
        a->callbacks->free_unused(a->udata, key);
        a->callbacks->free_unused(a->udata, val);
      }
    }
  } else {
    /* No map - free the objects */
    if (a->callbacks->free_unused) {
      a->callbacks->free_unused(a->udata, key);
      a->callbacks->free_unused(a->udata, val);
    }
  }

  (void)content_type;
  return NULL;
}

/** Called when a file upload starts. */
FIO_SFUNC void *fio___http_multipart_on_file_start(
    void *udata,
    fio_buf_info_s name,
    fio_buf_info_s filename,
    fio_buf_info_s content_type) {
  fio___http_multipart_adapter_s *a = (fio___http_multipart_adapter_s *)udata;
  if (!a || a->err || !a->callbacks)
    return NULL;

  /* Store key for later insertion */
  if (a->callbacks->on_string)
    a->current_key = a->callbacks->on_string(a->udata, name.buf, name.len);

  /* Call user's on_file callback */
  void *file_ctx = NULL;
  if (a->callbacks->on_file) {
    fio_str_info_s name_s = {.buf = name.buf, .len = name.len};
    fio_str_info_s filename_s = {.buf = filename.buf, .len = filename.len};
    fio_str_info_s ct_s = {.buf = content_type.buf, .len = content_type.len};
    file_ctx = a->callbacks->on_file(a->udata, name_s, filename_s, ct_s);
  }

  return file_ctx;
}

/** Called with file data chunk. */
FIO_SFUNC int fio___http_multipart_on_file_data(void *udata,
                                                void *file_ctx,
                                                fio_buf_info_s data) {
  fio___http_multipart_adapter_s *a = (fio___http_multipart_adapter_s *)udata;
  if (!a || a->err || !a->callbacks)
    return -1;

  if (a->callbacks->on_file_data)
    return a->callbacks->on_file_data(a->udata, file_ctx, data);

  return 0;
}

/** Called when file upload ends. */
FIO_SFUNC void fio___http_multipart_on_file_end(void *udata, void *file_ctx) {
  fio___http_multipart_adapter_s *a = (fio___http_multipart_adapter_s *)udata;
  if (!a || !a->callbacks)
    return;

  /* Notify user that file is done */
  if (a->callbacks->on_file_done)
    a->callbacks->on_file_done(a->udata, file_ctx);

  /* Insert file handle into map with stored key */
  if (a->map && a->current_key && file_ctx && a->callbacks->map_set) {
    if (a->callbacks->map_set(a->udata, a->map, a->current_key, file_ctx)) {
      a->err = -1;
      if (a->callbacks->free_unused) {
        a->callbacks->free_unused(a->udata, a->current_key);
        a->callbacks->free_unused(a->udata, file_ctx);
      }
    }
  } else if (a->current_key && a->callbacks->free_unused) {
    /* No map or no file_ctx - free the key */
    a->callbacks->free_unused(a->udata, a->current_key);
  }
  a->current_key = NULL;
}

/** Called on parse error. */
FIO_SFUNC void fio___http_multipart_on_error(void *udata) {
  fio___http_multipart_adapter_s *a = (fio___http_multipart_adapter_s *)udata;
  if (a)
    a->err = -1;
}

/** Static callback adapter mapping multipart parser to HTTP body parse. */
static const fio_multipart_parser_callbacks_s
    fio___http_multipart_adapter_callbacks = {
        .on_field = fio___http_multipart_on_field,
        .on_file_start = fio___http_multipart_on_file_start,
        .on_file_data = fio___http_multipart_on_file_data,
        .on_file_end = fio___http_multipart_on_file_end,
        .on_error = fio___http_multipart_on_error,
};

/* *****************************************************************************
Multipart Body Parsing - Helper: Extract boundary from Content-Type
***************************************************************************** */

/**
 * Extracts the boundary parameter from a Content-Type header value.
 * Returns empty fio_buf_info_s if boundary not found.
 */
FIO_SFUNC fio_buf_info_s
fio___http_multipart_extract_boundary(fio_str_info_s content_type) {
  fio_buf_info_s boundary = FIO_BUF_INFO0;
  if (!content_type.buf || !content_type.len)
    return boundary;

  /* Search for "boundary=" (case-insensitive search for parameter) */
  const char *p = content_type.buf;
  const char *end = content_type.buf + content_type.len;

  while (p < end) {
    /* Skip to next semicolon or start */
    while (p < end && *p != ';')
      ++p;
    if (p >= end)
      break;
    ++p; /* Skip ';' */

    /* Skip whitespace */
    while (p < end && (*p == ' ' || *p == '\t'))
      ++p;

    /* Check for "boundary" (case-insensitive, 8 chars) */
    if ((size_t)(end - p) >= 9) { /* "boundary=" is 9 chars */
      char c0 = p[0] | 0x20;
      char c1 = p[1] | 0x20;
      char c2 = p[2] | 0x20;
      char c3 = p[3] | 0x20;
      char c4 = p[4] | 0x20;
      char c5 = p[5] | 0x20;
      char c6 = p[6] | 0x20;
      char c7 = p[7] | 0x20;
      if (c0 == 'b' && c1 == 'o' && c2 == 'u' && c3 == 'n' && c4 == 'd' &&
          c5 == 'a' && c6 == 'r' && c7 == 'y' && p[8] == '=') {
        p += 9; /* Skip "boundary=" */

        /* Skip optional whitespace after '=' */
        while (p < end && (*p == ' ' || *p == '\t'))
          ++p;

        if (p >= end)
          break;

        /* Extract value - quoted or unquoted */
        if (*p == '"') {
          ++p;
          const char *value_start = p;
          while (p < end && *p != '"')
            ++p;
          boundary.buf = (char *)value_start;
          boundary.len = (size_t)(p - value_start);
        } else {
          const char *value_start = p;
          while (p < end && *p != ';' && *p != ' ' && *p != '\t' &&
                 *p != '\r' && *p != '\n')
            ++p;
          boundary.buf = (char *)value_start;
          boundary.len = (size_t)(p - value_start);
        }
        break;
      }
    }
  }

  return boundary;
}

/* *****************************************************************************
Multipart Body Parsing - Main Implementation
***************************************************************************** */

FIO_SFUNC fio_http_body_parse_result_s fio___http_body_parse_multipart(
    fio_http_s *h,
    const fio_http_body_parse_callbacks_s *callbacks,
    void *udata) {
  fio_http_body_parse_result_s result = {.result = NULL,
                                         .consumed = 0,
                                         .err = 0};

  if (!h || !callbacks) {
    result.err = -1;
    return result;
  }

  /* Get Content-Type header to extract boundary */
  fio_str_info_s content_type =
      fio_http_request_header(h, FIO_STR_INFO2((char *)"content-type", 12), 0);

  /* Extract boundary from Content-Type */
  fio_buf_info_s boundary = fio___http_multipart_extract_boundary(content_type);
  if (!boundary.buf || !boundary.len) {
    result.err = -1;
    if (callbacks->on_error)
      result.result = callbacks->on_error(udata, NULL);
    return result;
  }

  /* Seek to body start */
  fio_http_body_seek(h, 0);

  /* Read entire body */
  fio_str_info_s body = fio_http_body_read(h, (size_t)-1);
  if (!body.len || !body.buf) {
    /* Empty body - not necessarily an error */
    return result;
  }

  /* Create result map */
  void *map = NULL;
  if (callbacks->on_map)
    map = callbacks->on_map(udata, NULL);

  /* Set up adapter context */
  fio___http_multipart_adapter_s adapter = {
      .callbacks = callbacks,
      .udata = udata,
      .map = map,
      .current_key = NULL,
      .err = 0,
  };

  /* Parse multipart data */
  fio_multipart_result_s mp_result =
      fio_multipart_parse(&fio___http_multipart_adapter_callbacks,
                          &adapter,
                          boundary,
                          body.buf,
                          body.len);

  /* Check for errors */
  if (mp_result.err || adapter.err) {
    result.err = mp_result.err ? mp_result.err : adapter.err;
    if (callbacks->on_error)
      result.result = callbacks->on_error(udata, map);
    else
      result.result = map; /* Return partial result */
    result.consumed = mp_result.consumed;
    return result;
  }

  /* Finalize map */
  if (map && callbacks->map_done)
    callbacks->map_done(udata, map);

  result.result = map;
  result.consumed = mp_result.consumed;
  return result;
}

/* *****************************************************************************
HTTP Body Parsing - Main Implementation
***************************************************************************** */

/**
 * Parses the HTTP request body, auto-detecting content type.
 *
 * Supports JSON, URL-encoded, and multipart/form-data bodies.
 * Calls the appropriate callbacks for each element found.
 */
SFUNC fio_http_body_parse_result_s
fio_http_body_parse(fio_http_s *h,
                    const fio_http_body_parse_callbacks_s *callbacks,
                    void *udata) {
  fio_http_body_parse_result_s result = {.result = NULL,
                                         .consumed = 0,
                                         .err = 0};

  if (!h || !callbacks) {
    result.err = -1;
    return result;
  }

  /* Detect content type from header */
  fio___http_body_content_type_e content_type =
      fio___http_body_detect_content_type(h);

  /* Route to appropriate parser */
  switch (content_type) {
  case FIO___HTTP_BODY_CONTENT_TYPE_JSON:
    return fio___http_body_parse_json(h, callbacks, udata);

  case FIO___HTTP_BODY_CONTENT_TYPE_URLENCODED:
    return fio___http_body_parse_urlencoded(h, callbacks, udata);

  case FIO___HTTP_BODY_CONTENT_TYPE_MULTIPART:
    return fio___http_body_parse_multipart(h, callbacks, udata);

  case FIO___HTTP_BODY_CONTENT_TYPE_UNKNOWN: /* fall through */
  default:
    /* Unknown content type - return error */
    result.err = -1;
    if (callbacks->on_error)
      result.result = callbacks->on_error(udata, NULL);
    return result;
  }
}

/* *****************************************************************************


                                TODO WIP Marker!!!


***************************************************************************** */

/* *****************************************************************************
Static file helper
***************************************************************************** */

/**
 * Attempts to send a static file from the `root` folder. On success the
 * response is complete and 0 is returned. Otherwise returns -1.
 */
SFUNC int fio_http_static_file_response(fio_http_s *h,
                                        fio_str_info_s rt,
                                        fio_str_info_s fnm,
                                        size_t max_age) {
  int fd = -1;
  size_t file_length = 0;
  /* combine public folder with path to get file name */
  fio_str_info_s mime_type = {0};
  FIO_STR_INFO_TMP_VAR(etag, 31);
  FIO_STR_INFO_TMP_VAR(filename, 4095);
  { /* test for HEAD and OPTIONS requests */
    fio_str_info_s m = fio_keystr_info(&h->method);
    if ((m.len == 7 && (fio_buf2u64u(m.buf) | 0x2020202020202020ULL) ==
                           (fio_buf2u64u("options") | 0x2020202020202020ULL)))
      goto file_not_found;
  }
  rt.len -= ((rt.len > 0) && (fnm.len > 0 && fnm.buf[0] == '/') &&
             (rt.buf[rt.len - 1] == '/' ||
              rt.buf[rt.len - 1] == FIO_FOLDER_SEPARATOR));
  fio_string_write(&filename, NULL, rt.buf, rt.len);
  fio_string_write_url_dec(&filename, NULL, fnm.buf, fnm.len);
  if (fio_filename_is_unsafe_url(filename.buf))
    goto file_not_found;

  { /* Test for incomplete file name */
    size_t file_type = fio_filename_type(filename.buf);
#if defined(S_IFDIR) && defined(FIO_HTTP_DEFAULT_INDEX_FILENAME)
    if (file_type == S_IFDIR) {
      filename.len -= (filename.buf[filename.len - 1] == '/' ||
                       filename.buf[filename.len - 1] == FIO_FOLDER_SEPARATOR);
#if FIO_HTTP_STATIC_FILE_COMPLETION
      fio_string_write(&filename,
                       NULL,
                       "/" FIO_HTTP_DEFAULT_INDEX_FILENAME,
                       sizeof(FIO_HTTP_DEFAULT_INDEX_FILENAME));
      file_type = 0;
#else
      fio_string_write(
          &filename,
          NULL, /* note that sizeof will count NUL, so we skip 1 char: */
          "/" FIO_HTTP_DEFAULT_INDEX_FILENAME ".html",
          sizeof(FIO_HTTP_DEFAULT_INDEX_FILENAME ".html"));
      file_type = fio_filename_type(filename.buf);
#endif /* FIO_HTTP_STATIC_FILE_COMPLETION */
    }
#endif /* S_IFDIR */
#if FIO_HTTP_STATIC_FILE_COMPLETION
    const fio_buf_info_s extensions[] = {FIO_BUF_INFO1((char *)".html"),
                                         FIO_BUF_INFO1((char *)".htm"),
                                         FIO_BUF_INFO1((char *)".txt"),
                                         FIO_BUF_INFO1((char *)".md"),
                                         FIO_BUF_INFO0};
    const fio_buf_info_s *pext = extensions;
    while (!file_type) {
      fio_string_write(&filename, NULL, pext->buf, pext->len);
      file_type = fio_filename_type(filename.buf);
      if (file_type)
        break;
      filename.len -= pext->len;
      ++pext;
      if (!pext->buf)
        goto file_not_found;
    }
    switch (file_type) {
    case S_IFREG: break;
#ifdef S_IFLNK
    case S_IFLNK: break;
#endif
    default: goto file_not_found;
    }
#else  /* FIO_HTTP_STATIC_FILE_COMPLETION */
    if (!file_type)
      goto file_not_found;
#endif /* FIO_HTTP_STATIC_FILE_COMPLETION */
  }
  {
    /* find mime type if registered */
    char *end = filename.buf + filename.len;
    char *ext = end;
    do {
      --ext;
    } while (ext[0] != '.' && ext[0] != '/');
    if ((ext++)[0] == '.') {
      mime_type = fio_http_mimetype(ext, end - ext);
      if (!mime_type.len)
        FIO_LOG_WARNING("missing mime-type for extension %s (not registered).",
                        ext);
    }
  }
  {
    fio_str_info_s ac =
        fio_http_request_header(h,
                                FIO_STR_INFO2((char *)"accept-encoding", 15),
                                0);
    if (!ac.len)
      goto accept_encoding_header_test_done;
    struct {
      char *value;
      fio_buf_info_s ext;
    } options[] = {{(char *)"br", FIO_BUF_INFO2((char *)".br", 3)},
                   {(char *)"zstd", FIO_BUF_INFO2((char *)".zstd", 4)},
                   {(char *)"gzip", FIO_BUF_INFO2((char *)".gz", 3)},
                   {(char *)"deflate", FIO_BUF_INFO2((char *)".zip", 4)},
                   {NULL}};
    for (size_t i = 0; options[i].value; ++i) {
      if (!strstr(ac.buf, options[i].value))
        continue;
      fio_string_write(&filename, NULL, options[i].ext.buf, options[i].ext.len);
      if (!fio_filename_type(filename.buf)) {
        filename.len -= options[i].ext.len;
        filename.buf[filename.len] = 0;
        continue;
      }
      fio_http_response_header_set(
          h,
          FIO_STR_INFO2((char *)"vary", 4),
          FIO_STR_INFO2((char *)"accept-encoding", 15));
      fio_http_response_header_set(
          h,
          FIO_STR_INFO2((char *)"content-encoding", 16),
          FIO_STR_INFO1(options[i].value));
      break;
    }
  }

accept_encoding_header_test_done:
  /* attempt to open file */
  fd = fio_filename_open(filename.buf, O_RDONLY);
  if (fd == -1)
    goto file_not_found;

  { /* test / validate etag */
    struct stat stt;
    if (fstat(fd, &stt))
      goto file_not_found;
    uint64_t etag_hash = fio_risky_hash(&stt, sizeof(stt), 0);
    fio_string_write_hex(&etag, NULL, etag_hash);
    fio_http_response_header_set(h, FIO_STR_INFO2((char *)"etag", 4), etag);
    filename.len = 0;
    filename.len = fio_time2rfc7231(filename.buf, stt.st_mtime);
    fio_http_response_header_set(h,
                                 FIO_STR_INFO1((char *)"last-modified"),
                                 filename);
    if (max_age) {
      filename.len = 0;
      fio_string_write2(&filename,
                        NULL,
                        FIO_STRING_WRITE_STR2("max-age=", 8),
                        FIO_STRING_WRITE_UNUM(max_age));
      fio_http_response_header_set(h,
                                   FIO_STR_INFO1((char *)"cache-control"),
                                   filename);
    }
    file_length = stt.st_size;
    filename.capa = 0;
    if (fio___http_response_etag_if_none_match(h))
      return 0;
  }
  /* test for range requests. */
  {
    /* test / validate range requests */
    fio_str_info_s rng =
        fio_http_request_header(h, FIO_STR_INFO2((char *)"range", 5), 0);
    if (!rng.len)
      goto range_request_review_finished;
    {
      fio_str_info_s ifrng =
          fio_http_request_header(h, FIO_STR_INFO2((char *)"if-range", 8), 0);
      if (ifrng.len && !FIO_STR_INFO_IS_EQ(ifrng, etag))
        goto range_request_review_finished;
    }
    if (rng.len < 7 || fio_buf2u32u(rng.buf) != fio_buf2u32u("byte") ||
        fio_buf2u16u(rng.buf + 4) != fio_buf2u16u("s="))
      goto range_request_review_finished;
    char *ipos = rng.buf + 6;
    size_t start_range = fio_atol10u(&ipos);
    if (ipos == rng.buf + 6)
      start_range = (size_t)-1;
    if (*ipos != '-')
      goto range_request_review_finished;
    ++ipos;
    size_t end_range = fio_atol10u(&ipos);
    if (end_range > file_length)
      goto range_request_review_finished;
    if (!end_range)
      end_range = file_length - 1;
    if (start_range == (size_t)-1) {
      start_range = file_length - end_range;
      end_range = file_length - 1;
    }
    if (start_range > end_range || end_range > file_length)
      goto invalid_range;
    if (!start_range && end_range + 1 == file_length)
      goto range_request_review_finished;
    /* update response headers and info */
    h->status = 206;
    filename.len = 0;
    filename.capa = 1024;
    fio_string_write2(&filename,
                      NULL,
                      FIO_STRING_WRITE_STR2("bytes ", 6),
                      FIO_STRING_WRITE_UNUM(start_range),
                      FIO_STRING_WRITE_STR2("-", 1),
                      FIO_STRING_WRITE_UNUM((end_range)),
                      FIO_STRING_WRITE_STR2("/", 1),
                      FIO_STRING_WRITE_UNUM(file_length));
    fio_http_response_header_set(h,
                                 FIO_STR_INFO2((char *)"content-range", 13),
                                 filename);
    file_length = (end_range - start_range) + 1;
    filename.capa = start_range;
    fio_http_response_header_set(h,
                                 FIO_STR_INFO2((char *)"etag", 4),
                                 FIO_STR_INFO2(NULL, 0));
  }

range_request_review_finished:
  /* allow interrupted downloads to resume */
  fio_http_response_header_set(h,
                               FIO_STR_INFO2((char *)"accept-ranges", 13),
                               FIO_STR_INFO2((char *)"bytes", 5));
  /* test for HEAD requests */
  {
    fio_str_info_s m = fio_keystr_info(&h->method);
    if ((m.len == 4 && (fio_buf2u32u(m.buf) | 0x20202020UL) ==
                           (fio_buf2u32u("head") | 0x20202020UL)))
      goto head_request;
  }

  /* finish up (set mime type and send file) */
  if (mime_type.len)
    fio_http_response_header_set(h,
                                 FIO_STR_INFO2((char *)"content-type", 12),
                                 mime_type);
  { /* send response (avoid macro for C++ compatibility) */
    fio_http_write_args_s args = {
        .len = file_length,
        .offset = filename.capa, /* now holds starting offset */
        .fd = fd,
        .finish = 1};
    fio_http_write FIO_NOOP(h, args);
  }
  return 0;

file_not_found:
  if (fd != -1)
    close(fd);
  return -1;

head_request:
  /* TODO! HEAD responses should close?. */
  if (fd != -1)
    close(fd);
  {
    fio_http_write_args_s args = {.finish = 1};
    fio_http_write FIO_NOOP(h, args);
  }
  return 0;

invalid_range:
  filename.len = 0;
  filename.capa = 1024;
  fio_string_write2(&filename,
                    NULL,
                    FIO_STRING_WRITE_STR2("bytes */", 8),
                    FIO_STRING_WRITE_UNUM(file_length));
  fio_http_response_header_set(h,
                               FIO_STR_INFO2((char *)"content-range", 13),
                               filename);
  return fio_http_send_error_response(h, 416);
}

/* *****************************************************************************
Status Strings
***************************************************************************** */

/** Returns a human readable string related to the HTTP status number. */
SFUNC fio_str_info_s fio_http_status2str(size_t status) {
  fio_str_info_s r = {0};
#define HTTP_RETURN_STATUS(str)                                                \
  do {                                                                         \
    r.len = FIO_STRLEN(str);                                                   \
    r.buf = (char *)str;                                                       \
    return r;                                                                  \
  } while (0);
  switch (status) {
  // clang-format off
  case 100: HTTP_RETURN_STATUS("Continue");
  case 101: HTTP_RETURN_STATUS("Switching Protocols");
  case 102: HTTP_RETURN_STATUS("Processing");
  case 103: HTTP_RETURN_STATUS("Early Hints");
  case 110: HTTP_RETURN_STATUS("Response is Stale"); /* caching code*/
  case 111: HTTP_RETURN_STATUS("Re-validation Failed"); /* caching code*/
  case 112: HTTP_RETURN_STATUS("Disconnected Operation"); /* caching code*/
  case 113: HTTP_RETURN_STATUS("Heuristic Expiration"); /* caching code*/
  case 199: HTTP_RETURN_STATUS("Miscellaneous Warning"); /* caching code*/
  case 200: HTTP_RETURN_STATUS("OK");
  case 201: HTTP_RETURN_STATUS("Created");
  case 202: HTTP_RETURN_STATUS("Accepted");
  case 203: HTTP_RETURN_STATUS("Non-Authoritative Information");
  case 204: HTTP_RETURN_STATUS("No Content");
  case 205: HTTP_RETURN_STATUS("Reset Content");
  case 206: HTTP_RETURN_STATUS("Partial Content");
  case 207: HTTP_RETURN_STATUS("Multi-Status");
  case 208: HTTP_RETURN_STATUS("Already Reported");
  case 214: HTTP_RETURN_STATUS("Transformation Applied"); /* caching code*/
  case 218: HTTP_RETURN_STATUS("This is fine (Apache Web Server)"); /* unofficial */
  case 226: HTTP_RETURN_STATUS("IM Used");
  case 299: HTTP_RETURN_STATUS("Miscellaneous Persistent Warning"); /* caching code*/
  case 300: HTTP_RETURN_STATUS("Multiple Choices");
  case 301: HTTP_RETURN_STATUS("Moved Permanently");
  case 302: HTTP_RETURN_STATUS("Found");
  case 303: HTTP_RETURN_STATUS("See Other");
  case 304: HTTP_RETURN_STATUS("Not Modified");
  case 305: HTTP_RETURN_STATUS("Use Proxy");
  case 307: HTTP_RETURN_STATUS("Temporary Redirect");
  case 308: HTTP_RETURN_STATUS("Permanent Redirect");
  case 400: HTTP_RETURN_STATUS("Bad Request");
  case 401: HTTP_RETURN_STATUS("Unauthorized");
  case 402: HTTP_RETURN_STATUS("Payment Required");
  case 403: HTTP_RETURN_STATUS("Forbidden");
  case 404: HTTP_RETURN_STATUS("Not Found");
  case 405: HTTP_RETURN_STATUS("Method Not Allowed");
  case 406: HTTP_RETURN_STATUS("Not Acceptable");
  case 407: HTTP_RETURN_STATUS("Proxy Authentication Required");
  case 408: HTTP_RETURN_STATUS("Request Timeout");
  case 409: HTTP_RETURN_STATUS("Conflict");
  case 410: HTTP_RETURN_STATUS("Gone");
  case 411: HTTP_RETURN_STATUS("Length Required");
  case 412: HTTP_RETURN_STATUS("Precondition Failed");
  case 413: HTTP_RETURN_STATUS("Content Too Large");
  case 414: HTTP_RETURN_STATUS("URI Too Long");
  case 415: HTTP_RETURN_STATUS("Unsupported Media Type");
  case 416: HTTP_RETURN_STATUS("Range Not Satisfiable");
  case 417: HTTP_RETURN_STATUS("Expectation Failed");
  case 418: HTTP_RETURN_STATUS("I am a Teapot"); /* April Fool's Day, 1998 */
  case 419: HTTP_RETURN_STATUS("Page Expired (Laravel Framework)"); /* unofficial */
  case 420: HTTP_RETURN_STATUS("Enhance Your Calm (Twitter) - Method Failure (Spring Framework)"); /* unofficial */
  case 421: HTTP_RETURN_STATUS("Misdirected Request");
  case 422: HTTP_RETURN_STATUS("Unprocessable Content");
  case 423: HTTP_RETURN_STATUS("Locked");
  case 424: HTTP_RETURN_STATUS("Failed Dependency");
  case 425: HTTP_RETURN_STATUS("Too Early");
  case 426: HTTP_RETURN_STATUS("Upgrade Required");
  case 427: HTTP_RETURN_STATUS("Unassigned");
  case 428: HTTP_RETURN_STATUS("Precondition Required");
  case 429: HTTP_RETURN_STATUS("Too Many Requests");
  case 430: HTTP_RETURN_STATUS("Request Header Fields Too Large (Shopify)"); /* unofficial */
  case 431: HTTP_RETURN_STATUS("Request Header Fields Too Large");
  case 444: HTTP_RETURN_STATUS("No Response"); /* nginx code */
  case 450: HTTP_RETURN_STATUS("Blocked by Windows Parental Controls (Microsoft)"); /* unofficial */
  case 451: HTTP_RETURN_STATUS("Unavailable For Legal Reasons");
  case 494: HTTP_RETURN_STATUS("Request header too large"); /* nginx code */
  case 495: HTTP_RETURN_STATUS("SSL Certificate Error"); /* nginx code */
  case 496: HTTP_RETURN_STATUS("SSL Certificate Required"); /* nginx code */
  case 497: HTTP_RETURN_STATUS("HTTP Request Sent to HTTPS Port"); /* nginx code */
  case 498: HTTP_RETURN_STATUS("Invalid Token (Esri)"); /* unofficial */
  case 499: HTTP_RETURN_STATUS("Client Closed Request"); /* nginx code */
  case 500: HTTP_RETURN_STATUS("Internal Server Error");
  case 501: HTTP_RETURN_STATUS("Not Implemented");
  case 502: HTTP_RETURN_STATUS("Bad Gateway");
  case 503: HTTP_RETURN_STATUS("Service Unavailable");
  case 504: HTTP_RETURN_STATUS("Gateway Timeout");
  case 505: HTTP_RETURN_STATUS("HTTP Version Not Supported");
  case 506: HTTP_RETURN_STATUS("Variant Also Negotiates");
  case 507: HTTP_RETURN_STATUS("Insufficient Storage");
  case 508: HTTP_RETURN_STATUS("Loop Detected");
  case 509: HTTP_RETURN_STATUS("Bandwidth Limit Exceeded (Apache Web Server/cPanel)"); /* unofficial */
  case 510: HTTP_RETURN_STATUS("Not Extended");
  case 511: HTTP_RETURN_STATUS("Network Authentication Required");
  case 529: HTTP_RETURN_STATUS("Site is overloaded (Qualys)"); /* unofficial */
  case 530: HTTP_RETURN_STATUS("Site is frozen (Pantheon web)"); /* unofficial */
  case 598: HTTP_RETURN_STATUS("Network read timeout error"); /* unofficial */
    // clang-format on
  }
  HTTP_RETURN_STATUS("Unknown");
#undef HTTP_RETURN_STATUS
}

/* *****************************************************************************
MIME File Type Helpers
***************************************************************************** */

typedef struct {
  uint64_t ext;
  uint16_t len;
  char mime[118]; /* all together 128 bytes per node */
} fio___http_mime_info_s;

#define FIO___HTTP_MIME_IS_VALID(o) ((o)->ext != 0)
#define FIO___HTTP_MIME_CMP(a, b)   ((a)->ext == (b)->ext)
#define FIO___HTTP_MIME_HASH(o)     fio_risky_num(((o)->ext), 0)

#undef FIO_TYPEDEF_IMAP_REALLOC
#define FIO_TYPEDEF_IMAP_REALLOC(ptr, old_size, new_size, copy_len)            \
  realloc(ptr, new_size)
#undef FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE
#define FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE 0
#undef FIO_TYPEDEF_IMAP_FREE
#define FIO_TYPEDEF_IMAP_FREE(ptr, len) free(ptr)

FIO_TYPEDEF_IMAP_ARRAY(fio___http_mime_map,
                       fio___http_mime_info_s,
                       uint32_t,
                       FIO___HTTP_MIME_HASH,
                       FIO___HTTP_MIME_CMP,
                       FIO___HTTP_MIME_IS_VALID)

static fio___http_mime_map_s FIO___HTTP_MIMETYPES;
#undef FIO___HTTP_MIME_IS_VALID
#undef FIO___HTTP_MIME_CMP
#undef FIO___HTTP_MIME_HASH

#undef FIO_TYPEDEF_IMAP_REALLOC
#define FIO_TYPEDEF_IMAP_REALLOC FIO_MEM_REALLOC
#undef FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE
#define FIO_TYPEDEF_IMAP_REALLOC_IS_SAFE FIO_MEM_REALLOC_IS_SAFE
#undef FIO_TYPEDEF_IMAP_FREE
#define FIO_TYPEDEF_IMAP_FREE FIO_MEM_FREE

/** Registers a Mime-Type to be associated with the file extension. */
SFUNC int fio_http_mimetype_register(char *file_ext,
                                     size_t file_ext_len,
                                     fio_str_info_s mime_type) {
  fio___http_mime_info_s tmp, *old;
  if (file_ext_len > 7 || mime_type.len > 117)
    return -1;
  tmp.ext = 0;
  FIO_MEMCPY(&tmp.ext, file_ext, file_ext_len);
  if (!mime_type.len)
    goto remove_mime;
  FIO_MEMCPY(&tmp.mime, mime_type.buf, mime_type.len);
  tmp.len = mime_type.len;
  tmp.mime[mime_type.len] = 0;
  old = fio___http_mime_map_get(&FIO___HTTP_MIMETYPES, tmp);
  if (old && old->len == tmp.len && !FIO_MEMCMP(old->mime, tmp.mime, tmp.len)) {
    FIO_LOG_WARNING("mime-type collision: %.*s was %s, now %s",
                    (int)file_ext_len,
                    file_ext,
                    old->mime,
                    tmp.mime);
  }
  fio___http_mime_map_set(&FIO___HTTP_MIMETYPES, tmp, 1);
  return 0;

remove_mime:
  return fio___http_mime_map_remove(&FIO___HTTP_MIMETYPES, tmp);
}

/** Finds the Mime-Type associated with the file extension (if registered). */
SFUNC fio_str_info_s fio_http_mimetype(char *file_ext, size_t file_ext_len) {
  fio_str_info_s r = {0};
  fio___http_mime_info_s tmp, *val;
  tmp.ext = 0;
  FIO_MEMCPY(&tmp.ext, file_ext, file_ext_len);
  val = fio___http_mime_map_get(&FIO___HTTP_MIMETYPES, tmp);
  if (!val)
    return r;
  r.len = val->len;
  r.buf = val->mime;
  return r;
}

#define REGISTER_MIME(ext, type)                                               \
  fio_http_mimetype_register((char *)ext,                                      \
                             sizeof(ext) - 1,                                  \
                             FIO_STR_INFO2((char *)type, sizeof(type) - 1))

/** Registers known mime-types that aren't often used by Web Servers. */
FIO_SFUNC void fio_http_mime_register_essential(void) {
  /* clang-format off */
  REGISTER_MIME("3ds", "image/x-3ds");
  REGISTER_MIME("3g2", "video/3gpp");
  REGISTER_MIME("3gp", "video/3gpp");
  REGISTER_MIME("7z", "application/x-7z-compressed");
  REGISTER_MIME("aac", "audio/aac");
  REGISTER_MIME("abw", "application/x-abiword");
  REGISTER_MIME("aif", "audio/x-aiff");
  REGISTER_MIME("aifc", "audio/x-aiff");
  REGISTER_MIME("aiff", "audio/x-aiff");
  REGISTER_MIME("arc", "application/x-freearc");
  REGISTER_MIME("atom", "application/atom+xml");
  REGISTER_MIME("avi", "video/x-msvideo");
  REGISTER_MIME("avif", "image/avif");
  REGISTER_MIME("azw", "application/vnd.amazon.ebook");
  REGISTER_MIME("bin", "application/octet-stream");
  REGISTER_MIME("bmp", "image/bmp");
  REGISTER_MIME("bz", "application/x-bzip");
  REGISTER_MIME("bz2", "application/x-bzip2");
  REGISTER_MIME("cda", "application/x-cdf");
  REGISTER_MIME("csh", "application/x-csh");
  REGISTER_MIME("css", "text/css");
  REGISTER_MIME("csv", "text/csv");
  REGISTER_MIME("dmg", "application/x-apple-diskimage");
  REGISTER_MIME("doc", "application/msword");
  REGISTER_MIME("docx", "application/" "vnd.openxmlformats-officedocument.wordprocessingml.document");
  REGISTER_MIME("eot", "application/vnd.ms-fontobject");
  REGISTER_MIME("epub", "application/epub+zip");
  REGISTER_MIME("gif", "image/gif");
  REGISTER_MIME("gz", "application/gzip");
  REGISTER_MIME("htm", "text/html");
  REGISTER_MIME("html", "text/html");
  REGISTER_MIME("ico", "image/vnd.microsoft.icon");
  REGISTER_MIME("ics", "text/calendar");
  REGISTER_MIME("iso", "application/x-iso9660-image");
  REGISTER_MIME("jar", "application/java-archive");
  REGISTER_MIME("jpe", "image/jpeg");
  REGISTER_MIME("jpeg", "image/jpeg");
  REGISTER_MIME("jpg", "image/jpeg");
  REGISTER_MIME("jpgm", "video/jpm");
  REGISTER_MIME("jpgv", "video/jpeg");
  REGISTER_MIME("jpm", "video/jpm");
  REGISTER_MIME("js", "application/javascript");
  REGISTER_MIME("json", "application/json");
  REGISTER_MIME("jsonld", "application/ld+json");
  REGISTER_MIME("jsonml", "application/jsonml+json");
  REGISTER_MIME("md", "text/markdown");  
  REGISTER_MIME("mid", "audio/midi");
  REGISTER_MIME("midi", "audio/midi");
  REGISTER_MIME("mjs", "text/javascript");
  REGISTER_MIME("mp3", "audio/mpeg");
  REGISTER_MIME("mp4", "video/mp4");
  REGISTER_MIME("m4a", "audio/mp4");
  REGISTER_MIME("m4v", "video/mp4");
  REGISTER_MIME("mpeg", "video/mpeg");
  REGISTER_MIME("mpkg", "application/vnd.apple.installer+xml");
  REGISTER_MIME("odp", "application/vnd.oasis.opendocument.presentation");
  REGISTER_MIME("ods", "application/vnd.oasis.opendocument.spreadsheet");
  REGISTER_MIME("odt", "application/vnd.oasis.opendocument.text");
  REGISTER_MIME("oga", "audio/ogg");
  REGISTER_MIME("ogv", "video/ogg");
  REGISTER_MIME("ogx", "application/ogg");
  REGISTER_MIME("opus", "audio/opus");
  REGISTER_MIME("otf", "font/otf");
  REGISTER_MIME("pdf", "application/pdf");
  REGISTER_MIME("php", "application/x-httpd-php");
  REGISTER_MIME("png", "image/png");
  REGISTER_MIME("ppt", "application/vnd.ms-powerpoint");
  REGISTER_MIME("pptx","application/""vnd.openxmlformats-officedocument.presentationml.presentation");
  REGISTER_MIME("rar", "application/vnd.rar");
  REGISTER_MIME("rtf", "application/rtf");
  REGISTER_MIME("sh", "application/x-sh");
  REGISTER_MIME("svg", "image/svg+xml");
  REGISTER_MIME("svgz", "image/svg+xml");
  REGISTER_MIME("tar", "application/x-tar");
  REGISTER_MIME("tif", "image/tiff");
  REGISTER_MIME("tiff", "image/tiff");
  REGISTER_MIME("ts", "video/mp2t");
  REGISTER_MIME("ttf", "font/ttf");
  REGISTER_MIME("txt", "text/plain");
  REGISTER_MIME("vsd", "application/vnd.visio");
  REGISTER_MIME("wav", "audio/wav");
  REGISTER_MIME("weba", "audio/webm");
  REGISTER_MIME("webm", "video/webm");
  REGISTER_MIME("webp", "image/webp");
  REGISTER_MIME("woff", "font/woff");
  REGISTER_MIME("woff2", "font/woff2");
  REGISTER_MIME("xhtml", "application/xhtml+xml");
  REGISTER_MIME("xls", "application/vnd.ms-excel");
  REGISTER_MIME("xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
  REGISTER_MIME("xml", "application/xml");
  REGISTER_MIME("xul", "application/vnd.mozilla.xul+xml");
  REGISTER_MIME("zip", "application/zip");
  /* clang-format on */
}

#undef REGISTER_MIME

/* *****************************************************************************
Constructor / Destructor
***************************************************************************** */

FIO_SFUNC void fio___http_cleanup(void *ignr_) {
  (void)ignr_;
#if FIO_HTTP_CACHE_LIMIT
  for (size_t i = 0; i < 2; ++i) {
    const char *names[] = {"cookie names", "header values"};
    FIO_LOG_DEBUG2(
        "freeing %zu strings from %s cache (capacity was: %zu)",
        fio___http_str_cache_count(&FIO___HTTP_STRING_CACHE[i].cache),
        names[i],
        fio___http_str_cache_capa(&FIO___HTTP_STRING_CACHE[i].cache));
#ifdef FIO_LOG_LEVEL_DEBUG
    if (FIO_LOG_LEVEL_DEBUG == FIO_LOG_LEVEL) {
      FIO_MAP_EACH(fio___http_str_cache,
                   (&FIO___HTTP_STRING_CACHE[i].cache),
                   pos) {
        fprintf(stderr, "\t \"%s\" (%zu bytes)\n", pos.key.buf, pos.key.len);
      }
    }
#endif
    fio___http_str_cache_destroy(&FIO___HTTP_STRING_CACHE[i].cache);
    FIO___LOCK_DESTROY(FIO___HTTP_STRING_CACHE[i].lock);
    (void)names; /* if unused */
  }
#endif /* FIO_HTTP_CACHE_LIMIT */
  FIO_LOG_DEBUG2("(%d) HTTP MIME hash storage count/capa: %zu / %zu",
                 fio_getpid(),
                 FIO___HTTP_MIMETYPES.count,
                 fio___http_mime_map_capa(&FIO___HTTP_MIMETYPES));
  fio___http_mime_map_destroy(&FIO___HTTP_MIMETYPES);
}

FIO_CONSTRUCTOR(fio___http_str_cache_static_builder) {
  fio___http_str_cached_init();
  fio_state_callback_add(FIO_CALL_AT_EXIT, fio___http_cleanup, NULL);
  fio_http_mime_register_essential();
}

/* *****************************************************************************
Cleanup
***************************************************************************** */
#undef FIO___HTTP_TIME_DIV
#undef FIO___HTTP_TIME_UNIT

#endif /* FIO_EXTERN_COMPLETE */

#undef FIO_HTTP_HANDLE
#endif /* FIO_HTTP_HANDLE */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_HTTP1_PARSER       /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                HTTP/1.1 Parser




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_HTTP1_PARSER) && !defined(H___FIO_HTTP1_PARSER___H) &&         \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN))
/* *****************************************************************************
The HTTP/1.1 provides static functions only, always as part or implementation.
***************************************************************************** */
#define H___FIO_HTTP1_PARSER___H

/* *****************************************************************************
HTTP/1.x Parser API
***************************************************************************** */

/** The HTTP/1.1 parser type */
typedef struct fio_http1_parser_s fio_http1_parser_s;
/** Initialization value for the parser */
#define FIO_HTTP1_PARSER_INIT ((fio_http1_parser_s){0})

/**
 * Parses HTTP/1.x data, calling any callbacks.
 *
 * Returns bytes consumed or `FIO_HTTP1_PARSER_ERROR` (`(size_t)-1`) on error.
 */
FIO_SFUNC size_t fio_http1_parse(fio_http1_parser_s *p,
                                 fio_buf_info_s buf,
                                 void *udata);

/** Returns true if the parser is waiting to parse a new request/response .*/
FIO_IFUNC size_t fio_http1_parser_is_empty(fio_http1_parser_s *p);

/** Returns true if the parser is waiting for header data .*/
FIO_IFUNC size_t fio_http1_parser_is_on_header(fio_http1_parser_s *p);

/** Returns true if the parser is on body data .*/
FIO_IFUNC size_t fio_http1_parser_is_on_body(fio_http1_parser_s *p);

/** The error return value for fio_http1_parse. */
#define FIO_HTTP1_PARSER_ERROR ((size_t)-1)

/** Returns the number of bytes of payload still expected to be received. */
FIO_IFUNC size_t fio_http1_expected(fio_http1_parser_s *p);

/** A return value for `fio_http1_expected` when chunked data is expected. */
#define FIO_HTTP1_EXPECTED_CHUNKED ((size_t)(-2))

/** `fio_http1_expected` value when body isn't allowed (GET/HEAD/OPTIONS). */
#define FIO___HTTP1_BODY_NOT_ALLOWED ((size_t)(-1))

/* *****************************************************************************
HTTP/1.x callbacks (to be implemented by parser user)
***************************************************************************** */

/** called when either a request or a response was received. */
static void fio_http1_on_complete(void *udata);
/** called when a request method is parsed. */
static int fio_http1_on_method(fio_buf_info_s method, void *udata);
/** called when a response status is parsed. the status_str is the string
 * without the prefixed numerical status indicator.*/
static int fio_http1_on_status(size_t istatus,
                               fio_buf_info_s status,
                               void *udata);
/** called when a request URL is parsed. */
static int fio_http1_on_url(fio_buf_info_s path, void *udata);
/** called when a the HTTP/1.x version is parsed. */
static int fio_http1_on_version(fio_buf_info_s version, void *udata);
/** called when a header is parsed. */
static int fio_http1_on_header(fio_buf_info_s name,
                               fio_buf_info_s value,
                               void *udata);
/** called when the special content-length header is parsed. */
static int fio_http1_on_header_content_length(fio_buf_info_s name,
                                              fio_buf_info_s value,
                                              size_t content_length,
                                              void *udata);
/** called when `Expect` arrives and may require a 100 continue response. */
static int fio_http1_on_expect(void *udata);
/** called when a body chunk is parsed. */
static int fio_http1_on_body_chunk(fio_buf_info_s chunk, void *udata);

/* *****************************************************************************
Implementation Stage Helpers
***************************************************************************** */

/* parsing stage 0 - read first line (proxy?). */
static int fio_http1___start(fio_http1_parser_s *p,
                             fio_buf_info_s *buf,
                             void *udata);
/* parsing stage 1 - read headers. */
static int fio_http1___read_header(fio_http1_parser_s *p,
                                   fio_buf_info_s *buf,
                                   void *udata);
/* parsing stage 2 - read body. */
static int fio_http1___read_body(fio_http1_parser_s *p,
                                 fio_buf_info_s *buf,
                                 void *udata);
/* parsing stage 2 - read chunked body. */
static int fio_http1___read_body_chunked(fio_http1_parser_s *p,
                                         fio_buf_info_s *buf,
                                         void *udata);
/* parsing stage 1 - read headers. */
static int fio_http1___read_trailer(fio_http1_parser_s *p,
                                    fio_buf_info_s *buf,
                                    void *udata);
/* completed parsing. */
static int fio_http1___finish(fio_http1_parser_s *p,
                              fio_buf_info_s *buf,
                              void *udata);

/* *****************************************************************************
HTTP Parser Type
***************************************************************************** */

/** The HTTP/1.1 parser type implementation */
struct fio_http1_parser_s {
  int (*fn)(fio_http1_parser_s *, fio_buf_info_s *, void *);
  size_t expected;
};

/** Returns true if the parser is waiting to parse a new request/response .*/
FIO_IFUNC size_t fio_http1_parser_is_empty(fio_http1_parser_s *p) {
  return !p->fn || p->fn == fio_http1___start;
}

/** Returns true if the parser is waiting for header data .*/
FIO_IFUNC size_t fio_http1_parser_is_on_header(fio_http1_parser_s *p) {
  return p->fn == fio_http1___read_header || p->fn == fio_http1___read_trailer;
}

/** Returns true if the parser is on body data .*/
FIO_IFUNC size_t fio_http1_parser_is_on_body(fio_http1_parser_s *p) {
  return p->fn == fio_http1___read_body ||
         p->fn == fio_http1___read_body_chunked;
}

/** Returns the number of bytes of payload still expected to be received. */
FIO_IFUNC size_t fio_http1_expected(fio_http1_parser_s *p) {
  if (p->expected == FIO___HTTP1_BODY_NOT_ALLOWED)
    return 0;
  return p->expected;
}

/* *****************************************************************************
Main Parsing Loop
***************************************************************************** */

FIO_SFUNC size_t fio_http1_parse(fio_http1_parser_s *p,
                                 fio_buf_info_s buf,
                                 void *udata) {
  int i = 0;
  char *buf_start = buf.buf;
  if (!buf.len)
    return 0;
  if (!p->fn)
    p->fn = fio_http1___start;
  while (!(i = p->fn(p, &buf, udata)))
    ;
  if (i < 0)
    return FIO_HTTP1_PARSER_ERROR;
  return buf.buf - buf_start;
}

/* completed parsing. */
static int fio_http1___finish(fio_http1_parser_s *p,
                              fio_buf_info_s *buf,
                              void *udata) {
  (void)buf;
  *p = (fio_http1_parser_s){0};
  fio_http1_on_complete(udata);
  return 1;
}

/* *****************************************************************************
Reading the first line
***************************************************************************** */

/* parsing stage 0 - read first line (TODO: proxy protocol support?). */
static int fio_http1___start(fio_http1_parser_s *p,
                             fio_buf_info_s *buf,
                             void *udata) {
  const uint32_t method_get = (fio_buf2u32u("GET ") | 0x20202020);
  const uint32_t method_head = (fio_buf2u32u("HEAD") | 0x20202020);
  const uint64_t method_options =
      (fio_buf2u64u("OPTIONS ") | (uint64_t)0x2020202020202020ULL);
  /* find line start/end and test */
  fio_buf_info_s wrd[3];
  char *start = buf->buf;
  char *tmp;
  while ((start[0] == ' ' || start[0] == '\r' || start[0] == '\n') &&
         start < buf->buf + buf->len) /* skip white space */
    ++start;
  if (start == buf->buf + buf->len) {
    buf->buf = start;
    return 1;
  }
  char *eol = (char *)FIO_MEMCHR(start, '\n', buf->len);
  if (!eol)
    return 1;
  if (start + 13 > eol) /* test for minimal data GET HTTP/1 or ### HTTP/1 */
    return -1;

  /* prep next stage */
  buf->len -= (eol - buf->buf) + 1;
  buf->buf = eol + 1;
  eol -= eol[-1] == '\r';

  /* parse first line */
  /* request: method path version ; response: version code txt */
  if (!(tmp = (char *)FIO_MEMCHR(start, ' ', (size_t)(eol - start))))
    return -1;
  wrd[0] = FIO_BUF_INFO2(start, (size_t)(tmp - start));
  start = tmp + 1;
  if (!(tmp = (char *)FIO_MEMCHR(start, ' ', eol - start)))
    return -1;
  wrd[1] = FIO_BUF_INFO2(start, (size_t)(tmp - start));
  start = tmp + 1;
  if (start >= eol)
    return -1;
  wrd[2] = FIO_BUF_INFO2(start, (size_t)(eol - start));
  if (fio_c2i(wrd[1].buf[0]) < 10) /* test if path or code */
    goto parse_response_line;
  if (wrd[2].len > 14)
    wrd[2].len = 14;
  if (fio_http1_on_method(wrd[0], udata))
    return -1;
  if (fio_http1_on_url(wrd[1], udata))
    return -1;
  if (fio_http1_on_version(wrd[2], udata))
    return -1;

  /* make sure GET / HEAD / OPTIONS requests don't have a body */
  if (((wrd[0].len == 3 || wrd[0].len == 4) &&
       ((fio_buf2u32u(wrd[0].buf) | 0x20202020) == method_get ||
        (fio_buf2u32u(wrd[0].buf) | 0x20202020) == method_head)) ||
      (wrd[0].len == 7 &&
       ((fio_buf2u64u(wrd[0].buf) | (uint64_t)0x2020202020202020ULL) ==
        method_options)))
    p->expected = FIO___HTTP1_BODY_NOT_ALLOWED;

  /* switch to header reading mode */
  return (p->fn = fio_http1___read_header)(p, buf, udata);

parse_response_line:
  if (wrd[0].len > 14)
    wrd[0].len = 14;
  if (fio_http1_on_version(wrd[0], udata))
    return -1;
  if (fio_http1_on_status(fio_atol10u(&wrd[1].buf), wrd[2], udata))
    return -1;
  return (p->fn = fio_http1___read_header)(p, buf, udata);
}

/* *****************************************************************************
Reading Headers
***************************************************************************** */

/* parsing stage 1 - read headers (after `expect` header). */
static int fio_http1___read_header_post_expect(fio_http1_parser_s *p,
                                               fio_buf_info_s *buf,
                                               void *udata);

/* handle headers before calling callback. */
static inline int fio_http1___on_header(fio_http1_parser_s *p,
                                        fio_buf_info_s name,
                                        fio_buf_info_s value,
                                        void *udata) {
  /* test for special headers */
  switch (name.len) {
  case 6: /* test for "expect" */
    if (value.len == 12 && fio_buf2u32u(name.buf) == fio_buf2u32u("expe") &&
        fio_buf2u32u(name.buf + 2) == fio_buf2u32u("pect")) {
      /* Expect value validation */
      if (fio_buf2u64u(value.buf) == fio_buf2u64u("100-cont") &&
          fio_buf2u32u(value.buf + 8) == fio_buf2u32u("inue")) {
        p->fn = fio_http1___read_header_post_expect;
        return 0;
      }
      return -1;
    }
    break;
  case 14: /* test for "content-length" */
    if (fio_buf2u64u(name.buf) == fio_buf2u64u("content-") &&
        fio_buf2u64u(name.buf + 6) == fio_buf2u64u("t-length")) {
      char *tmp = value.buf;
      errno = 0; /* reset errno before parsing */
      uint64_t clen = fio_atol10u(&tmp);
      /* Reject if: parsing failed (tmp didn't reach end), overflow occurred,
       * or value collides with sentinel values */
      if ((unsigned)(tmp != value.buf + value.len) | (errno == E2BIG) |
          (clen == FIO___HTTP1_BODY_NOT_ALLOWED) |
          (clen == FIO_HTTP1_EXPECTED_CHUNKED))
        return -1;
      if (!clen) /* no length? */
        clen = FIO___HTTP1_BODY_NOT_ALLOWED;
      /* Prevent CL.TE / TE.CL by validating header's payload changes nothing */
      if (p->expected)
        return 0 - (p->expected != clen); /* causes parser to fail and stop */
      p->expected = clen;
      if (clen == FIO___HTTP1_BODY_NOT_ALLOWED)
        return 0;
      /* fio_http1_on_header_content_length tests if body length is too large */
      return 0 -
             (fio_http1_on_header_content_length(name, value, clen, udata) ==
              -1);
    }
    break;
  case 17: /* test for "transfer-encoding" (chunked?) */
    if (value.len >= 7 && (name.buf[16] == 'g') &&
        !((fio_buf2u64u(name.buf) ^ fio_buf2u64u("transfer")) |
          (fio_buf2u64u(name.buf + 8) ^ fio_buf2u64u("-encodin")))) {
      char *c_start = value.buf + value.len - 7;
      if ((fio_buf2u32u(c_start) | 0x20202020UL) == fio_buf2u32u("chun") &&
          (fio_buf2u32u(c_start + 3) | 0x20202020UL) == fio_buf2u32u("nked")) {
        if (p->expected && p->expected != FIO_HTTP1_EXPECTED_CHUNKED)
          return -1;
        p->expected = FIO_HTTP1_EXPECTED_CHUNKED;
        /* endpoint does not need to know if the body was chunked or not */
        if (value.len == 7)
          return 0;
        if (c_start[-1] != ' ' && c_start[-1] != ',' && c_start[-1] != '\t')
          return -1;
        while (
            (c_start[-1] == ' ' || c_start[-1] == ',' || c_start[-1] == '\t') &&
            c_start > value.buf)
          --c_start;
        if (c_start == value.buf)
          return 0;
        value.len = c_start - value.buf;
      }
    }
    break;
  }
  /* perform callback */
  return 0 - (fio_http1_on_header(name, value, udata) == -1);
}

/* handle trailers (chunked encoding only) before calling callback. */
static inline int fio_http1___on_trailer(fio_http1_parser_s *p,
                                         fio_buf_info_s name,
                                         fio_buf_info_s value,
                                         void *udata) {
  (void)p;
  fio_buf_info_s forbidden[] = {
      FIO_BUF_INFO1((char *)"authorization"),
      FIO_BUF_INFO1((char *)"cache-control"),
      FIO_BUF_INFO1((char *)"content-encoding"),
      FIO_BUF_INFO1((char *)"content-length"),
      FIO_BUF_INFO1((char *)"content-range"),
      FIO_BUF_INFO1((char *)"content-type"),
      FIO_BUF_INFO1((char *)"expect"),
      FIO_BUF_INFO1((char *)"host"),
      FIO_BUF_INFO1((char *)"max-forwards"),
      FIO_BUF_INFO1((char *)"set-cookie"),
      FIO_BUF_INFO1((char *)"te"),
      FIO_BUF_INFO1((char *)"trailer"),
      FIO_BUF_INFO1((char *)"transfer-encoding"),
      FIO_BUF_INFO2(NULL, 0),
  }; /* known forbidden headers in trailer */
  for (size_t i = 0; forbidden[i].buf; ++i) {
    if (FIO_BUF_INFO_IS_EQ(name, forbidden[i]))
      return -1;
  }
  return fio_http1_on_header(name, value, udata);
}

/* returns either a lower case (ASCI) or the original char. */
static inline uint8_t fio_http1_tolower(uint8_t c) {
  c |= (((uint8_t)(c - (uint8_t)'A') < (uint8_t)((uint8_t)'Z' - ((uint8_t)'A')))
        << 5);
  return c;
}

/* seeks to the ':' divisor while testing and converting to downcase. */
static char *fio_http1___seek_header_div(char *p) {
  /* this is the subset of the forbidden chars that allows UTF-8 headers */
  static const _Bool forbidden_name_chars[256] = {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  FIO_ASSERT(forbidden_name_chars[' '] && forbidden_name_chars['\t'],
             "missing forbidden HTTP Header Name characters");
  for (;;) {
    if (FIO_UNLIKELY(forbidden_name_chars[((uint8_t)(*p))]))
      return p;
    *p = (char)fio_http1_tolower((uint8_t)(*p));
    ++p;
  }
}

/* extract header name and value from a line and pass info to handler */
static inline int fio_http1___read_header_line(
    fio_http1_parser_s *p,
    fio_buf_info_s *buf,
    void *udata,
    int (*handler)(fio_http1_parser_s *,
                   fio_buf_info_s,
                   fio_buf_info_s,
                   void *)) {
  for (;;) {
    char *start = buf->buf;
    char *eol = (char *)FIO_MEMCHR(start, '\n', buf->len);
    char *div;
    fio_buf_info_s name, value;
    if (!eol)
      return 1;

    buf->len -= (eol - buf->buf) + 1;
    buf->buf = eol + 1;
    eol -= (eol[-1] == '\r');
    if (FIO_UNLIKELY(eol == start))
      goto headers_finished;

    div = fio_http1___seek_header_div(start);
    if (div[0] != ':' || div == start)
      return -1;
    name = FIO_BUF_INFO2(start, (size_t)(div - start));
    do {
      ++div;
    } while (*div == ' ' || *div == '\t');

    if (div != eol)
      while (eol[-1] == ' ' || eol[-1] == '\t')
        --eol;
    value = FIO_BUF_INFO2((div == eol) ? NULL : div, (size_t)(eol - div));
    int r = handler(p, name, value, udata);
    if (FIO_UNLIKELY(r))
      return r;
  }

headers_finished:
  if (p->fn == fio_http1___read_header_post_expect && p->expected &&
      fio_http1_on_expect(udata))
    goto expect_failed;
  p->fn = (!p->expected || p->expected == FIO___HTTP1_BODY_NOT_ALLOWED)
              ? fio_http1___finish
          : (!(p->expected - FIO_HTTP1_EXPECTED_CHUNKED))
              ? fio_http1___read_body_chunked
              : fio_http1___read_body;
  return p->fn(p, buf, udata);

expect_failed:
  *p = (fio_http1_parser_s){0};
  return 1;
}

/* parsing stage 1 - read headers. */
static int fio_http1___read_header(fio_http1_parser_s *p,
                                   fio_buf_info_s *buf,
                                   void *udata) {
  return fio_http1___read_header_line(p, buf, udata, fio_http1___on_header);
}

/* parsing stage 1 - read headers (after `expect` header). */
static int fio_http1___read_header_post_expect(fio_http1_parser_s *p,
                                               fio_buf_info_s *buf,
                                               void *udata) {
  return fio_http1___read_header_line(p, buf, udata, fio_http1___on_header);
}

/* parsing stage 1 - read headers. */
static int fio_http1___read_trailer(fio_http1_parser_s *p,
                                    fio_buf_info_s *buf,
                                    void *udata) {
  return fio_http1___read_header_line(p, buf, udata, fio_http1___on_trailer);
}

/* *****************************************************************************
Reading the Body
***************************************************************************** */

/* parsing stage 2 - read body - known content length. */
static int fio_http1___read_body(fio_http1_parser_s *p,
                                 fio_buf_info_s *buf,
                                 void *udata) {
  if (!buf->len)
    return 1;
  if (buf->len >= p->expected) {
    buf->len = p->expected;
    if (fio_http1_on_body_chunk(*buf, udata))
      return -1;
    buf->buf += buf->len;
    return fio_http1___finish(p, buf, udata);
  }
  if (fio_http1_on_body_chunk(*buf, udata))
    return -1;
  buf->buf += buf->len;
  p->expected -= buf->len;
  buf->len = 0;
  return 1;
}

/* *****************************************************************************
Reading the Body (chunked)
***************************************************************************** */

/* parsing stage 2 - read chunked body - read chunk data. */
static int fio_http1___read_body_chunked_read(fio_http1_parser_s *p,
                                              fio_buf_info_s *buf,
                                              void *udata) {
  if (!buf->len)
    return 1;
  if (buf->len >= p->expected) {
    if (fio_http1_on_body_chunk(FIO_BUF_INFO2(buf->buf, p->expected), udata))
      return -1;
    buf->buf += p->expected;
    buf->len -= p->expected;
    p->fn = fio_http1___read_body_chunked;
    return 0;
  }
  if (fio_http1_on_body_chunk(buf[0], udata))
    return -1;
  p->expected -= buf->len;
  buf->buf += buf->len;
  return 1;
}

/* parsing stage 2 - read chunked body - read next chunk length. */
static int fio_http1___read_body_chunked(fio_http1_parser_s *p,
                                         fio_buf_info_s *buf,
                                         void *udata) {
  (void)udata;
  if (buf->len < 3)
    return 1;
  { /* remove possible extra EOL after chunk payload */
    size_t tmp = (buf->buf[0] == '\r');
    tmp += (buf->buf[tmp] == '\n');
    buf->len -= tmp;
    buf->buf += tmp;
  }

  if (!FIO_MEMCHR(buf->buf, '\n', buf->len)) /* prevent read overflow */
    return (buf->len < 10) ? 1 : -1;

  char *eol = buf->buf;
  size_t expected = fio_atol16u(&eol); /* never overflows, EOL validated */
  if (eol == buf->buf)
    return -1;
  eol += (eol[0] == '\r');
  if (eol >= buf->buf + buf->len)
    return 1; /* read overflowed */
  if (eol[0] != '\n')
    return -1;
  ++eol;
  p->expected = expected;
  if (p->expected) {
    /* further data expected */
    buf->len -= eol - buf->buf;
    buf->buf = eol;
    return (p->fn = fio_http1___read_body_chunked_read)(p, buf, udata);
  }
  if ((eol + 1 < buf->buf + buf->len) && (eol[0] == '\r' || eol[0] == '\n')) {
    /* no trailers, finish now. */
    eol += (eol[0] == '\r');
    ++eol;
    buf->len -= eol - buf->buf;
    buf->buf = eol;
    return fio_http1___finish(p, buf, udata);
  }
  /* possible trailers */
  buf->len -= eol - buf->buf;
  buf->buf = eol;
  return (p->fn = fio_http1___read_trailer)(p, buf, udata);
}

/* *****************************************************************************
Cleanup
***************************************************************************** */
#undef FIO_HTTP1_PARSER
#endif /* FIO_HTTP1_PARSER && FIO_EXTERN_COMPLETE*/
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_BITWISE            /* Development inclusion - ignore line */
#define FIO_RAND               /* Development inclusion - ignore line */
#define FIO_WEBSOCKET_PARSER   /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                              WebSocket Parser




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_WEBSOCKET_PARSER) && !defined(H___FIO_WEBSOCKET_PARSER___H) && \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN))
/* *****************************************************************************
The parser provides static functions only, always as part or implementation.
***************************************************************************** */
#define H___FIO_WEBSOCKET_PARSER___H

/* *****************************************************************************
WebSocket Parsing API
***************************************************************************** */

typedef struct fio_websocket_parser_s fio_websocket_parser_s;
/**
 * Parses WebSocket data, calling any callbacks.
 *
 * Returns bytes consumed or `FIO_WEBSOCKET_PARSER_ERROR` (`(size_t)-1`) on
 * error.
 */
FIO_SFUNC size_t fio_websocket_parse(fio_websocket_parser_s *p,
                                     fio_buf_info_s buf,
                                     void *udata);

// FIO_SFUNC

/** The parsers return value on error. */
#define FIO_WEBSOCKET_PARSER_ERROR ((size_t)-1)

/**
 * Maximum allowed WebSocket frame payload length.
 * Default: 1GB (1 << 30). Override before including this header if needed.
 * Setting this helps prevent DoS attacks via memory exhaustion.
 */
#ifndef FIO_WEBSOCKET_MAX_PAYLOAD
#define FIO_WEBSOCKET_MAX_PAYLOAD ((uint64_t)(1ULL << 30))
#endif

/* *****************************************************************************
WebSocket Parsing Callbacks
***************************************************************************** */

/** Called when a message frame was received. */
FIO_SFUNC void fio_websocket_on_message(void *udata,
                                        fio_buf_info_s msg,
                                        unsigned char is_text);

/**
 * Called when the parser needs to copy the message to an external buffer.
 *
 * MUST return the external buffer, as it may need to be unmasked.
 *
 * Partial message length may be equal to zero (`partial.len == 0`).
 */
FIO_SFUNC fio_buf_info_s fio_websocket_write_partial(void *udata,
                                                     fio_buf_info_s partial,
                                                     size_t more_expected);

/** Called when the permessage-deflate extension requires decompression. */
FIO_SFUNC fio_buf_info_s fio_websocket_decompress(void *udata,
                                                  fio_buf_info_s msg);

/** Called when a `ping` message was received. */
FIO_SFUNC void fio_websocket_on_protocol_ping(void *udata, fio_buf_info_s msg);

/** Called when a `pong` message was received. */
FIO_SFUNC void fio_websocket_on_protocol_pong(void *udata, fio_buf_info_s msg);

/** Called when a `close` message was received. */
FIO_SFUNC void fio_websocket_on_protocol_close(void *udata, fio_buf_info_s msg);

/* *****************************************************************************
WebSocket Formatting API
***************************************************************************** */
/**
 * Returns the length of the buffer required to wrap a message `len` long
 *
 * Client connections should add 4 to this number to accommodate for the mask.
 */
FIO_IFUNC uint64_t fio_websocket_wrapped_len(uint64_t len);

/**
 * Wraps a WebSocket server message and writes it to the target buffer.
 *
 * The `first` and `last` flags can be used to support message fragmentation.
 *
 * * target: the target buffer to write to.
 * * msg:    the message to be wrapped.
 * * len:    the message length.
 * * opcode: set to 1 for UTF-8 message, 2 for binary, etc'.
 * * first:  set to 1 if `msg` points the beginning of the message.
 * * last:   set to 1 if `msg + len` ends the message.
 * * client: set to 1 to use client mode (data  masking).
 *
 * Further opcode values:
 * * %x0 denotes a continuation frame
 * *  %x1 denotes a text frame
 * *  %x2 denotes a binary frame
 * *  %x3-7 are reserved for further non-control frames
 * *  %x8 denotes a connection close
 * *  %x9 denotes a ping
 * *  %xA denotes a pong
 * *  %xB-F are reserved for further control frames
 *
 * Returns the number of bytes written. Always `websocket_wrapped_len(len)`
 */
FIO_SFUNC uint64_t fio_websocket_server_wrap(void *target,
                                             const void *msg,
                                             uint64_t len,
                                             unsigned char opcode,
                                             unsigned char first,
                                             unsigned char last,
                                             unsigned char rsv);

/**
 * Wraps a WebSocket client message and writes it to the target buffer.
 *
 * The `first` and `last` flags can be used to support message fragmentation.
 *
 * * target: the target buffer to write to.
 * * msg:    the message to be wrapped.
 * * len:    the message length.
 * * opcode: set to 1 for UTF-8 message, 2 for binary, etc'.
 * * first:  set to 1 if `msg` points the beginning of the message.
 * * last:   set to 1 if `msg + len` ends the message.
 * * client: set to 1 to use client mode (data  masking).
 *
 * Returns the number of bytes written. Always `websocket_wrapped_len(len) + 4`
 */
FIO_SFUNC uint64_t fio_websocket_client_wrap(void *target,
                                             const void *msg,
                                             uint64_t len,
                                             unsigned char opcode,
                                             unsigned char first,
                                             unsigned char last,
                                             unsigned char rsv);

/* *****************************************************************************
API - Parsing (unwrapping)
***************************************************************************** */

/* *****************************************************************************

                                Implementation

***************************************************************************** */

/** returns the length of the buffer required to wrap a message `len` long */
FIO_IFUNC uint64_t fio_websocket_wrapped_len(uint64_t len) {
  return len + 2ULL + ((len > 125) << 1) +
         ((0ULL - (len > ((1UL << 16) - 1))) & 6ULL);
}

/* *****************************************************************************
Message Wrapping
***************************************************************************** */

FIO_IFUNC uint64_t fio_websocket_header(void *target,
                                        uint64_t message_len,
                                        uint32_t mask,
                                        unsigned char opcode,
                                        unsigned char first,
                                        unsigned char last,
                                        unsigned char rsv) {
  ((uint8_t *)target)[0] = 0U |
                           /*fin*/ ((last & 1U) << 7) |
                           /* opcode */ ((16U - !!first) & (opcode & 15U)) |
                           /* rsv */ ((rsv & 7) << 4);
  ((uint8_t *)target)[1] = ((!!mask) << 7U);
  size_t mask_l = ((!!mask) << 2);
  if (message_len < 126) {
    ((uint8_t *)target)[1] |= message_len;
    if (mask)
      fio_u2buf32u(((uint8_t *)target + 2), mask);
    return 2 + mask_l;
  } else if (message_len < (1UL << 16)) {
    /* head is 4 bytes */
    ((uint8_t *)target)[1] |= 126;
    fio_u2buf16_be(((uint8_t *)target + 2), message_len);
    if (mask)
      fio_u2buf32u(((uint8_t *)target + 4), mask);
    return 4 + mask_l;
  } else {
    /* Really Long Message  */
    ((uint8_t *)target)[1] |= 127;
    fio_u2buf64_be(((uint8_t *)target + 2), message_len);
    if (mask)
      fio_u2buf32u(((uint8_t *)target + 10), mask);
    return 10 + mask_l;
  }
}

/**
 * Wraps a WebSocket server message and writes it to the target buffer.
 *
 * The `first` and `last` flags can be used to support message fragmentation.
 *
 * * target: the target buffer to write to.
 * * msg:    the message to be wrapped.
 * * len:    the message length.
 * * opcode: set to 1 for UTF-8 message, 2 for binary, etc'.
 * * first:  set to 1 if `msg` points the beginning of the message.
 * * last:   set to 1 if `msg + len` ends the message.
 * * client: set to 1 to use client mode (data  masking).
 *
 * Further opcode values:
 * * %x0 denotes a continuation frame
 * *  %x1 denotes a text frame
 * *  %x2 denotes a binary frame
 * *  %x3-7 are reserved for further non-control frames
 * *  %x8 denotes a connection close
 * *  %x9 denotes a ping
 * *  %xA denotes a pong
 * *  %xB-F are reserved for further control frames
 *
 * Returns the number of bytes written. Always `websocket_wrapped_len(len)`
 */
FIO_SFUNC uint64_t fio_websocket_server_wrap(void *restrict target,
                                             const void *restrict msg,
                                             uint64_t len,
                                             unsigned char opcode,
                                             unsigned char first,
                                             unsigned char last,
                                             unsigned char rsv) {
  uint64_t r = fio_websocket_header(target, len, 0, opcode, first, last, rsv);
  FIO_MEMCPY(((uint8_t *)target) + r, msg, len);
  r += len;
  return r;
}

/**
 * Wraps a WebSocket client message and writes it to the target buffer.
 *
 * The `first` and `last` flags can be used to support message fragmentation.
 *
 * * target: the target buffer to write to.
 * * msg:    the message to be wrapped.
 * * len:    the message length.
 * * opcode: set to 1 for UTF-8 message, 2 for binary, etc'.
 * * first:  set to 1 if `msg` points the beginning of the message.
 * * last:   set to 1 if `msg + len` ends the message.
 *
 * Returns the number of bytes written. Always `websocket_wrapped_len(len) +
 * 4`
 */
FIO_SFUNC uint64_t fio_websocket_client_wrap(void *restrict target,
                                             const void *restrict msg,
                                             uint64_t len,
                                             unsigned char opcode,
                                             unsigned char first,
                                             unsigned char last,
                                             unsigned char rsv) {
  /* WebSocket masking per RFC 6455 - prevents proxy cache poisoning attacks.
   * PRNG is acceptable here as masking is not for cryptographic security;
   * it's specifically to prevent intermediary interpretation of frame data. */
  uint64_t mask = (fio_rand64() | 0x01020408ULL) & 0xFFFFFFFFULL; /* non-zero */
  mask |= mask << 32;
  uint64_t r = fio_websocket_header(target,
                                    len,
                                    (uint32_t)mask,
                                    opcode,
                                    first,
                                    last,
                                    rsv);
  fio_xmask_cpy((((char *)target) + r), (const char *)msg, len, mask);
  r += len;
  return r;
}

/* *****************************************************************************
WebSocket Parser Type
***************************************************************************** */

/** The WebSocket parser type implementation */
struct fio_websocket_parser_s {
  int (*fn)(fio_websocket_parser_s *, fio_buf_info_s *, void *);
  uint64_t start_at;
  uint64_t expect;
  uint32_t mask;
  uint8_t first;
  uint8_t current;
  uint8_t must_mask;
};

/* *****************************************************************************
Frame Consumption
***************************************************************************** */
FIO_SFUNC int fio___websocket_consume_header(fio_websocket_parser_s *p,
                                             fio_buf_info_s *buf,
                                             void *udata);

FIO_SFUNC int fio___websocket_consume_frame_partial(fio_websocket_parser_s *p,
                                                    fio_buf_info_s *buf,
                                                    void *udata) {
  fio_websocket_write_partial(udata, *buf, (p->expect -= buf->len));
  buf->buf += buf->len;
  buf->len = 0;
  return 1;
}

FIO_SFUNC int fio___websocket_consume_frame_finish(fio_websocket_parser_s *p,
                                                   fio_buf_info_s *buf,
                                                   void *udata) {
  fio_buf_info_s msg = FIO_BUF_INFO2(buf->buf, p->expect);
  buf->buf += p->expect;
  buf->len -= p->expect;
  p->expect = 0;
  msg = fio_websocket_write_partial(udata, msg, 0);
  if (!msg.buf) /* protocol error response from callback */
    return -1;
  fio_xmask(msg.buf + p->start_at,
            msg.len - p->start_at,
            (((uint64_t)p->mask) << 32) | (uint64_t)p->mask);
  p->start_at += msg.len;
  p->fn = fio___websocket_consume_header;
  if (!(p->current & 128)) /* done? if not, consume next frame */
    return 0;
  /* done */
  if (p->first & 64) { /* RSV1 set: decompress */
    msg = fio_websocket_decompress(udata, msg);
    if (!msg.buf)
      return -1;
  }
  size_t cond = (p->first & 15);
  *p = (fio_websocket_parser_s){.fn = fio___websocket_consume_header};
  switch (cond) {
  case 0: return -1;         /* continuation - error? */
  case 1: /* fall through */ /* text / data frame */
  case 2: fio_websocket_on_message(udata, msg, (cond & 1)); return 1;
  case 8: fio_websocket_on_protocol_close(udata, msg); return 1;
  case 9: fio_websocket_on_protocol_ping(udata, msg); return 1;
  case 10: fio_websocket_on_protocol_pong(udata, msg); return 1;
  default:
    FIO_LOG_DDEBUG2("ERROR: WebSocket protocol error - unknown opcode %u\n",
                    (unsigned int)(p->first & 15));
    return -1;
  }
  return 1;
}

FIO_SFUNC int fio___websocket_consume_frame(fio_websocket_parser_s *p,
                                            fio_buf_info_s *buf,
                                            void *udata) {
  return (p->expect > buf->len
              ? fio___websocket_consume_frame_partial
              : fio___websocket_consume_frame_finish)(p, buf, udata);
}

/* *****************************************************************************
Header Consumption
***************************************************************************** */
FIO_SFUNC int fio___websocket_consume_header(fio_websocket_parser_s *p,
                                             fio_buf_info_s *buf,
                                             void *udata) {
  if (buf->len < 2)
    return 1;
  const uint8_t mask_f = (((uint8_t *)buf->buf)[1] >> 7) & 1;
  const uint8_t mask_l = (mask_f << 2);
  const uint8_t info = (uint8_t)(buf->buf[0]);
  uint8_t len_indicator = ((((uint8_t *)buf->buf)[1]) & 127U);
  switch (len_indicator) {
  case 126:
    if (buf->len < 8UL)
      return 1;
    p->expect = fio_buf2u16_be(buf->buf + 2);
    p->mask = (0ULL - mask_f) & fio_buf2u32u(buf->buf + 4);
    buf->buf += 4 + mask_l;
    buf->len -= 4 + mask_l;
    break;

  case 127:
    if (buf->len < 14UL)
      return 1;
    p->expect = fio_buf2u64_be(buf->buf + 2);
    /* RFC 6455: most significant bit MUST be 0, and enforce max payload limit
     * to prevent memory exhaustion attacks */
    if ((p->expect & 0x8000000000000000ULL) ||
        (p->expect > FIO_WEBSOCKET_MAX_PAYLOAD))
      return -1;
    p->mask = (0ULL - mask_f) & fio_buf2u32u(buf->buf + 10);
    buf->buf += 10 + mask_l;
    buf->len -= 10 + mask_l;
    break;

  default:
    if (buf->len < (2ULL + mask_l))
      return 1;
    p->expect = len_indicator;
    p->mask = mask_f ? fio_buf2u32u(buf->buf + 2) : 0;
    buf->buf += 2 + mask_l;
    buf->len -= 2 + mask_l;
    break;
  }
  if (p->first) {
    p->current = info;
    if ((info & 15)) /* continuation frame == 0 ; is it missing? */
      return -1;
  } else {
    p->first = p->current = info;
    p->start_at = 0;
    if (!(info & 15)) /* continuation frame == 0 ; where's the first? */
      return -1;
  }
  if (p->must_mask && !p->mask)
    return -1;
  return (p->fn = fio___websocket_consume_frame)(p, buf, udata);
}
/* *****************************************************************************
Main Parsing Loop
***************************************************************************** */

FIO_SFUNC size_t fio_websocket_parse(fio_websocket_parser_s *p,
                                     fio_buf_info_s buf,
                                     void *udata) {
  int i = 0;
  char *buf_start = buf.buf;
  if (!buf.len)
    return 0;
  if (!p->fn)
    p->fn = fio___websocket_consume_header;
  while (!(i = p->fn(p, &buf, udata)))
    ;
  if (i < 0)
    return FIO_WEBSOCKET_PARSER_ERROR;
  return buf.buf - buf_start;
}

/* *****************************************************************************
Reading the first line
***************************************************************************** */

/* *****************************************************************************
Cleanup
***************************************************************************** */

#undef FIO_WEBSOCKET_PARSER
#endif /* FIO_WEBSOCKET_PARSER && FIO_EXTERN_COMPLETE */
/* ************************************************************************* */
#if !defined(FIO_INCLUDE_FILE) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_HTTP               /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                  HTTP Implementation for FIO_SERVER




Copyright and License: see header file (000 copyright.h) or top of file
***************************************************************************** */
#if defined(FIO_HTTP) && !defined(H___FIO_HTTP___H) &&                         \
    !defined(FIO___RECURSIVE_INCLUDE)
#define H___FIO_HTTP___H
/* *****************************************************************************
HTTP Setting Defaults
***************************************************************************** */

#ifndef FIO_HTTP_DEFAULT_MAX_HEADER_SIZE
#define FIO_HTTP_DEFAULT_MAX_HEADER_SIZE 32768 /* (1UL << 15) */
#endif
#ifndef FIO_HTTP_DEFAULT_MAX_LINE_LEN
#define FIO_HTTP_DEFAULT_MAX_LINE_LEN 8192 /* (1UL << 13) */
#endif
#ifndef FIO_HTTP_DEFAULT_MAX_BODY_SIZE
#define FIO_HTTP_DEFAULT_MAX_BODY_SIZE 33554432 /* (1UL << 25) */
#endif
#ifndef FIO_HTTP_DEFAULT_WS_MAX_MSG_SIZE
#define FIO_HTTP_DEFAULT_WS_MAX_MSG_SIZE 262144 /* (1UL << 18) */
#endif
#ifndef FIO_HTTP_DEFAULT_TIMEOUT
#define FIO_HTTP_DEFAULT_TIMEOUT 50
#endif
#ifndef FIO_HTTP_DEFAULT_TIMEOUT_LONG
#define FIO_HTTP_DEFAULT_TIMEOUT_LONG 50
#endif

#ifndef FIO_HTTP_SHOW_CONTENT_LENGTH_HEADER
/** Adds a "content-length" header to the HTTP handle (usually redundant). */
#define FIO_HTTP_SHOW_CONTENT_LENGTH_HEADER 0
#endif

#ifndef FIO_HTTP_WEBSOCKET_WRITE_VALIDITY_TEST_LIMIT
/** UTF-8 validity tests will be performed only for data shorter than this. */
#define FIO_HTTP_WEBSOCKET_WRITE_VALIDITY_TEST_LIMIT ((1UL << 16) - 10UL)
#endif

#ifndef FIO_WEBSOCKET_STATS
/* If true, logs longest WebSocket round-trips (using FIO_LOG_INFO). */
#define FIO_WEBSOCKET_STATS 0
#endif

/* *****************************************************************************
HTTP Listen
***************************************************************************** */
typedef struct fio_http_settings_s {
  /** Called before body uploads, when a client sends an `Expect` header. */
  void (*pre_http_body)(fio_http_s *h);
  /** Callback for HTTP requests (server) or responses (client). */
  void (*on_http)(fio_http_s *h);
  /** Called when a request / response cycle is finished with no Upgrade. */
  void (*on_finish)(fio_http_s *h);

  /** Authenticate EventSource (SSE) requests, return non-zero to deny.*/
  int (*on_authenticate_sse)(fio_http_s *h);
  /** Authenticate WebSockets Upgrade requests, return non-zero to deny.*/
  int (*on_authenticate_websocket)(fio_http_s *h);

  /** Called once a WebSocket / SSE connection upgrade is complete. */
  void (*on_open)(fio_http_s *h);

  /** Called when a WebSocket message is received. */
  void (*on_message)(fio_http_s *h, fio_buf_info_s msg, uint8_t is_text);
  /** Called when an EventSource event is received. */
  void (*on_eventsource)(fio_http_s *h,
                         fio_buf_info_s id,
                         fio_buf_info_s event,
                         fio_buf_info_s data);
  /** Called when an EventSource reconnect event requests an ID. */
  void (*on_eventsource_reconnect)(fio_http_s *h, fio_buf_info_s id);

  /** Called for WebSocket / SSE connections when outgoing buffer is empty. */
  void (*on_ready)(fio_http_s *h);
  /** Called for open WebSocket / SSE connections during shutting down. */
  void (*on_shutdown)(fio_http_s *h);
  /** Called after a WebSocket / SSE connection is closed (for cleanup). */
  void (*on_close)(fio_http_s *h);

  /** (optional) the callback to be performed when the HTTP service closes. */
  void (*on_stop)(struct fio_http_settings_s *settings);

  /** Default opaque user data for HTTP handles (fio_http_s). */
  void *udata;

  /** Optional SSL/TLS support. */
  fio_io_functions_s *tls_io_func;
  /** Optional SSL/TLS support. */
  fio_io_tls_s *tls;
  /** Optional HTTP task queue (for multi-threading HTTP responses) */
  fio_io_async_s *queue;
  /**
   * A public folder for file transfers - allows to circumvent any application
   * layer logic and simply serve static files.
   *
   * Supports automatic `gz` pre-compressed alternatives.
   */
  fio_str_info_s public_folder;
  /**
   * The max-age value (in seconds) for caching static files send from
   * `public_folder`.
   *
   * Defaults to 0 (not sent).
   */
  size_t max_age;
  /**
   * The maximum total of bytes for the overall size of the request string and
   * headers, combined.
   *
   * Defaults to FIO_HTTP_DEFAULT_MAX_HEADER_SIZE bytes.
   */
  uint32_t max_header_size;
  /**
   * The maximum number of bytes allowed per header / request line.
   *
   * Defaults to FIO_HTTP_DEFAULT_MAX_LINE_LEN bytes.
   */
  uint32_t max_line_len;
  /**
   * The maximum size of an HTTP request's body (posting / downloading).
   *
   * Defaults to FIO_HTTP_DEFAULT_MAX_BODY_SIZE bytes.
   */
  size_t max_body_size;
  /**
   * The maximum WebSocket message size/buffer (in bytes) for Websocket
   * connections. Defaults to FIO_HTTP_DEFAULT_WS_MAX_MSG_SIZE bytes.
   */
  size_t ws_max_msg_size;
  /** reserved for future use. */
  intptr_t reserved1;
  /** reserved for future use. */
  intptr_t reserved2;
  /**
   * An HTTP/1.x connection timeout.
   *
   * Defaults to FIO_HTTP_DEFAULT_TIMEOUT seconds.
   *
   * Note: the connection might be closed (by other side) before timeout occurs.
   */
  uint8_t timeout;
  /**
   * Timeout for the WebSocket connections in seconds. Defaults to
   * FIO_HTTP_DEFAULT_TIMEOUT_LONG seconds.
   *
   * A ping will be sent whenever the timeout is reached.
   *
   * Connections are only closed when a ping cannot be sent (the network layer
   * fails). Pongs are ignored.
   */
  uint8_t ws_timeout;
  /**
   * Timeout for EventSource (SSE) connections in seconds. Defaults to
   * FIO_HTTP_DEFAULT_TIMEOUT_LONG seconds.
   *
   * A ping will be sent whenever the timeout is reached.
   *
   * Connections are only closed when a ping cannot be sent (the network layer
   * fails).
   */
  uint8_t sse_timeout;
  /** Timeout for client connections (only relevant in client mode). */
  uint8_t connect_timeout;
  /** Logging flag - set to TRUE to log HTTP requests. */
  uint8_t log;
} fio_http_settings_s;

/* a pointer safety type */
typedef struct fio_http_listener_s fio_http_listener_s;

/** Listens to HTTP / WebSockets / SSE connections on `url`. */
SFUNC fio_http_listener_s *fio_http_listen(const char *url,
                                           fio_http_settings_s settings);

/** Listens to HTTP / WebSockets / SSE connections on `url`. */
#define fio_http_listen(url, ...)                                              \
  fio_http_listen(url, (fio_http_settings_s){__VA_ARGS__})

/** Returns the a pointer to the HTTP settings associated with the listener. */
SFUNC fio_http_settings_s *fio_http_listener_settings(fio_http_listener_s *l);

/** Allows all clients to connect (bypasses authentication). */
SFUNC int FIO_HTTP_AUTHENTICATE_ALLOW(fio_http_s *h);

/** Returns the IO object associated with the HTTP object (request only). */
SFUNC fio_io_s *fio_http_io(fio_http_s *);

/** Macro helper for HTTP handle pub/sub subscriptions. */
#define fio_http_subscribe(h, ...)                                             \
  fio_subscribe(.io = fio_http_io(h), __VA_ARGS__)

/** Connects to HTTP / WebSockets / SSE connections on `url`. */
SFUNC fio_io_s *fio_http_connect(const char *url,
                                 fio_http_s *h,
                                 fio_http_settings_s settings);

/** Connects to HTTP / WebSockets / SSE connections on `url`. */
#define fio_http_connect(url, h, ...)                                          \
  fio_http_connect(url, h, (fio_http_settings_s){__VA_ARGS__})

/** Returns the HTTP settings associated with the HTTP object, if any. */
SFUNC fio_http_settings_s *fio_http_settings(fio_http_s *);

/* *****************************************************************************
HTTP Routing  prefix matching
***************************************************************************** */

/**
 * Adds a route prefix to the HTTP handler.
 *
 * Order of route settings is irrelevant (unless overwriting an existing route).
 *
 * Matching is performed as a best-prefix match. i.e.:
 *
 * - All paths match the route `"/"` (the default prefix).
 *
 * - The route `"/user"` will match `"/user"` and all `"/user/..."` paths but
 *   not `"/user..."`
 *
 * - Setting `"/user/new"` as well as `"/user"` (in whatever order) will route
 *   `"/user/new"` and `"/user/new/..."` to `"/user/new"`. Otherwise, the
 *   `"/user"` route will continue to behave the same.
 *
 * Note: the `udata`, `on_finish`, `public_folder` and `log` properties are all
 * inherited (if missing) from the default HTTP settings used to create the
 * listener.
 *
 * Note: TLS options are ignored.
 * */
SFUNC int fio_http_route(fio_http_listener_s *listener,
                         const char *url,
                         fio_http_settings_s settings);
#define fio_http_route(listener, url, ...)                                     \
  fio_http_route(listener, url, (fio_http_settings_s){__VA_ARGS__})

/** Returns a link to the settings matching `url`, as set by `fio_http_route` */
SFUNC fio_http_settings_s *fio_http_route_settings(fio_http_listener_s *l,
                                                   const char *url);

/* *****************************************************************************
HTTP Routing  CRUD
***************************************************************************** */

typedef enum {
  FIO_HTTP_RESOURCE_NONE,
  FIO_HTTP_RESOURCE_INDEX,
  FIO_HTTP_RESOURCE_SHOW,
  FIO_HTTP_RESOURCE_NEW,
  FIO_HTTP_RESOURCE_EDIT,
  FIO_HTTP_RESOURCE_CREATE,
  FIO_HTTP_RESOURCE_UPDATE,
  FIO_HTTP_RESOURCE_DELETE,
} fio_http_resource_action_e;

/** returns expected action or `FIO_HTTP_RESOURCE_NONE` on error. */
FIO_IFUNC fio_http_resource_action_e fio_http_resource_action(fio_http_s *h);

/* *****************************************************************************
WebSocket Helpers - HTTP Upgraded Connections
***************************************************************************** */

/** Writes a WebSocket message. Fails if connection wasn't upgraded yet. */
SFUNC int fio_http_websocket_write(fio_http_s *h,
                                   const void *buf,
                                   size_t len,
                                   uint8_t is_text);

/**
 * Sets a specific on_message callback for this connection.
 *
 * Returns -1 on error (i.e., upgrade still in negotiation).
 */
SFUNC int fio_http_on_message_set(fio_http_s *h,
                                  void (*on_message)(fio_http_s *,
                                                     fio_buf_info_s,
                                                     uint8_t));

/** Optional WebSocket subscription callback. */
SFUNC void FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT(fio_msg_s *msg);
/** Optional WebSocket subscription callback - all messages are UTF-8 valid. */
SFUNC void FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_TEXT(fio_msg_s *msg);
/** Optional WebSocket subscription callback - messages may be non-UTF-8. */
SFUNC void FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_BINARY(fio_msg_s *msg);

/* *****************************************************************************
EventSource (SSE) Helpers - HTTP Upgraded Connections
***************************************************************************** */

/** Named arguments for fio_http_sse_write. */
typedef struct {
  /** The message's `id` data (if any). */
  fio_buf_info_s id;
  /** The message's `event` data (if any). */
  fio_buf_info_s event;
  /** The message's `data` data (if any). */
  fio_buf_info_s data;
} fio_http_sse_write_args_s;

/** Writes an SSE message (UTF-8). Fails if connection wasn't upgraded yet. */
SFUNC int fio_http_sse_write(fio_http_s *h, fio_http_sse_write_args_s args);

/** Writes an SSE message (UTF-8). Fails if connection wasn't upgraded yet. */
#define fio_http_sse_write(h, ...)                                             \
  fio_http_sse_write((h), ((fio_http_sse_write_args_s){__VA_ARGS__}))

/** Optional EventSource subscription callback - messages MUST be UTF-8. */
SFUNC void FIO_HTTP_SSE_SUBSCRIBE_DIRECT(fio_msg_s *msg);

/* *****************************************************************************
Module Implementation - HTTP Routing  CRUD
***************************************************************************** */

/** returns expected action or `FIO_HTTP_RESOURCE_NONE` on error. */
FIO_IFUNC fio_http_resource_action_e fio_http_resource_action(fio_http_s *h) {
  fio_http_resource_action_e r = FIO_HTTP_RESOURCE_NONE;
  if (!h)
    return r;
  const uint32_t new_s = fio_buf2u32u("/new") | 0x20202020U;
  const uint32_t edit_s = fio_buf2u32u("edit");
  const uint32_t get = fio_buf2u32u("get\x20");
  const uint32_t put = fio_buf2u32u("put\x20");
  const uint32_t post = fio_buf2u32u("post");
  const uint32_t patc = fio_buf2u32u("patc");
  const uint32_t dele = fio_buf2u32u("dele");
  const uint32_t lete = fio_buf2u32u("lete");
  fio_str_info_s method = fio_http_method(h);
  fio_str_info_s path = fio_http_path(h);
  bool path_ends_with_dash = (path.len && path.buf[path.len - 1] == '/');
  bool path_is_new = ((path.len == 4 || (path.len > 4 && path.buf[4] == '/')) &&
                      ((fio_buf2u32u(path.buf) | 0x20202020U) == new_s));
  if (method.len < 3)
    return r;
  uint32_t tmp = fio_buf2u32u(method.buf) | 0x20202020U; /* down-case */
  /* GET */
  if (tmp == get) {
    bool path_is_edit =
        ((path.len > 6) &&
         path.buf[path.len - (5 + path_ends_with_dash)] == '/' &&
         ((fio_buf2u32u((path.buf + path.len) - (4 + path_ends_with_dash)) |
           0x20202020U) == edit_s));
    /* index vs show */
    r = (fio_http_resource_action_e)((unsigned)FIO_HTTP_RESOURCE_INDEX +
                                     (path.len > 1));
    /* show vs new */
    r = (fio_http_resource_action_e)((unsigned)r +
                                     (path_is_new & (!path_is_edit)));
    /* show vs edit */
    r = (fio_http_resource_action_e)((unsigned)r +
                                     ((unsigned)path_is_edit << 1));
    /* new/edit collision */
    r = (fio_http_resource_action_e)((unsigned)r -
                                     (((unsigned)(r == FIO_HTTP_RESOURCE_EDIT) &
                                       path_is_new) *
                                      FIO_HTTP_RESOURCE_EDIT));
    /* PUT/POST/PATCH */
  } else if (tmp == put || (tmp == post && method.len == 4) ||
             (tmp == patc && ((method.buf[4] | 32) == 'h') &&
              method.len == 5)) {
    /* create vs edit */
    r = (fio_http_resource_action_e)((unsigned)FIO_HTTP_RESOURCE_CREATE +
                                     (path.len > 1 && !path_is_new));
    /* DELETE */
  } else if (path.len > 1 && !path_is_new && method.len == 6 && tmp == dele &&
             (fio_buf2u32u(method.buf + 2) | 0x20202020U) == lete) {
    r = FIO_HTTP_RESOURCE_DELETE;
  }
  return r;
}

/* *****************************************************************************
Module Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/*
REMEMBER:
========

All memory allocations should use:
* FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)
* FIO_MEM_FREE_(ptr, size)

*/

/* *****************************************************************************
HTTP Settings Validation
***************************************************************************** */

static void fio___http_default_on_http_request(fio_http_s *h) {
  fio_http_send_error_response(h, 404);
}
static void fio___http_default_noop(fio_http_s *h) { ((void)h); }
static int fio___http_default_authenticate(fio_http_s *h) {
  ((void)h);
  return -1;
}

// on_queue
static void fio___http_default_on_stop(struct fio_http_settings_s *settings) {
  ((void)settings);
}

static void fio___http_default_close(fio_http_s *h) {
  fio_io_close(fio_http_io(h));
}

/** Called when a WebSocket message is received. */
static void fio___http_default_on_message(fio_http_s *h,
                                          fio_buf_info_s msg,
                                          uint8_t is_text) {
  (void)h, (void)msg, (void)is_text;
}
/** Called when an EventSource event is received. */
static void fio___http_default_on_eventsource(fio_http_s *h,
                                              fio_buf_info_s id,
                                              fio_buf_info_s event,
                                              fio_buf_info_s data) {
  (void)h, (void)id, (void)event, (void)data;
}
/** Called when an EventSource event is received. */
static void fio___http_default_on_eventsource_redirect(fio_http_s *h,
                                                       fio_buf_info_s id,
                                                       fio_buf_info_s event,
                                                       fio_buf_info_s data);

/** Called when an EventSource reconnect event requests an ID. */
static void fio___http_default_on_eventsource_reconnect(fio_http_s *h,
                                                        fio_buf_info_s id) {
  (void)h, (void)id;
}

static void fio___http_settings_validate(fio_http_settings_s *s,
                                         int is_client) {
  if (!s->pre_http_body)
    s->pre_http_body = fio___http_default_noop;
  if (!s->on_http)
    s->on_http = is_client ? fio___http_default_noop
                           : fio___http_default_on_http_request;
  if (!s->on_finish)
    s->on_finish = fio___http_default_noop;
  if (!s->on_stop)
    s->on_stop = fio___http_default_on_stop;
  if (!s->on_authenticate_sse)
    s->on_authenticate_sse = is_client ? FIO_HTTP_AUTHENTICATE_ALLOW
                                       : fio___http_default_authenticate;
  if (!s->on_authenticate_websocket)
    s->on_authenticate_websocket = is_client ? FIO_HTTP_AUTHENTICATE_ALLOW
                                             : fio___http_default_authenticate;
  if (!s->on_open)
    s->on_open = fio___http_default_noop;
  if (!s->on_message)
    s->on_message = fio___http_default_on_message;
  if (!s->on_eventsource)
    s->on_eventsource = (s->on_message == fio___http_default_on_message
                             ? fio___http_default_on_eventsource
                             : fio___http_default_on_eventsource_redirect);
  if (!s->on_eventsource_reconnect)
    s->on_eventsource_reconnect = fio___http_default_on_eventsource_reconnect;
  if (!s->on_ready)
    s->on_ready = fio___http_default_noop;
  if (!s->on_shutdown)
    s->on_shutdown = fio___http_default_noop;
  if (!s->on_close)
    s->on_close = fio___http_default_noop;
  if (!s->max_header_size)
    s->max_header_size = FIO_HTTP_DEFAULT_MAX_HEADER_SIZE;
  if (!s->max_line_len)
    s->max_line_len = FIO_HTTP_DEFAULT_MAX_LINE_LEN;
  if (!s->max_body_size)
    s->max_body_size = FIO_HTTP_DEFAULT_MAX_BODY_SIZE;
  if (!s->ws_max_msg_size)
    s->ws_max_msg_size = FIO_HTTP_DEFAULT_WS_MAX_MSG_SIZE;
  if (!s->timeout)
    s->timeout = FIO_HTTP_DEFAULT_TIMEOUT;
  if (!s->ws_timeout)
    s->ws_timeout = FIO_HTTP_DEFAULT_TIMEOUT_LONG;
  if (!s->sse_timeout)
    s->sse_timeout = s->ws_timeout;

  if (s->max_header_size < s->max_line_len)
    s->max_header_size = s->max_line_len;

  if (s->public_folder.buf) {
    if (s->public_folder.len > 1 &&
        s->public_folder.buf[s->public_folder.len - 1] == '/' &&
        !(s->public_folder.len == 2 && s->public_folder.buf[0] == '~'))
      --s->public_folder.len;
    if (!fio_filename_is_folder(s->public_folder.buf)) {
      FIO_LOG_ERROR("HTTP public folder not found (or not a folder), setting "
                    "ignored.\n\t%s",
                    s->public_folder.buf);
      s->public_folder = ((fio_str_info_s){0});
    }
  }
}

/* *****************************************************************************
HTTP Protocols used by the HTTP module
***************************************************************************** */

typedef enum fio___http_protocol_selector_e {
  FIO___HTTP_PROTOCOL_ACCEPT = 0,
  FIO___HTTP_PROTOCOL_HTTP1,
  FIO___HTTP_PROTOCOL_HTTP2,
  FIO___HTTP_PROTOCOL_WS,
  FIO___HTTP_PROTOCOL_SSE,
  FIO___HTTP_PROTOCOL_NONE
} fio___http_protocol_selector_e;

/* *****************************************************************************
HTTP Protocol Container (vtable + settings storage)
***************************************************************************** */
#define FIO___RECURSIVE_INCLUDE 1

typedef union fio___http_router_u {
  fio_http_settings_s s;
  void *ptr[256];
  union fio___http_router_u *map[256];
} fio___http_router_u;

FIO_SFUNC void fio___http_router_destroy(fio___http_router_u *router);

typedef struct {
  fio_http_settings_s settings;
  void (*on_http_callback)(void *, void *);
  fio_queue_s *queue;
  struct {
    fio_io_protocol_s protocol;
    fio_http_controller_s controller;
  } state[FIO___HTTP_PROTOCOL_NONE + 1];
  fio___http_router_u router;
  char public_folder_buf[];
} fio___http_protocol_s;
#include FIO_INCLUDE_FILE

#define FIO_REF_NAME             fio___http_protocol
#define FIO_REF_FLEX_TYPE        char
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_REF_DESTROY(o)                                                     \
  do {                                                                         \
    if (o.settings.tls)                                                        \
      fio_io_tls_free(o.settings.tls);                                         \
    fio___http_router_destroy(&o.router);                                      \
  } while (0)
#include FIO_INCLUDE_FILE

FIO_IFUNC fio___http_protocol_s *fio___http_protocol_init(
    fio___http_protocol_s *p,
    const char *url,
    fio_http_settings_s s,
    bool is_client);
/* *****************************************************************************
HTTP Connection Container
***************************************************************************** */

struct fio___http_connection_http_s {
  void (*on_http_callback)(void *, void *);
  void (*on_http)(fio_http_s *h);
  void (*on_finish)(fio_http_s *h);
  fio_http1_parser_s parser;
  fio_str_info_s buf;
  uint32_t max_header;
  uint32_t max_line;
  uint32_t header_bytes;
};
struct fio___http_connection_ws_s {
  void (*on_message)(fio_http_s *h, fio_buf_info_s msg, uint8_t is_text);
  void (*on_ready)(fio_http_s *h);
  fio_websocket_parser_s parser;
  char *msg;
  uint16_t code;
};
struct fio___http_connection_sse_s {
  void (*on_message)(fio_http_s *h,
                     fio_buf_info_s id,
                     fio_buf_info_s event,
                     fio_buf_info_s data);
  void (*on_ready)(fio_http_s *h);
  fio_buf_info_s id;
  fio_buf_info_s event;
  char *data;
};

/** Connection objects for managing HTTP / WebSocket connection state. */
typedef struct {
  fio_io_s *io;
  fio_http_s *h;
  fio_http_settings_s *settings;
  fio_queue_s *queue;
  void *udata;
  union {
    struct fio___http_connection_http_s http;
    struct fio___http_connection_ws_s ws;
    struct fio___http_connection_sse_s sse;
  } state;
  uint32_t len;
  uint32_t capa;
  uint8_t log;
  uint8_t suspend;
  uint8_t is_client;
  char buf[];
} fio___http_connection_s;

#define FIO_REF_NAME             fio___http_connection
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_REF_FLEX_TYPE        char
#define FIO_REF_DESTROY(o)                                                     \
  do {                                                                         \
    fio___http_protocol_free(                                                  \
        FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, o.settings));      \
  } while (0)
#include FIO_INCLUDE_FILE

#undef FIO___RECURSIVE_INCLUDE

/* *****************************************************************************
HTTP Routing
***************************************************************************** */

FIO_LEAK_COUNTER_DEF(fio___http_router_u)
FIO_SFUNC void fio___http_on_http_with_public_folder(void *h_, void *ignr);

void fio_http_route___(void);
/** Adds a route prefix to the HTTP handler. */
SFUNC int fio_http_route FIO_NOOP(fio_http_listener_s *l,
                                  const char *url,
                                  fio_http_settings_s s) {
  int err = 0;
  const uint8_t *u = (const uint8_t *)url;
  fio___http_protocol_s *p;
  fio___http_router_u *r;
  if (!l)
    goto invalid_listener_error;
  p = FIO_PTR_FROM_FIELD(fio___http_protocol_s,
                         state[FIO___HTTP_PROTOCOL_ACCEPT].protocol,
                         fio_io_listener_protocol((fio_io_listener_s *)l));
  r = &p->router;
  if (!u || !u[0]) {
    url = "/";
    u = (const uint8_t *)url;
  }
  /* skip first `/` character, they should always exist anyway */
  u += (*u == (uint8_t)'/');
  /* skip last `/` character, to preserve memory and reduce seeking time */
  for (; *u && (*u != (uint8_t)'/' || u[1]); ++u) {
    if (*u < (sizeof(s) / sizeof(void *)))
      goto invalid_char_error;
    if (!r->map[*u])
      break;
    r = r->map[*u];
  }
  /* skip last `/` character, to preserve memory and reduce seeking time */
  for (; *u && (*u != (uint8_t)'/' || u[1]); ++u) {
    if (*u < (sizeof(s) / sizeof(void *)))
      goto invalid_char_error;
    r->map[*u] =
        (fio___http_router_u *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*r), 0);
    r = r->map[*u];
    FIO_ASSERT_ALLOC(r);
    FIO_LEAK_COUNTER_ON_ALLOC(fio___http_router_u);
    if (!FIO_MEM_REALLOC_IS_SAFE_) {
      FIO_MEMSET(r, 0, sizeof(*r));
    }
  }
  /* we are at the leaf node of the path */

  /* inherit reasonable defaults */
  if (!s.on_finish)
    s.on_finish = p->settings.on_finish;
  if (!s.udata)
    s.udata = p->settings.udata;
  if (!s.on_stop)
    s.on_stop = p->settings.on_stop;
  if (!s.on_authenticate_sse)
    s.on_authenticate_sse = p->settings.on_authenticate_sse;
  if (!s.on_authenticate_websocket)
    s.on_authenticate_websocket = p->settings.on_authenticate_websocket;
  if (!s.max_header_size)
    s.max_header_size = p->settings.max_header_size;
  if (!s.max_line_len)
    s.max_line_len = p->settings.max_line_len;
  if (!s.max_body_size)
    s.max_body_size = p->settings.max_body_size;
  if (!s.ws_max_msg_size)
    s.ws_max_msg_size = p->settings.ws_max_msg_size;
  if (!s.timeout)
    s.timeout = p->settings.timeout;
  if (!s.ws_timeout)
    s.ws_timeout = p->settings.ws_timeout;
  if (!s.sse_timeout)
    s.sse_timeout = p->settings.sse_timeout;
  if (!s.log)
    s.log = p->settings.log;
  s.tls = NULL;
  s.tls_io_func = NULL;
  /* validate settings and store */
  fio___http_settings_validate(&s, 0);
  if (!s.public_folder.buf)
    s.public_folder = p->settings.public_folder;
  else if (s.public_folder.buf && s.public_folder.len) {
    s.tls =
        (fio_io_tls_s *)FIO_MEM_REALLOC_(NULL, 0, s.public_folder.len + 1, 0);
    FIO_ASSERT_ALLOC(s.tls);
    FIO_MEMCPY(s.tls, s.public_folder.buf, s.public_folder.len);
    s.public_folder = FIO_STR_INFO2((char *)s.tls, s.public_folder.len);
    s.public_folder.buf[s.public_folder.len] = 0;
  }
  /* make sure we're not leaking memory when overwriting an existing route */
  if (r->s.on_http) {
    if (r->s.on_stop != p->settings.on_stop || r->s.udata != p->settings.udata)
      r->s.on_stop(&r->s);
    if (r->s.tls && (char *)r->s.tls == r->s.public_folder.buf)
      FIO_MEM_FREE_(r->s.tls, r->s.public_folder.len + 1);
  }
  /* if we have a route with a static file service, we need this */
  if (s.public_folder.buf && s.public_folder.len) {
    p->on_http_callback = fio___http_on_http_with_public_folder;
  }
  r->s = s;
  return err;

invalid_char_error:
  if (url)
    FIO_LOG_ERROR("Invalid character found in path URL[%zu]: %s",
                  (size_t)((const char *)u - url),
                  url);
  else
    FIO_LOG_FATAL("HTTP Router requires a non-NULL URL!");
  err = -1;
  return err;

invalid_listener_error:
  FIO_LOG_FATAL("HTTP Router requires an existing HTTP listener object.");
  err = -1;
  return err;
}

void fio___http_route_settings___(void);
FIO_SFUNC fio_http_settings_s *fio___http_route_settings(
    fio___http_router_u *route,
    fio_str_info_s *path) {
  fio_http_settings_s *r = &route->s;
  uint8_t *pos = (uint8_t *)path->buf;
  const uint8_t *n = pos;
  pos += (*pos == (uint8_t)'/');
  if (!*pos)
    return r;
  for (uint8_t c, hi, lo;
       route && ((c = *pos) >= (sizeof(*r) / sizeof(void *)));
       ++pos) {
    /* we have a possible match here - store before stepping into path */
    if (c == (uint8_t)'/' && route->s.on_http) {
      r = &route->s;
      n = pos;
    } else if (c == (uint8_t)'%' && (hi = fio_c2i(pos[1])) < 16) {
      if ((lo = fio_c2i(pos[2])) < 16) { /* decrypt route */
        c = (hi << 4) | lo;
        pos += 2;
        if (c < (sizeof(*r) / sizeof(void *)))
          break;
      }
    }
    route = route->map[c];
  }
  /* test if '/' may be inferred */
  if (!*pos && route && route->map[0]) {
    r = &route->s;
    path->len = 1;
    n = (uint8_t *)path->buf;
  }
  n -= (n == (uint8_t *)path->buf + 1);
  *path = FIO_STR_INFO2((char *)n, path->len - ((char *)n - path->buf));
  return r;
}

void fio___http_route_get___(void);
FIO_SFUNC fio_http_settings_s *fio___http_route_get(fio_http_s *h) {
  fio_http_settings_s *r = NULL;
  fio___http_connection_s *connection =
      (fio___http_connection_s *)fio_http_cdata(h);
  if (!connection)
    return r;
  fio___http_protocol_s *p =
      FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, connection->settings);
  fio_str_info_s path = fio_http_opath(h);
  r = fio___http_route_settings(&p->router, &path);
  fio_http_udata_set(h, r->udata);
  fio_http_path_set(h, path);
  connection->state.http.on_http = r->on_http;
  connection->state.http.on_finish = r->on_finish;
  return r;
}

FIO_SFUNC void fio___http_router_destroy(fio___http_router_u *r) {
  if (!r)
    return;
  if (r->s.tls && (char *)r->s.tls == r->s.public_folder.buf)
    FIO_MEM_FREE_(r->s.tls, r->s.public_folder.len + 1);
  for (size_t i = (sizeof(r->s) / sizeof(void *)); i < 256; ++i) {
    if (!r->map[i])
      continue;
    fio___http_router_destroy(r->map[i]);
    FIO_MEM_FREE_(r->map[i], sizeof(*r));
    FIO_LEAK_COUNTER_ON_FREE(fio___http_router_u);
  }
  if (r->s.on_stop)
    r->s.on_stop(&r->s);
}

SFUNC fio_http_settings_s *fio_http_route_settings(fio_http_listener_s *l,
                                                   const char *url) {
  fio_http_settings_s *r = NULL;
  fio___http_protocol_s *p;
  fio_str_info_s path = FIO_STR_INFO2((char *)url, 1);
  if (!l)
    return r;
  p = FIO_PTR_FROM_FIELD(fio___http_protocol_s,
                         state[FIO___HTTP_PROTOCOL_ACCEPT].protocol,
                         fio_io_listener_protocol((fio_io_listener_s *)l));
  r = fio___http_route_settings(&p->router, &path);
  return r;
}

/* *****************************************************************************
Revisit defaults
***************************************************************************** */

/** Called when an EventSource event is received. */
static void fio___http_default_on_eventsource_redirect(fio_http_s *h,
                                                       fio_buf_info_s id,
                                                       fio_buf_info_s event,
                                                       fio_buf_info_s data) {
  fio_http_settings_s *s = fio___http_route_get(h);
  s->on_message(h, data, 1);
  (void)h, (void)id, (void)event, (void)data;
}

/* *****************************************************************************
HTTP Request handling / handling
***************************************************************************** */

FIO_SFUNC void fio___http_perform_user_callback(void *cb_, void *h_) {
  union {
    void (*fn)(fio_http_s *);
    void *ptr;
  } cb = {.ptr = cb_};
  fio_http_s *h = (fio_http_s *)h_;
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);

  if (FIO_LIKELY(c && FIO_SOCK_IS_OPEN(fio_io_fd(c->io))))
    cb.fn(h);
  fio_http_free(h);
}

FIO_SFUNC void fio___http_perform_user_upgrade_callback_websocket(void *cb_,
                                                                  void *h_) {
  union {
    int (*fn)(fio_http_s *);
    void *ptr;
  } cb = {.ptr = cb_};
  fio_http_s *h = (fio_http_s *)h_;
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  struct fio___http_connection_http_s old = c->state.http;
  if (!FIO_LIKELY(fio_io_is_open(c->io)) || cb.fn(h))
    goto refuse_upgrade;
  if (c->h) /* request after WebSocket Upgrade? an attack vector? */
    goto refuse_upgrade;
#if HAVE_ZLIB && 0           /* TODO: logs and fix extension handling logic */
  FIO_HTTP_HEADER_EACH_VALUE(/* TODO: setup WebSocket extension */
                             h,
                             1,
                             FIO_STR_INFO2((char *)"sec-websocket-extensions",
                                           24),
                             val) {
    FIO_LOG_DDEBUG2("WebSocket extension requested: %.*s",
                    (int)val.len,
                    val.buf);
    if (!FIO_STR_INFO_IS_EQ(val,
                            FIO_STR_INFO2((char *)"permessage-deflate", 18)))
      continue;
    size_t client_bits = 0, server_bits = 0;
    FIO_HTTP_HEADER_VALUE_EACH_PROPERTY(val, p) {
      FIO_LOG_DDEBUG2("\t %.*s: %.*s",
                      (int)p.name.len,
                      p.name.buf,
                      (int)p.value.len,
                      p.value.buf);
      if (FIO_STR_INFO_IS_EQ(p.name,
                             FIO_STR_INFO2((char *)"client_max_window_bits",
                                           22))) { /* used by chrome */
        char *iptr = p.value.buf;
        client_bits = iptr ? fio_atol10u(&iptr) : 0;
        if (client_bits < 8 || client_bits > 15)
          client_bits = (size_t)-1;
      }
      if (FIO_STR_INFO_IS_EQ(
              p.name,
              FIO_STR_INFO2((char *)"server_max_window_bits", 22))) {
        char *iptr = p.value.buf;
        server_bits = iptr ? fio_atol10u(&iptr) : 0;
        if (server_bits < 8 || server_bits > 15)
          server_bits = (size_t)-1;
      }
    }
    if (client_bits)
      ; /* TODO */
    if (server_bits)
      ; /* TODO */
    break;
  } /* HAVE_ZLIB */
#endif
  fio_http_upgrade_websocket(h);
  return;

refuse_upgrade:
  c->state.http = old;
  if (fio_http_send_error_response(h, 403))
    fio_io_free(c->io);
  fio_http_free(h);
}

FIO_SFUNC void fio___http_perform_user_upgrade_callback_sse(void *cb_,
                                                            void *h_) {
  union {
    int (*fn)(fio_http_s *);
    void *ptr;
  } cb = {.ptr = cb_};
  fio_http_s *h = (fio_http_s *)h_;
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (!FIO_LIKELY(fio_io_is_open(c->io)) || cb.fn(h))
    goto refuse_upgrade;
  if (c->h) /* request after eventsource? an attack vector? */
    goto refuse_upgrade;
  fio_http_upgrade_sse(h);
  return;

refuse_upgrade:
  if (fio_http_send_error_response(h, 403))
    fio_io_free(c->io);
  fio_http_free(h);
}

FIO_IFUNC int fio___http_on_http_test4upgrade(fio_http_s *h,
                                              fio___http_connection_s *c,
                                              fio_http_settings_s *s) {
  union {
    int (*fn)(fio_http_s *);
    void *ptr;
  } cb;
  if (fio_http_websocket_requested(h))
    goto websocket_requested;
  if (fio_http_sse_requested(h))
    goto sse_requested;
  return 0;

websocket_requested:
  cb.fn = s->on_authenticate_websocket;
  fio_queue_push(c->queue,
                 fio___http_perform_user_upgrade_callback_websocket,
                 cb.ptr,
                 (void *)h);
  return -1;

sse_requested:
  cb.fn = s->on_authenticate_sse;
  fio_queue_push(c->queue,
                 fio___http_perform_user_upgrade_callback_sse,
                 cb.ptr,
                 (void *)h);
  return -1;

#if 0
http2_requested:
  // Connection: Upgrade, HTTP2-Settings
  // Upgrade: h2c
  // HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>
  return 0; /* allowed to ignore upgrade request */
#endif
}

FIO_SFUNC void fio___http_on_http_direct(void *h_, void *ignr) {
  fio_http_s *h = (fio_http_s *)h_;
  fio_http_status_set(h, 200);
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  fio_http_settings_s *s = fio___http_route_get(h);
  if (fio___http_on_http_test4upgrade(h, c, s))
    return;
  union {
    void (*fn)(fio_http_s *);
    void *ptr;
  } cb = {.fn = s->on_http};
  fio_queue_push(c->queue, fio___http_perform_user_callback, cb.ptr, (void *)h);
  (void)ignr;
}

FIO_SFUNC void fio___http_on_http_with_public_folder(void *h_, void *ignr) {
  fio_http_s *h = (fio_http_s *)h_;
  fio_http_status_set(h, 200);
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  fio_http_settings_s *s = fio___http_route_get(h);
  if (fio___http_on_http_test4upgrade(h, c, s))
    return;
  if (s->public_folder.buf &&
      (fio_http_method(h).len != 4 || (fio_buf2u32u(fio_http_method(h).buf) |
                                       0x20202020UL) != fio_buf2u32u("post")) &&
      !fio_http_static_file_response(
          h,
          s->public_folder,
          (s->public_folder.buf == c->settings->public_folder.buf
               ? fio_http_opath(h)
               : fio_http_path(h)),
          s->max_age)) {
    fio_http_free(h);
    return;
  }
  union {
    void (*fn)(fio_http_s *);
    void *ptr;
  } cb = {.fn = s->on_http};
  fio_queue_push(c->queue, fio___http_perform_user_callback, cb.ptr, (void *)h);
  (void)ignr;
}

FIO_SFUNC void fio___http_perform_user_callback_client(void *cb_, void *h_) {
  fio_http_s *h = (fio_http_s *)h_;
  union {
    void (*fn)(fio_http_s *);
    void *ptr;
  } cb = {.ptr = cb_};
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  /* unlike Server mode, handle responses from closed connections */
  cb.fn(h);
  fio_http_free(h);
  fio_io_free(c->io);
}

FIO_SFUNC void fio___http_on_http_client(void *h_, void *ignr) {
  fio_http_s *h = (fio_http_s *)h_;
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  size_t pr = FIO___HTTP_PROTOCOL_WS;
  union {
    void (*fn)(fio_http_s *);
    void *ptr;
  } cb = {.fn = c->state.http.on_http};

  /* TODO! review WS and SSE responses. */
  if (fio_http_websocket_accepted(h))
    goto websocket_accepted;
  if (fio_http_sse_accepted(h))
    goto sse_accepted;
  fio_queue_push(c->queue,
                 fio___http_perform_user_callback_client,
                 cb.ptr,
                 (void *)h);
  return;
  (void)ignr;

sse_accepted:
  pr = FIO___HTTP_PROTOCOL_SSE;

websocket_accepted:
  c->h = h; /* was set to NULL in `on_http_complete` */
  fio_http_controller_set(
      c->h,
      &(FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings)
            ->state[pr]
            .controller));
  fio_io_protocol_set(
      c->io,
      &(FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings)
            ->state[pr]
            .protocol));

  FIO_LOG_DDEBUG2("(%d) Client %s upgrade complete for fd %d",
                  fio_io_pid(),
                  (fio_http_is_websocket(h) ? "WebSocket" : "SSE"),
                  fio_io_fd(c->io));

  fio_io_free(c->io); /* fio_dup called by fio_http1_on_complete */
  c->suspend = 0;
  fio_io_unsuspend(c->io);
}

/* *****************************************************************************
ALPN Helpers
***************************************************************************** */

FIO_SFUNC void fio___http_on_select_h1(fio_io_s *io) {
  FIO_LOG_DDEBUG2("TLS ALPN HTTP/1.1 selected for %p", io);
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  fio_io_protocol_set(
      io,
      &(FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings)
            ->state[FIO___HTTP_PROTOCOL_HTTP1]
            .protocol));
}
FIO_SFUNC void fio___http_on_select_h2(fio_io_s *io) {
  FIO_LOG_ERROR("TLS ALPN HTTP/2 not supported for %p", io);
  (void)io;
}

/* *****************************************************************************
HTTP Listen
***************************************************************************** */

static void fio___http_listen_on_start(fio_io_protocol_s *protocol, void *u) {
  (void)u;
  fio___http_protocol_s *p = (fio___http_protocol_s *)protocol;
  p->queue = ((p->settings.queue && p->settings.queue->q) ? p->settings.queue->q
                                                          : fio_io_queue());
}

static void fio___http_listen_on_stop(fio_io_protocol_s *p, void *u) {
  (void)u;
  fio___http_protocol_free(
      FIO_PTR_FROM_FIELD(fio___http_protocol_s,
                         state[FIO___HTTP_PROTOCOL_ACCEPT].protocol,
                         p));
}

void fio_http_listen___(void); /* IDE marker */
SFUNC fio_http_listener_s *fio_http_listen FIO_NOOP(const char *url,
                                                    fio_http_settings_s s) {
  fio___http_settings_validate(&s, 0);
  if (url) {
    fio_url_s u = fio_url_parse(url, FIO_STRLEN(url));
    if (u.path.len)
      FIO_LOG_WARNING(
          "HTTP listener is always at the root (home folder).\n\t"
          "  Ignoring the path set in the listening instruction: %.*s",
          (int)u.path.len,
          u.path.buf);
  }
  fio___http_protocol_s *p = fio___http_protocol_new(s.public_folder.len + 1);
  fio___http_protocol_init(p, url, s, 0);
  fio_http_listener_s *listener = (fio_http_listener_s *)
      fio_io_listen(.url = url,
                    .protocol = &p->state[FIO___HTTP_PROTOCOL_ACCEPT].protocol,
                    .tls = s.tls,
                    .on_start = fio___http_listen_on_start,
                    .on_stop = fio___http_listen_on_stop,
                    .queue_for_accept = p->settings.queue);
  return listener;
}

/** Returns the a pointer to the HTTP settings associated with the listener. */
SFUNC fio_http_settings_s *fio_http_listener_settings(fio_http_listener_s *l) {
  fio___http_protocol_s *p =
      FIO_PTR_FROM_FIELD(fio___http_protocol_s,
                         state[FIO___HTTP_PROTOCOL_ACCEPT].protocol,
                         fio_io_listener_protocol((fio_io_listener_s *)l));
  return &p->settings;
}

/* *****************************************************************************
HTTP Connect
***************************************************************************** */

static void fio___http_connect_on_failed(fio_io_protocol_s *p, void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  fio_http_free(c->h);
  c->h = NULL;
  fio___http_connection_free(c);
  (void)p;
}

void fio_http_connect___(void); /* IDE Marker */
/** Connects to HTTP / WebSockets / SSE connections on `url`. */
SFUNC fio_io_s *fio_http_connect FIO_NOOP(const char *url,
                                          fio_http_s *h,
                                          fio_http_settings_s s) {
  FIO_STR_INFO_TMP_VAR(origin, 4096);
  fio___http_settings_validate(&s, 1);
  fio_url_s u = (fio_url_s){0};
  if (url)
    u = fio_url_parse(url, strlen(url));

  if (!h)
    h = fio_http_new();
  if (!fio_http_path(h).len)
    fio_http_path_set(h,
                      u.path.len ? FIO_BUF2STR_INFO(u.path)
                                 : FIO_STR_INFO2((char *)"/", 1));
  if (!fio_http_query(h).len && u.query.len)
    fio_http_query_set(h, FIO_BUF2STR_INFO(u.query));
  if (!fio_http_method(h).len)
    fio_http_method_set(h, FIO_STR_INFO2((char *)"GET", 3));
  if (u.host.len) {
    fio_http_request_header_set_if_missing(h,
                                           FIO_STR_INFO2((char *)"host", 4),
                                           FIO_BUF2STR_INFO(u.host));
    /* Origin header */
    fio_string_write2(
        &origin,
        NULL,
        FIO_STRING_WRITE_STR2("https", (size_t)(4 + fio_url_is_tls(u).tls)),
        FIO_STRING_WRITE_STR2("://", 3U),
        FIO_STRING_WRITE_STR_INFO(u.host),
        FIO_STRING_WRITE_STR2(":", (size_t)(!!u.port.len)),
        FIO_STRING_WRITE_STR_INFO(u.port));
  }

  /* test for ws:// or wss:// - WebSocket scheme */
  if ((u.scheme.len == 2 ||
       (u.scheme.len == 3 && ((u.scheme.buf[2] | 0x20) == 's'))) &&
      (fio_buf2u16u(u.scheme.buf) | 0x2020) == fio_buf2u16u("ws")) {
    fio_http_request_header_set_if_missing(h,
                                           FIO_STR_INFO2((char *)"origin", 6),
                                           origin);
    fio_http_websocket_set_request(h);
  }
  /* test for sse:// or sses:// - Server Sent Events scheme */
  else if ((u.scheme.len == 3 ||
            (u.scheme.len == 4 && ((u.scheme.buf[3] | 0x20) == 's'))) &&
           (fio_buf2u32u(u.scheme.buf) | fio_buf2u32u("\x20\x20\x20\xFF")) ==
               fio_buf2u32u("sse\xFF")) {
    fio_http_request_header_set_if_missing(h,
                                           FIO_STR_INFO2((char *)"origin", 6),
                                           origin);
    fio_http_sse_set_request(h);
  }

  /* TODO: test for and attempt to re-use connection */
  // if (fio_http_cdata(h)) { }

  fio___http_protocol_s *p = fio___http_protocol_new(u.host.len);
  fio___http_protocol_init(p, url, s, 1);
  fio___http_connection_s *c =
      fio___http_connection_new(p->settings.max_line_len);
  FIO_ASSERT_ALLOC(c);
  *c = (fio___http_connection_s){
      .io = NULL,
      .h = h,
      .settings = &(p->settings),
      .queue = p->queue,
      .udata = p->settings.udata,
      .state.http =
          {
              .on_http_callback = p->on_http_callback,
              .on_http = p->settings.on_http,
              .on_finish = p->settings.on_finish,
              .max_header = p->settings.max_header_size,
              .max_line = p->settings.max_line_len,
          },
      .capa = p->settings.max_line_len,
      .log = p->settings.log,
      .is_client = 1,
  };
  fio_http_controller_set(h, &p->state[FIO___HTTP_PROTOCOL_HTTP1].controller);
  if (!fio_http_udata(h)) /* avoid overwriting existing `udata` if set */
    fio_http_udata_set(h, c->udata);
  fio_http_cdata_set(h, fio___http_connection_dup(c));
  return fio_io_connect(url,
                        .protocol =
                            &p->state[FIO___HTTP_PROTOCOL_HTTP1].protocol,
                        .on_failed = fio___http_connect_on_failed,
                        .udata = c,
                        .tls = s.tls,
                        .timeout = s.connect_timeout);
}

/* *****************************************************************************
HTTP/1.1 Request / Response Completed
***************************************************************************** */

/** called when either a request or a response was received. */
static void fio_http1_on_complete(void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  fio_io_dup(c->io); /* make sure the IO and its data are valid in callback */
  fio_io_suspend(c->io);
  fio_http_s *h = c->h;
  c->h = NULL;
  c->state.http.header_bytes = 0;
  c->suspend = 1;
  // fio_io_defer(c->state.http.on_http_callback, h, NULL);
  fio_queue_push(fio_io_queue(), c->state.http.on_http_callback, h);
}

/* *****************************************************************************
HTTP/1.1 Parser callbacks
***************************************************************************** */

FIO_IFUNC void fio___http_request_too_big(fio___http_connection_s *c) {
  fio_http_s *h = c->h;
  fio_io_dup(c->io); /* sending the response will result in fio_undup */
  fio_io_suspend(c->io);
  c->h = NULL;
  c->suspend = 1;
  if (fio_http_send_error_response(h, 413))
    fio_io_free(c->io); /* response not sent, we need to fio_undup */
  fio_http_free(h);
}

FIO_IFUNC void fio_http1_attach_handle(fio___http_connection_s *c) {
  c->h = fio_http_new();
  FIO_ASSERT_ALLOC(c->h);
  fio_http_controller_set(
      c->h,
      &(FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings))
           ->state[FIO___HTTP_PROTOCOL_HTTP1]
           .controller);
  fio_http_udata_set(c->h, c->udata);
  fio_http_cdata_set(c->h, fio___http_connection_dup(c));
}

/** called when a request method is parsed. */
static int fio_http1_on_method(fio_buf_info_s method, void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  if (c->h)
    return -1;
  fio_http1_attach_handle(c);
  fio_http_method_set(c->h, FIO_BUF2STR_INFO(method));
  return 0;
}
/** called when a response status is parsed. the status_str is the string
 * without the prefixed numerical status indicator.*/
static int fio_http1_on_status(size_t istatus,
                               fio_buf_info_s status,
                               void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  fio_http_clear_response(c->h, istatus != 301 && istatus != 302);
  fio_http_status_set(c->h, istatus);
  return 0;
  (void)status;
}
/** called when a request URL is parsed. */
static int fio_http1_on_url(fio_buf_info_s url, void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  fio_url_s u = fio_url_parse(url.buf, url.len);
  if (!u.path.len || u.path.buf[0] != '/')
    return -1;
  fio_http_path_set(c->h, FIO_BUF2STR_INFO(u.path));
  fio_http_opath_set(c->h, FIO_BUF2STR_INFO(u.path));
  if (u.query.len)
    fio_http_query_set(c->h, FIO_BUF2STR_INFO(u.query));
  if (u.host.len)
    (!(c->h) ? fio_http_request_header_set
             : fio_http_response_header_set)(c->h,
                                             FIO_STR_INFO1((char *)"host"),
                                             FIO_BUF2STR_INFO(u.host));
  return 0;
}
/** called when a the HTTP/1.x version is parsed. */
static int fio_http1_on_version(fio_buf_info_s version, void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  FIO_ASSERT_DEBUG(c->h, "on_version called without a pre-existing handle!");
  if (!c->h)
    return -1;
  fio_http_version_set(c->h, FIO_BUF2STR_INFO(version));
  return 0;
}
/** called when a header is parsed. */
static int fio_http1_on_header(fio_buf_info_s name,
                               fio_buf_info_s value,
                               void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  if (!c->h)
    return 0; /* ignore possible post-error response headers */
  const size_t line_len = value.len + name.len;
  c->state.http.header_bytes += line_len;
  if ((unsigned)(c->state.http.header_bytes > c->state.http.max_header) |
      (line_len > c->state.http.max_line))
    goto headers_too_big;
  (!fio_http_status(c->h)
       ? fio_http_request_header_add
       : fio_http_response_header_add)(c->h,
                                       FIO_BUF2STR_INFO(name),
                                       FIO_BUF2STR_INFO(value));
  return 0;
headers_too_big:
  fio_http_send_error_response(c->h, 431);
  return -1;
}
/** called when the special content-length header is parsed. */
static int fio_http1_on_header_content_length(fio_buf_info_s name,
                                              fio_buf_info_s value,
                                              size_t content_length,
                                              void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  fio_http_s *h = c->h;
  if (!h)
    return 0;
  if (content_length > c->settings->max_body_size)
    goto too_big;
  if (content_length)
    fio_http_body_expect(c->h, content_length);
#if FIO_HTTP_SHOW_CONTENT_LENGTH_HEADER
  (!(h->status) ? fio_http_request_header_add
                : fio_http_response_header_add)(h,
                                                FIO_BUF2STR_INFO(name),
                                                FIO_BUF2STR_INFO(value));
#endif
  return 0;
too_big:
  fio___http_request_too_big(c);
  return 0; /* should we disconnect (return -1), or not? */
  (void)name, (void)value;
}
/** called when `Expect` arrives and may require a 100 continue response. */
static int fio_http1_on_expect(void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  const fio_buf_info_s response =
      FIO_BUF_INFO1((char *)"HTTP/1.1 100 Continue\r\n\r\n");
  fio_http_s *h = c->h;
  if (!h)
    return 1;
  c->h = NULL;
  /* TODO: test for body size violation and deny request if payload too big. */
  if (FIO_HTTP1_EXPECTED_CHUNKED != fio_http1_expected(&c->state.http.parser) &&
      c->settings->max_body_size > fio_http1_expected(&c->state.http.parser))
    goto payload_too_big;
  c->settings->pre_http_body(h);
  if (fio_http_status(h))
    goto response_sent;
  c->h = h;
  fio_io_write2(c->io, .buf = response.buf, .len = response.len, .copy = 0);
  return 0; /* TODO?: improve support for `expect` headers? */
payload_too_big:
  fio_io_dup(c->io);
  if (fio_http_send_error_response(h, 413))
    fio_io_free(c->io); /* response not sent, we need to fio_undup */
                        /* fall through */
response_sent:
  // c->h = NULL;
  fio_http_free(h);
  return 1;
}

/** called when a body chunk is parsed. */
static int fio_http1_on_body_chunk(fio_buf_info_s chunk, void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  if (!c->h)
    return -1; /* close connection if a large payload is unstoppable */
  if (c->is_client &&
      (fio_http_status(c->h) == 301 || fio_http_status(c->h) == 302))
    return 0; /* don't overwrite client payload on redirect */
  if (chunk.len + fio_http_body_length(c->h) > c->settings->max_body_size)
    goto too_big;
  fio_http_body_write(c->h, chunk.buf, chunk.len);
  return 0;
too_big:
  fio___http_request_too_big(c);
  return 0;
}

/* *****************************************************************************
HTTP/1.1 Accepting new connections (tests for special HTTP/2 pre-knowledge)
***************************************************************************** */

/** Called when an IO is attached to a protocol. */
FIO_SFUNC void fio___http_on_attach_accept(fio_io_s *io) {

  fio___http_protocol_s *p =
      FIO_PTR_FROM_FIELD(fio___http_protocol_s,
                         state[FIO___HTTP_PROTOCOL_ACCEPT].protocol,
                         fio_io_protocol(io));
  fio___http_protocol_dup(p);
  // p->queue = fio_io_queue();

  const uint32_t capa = p->settings.max_line_len;
  fio___http_connection_s *c = fio___http_connection_new(capa);
  FIO_ASSERT_ALLOC(c);
  *c = (fio___http_connection_s){
      .io = io,
      .settings = &(p->settings),
      .queue =
          ((p->settings.queue && p->settings.queue->q) ? p->settings.queue->q
                                                       : fio_io_queue()),
      .udata = p->settings.udata,
      .state.http =
          {
              .on_http_callback = p->on_http_callback,
              .on_http = p->settings.on_http,
              .on_finish = p->settings.on_finish,
              .max_header = p->settings.max_header_size,
              .max_line = p->settings.max_line_len,
          },
      .capa = capa,
      .log = p->settings.log,
  };
  fio_io_udata_set(io, (void *)c);
  FIO_LOG_DDEBUG2("(%d) HTTP accepted a new connection (%p)",
                  (int)fio_thread_getpid(),
                  c->io);
#if 0 /* skip pre-knowledge test? */
  fio_io_protocol_set(
      io,
      &(FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings)
            ->state[FIO___HTTP_PROTOCOL_HTTP1]
            .protocol));
#endif
}

/** Called when a data is available. */
FIO_SFUNC void fio___http1_accept_on_data(fio_io_s *io) {
  const fio_buf_info_s prior_knowledge = FIO_BUF_INFO2(
      (char *)"\x50\x52\x49\x20\x2a\x20\x48\x54\x54\x50\x2f\x32\x2e\x30"
              "\x0d\x0a\x0d\x0a\x53\x4d\x0d\x0a\x0d\x0a",
      24);
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  fio_io_protocol_s *phttp_new;
  size_t r = fio_io_read(io, c->buf + c->len, c->capa - c->len);
  if (!r) /* nothing happened */
    return;
  c->len = (uint32_t)r;
  if (prior_knowledge.buf[0] != c->buf[0] ||
      FIO_MEMCMP(
          prior_knowledge.buf,
          c->buf,
          (c->len > prior_knowledge.len ? prior_knowledge.len : c->len))) {
    /* no prior knowledge, switch to HTTP/1.1 */
    phttp_new =
        &(FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings)
              ->state[FIO___HTTP_PROTOCOL_HTTP1]
              .protocol);
    fio_io_protocol_set(io, phttp_new);
    return;
  }
  if (c->len < prior_knowledge.len) /* wait for more data */
    return;

  if (c->len > prior_knowledge.len)
    FIO_MEMMOVE(c->buf,
                c->buf + prior_knowledge.len,
                c->len - prior_knowledge.len);
  c->len -= prior_knowledge.len;
  phttp_new = &(FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings)
                    ->state[FIO___HTTP_PROTOCOL_HTTP2]
                    .protocol);

  fio_io_protocol_set(io, phttp_new);
}

FIO_SFUNC void fio___http_on_close(void *buf, void *udata) {
  FIO_LOG_DDEBUG2("(%d) HTTP connection closed for %p",
                  (int)fio_thread_getpid(),
                  udata);
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  c->io = NULL;
  fio_http_free(c->h);
  fio___http_connection_free(c);
  (void)buf;
}

/* *****************************************************************************
HTTP/1.1 Protocol
***************************************************************************** */

FIO_SFUNC int fio___http1_process_data(fio_io_s *io,
                                       fio___http_connection_s *c) {
  (void)io;
  for (;;) {
    size_t consumed = fio_http1_parse(&c->state.http.parser,
                                      FIO_BUF_INFO2(c->buf, c->len),
                                      (void *)c);
    if (!consumed)
      goto nothing_consumed;
    if (consumed == FIO_HTTP1_PARSER_ERROR)
      goto http1_error;
    c->len -= consumed;
    if (c->len)
      FIO_MEMMOVE(c->buf, c->buf + consumed, c->len);
    if (c->suspend)
      return -1;
  }
  return 0;

nothing_consumed:
  if (c->len == c->capa)
    goto http1_abuse;
  else
    return -1;

http1_error:
  FIO_LOG_DDEBUG2("(%d) HTTP/1.1 parser error! disconnecting client at %d",
                  fio_io_pid(),
                  fio_io_fd(io));
  if (c->h) {
    fio_http_s *h = c->h;
    c->h = NULL;
    if (!c->is_client) {
      fio_io_dup(c->io);
      if (fio_http_send_error_response(h, 400))
        fio_io_free(c->io);
    }
    fio_http_free(h);
  }
  fio_io_close(io);
  return -1;

http1_abuse:
  FIO_LOG_DDEBUG2(
      "(%d) HTTP/1.1 hit security limit, disconnecting client at %d",
      fio_io_pid(),
      fio_io_fd(io));
  if (c->h) {
    fio_http_s *h = c->h;
    c->h = NULL;
    if (!c->is_client) {
      fio_io_dup(c->io);
      if (fio_http_send_error_response(h, 431))
        fio_io_free(c->io);
    }
    fio_http_free(h);
  }
  fio_io_close(io);
  return -1;
}

// /** Called when a data is available. */
FIO_SFUNC void fio___http1_on_data(fio_io_s *io) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  size_t r;
  for (;;) {
    if (c->capa == c->len)
      return;
    if (!(r = fio_io_read(io, c->buf + c->len, c->capa - c->len)))
      return;
    c->len += r;
    if (fio___http1_process_data(io, c))
      return;
  }
}

// /** Called when an IO is attached to a protocol. */
FIO_SFUNC void fio___http1_on_attach(fio_io_s *io) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  if (c->len)
    fio___http1_process_data(io, c);
  return;
}

/* *****************************************************************************
HTTP/1.1 Client Protocol
***************************************************************************** */

/** Iterates through all cookies. A non-zero return will stop iteration. */
FIO_SFUNC int fio_http1___write_client_cookie_callback(fio_http_s *h,
                                                       fio_str_info_s name,
                                                       fio_str_info_s value,
                                                       void *udata) {
  fio_str_info_s *buf = (fio_str_info_s *)udata;
  fio_string_write2(buf,
                    FIO_STRING_REALLOC,
                    FIO_STRING_WRITE_STR2("cookie:", 7),
                    FIO_STRING_WRITE_STR_INFO(name),
                    FIO_STRING_WRITE_STR2("=", 1),
                    FIO_STRING_WRITE_STR_INFO(value),
                    FIO_STRING_WRITE_STR2("\r\n", 2));
  return 0;
  (void)h;
}

/** called by the HTTP handle for each header. */
FIO_SFUNC int fio_http1___write_header_callback(fio_http_s *h,
                                                fio_str_info_s name,
                                                fio_str_info_s value,
                                                void *out_) {
  (void)h;
  /* manually copy, as this is an "all or nothing" copy (no truncation) */
  fio_str_info_s *out = (fio_str_info_s *)out_;
  return fio_string_write2(out,
                           FIO_STRING_REALLOC,
                           FIO_STRING_WRITE_STR2(name.buf, name.len),
                           FIO_STRING_WRITE_STR2(":", 1),
                           FIO_STRING_WRITE_STR2(value.buf, value.len),
                           FIO_STRING_WRITE_STR2("\r\n", 2));
}

FIO_SFUNC void fio___http1_send_request(fio_http_s *h) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (!c->io || !fio_io_is_open(c->io))
    return;
  fio_str_info_s buf = FIO_STR_INFO2(NULL, 0);
  /* set Content-Length (client is never streaming) */
  if (fio_http_body_length(h)) {
    char ibuf[32];
    fio_str_info_s k = FIO_STR_INFO2((char *)"content-length", 14);
    fio_str_info_s v = FIO_STR_INFO3(ibuf, 0, 32);
    v.len = fio_digits10u(fio_http_body_length(h));
    fio_ltoa10u(v.buf, fio_http_body_length(h), v.len);
    fio_http_request_header_set(h, k, v);
  }
  { /* set sensible defaults for common headers (Accept, User-Agent) */
    fio_http_request_header_set_if_missing(h,
                                           FIO_STR_INFO1((char *)"accept"),
                                           FIO_STR_INFO1((char *)"*/*"));
    fio_http_request_header_set_if_missing(
        h,
        FIO_STR_INFO1((char *)"user-agent"),
        FIO_STR_INFO1((char *)"facil.io/" FIO_VERSION_STRING));
  }
  { /* write status string */
    fio_str_info_s method = fio_http_method(h);
    fio_str_info_s path = fio_http_path(h);
    fio_str_info_s version = fio_http_version(h);
    if (!path.len)
      path = FIO_STR_INFO1((char *)"/");
    if ((version.len - 1) > 15)
      version = FIO_STR_INFO1((char *)"HTTP/1.1");
    fio_string_write2(&buf,
                      FIO_STRING_REALLOC,
                      FIO_STRING_WRITE_STR_INFO(method),
                      FIO_STRING_WRITE_STR2(" ", 1),
                      FIO_STRING_WRITE_STR_INFO(path),
                      FIO_STRING_WRITE_STR2(" ", 1),
                      FIO_STRING_WRITE_STR_INFO(version),
                      FIO_STRING_WRITE_STR2("\r\n", 2));
  }
  /* write headers */
  fio_http_request_header_each(h, fio_http1___write_header_callback, &buf);
  /* write cookies */
  fio_http_cookie_each(h, fio_http1___write_client_cookie_callback, &buf);
  fio_string_write(&buf, FIO_STRING_REALLOC, "\r\n", 2);
  /* send data (moves memory ownership) */
  fio_io_write2(c->io,
                .buf = buf.buf,
                .len = buf.len,
                .dealloc = FIO_STRING_FREE,
                .copy = 0);
  /* make sure we listen to incoming data */
  c->suspend = 0;
  fio_io_unsuspend(c->io);
  /* Write Body */
  if (!fio_http_body_length(h))
    return;
  fio_http_body_seek(h, 0);
  if (fio_http_body_fd(h) == -1) {
    buf = fio_http_body_read(h, (size_t)-1);
    fio_io_write2(c->io,
                  .buf = (char *)fio_http_dup(h),
                  .len = buf.len,
                  .offset = (size_t)((char *)h - buf.buf),
                  .dealloc = (void (*)(void *))fio_http_free);
  } else {
    fio_io_write2(c->io,
                  .fd = fio_http_body_fd(h),
                  .len = fio_http_body_length(h),
                  .copy = 1);
  }
}

FIO_SFUNC void fio___http1_on_attach_client(fio_io_s *io) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  // c->io = fio_io_dup(io);
  c->io = io;
  fio___http1_send_request(c->h);
  if (c->len)
    fio___http1_process_data(io, c);
  return;
}

/* *****************************************************************************
HTTP/1 Controller
***************************************************************************** */
FIO_SFUNC int fio___http_controller_get_fd(fio_http_s *h) {
  return fio_io_fd(fio_http_io(h));
}

/** Informs the controller that request / response headers must be sent. */
FIO_SFUNC void fio___http_controller_http1_send_headers(fio_http_s *h) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (!c->io || !fio_io_is_open(c->io))
    return;
  fio_str_info_s buf = FIO_STR_INFO2(NULL, 0);
  { /* write status string */
    fio_str_info_s ver = fio_http_version(h);
    fio_str_info_s status = fio_http_status2str(fio_http_status(h));
    if (ver.len > 15) {
      FIO_LOG_ERROR("HTTP/1.1 client version string too long!");
      ver = FIO_STR_INFO1((char *)"HTTP/1.1");
    }
    fio_string_write2(&buf,
                      FIO_STRING_REALLOC,
                      FIO_STRING_WRITE_STR2(ver.buf, ver.len),
                      FIO_STRING_WRITE_STR2(" ", 1),
                      FIO_STRING_WRITE_NUM(fio_http_status(h)),
                      FIO_STRING_WRITE_STR2(" ", 1),
                      FIO_STRING_WRITE_STR2(status.buf, status.len),
                      FIO_STRING_WRITE_STR2("\r\n", 2));
  }

  /* write headers */
  fio_http_response_header_each(h, fio_http1___write_header_callback, &buf);
  /* write cookies */
  fio_http_set_cookie_each(h, fio_http1___write_header_callback, &buf);
  /* add streaming headers? */
  if (fio_http_is_streaming(h))
    fio_string_write(&buf,
                     FIO_STRING_REALLOC,
                     "transfer-encoding: chunked\r\n",
                     28);
  fio_string_write(&buf, FIO_STRING_REALLOC, "\r\n", 2);
  /* send data (move memory ownership)? */
  c->state.http.buf = buf;
  return;
  // fio_io_write2(c->io,
  //               .buf = buf.buf,
  //               .len = buf.len,
  //               .dealloc = FIO_STRING_FREE,
  //               .copy = 0);
}
/** called by the HTTP handle for each body chunk (or to finish a response. */
FIO_SFUNC void fio___http_controller_http1_write_body(
    fio_http_s *h,
    fio_http_write_args_s args) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (!c->io || !fio_io_is_open(c->io))
    goto no_write_err;
  if (fio_http_is_streaming(h))
    goto stream_chunk;
  if (c->state.http.buf.len) {
    if (args.buf && args.len) {
      fio_string_write(&c->state.http.buf,
                       FIO_STRING_REALLOC,
                       (char *)args.buf + args.offset,
                       args.len);
      if (args.dealloc)
        args.dealloc((void *)args.buf);
    }
    fio_io_write2(c->io,
                  .buf = (void *)c->state.http.buf.buf,
                  .len = c->state.http.buf.len,
                  .dealloc = FIO_STRING_FREE);
    c->state.http.buf = FIO_STR_INFO0;
    if (args.buf && args.len)
      return;
  }

  fio_io_write2(c->io,
                .buf = (void *)args.buf,
                .fd = args.fd,
                .len = args.len,
                .offset = args.offset,
                .dealloc = args.dealloc,
                .copy = (uint8_t)args.copy);
  return;

stream_chunk:
  if (args.len && args.buf) { /* String */
    if (args.copy || args.len < (1 << 16)) {
      fio_string_write2(
          &c->state.http.buf,
          FIO_STRING_REALLOC,
          FIO_STRING_WRITE_HEX(args.len),   /* chunk header - length */
          FIO_STRING_WRITE_STR2("\r\n", 2), /* chunk header - EOL */
          FIO_STRING_WRITE_STR2((char *)args.buf, args.buf ? args.len : 0),
          FIO_STRING_WRITE_STR2("\r\n", 2)); /* chunk trailer - EOL */
      fio_io_write2(c->io,
                    .buf = (void *)c->state.http.buf.buf,
                    .len = c->state.http.buf.len,
                    .dealloc = FIO_STRING_FREE);
      c->state.http.buf = FIO_STR_INFO0;
      if (args.dealloc)
        args.dealloc((void *)args.buf);
      return;
    } else { /* avoid copying the incoming data if possible */
      FIO_STR_INFO_TMP_VAR(buf, 32);
      if (c->state.http.buf.buf)
        buf = c->state.http.buf;
      c->state.http.buf = FIO_STR_INFO0;
      fio_string_write2(
          &buf,
          NULL,
          FIO_STRING_WRITE_HEX(args.len),    /* chunk header - length */
          FIO_STRING_WRITE_STR2("\r\n", 2)); /* chunk header - EOL */
      fio_io_write2(c->io,
                    .buf = buf.buf,
                    .len = buf.len,
                    .copy = !FIO_STR_INFO_TMP_IS_REALLOCATED(buf),
                    .dealloc = FIO_STR_INFO_TMP_IS_REALLOCATED(buf)
                                   ? FIO_STRING_FREE
                                   : NULL);
      fio_io_write2(c->io,
                    .buf = (void *)args.buf,
                    .len = args.len,
                    .dealloc = args.dealloc);
      /* chunk trailer - EOL */
      fio_io_write2(c->io, .buf = (void *)"\r\n", .len = 2);
      return;
    }
  } else if ((uint32_t)(args.fd + 1) > 1U) { /* File? */
    if (!args.len) {
      if (fio_fd_type(args.fd) != S_IFREG)
        goto no_length_err;
      /* collect remaining file length */
      off_t len = fio_fd_size(args.fd);
      off_t offset = lseek(args.fd, 0, SEEK_CUR);
      if (len > 0 && offset > 0)
        len -= offset;
      if (len <= 0)
        goto no_length_err;
      args.len = (size_t)len;
    }
    FIO_STR_INFO_TMP_VAR(buf, 32);
    if (c->state.http.buf.buf)
      buf = c->state.http.buf;
    c->state.http.buf = FIO_STR_INFO0;
    fio_string_write2(
        &buf,
        NULL,
        FIO_STRING_WRITE_HEX(args.len),    /* chunk header - length */
        FIO_STRING_WRITE_STR2("\r\n", 2)); /* chunk header - EOL */
    fio_io_write2(
        c->io,
        .buf = buf.buf,
        .len = buf.len,
        .copy = !FIO_STR_INFO_TMP_IS_REALLOCATED(buf),
        .dealloc =
            (FIO_STR_INFO_TMP_IS_REALLOCATED(buf) ? FIO_STRING_FREE : NULL));
    fio_io_write2(c->io,
                  .fd = args.fd,
                  .len = args.len,
                  .copy = (bool)args.copy,
                  .dealloc = args.dealloc);
    /* chunk trailer - EOL */
    fio_io_write2(c->io, .buf = (void *)"\r\n", .len = 2);
  } else
    goto no_write_err;
  return;
no_length_err:
  FIO_LOG_ERROR("HTTP1 streaming requires a correctly pre-determined "
                "length per chunk.");
no_write_err:
  if (args.buf) {
    if (args.dealloc)
      args.dealloc((void *)args.buf);
  } else if ((uint32_t)(args.fd + 1) > 1U) {
    close(args.fd);
  }
}

FIO_SFUNC void fio___http_controller_http1_on_finish_task(void *c_,
                                                          void *upgraded) {
  fio___http_connection_s *c = (fio___http_connection_s *)c_;
  c->suspend = 0;

  if (upgraded)
    goto upgraded;

  if (!c->io)
    goto no_io;

  if (fio_io_is_open(c->io)) {
    /* TODO: test for connection:close header and h->status values */
    fio___http1_process_data(c->io, c);
  }
  if (!c->suspend)
    fio_io_unsuspend(c->io);
  fio_io_free(c->io);
  return;

upgraded:
  if (c->h || !fio_io_is_open(c->io))
    goto something_is_wrong;
  c->h = (fio_http_s *)upgraded;
  { /* TODO! test if safe to move to user thread for callback execution? */
    const size_t pr_i = fio_http_is_websocket(c->h) ? FIO___HTTP_PROTOCOL_WS
                                                    : FIO___HTTP_PROTOCOL_SSE;
    fio_http_controller_set(
        c->h,
        &(FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings)
              ->state[pr_i]
              .controller));
    fio_io_protocol_set(
        c->io,
        &(FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings)
              ->state[pr_i]
              .protocol));
    if (pr_i == FIO___HTTP_PROTOCOL_SSE) {
      fio_str_info_s last_id =
          fio_http_request_header(c->h,
                                  FIO_STR_INFO2((char *)"last-event-id", 13),
                                  0);
      if (last_id.buf)
        c->settings->on_eventsource_reconnect(c->h, FIO_STR2BUF_INFO(last_id));
    }
  }
  fio_io_unsuspend(c->io);
  fio_io_free(c->io);
  return;

something_is_wrong:
  if (fio_io_is_open(c->io))
    FIO_LOG_DEBUG2("(%d) Connection upgrade went wrong for fd %d - closing",
                   fio_io_pid(),
                   fio_io_fd(c->io));
  fio_io_protocol_set(c->io, NULL); /* make zombie, timeout will clear it. */
  fio_io_free(c->io);
/* fall through */
no_io:
  fio___http_connection_free(c); /* free HTTP connection element */
}

/** called once a request / response had finished */
FIO_SFUNC void fio___http_controller_http1_on_finish(fio_http_s *h) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (c->state.http.buf.len) {
    if (fio_http_is_streaming(h))
      fio_string_write(&c->state.http.buf, FIO_STRING_REALLOC, "0\r\n\r\n", 5);
    fio_io_write2(c->io,
                  .buf = (void *)c->state.http.buf.buf,
                  .len = c->state.http.buf.len,
                  .dealloc = FIO_STRING_FREE);
    c->state.http.buf = FIO_STR_INFO0;
  } else {
    if (fio_http_is_streaming(h))
      fio_io_write2(c->io, .buf = (char *)"0\r\n\r\n", .len = 5, .copy = 1);
  }
  if (c->log)
    fio_http_write_log(h);
  if (fio_http_is_upgraded(h))
    goto upgraded;
  /* once the function returns, `h` may be freed (auto-finish on free).
   * so we must call this callback here (sync), no matter the thread */
  c->state.http.on_finish(h);
  fio_io_defer(fio___http_controller_http1_on_finish_task, (void *)(c), NULL);
  return;

upgraded:
  fio_io_defer(fio___http_controller_http1_on_finish_task,
               (void *)(c),
               (void *)h);
}

/* *****************************************************************************
HTTP/2 Protocol (disconnect, as HTTP/2 is unsupported)
***************************************************************************** */

// /** Called when an IO is attached to a protocol. */
// void (*on_attach)(fio_io_s *io);
// /** Called when a data is available. */
// void (*on_data)(fio_io_s *io);
// /** called once all pending `fio_io_write` calls are finished. */
// void (*on_ready)(fio_io_s *io);
// /** Called after the connection was closed, and pending tasks
// completed.
// */ void (*on_close)(void *udata);

/* *****************************************************************************
HTTP/2 Controller (TODO!)
***************************************************************************** */

// /** Called when an HTTP handle is freed. */
// void (*on_destroyed)(fio_http_s *h, void *cdata);
// /** Informs the controller that request / response headers must be
// sent.
// */ void (*send_headers)(fio_http_s *h);
// /** called by the HTTP handle for each body chunk (or to finish a
// response.
// */ void (*write_body)(fio_http_s *h, fio_http_write_args_s args);
// /** called once a request / response had finished */
// void (*on_finish)(fio_http_s *h);

/* *****************************************************************************
Authentication Helper
***************************************************************************** */

/** Allows all clients to connect (bypasses authentication). */
SFUNC int FIO_HTTP_AUTHENTICATE_ALLOW(fio_http_s *h) {
  ((void)h);
  return 0;
}

/* *****************************************************************************
WebSocket Parser Callbacks
***************************************************************************** */

FIO_SFUNC int fio___websocket_process_data(fio_io_s *io,
                                           fio___http_connection_s *c);

FIO_SFUNC void fio___websocket_on_message_finalize(void *c_, void *ignr_) {
  fio___http_connection_s *c = (fio___http_connection_s *)c_;
  c->suspend = 0;
  if (c->len)
    fio___websocket_process_data(c->io, c);
  fio_io_unsuspend(c->io);
  fio_io_free(c->io);
  fio___http_connection_free(c);
  (void)ignr_;
}

FIO_SFUNC void fio___websocket_on_message_task(void *c_, void *is_text) {
  fio___http_connection_s *c = (fio___http_connection_s *)c_;
  c->state.ws.on_message(c->h,
                         fio_bstr_buf(c->state.ws.msg),
                         (uint8_t)(uintptr_t)is_text);
  fio_bstr_free(c->state.ws.msg);
  c->state.ws.msg = NULL;
  fio_io_defer(fio___websocket_on_message_finalize, c, NULL);
}

/** Called when a message frame was received. */
FIO_SFUNC void fio_websocket_on_message(void *udata,
                                        fio_buf_info_s msg,
                                        unsigned char is_text) {
  /* TODO: suspend IO and queue in async queue? */
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  // c->state.ws.on_message(c->h,
  //                        fio_bstr_buf(c->state.ws.msg),
  //                        (uint8_t)(uintptr_t)is_text);
  // fio_bstr_free(c->state.ws.msg);
  // c->state.ws.msg = NULL;
  // c->suspend = 0;
  // fio___websocket_process_data(c->io, c);
  // if (!c->suspend)
  //   fio_io_unsuspend(c->io);
  // return; /* TODO: FIXME! */
  fio_io_dup(c->io);
  fio___http_connection_dup(c);
  fio_io_suspend(c->io);
  c->suspend = 1;
  fio_queue_push(c->queue,
                 fio___websocket_on_message_task,
                 udata,
                 (void *)(uintptr_t)is_text);
  (void)msg;
}

/**
 * Called when the parser needs to copy the message to an external buffer.
 *
 * MUST return the external buffer, as it may need to be unmasked.
 *
 * Partial message length may be equal to zero (`partial.len == 0`).
 */
FIO_SFUNC fio_buf_info_s fio_websocket_write_partial(void *udata,
                                                     fio_buf_info_s partial,
                                                     size_t more_expected) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  if (!c->state.ws.msg && more_expected)
    c->state.ws.msg = fio_bstr_reserve(NULL, more_expected + partial.len);
  c->state.ws.msg = fio_bstr_write(c->state.ws.msg, partial.buf, partial.len);
  return fio_bstr_buf(c->state.ws.msg);
}

/** Called when the permessage-deflate extension requires decompression. */
FIO_SFUNC fio_buf_info_s fio_websocket_decompress(void *udata,
                                                  fio_buf_info_s msg) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  FIO_LOG_ERROR("WebSocket permessage-deflate not yet implemented!");
  (void)c;
  return msg;
}

/** Called when a `ping` message was received. */
FIO_SFUNC void fio_websocket_on_protocol_ping(void *udata, fio_buf_info_s msg) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  if (msg.len < 248) {
    char buf[256];
    size_t len =
        (c->is_client
             ? fio_websocket_client_wrap
             : fio_websocket_server_wrap)(buf, msg.buf, msg.len, 0x0A, 1, 1, 0);
    fio_io_write2(c->io, .buf = buf, .len = len, .copy = 1);
  } else {
    char *pong = fio_bstr_reserve(NULL, msg.len + 11);
    size_t len = (c->is_client ? fio_websocket_client_wrap
                               : fio_websocket_server_wrap)(pong,
                                                            msg.buf,
                                                            msg.len,
                                                            0x0A,
                                                            1,
                                                            1,
                                                            0);
    pong = fio_bstr_len_set(pong, len);
    fio_io_write2(c->io,
                  .buf = pong,
                  .len = len,
                  .dealloc = (void (*)(void *))fio_bstr_free);
  }
  fio_bstr_free(c->state.ws.msg);
  c->state.ws.msg = NULL;
}

/** Called when a `pong` message was received. */
FIO_SFUNC void fio_websocket_on_protocol_pong(void *udata, fio_buf_info_s msg) {
#if (defined(DEBUG) && DEBUG) ||                                               \
    (defined(FIO_WEBSOCKET_STATS) && FIO_WEBSOCKET_STATS)
  {
    char *pos = msg.buf;
    static uint64_t longest = 0;
    uint64_t ping_time = fio_io_last_tick() - fio_atol16u(&pos);
    if (ping_time < (1 << 16) && longest < ping_time) {
      longest = ping_time;
      FIO_LOG_INFO("WebSocket longest ping round-trip detected as: %zums",
                   (size_t)ping_time);
    }
  }
#endif
  FIO_LOG_DDEBUG2("Pong (%zu): %s", msg.len, msg.buf);
  (void)msg; /* do nothing */
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  fio_bstr_free(c->state.ws.msg);
  c->state.ws.msg = NULL;
}

/** Called when a `close` message was received. */
FIO_SFUNC void fio_websocket_on_protocol_close(void *udata,
                                               fio_buf_info_s msg) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  char buf[32];
  size_t len = fio_websocket_server_wrap(buf, NULL, 0, 0x08, 1, 1, 0);
  fio_io_write(c->io, buf, len);
  if (msg.len > 1)
    c->state.ws.code = fio_buf2u16_be(msg.buf);
  fio_io_close(c->io);
  if (msg.len > 2)
    FIO_LOG_DDEBUG2("WebSocket %p closed with error message: %s",
                    c->io,
                    msg.buf + 2);
  (void)msg;
}

/* *****************************************************************************
WebSocket Protocol
***************************************************************************** */

FIO_SFUNC int fio___websocket_process_data(fio_io_s *io,
                                           fio___http_connection_s *c) {
  (void)io, (void)c;
  size_t consumed = fio_websocket_parse(&c->state.ws.parser,
                                        FIO_BUF_INFO2(c->buf, c->len),
                                        (void *)c);
  if (!consumed)
    return -1;
  if (consumed == FIO_WEBSOCKET_PARSER_ERROR)
    goto ws_error;
  c->len -= consumed;
  if (c->len)
    FIO_MEMMOVE(c->buf, c->buf + consumed, c->len);
  if (c->suspend)
    return -1;
  return 0;

ws_error:
  FIO_LOG_DDEBUG2("WebSocket protocol error?");
  fio_websocket_on_protocol_close((void *)c, ((fio_buf_info_s){0}));
  return -1;
}

/** Called when a data is available. */
FIO_SFUNC void fio___websocket_on_data(fio_io_s *io) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  size_t r;
  for (;;) {
    if (c->capa == c->len)
      return;
    if (!(r = fio_io_read(io, c->buf + c->len, c->capa - c->len)))
      return;
    c->len += r;
    if (fio___websocket_process_data(io, c))
      return;
  }
}

FIO_SFUNC void fio___websocket_on_ready(fio_io_s *io) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  fio_http_s *h = c->h;
  if (!h)
    return;
  c->state.ws.on_ready(h);
}

FIO_SFUNC void fio___websocket_on_timeout(fio_io_s *io) {
  char buf[32];
  char tm[20] = "0x00000000000000000";
  fio_ltoa16u(tm + 2, fio_io_last_tick(), 16);
  size_t len = fio_websocket_server_wrap(buf, tm, 18, 0x09, 1, 1, 0);
  fio_io_write(io, buf, len);
}

FIO_SFUNC void fio___websocket_on_shutdown(fio_io_s *io) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  c->settings->on_shutdown(c->h);
  fio_websocket_on_protocol_close(c, ((fio_buf_info_s){0}));
}

/** Called when an IO is attached to a protocol. */
FIO_SFUNC void fio___websocket_on_attach(fio_io_s *io) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  fio_http_s *h = c->h;
  c->state.ws = (struct fio___http_connection_ws_s){
      .on_message = c->settings->on_message,
      .on_ready = c->settings->on_ready,
      .parser = {.must_mask = !c->is_client},
  };
  c->settings->on_open(h);
  fio___websocket_process_data(io, c);
}

/** Called after the connection was closed, and pending tasks completed. */
FIO_SFUNC void fio___websocket_on_close(void *buf, void *udata) {
  FIO_LOG_DDEBUG2("(%d) WebSocket connection closed for %p",
                  (int)fio_thread_getpid(),
                  udata);
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  c->io = NULL;
  fio_bstr_free(c->state.ws.msg);
  if (c->h) {
    fio_http_status_set(c->h, (size_t)(c->state.ws.code));
    c->settings->on_close(c->h);
    c->settings->on_finish(c->h);
    fio_http_free(c->h);
  }
  fio___http_connection_free(c);
  (void)buf;
}

/**
 * Sets a specific on_message callback for this connection.
 *
 * Returns -1 on error (i.e., upgrade still in negotiation).
 */
SFUNC int fio_http_on_message_set(fio_http_s *h,
                                  void (*on_message)(fio_http_s *,
                                                     fio_buf_info_s,
                                                     uint8_t)) {
  if (!h)
    return -1;
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (!c)
    return -1;
  if (!on_message)
    on_message = c->settings->on_message;
  c->state.ws.on_message = on_message;
  return 0;
}

/* *****************************************************************************
WebSocket Writing / Subscription Helpers
***************************************************************************** */

FIO_IFUNC void fio___http_websocket_subscribe_imp(fio_msg_s *msg,
                                                  uint8_t is_text) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(msg->io);
  if (!c)
    return;
  fio_http_websocket_write(c->h, msg->message.buf, msg->message.len, is_text);
}

/** Optional WebSocket subscription callback - all messages are UTF-8 valid. */
SFUNC void FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_TEXT(fio_msg_s *msg) {
  fio___http_websocket_subscribe_imp(msg, 1);
}
/** Optional WebSocket subscription callback - messages may be non-UTF-8. */
SFUNC void FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_BINARY(fio_msg_s *msg) {
  fio___http_websocket_subscribe_imp(msg, 0);
}

/** Optional WebSocket subscription callback. */
SFUNC void FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT(fio_msg_s *msg) {
  ((msg->message.len < FIO_HTTP_WEBSOCKET_WRITE_VALIDITY_TEST_LIMIT) &&
           (fio_string_utf8_valid(
               FIO_STR_INFO2((char *)msg->message.buf, msg->message.len)))
       ? FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_TEXT
       : FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT_BINARY)(msg);
}

/* *****************************************************************************
EventSource (SSE) Helpers - HTTP Upgraded Connections
***************************************************************************** */

void fio_http_sse_write___(void); /* IDE Marker */
/** Writes an SSE message (UTF-8). Fails if connection wasn't upgraded yet. */
SFUNC int fio_http_sse_write FIO_NOOP(fio_http_s *h,
                                      fio_http_sse_write_args_s args) {
  if (!args.data.len || !h || !fio_http_is_sse(h))
    return -1;
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (!c || !c->io)
    return -1;
  char *payload =
      fio_bstr_reserve(NULL, args.id.len + args.event.len + args.data.len + 22);
  if (args.id.len)
    payload = fio_bstr_write2(payload,
                              FIO_STRING_WRITE_STR2("id:", 3),
                              FIO_STRING_WRITE_STR2(args.id.buf, args.id.len),
                              FIO_STRING_WRITE_STR2("\r\n", 2));
  if (args.event.len)
    payload =
        fio_bstr_write2(payload,
                        FIO_STRING_WRITE_STR2("event:", 6),
                        FIO_STRING_WRITE_STR2(args.event.buf, args.event.len),
                        FIO_STRING_WRITE_STR2("\r\n", 2));
  { /* separate lines (add "data:" at beginning of each new line) */
    char *pos;
    while (args.data.len &&
           (pos = (char *)FIO_MEMCHR(args.data.buf, '\n', args.data.len))) {
      const size_t len = (pos + 1) - args.data.buf;
      pos -= (pos[-1] == '\r');
      payload = fio_bstr_write2(
          payload,
          FIO_STRING_WRITE_STR2("data:", 5),
          FIO_STRING_WRITE_STR2(args.data.buf, (size_t)(pos - args.data.buf)),
          FIO_STRING_WRITE_STR2("\r\n", 2));
      args.data.buf += len;
      args.data.len -= len;
    }
  }
  /* write reminder */
  if (args.data.len)
    payload =
        fio_bstr_write2(payload,
                        FIO_STRING_WRITE_STR2("data:", 5),
                        FIO_STRING_WRITE_STR2(args.data.buf, args.data.len),
                        FIO_STRING_WRITE_STR2("\r\n", 2));
  /* event ends on empty line */
  payload = fio_bstr_write(payload, "\r\n", 2);
  fio_io_write2(c->io,
                .buf = payload,
                .len = fio_bstr_len(payload),
                .dealloc = (void (*)(void *))fio_bstr_free);
  return 0;
}

/** Optional EventSource subscription callback - messages MUST be UTF-8. */
SFUNC void FIO_HTTP_SSE_SUBSCRIBE_DIRECT(fio_msg_s *msg) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(msg->io);
  if (!c)
    return;
  FIO_STR_INFO_TMP_VAR(id_str, 64);
  fio_string_write_hex(&id_str, NULL, msg->id);
  fio_http_sse_write(c->h,
                     .id = FIO_STR2BUF_INFO(id_str),
                     .event = FIO_STR2BUF_INFO(msg->channel),
                     .data = FIO_STR2BUF_INFO(msg->message));
}

/* *****************************************************************************
WebSocket Writing / Subscription Helpers
***************************************************************************** */

SFUNC int fio_http_websocket_write(fio_http_s *h,
                                   const void *buf,
                                   size_t len,
                                   uint8_t is_text) {
  if (!h || !fio_http_is_websocket(h))
    return -1;
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (!c)
    return -1;
  is_text = (!!is_text);
  is_text |= (!is_text) << 1;
  uint8_t rsv = 0;
  if (len < 512) { /* fast-path: no allocation, no compression */
    char tmp[520];
    size_t wlen =
        (c->is_client
             ? fio_websocket_client_wrap
             : fio_websocket_server_wrap)(tmp, buf, len, is_text, 1, 1, rsv);
    fio_io_write2(c->io, .buf = tmp, .len = wlen, .copy = 1);
    return 0;
  }
#if HAVE_ZLIB /* TODO: compress? */
  // if(c->state.ws.deflate) ;
#endif
  char *payload =
      fio_bstr_reserve(NULL,
                       fio_websocket_wrapped_len(len) + (c->is_client << 2));
  payload = fio_bstr_len_set(
      payload,
      (c->is_client
           ? fio_websocket_client_wrap
           : fio_websocket_server_wrap)(payload, buf, len, is_text, 1, 1, rsv));
  fio_io_write2(c->io,
                .buf = payload,
                .len = fio_bstr_len(payload),
                .dealloc = (void (*)(void *))fio_bstr_free);
  return 0 - !fio_io_is_open(c->io);
}

/* *****************************************************************************
WebSocket Controller
***************************************************************************** */

/* Called by the HTTP handle for each body chunk (or to finish a response). */
FIO_SFUNC void fio___http_controller_ws_write_body(fio_http_s *h,
                                                   fio_http_write_args_s args) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (args.buf && args.len < FIO_HTTP_WEBSOCKET_WRITE_VALIDITY_TEST_LIMIT) {
    unsigned char is_text =
        !!fio_string_utf8_valid(FIO_STR_INFO2((char *)args.buf, args.len));
    fio_http_websocket_write(h, (void *)args.buf, args.len, is_text);
    if (args.dealloc)
      args.dealloc((void *)args.buf);
    return;
  }
  char header[16];
  ((uint8_t *)header)[0] = 0 | 2 | 128;
  if (args.len < 126) {
    ((uint8_t *)header)[1] = args.len;
    fio_io_write(c->io, header, 2);
  } else if (args.len < (1UL << 16)) {
    /* head is 4 bytes */
    ((uint8_t *)header)[1] = 126 | ((!!c->is_client) << 7);
    fio_u2buf16_be(((uint8_t *)header + 2), args.len);
    fio_io_write(c->io, header, 4);
  } else {
    /* Really Long Message  */
    ((uint8_t *)header)[1] = 127 | ((!!c->is_client) << 7);
    fio_u2buf64_be(((uint8_t *)header + 2), args.len);
    fio_io_write(c->io, header, 10);
  }
  fio_io_write2(c->io,
                .buf = (void *)args.buf,
                .fd = args.fd,
                .len = args.len,
                .offset = args.offset,
                .dealloc = args.dealloc,
                .copy = (uint8_t)args.copy);
}

/* *****************************************************************************
EventSource / SSE Protocol (TODO!)
***************************************************************************** */

FIO_SFUNC void fio___sse_consume_data(fio___http_connection_s *c) {
  /* TODO: Fix Me! parse and process SSE data */
  FIO_LOG_DEBUG2("SSE data processing:\n%.*s", (int)c->len, c->buf);
  struct fio___http_connection_sse_s *sse = &c->state.sse;
  const char *next_line = c->buf;
  const char *stop = c->buf + c->len;
  for (; next_line < stop;) {
    char *line = (char *)next_line;
    const char *eol =
        (const char *)FIO_MEMCHR(next_line, '\n', stop - next_line);
    if (!eol)
      break;
    next_line = eol + 1;
    eol -= (eol > c->buf && eol[-1] == '\n');
    eol -= (eol > c->buf && eol[-1] == '\r');
    if (eol == line) { /* empty line, end of input? */
      if (sse->data || sse->event.buf || sse->id.buf) {
        sse->on_message(c->h, sse->id, sse->event, fio_bstr_buf(sse->data));
        fio_bstr_free(sse->data);
        sse->data = NULL;
        sse->event = sse->id = FIO_BUF_INFO0;
      }
      continue;
    }
    if (line[0] == ':') /* comment */
      continue;
    const size_t line_len = (size_t)(eol - line);
    if (line_len > 2 && line[2] == ':') { /* id */
      const char *start = line + 3;
      start += (start[0] == ' ' || start[0] == '\t');
      if ((line[0] |= 32) == 'i' && (line[1] |= 32) == 'd')
        sse->id = FIO_BUF_INFO2((char *)start, (size_t)(eol - start));

    } else if (line_len > 4 && line[4] == ':') { /* data */
      const char *start = line + 5;
      start += (start[0] == ' ' || start[0] == '\t');
      if ((fio_buf2u32u(line) | 0x20202020U) == fio_buf2u32u("data")) {
        if (fio_bstr_len(sse->data) + (size_t)(eol - start) >
            c->settings->ws_max_msg_size)
          goto breach;
        sse->data = fio_bstr_write2(
            sse->data,
            FIO_STRING_WRITE_STR2("\r\n", ((size_t) !!sse->data << 1)),
            FIO_STRING_WRITE_STR2(start, (size_t)(eol - start)));
      }

    } else if (line_len > 5 && line[5] == ':') { /* event */
      const char *start = line + 3;
      start += (start[0] == ' ' || start[0] == '\t');
      if ((line[0] |= 32) == 'e' &&
          (fio_buf2u32u(line + 1) | 0x20202020U) == fio_buf2u32u("vent"))
        sse->event = FIO_BUF_INFO2((char *)start, (size_t)(eol - start));

    } else if (!FIO_MEMCHR(line, ':', line_len))
      goto error;
  }
  FIO_ASSERT(next_line <= stop, "overflow on next line read");
  if (next_line > stop)
    next_line = stop;
  c->len -= next_line - c->buf;
  if (c->len)
    FIO_MEMMOVE(c->buf, next_line, c->len);
  return;

error:
  FIO_LOG_ERROR("SSE incoming data malformed!");
  FIO_LOG_DEBUG2("data dump:\n%.*s", (int)c->len, c->buf);
  fio_io_close(c->io);
  return;

breach:
  FIO_LOG_SECURITY("SSE incoming data payload too large!");
  fio_io_close(c->io);
}

/** Called when a data is available. */
FIO_SFUNC void fio___sse_on_data(fio_io_s *io) {
  FIO_LOG_DDEBUG2("(%d) Reading SSE data from socket", fio_io_pid());
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  size_t r;
  for (;;) {
    if (c->len + 2 > c->capa)
      goto error;
    if (!(r = fio_io_read(io, c->buf + c->len, c->capa - c->len)))
      return;
    c->len += r;
    fio___sse_consume_data(c);
  }
error:
  FIO_LOG_ERROR("Incoming SSE data too long (HTTP line limit set at %zu)!",
                c->capa);
  fio_io_close(io);
}

/** Called when an IO is attached to a protocol. */
static void fio___sse_on_attach(fio_io_s *io) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  fio_http_s *h = c->h;
  c->state.sse = (struct fio___http_connection_sse_s){
      .on_message = c->settings->on_eventsource,
      .on_ready = c->settings->on_ready,
  };
  c->settings->on_open(h);
  FIO_LOG_DDEBUG2("(%d) SSE attached; buffer length (unread): %zu",
                  fio_io_pid(),
                  c->len);
  if (c->len && c->is_client)
    fio___sse_consume_data(c);
}

FIO_SFUNC void fio___sse_on_timeout(fio_io_s *io) {
  char buf[32] = ":ping 0x0000000000000000\r\n\r\n";
  fio_ltoa16u(buf + 8, fio_io_last_tick(), 16);
  buf[24] = '\r'; /* overwrite written NUL character */
  fio_io_write(io, buf, 28);
}

FIO_SFUNC void fio___sse_on_shutdown(fio_io_s *io) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_io_udata(io);
  c->settings->on_shutdown(c->h);
  // fio_websocket_on_protocol_close(c, ((fio_buf_info_s){0}));
}

/** Called after the connection was closed, and pending tasks completed. */
FIO_SFUNC void fio___sse_on_close(void *buf, void *udata) {
  fio___http_connection_s *c = (fio___http_connection_s *)udata;
  FIO_LOG_DDEBUG2("(%d) SSE connection closed for %p", fio_io_pid(), c->io);
  c->io = NULL;
  fio_bstr_free(c->state.sse.data);
  if (c->h) {
    c->settings->on_close(c->h);
    c->settings->on_finish(c->h);
    fio_http_free(c->h);
  }
  fio___http_connection_free(c);
  (void)buf;
}

/* *****************************************************************************
EventSource / SSE Controller (TODO!)
***************************************************************************** */

/* called by the HTTP handle for each body chunk (or to finish a response. */
FIO_SFUNC void fio___http_controller_sse_write_body(
    fio_http_s *h,
    fio_http_write_args_s args) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (args.buf && args.len) {
    fio_http_sse_write(c->h, .data = FIO_BUF_INFO2((char *)args.buf, args.len));
  }
  if (args.dealloc && args.buf)
    args.dealloc((void *)args.buf);
  if (!args.buf && (unsigned)(args.fd + 1) > 1)
    close(args.fd);
}
/* *****************************************************************************
Connection Lost
***************************************************************************** */

FIO_SFUNC void fio___http_controller_on_destroyed_task(void *c_, void *ignr_) {
  fio___http_connection_s *c = (fio___http_connection_s *)c_;
  fio___http_connection_free(c);
  (void)ignr_;
}

FIO_SFUNC void fio___http_controller_http1_on_finish_client_task(void *c_,
                                                                 void *h_) {
  fio___http_connection_s *c = (fio___http_connection_s *)c_;
  fio_http_s *h = (fio_http_s *)h_;
  c->settings->on_finish(h);
  fio_http_free(h);
  fio___http_connection_free(c);
}

FIO_SFUNC void fio___http_controller_http1_on_finish_client(fio_http_s *h) {
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  /* on_finish should be called after the `on_close` or after on_http */
  if (!fio_http_is_upgraded(h)) {
    /* on_finish always manually called here */
    fio_io_defer(fio___http_controller_http1_on_finish_client_task,
                 (void *)fio___http_connection_dup(c),
                 (void *)fio_http_dup(h));
  }
}

/** Called when an HTTP handle is freed. */
FIO_SFUNC void fio__http_controller_on_destroyed(fio_http_s *h) {
  if (!(fio_http_is_upgraded(h) | fio_http_is_finished(h))) {
    /* auto-finish if freed without finishing */
    if (!fio_http_status(h))
      fio_http_status_set(h, 500); /* ignored if headers already sent */
    fio_http_write_args_s args = {.finish = 1}; /* never sets upgrade flag */
    fio_http_write FIO_NOOP(h, args);
  }
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (c->state.http.buf.buf)
    FIO_STRING_FREE2(c->state.http.buf);
  c->state.http.buf = FIO_STR_INFO0;
  fio_queue_push(fio_io_queue(),
                 fio___http_controller_on_destroyed_task,
                 fio_http_cdata(h));
}

/** Called when an HTTP handle is freed (no auto-finish, post upgrade). */
FIO_SFUNC void fio__http_controller_on_destroyed2(fio_http_s *h) {
  fio_queue_push(fio_io_queue(),
                 fio___http_controller_on_destroyed_task,
                 fio_http_cdata(h));
}

/** Called when an HTTP handle is freed. */
FIO_SFUNC void fio__http_controller_on_destroyed_client(fio_http_s *h) {
  fio_queue_push(fio_io_queue(),
                 fio___http_controller_on_destroyed_task,
                 fio_http_cdata(h));
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  c->state.http.on_finish(h);
  if (c->state.http.buf.buf)
    FIO_STRING_FREE2(c->state.http.buf);
  c->state.http.buf = FIO_STR_INFO0;
  c->h = NULL;
  if (c->io)
    fio_io_close(c->io);
  fio_queue_push(fio_io_queue(), fio___http_controller_on_destroyed_task, c);
}

/* *****************************************************************************
The Protocols at play
***************************************************************************** */

/** Returns a facil.io protocol object with the proper protocol callbacks. */
FIO_IFUNC fio_io_protocol_s FIO_NOOP
fio___http_protocol_get(fio___http_protocol_selector_e s, int is_client) {
  fio_io_protocol_s r = {0};
  (void)is_client, (void)s;
  switch (s) {
  case FIO___HTTP_PROTOCOL_ACCEPT:
    r = (fio_io_protocol_s){.on_attach = fio___http_on_attach_accept,
                            .on_data = fio___http1_accept_on_data,
                            .on_close = fio___http_on_close};
    return r;
  case FIO___HTTP_PROTOCOL_HTTP1:
    if (is_client) {
      r = (fio_io_protocol_s){.on_attach = fio___http1_on_attach_client,
                              .on_data = fio___http1_on_data,
                              .on_close = fio___http_on_close};
    } else {
      r = (fio_io_protocol_s){.on_attach = fio___http1_on_attach,
                              .on_data = fio___http1_on_data,
                              .on_close = fio___http_on_close};
    }
    return r;
  case FIO___HTTP_PROTOCOL_HTTP2:
    r = (fio_io_protocol_s){.on_close = fio___http_on_close};
    return r;
  case FIO___HTTP_PROTOCOL_WS:
    r = (fio_io_protocol_s){
        .on_attach = fio___websocket_on_attach,
        .on_data = fio___websocket_on_data,
        .on_ready = fio___websocket_on_ready,
        .on_close = fio___websocket_on_close,
        .on_shutdown = fio___websocket_on_shutdown,
        .on_timeout = fio___websocket_on_timeout,
        .on_pubsub = FIO_HTTP_WEBSOCKET_SUBSCRIBE_DIRECT,
    };
    return r;
  case FIO___HTTP_PROTOCOL_SSE:
    r = (fio_io_protocol_s){
        .on_attach = fio___sse_on_attach,
        .on_data = (is_client ? fio___sse_on_data : NULL),
        .on_ready = fio___websocket_on_ready,
        .on_close = fio___sse_on_close,
        .on_shutdown = fio___sse_on_shutdown,
        .on_timeout = fio___sse_on_timeout,
        .on_pubsub = FIO_HTTP_SSE_SUBSCRIBE_DIRECT,
    };
    return r;
  case FIO___HTTP_PROTOCOL_NONE: /* fall through*/
    r = (fio_io_protocol_s){.on_close = fio___http_on_close};
    return r;
  default:
    FIO_LOG_ERROR("internal function `fio___http_protocol_get` called with "
                  "illegal arguments!");
    return r;
  }
}

/** Returns an http controller object with the proper protocol callbacks. */
FIO_IFUNC fio_http_controller_s
fio___http_controller_get(fio___http_protocol_selector_e s, int is_client) {
  fio_http_controller_s r = {0};
  (void)is_client, (void)s;
  switch (s) {
  case FIO___HTTP_PROTOCOL_ACCEPT:
    r = (fio_http_controller_s){
        .on_destroyed = fio__http_controller_on_destroyed,
        .send_headers = fio___http_controller_http1_send_headers,
        .write_body = fio___http_controller_http1_write_body,
        .on_finish = fio___http_controller_http1_on_finish,
        .close_io = fio___http_default_close,
        .get_fd = fio___http_controller_get_fd,
    };
    return r;
  case FIO___HTTP_PROTOCOL_HTTP1:
    if (is_client) {
      r = (fio_http_controller_s){
          .on_destroyed = fio__http_controller_on_destroyed_client,
          .on_finish = fio___http_controller_http1_on_finish_client,
          .close_io = fio___http_default_close,
          .get_fd = fio___http_controller_get_fd,
      };
    } else {
      r = (fio_http_controller_s){
          .on_destroyed = fio__http_controller_on_destroyed,
          .send_headers = fio___http_controller_http1_send_headers,
          .write_body = fio___http_controller_http1_write_body,
          .on_finish = fio___http_controller_http1_on_finish,
          .close_io = fio___http_default_close,
          .get_fd = fio___http_controller_get_fd,
      };
    }
    return r;
  case FIO___HTTP_PROTOCOL_HTTP2:
    r = (fio_http_controller_s){
        .on_destroyed = fio__http_controller_on_destroyed,
        .close_io = fio___http_default_close,
        .get_fd = fio___http_controller_get_fd,
    };
    return r;
  case FIO___HTTP_PROTOCOL_WS:
    r = (fio_http_controller_s){
        .on_destroyed = fio__http_controller_on_destroyed2,
        .write_body = fio___http_controller_ws_write_body,
        .close_io = fio___http_default_close,
        .get_fd = fio___http_controller_get_fd,
    };
    return r;
  case FIO___HTTP_PROTOCOL_SSE:
    r = (fio_http_controller_s){
        .on_destroyed = fio__http_controller_on_destroyed2,
        .write_body = fio___http_controller_sse_write_body,
        .close_io = fio___http_default_close,
        .get_fd = fio___http_controller_get_fd,
    };
    return r;
  case FIO___HTTP_PROTOCOL_NONE:
    r = (fio_http_controller_s){
        .on_destroyed = fio__http_controller_on_destroyed2,
        .close_io = fio___http_default_close,
        .get_fd = fio___http_controller_get_fd,
    };
    return r;
  default:
    FIO_LOG_ERROR("internal function `fio___http_controller_get` called with "
                  "illegal arguments!");
    return r;
  }
}

FIO_IFUNC fio___http_protocol_s *fio___http_protocol_init(
    fio___http_protocol_s *p,
    const char *url,
    fio_http_settings_s s,
    bool is_client) {
  int should_free_tls = !s.tls;
  FIO_ASSERT_ALLOC(p);
  /* zero everything out and build from there */
  *p = (fio___http_protocol_s){0};
  /* fill in protocol and controller callbacks */
  for (size_t i = 0; i < FIO___HTTP_PROTOCOL_NONE + 1; ++i) {
    p->state[i].protocol =
        fio___http_protocol_get((fio___http_protocol_selector_e)i, is_client);
    p->state[i].controller =
        fio___http_controller_get((fio___http_protocol_selector_e)i, is_client);
  }
  /* fill in timeouts */
  for (size_t i = 0; i < FIO___HTTP_PROTOCOL_NONE; ++i)
    p->state[i].protocol.timeout = (unsigned)s.ws_timeout * 1000U;
  p->state[FIO___HTTP_PROTOCOL_SSE].protocol.timeout =
      (unsigned)s.sse_timeout * 1000U;
  p->state[FIO___HTTP_PROTOCOL_ACCEPT].protocol.timeout =
      (unsigned)s.timeout * 1000U;
  p->state[FIO___HTTP_PROTOCOL_HTTP1].protocol.timeout =
      (unsigned)s.timeout * 1000U;
  p->state[FIO___HTTP_PROTOCOL_NONE].protocol.timeout =
      (unsigned)s.timeout * 1000U;
  /* fill in TLS data */
  if (url) {
    fio_url_s u = fio_url_parse(url, strlen(url));
    s.tls = fio_io_tls_from_url(s.tls, u);
    if (s.tls) {
      s.tls = fio_io_tls_dup(s.tls);
      /* fio_io_tls_alpn_add(s.tls, "h2", fio___http_on_select_h2); // not yet
       */
      // fio_io_tls_alpn_add(s.tls, "http/1.1", fio___http_on_select_h1);
      fio_io_functions_s tmp_fn = fio_io_tls_default_functions(NULL);
      if (!s.tls_io_func)
        s.tls_io_func = &tmp_fn;
      for (size_t i = 0; i < FIO___HTTP_PROTOCOL_NONE + 1; ++i)
        p->state[i].protocol.io_functions = *s.tls_io_func;
      if (should_free_tls)
        fio_io_tls_free(s.tls);
    }
  }
  /* fill in settings, callbacks and public folders */
  p->settings = s;
  p->on_http_callback = is_client ? fio___http_on_http_client
                        : (p->settings.public_folder.len)
                            ? fio___http_on_http_with_public_folder
                            : fio___http_on_http_direct;
  p->settings.public_folder.buf = p->public_folder_buf;
  /* queue selector is performed later (on_start) */
  p->queue = fio_io_queue();
  /* initialize initial router */
  p->router.s = p->settings;

  if (s.public_folder.len)
    FIO_MEMCPY(p->public_folder_buf, s.public_folder.buf, s.public_folder.len);
  return p;
}
/* *****************************************************************************
HTTP Helpers
***************************************************************************** */

/** Returns the IO object associated with the HTTP object (request only). */
SFUNC fio_io_s *fio_http_io(fio_http_s *h) {
  if (!h)
    return NULL;
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (!c)
    return NULL;
  return c->io;
}

/** Returns the HTTP settings associated with the HTTP object, if any. */
SFUNC fio_http_settings_s *fio_http_settings(fio_http_s *h) {
  fio_http_settings_s *r = NULL;
  if (!h)
    return r;
  fio___http_connection_s *c = (fio___http_connection_s *)fio_http_cdata(h);
  if (!c)
    return r;
  fio___http_protocol_s *p =
      FIO_PTR_FROM_FIELD(fio___http_protocol_s, settings, c->settings);
  fio_str_info_s path = fio_http_opath(h);
  r = fio___http_route_settings(&p->router, &path);
  return r;
}

/* *****************************************************************************
Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_HTTP
#endif /* FIO_HTTP */
/* *****************************************************************************




                            Common Cleanup




***************************************************************************** */

/* *****************************************************************************
Common cleanup
***************************************************************************** */
#ifndef FIO___RECURSIVE_INCLUDE

/* undefine FIO_EXTERN only if its value indicates it is temporary. */
#if !defined(FIO_EXTERN) || (FIO_EXTERN + 1) < 3
#undef FIO_EXTERN
#endif
#if !defined(FIO_EXTERN_COMPLETE) || (FIO_EXTERN_COMPLETE + 1) < 3
#undef FIO_EXTERN_COMPLETE
#endif

#undef SFUNC
#undef IFUNC
#undef SFUNC_
#undef IFUNC_

#undef FIO_MALLOC_TMP_USE_SYSTEM
#undef FIO_MEM_REALLOC_
#undef FIO_MEM_FREE_
#undef FIO_MEM_REALLOC_IS_SAFE_
#undef FIO_MEMORY_NAME /* postponed due to possible use in macros */

#undef FIO___LOCK_TYPE
#undef FIO___LOCK_INIT
#undef FIO___LOCK_LOCK
#undef FIO___LOCK_LOCK_TRY
#undef FIO___LOCK_UNLOCK
#undef FIO_USE_THREAD_MUTEX_TMP

#else

#undef SFUNC
#undef IFUNC
#define SFUNC SFUNC_
#define IFUNC IFUNC_

#endif /* !FIO___RECURSIVE_INCLUDE */

/* *****************************************************************************
C++ extern end
***************************************************************************** */
/* support C++ */
#ifdef __cplusplus
}
#endif

/* *****************************************************************************
Recursive inclusion / cleanup
***************************************************************************** */
#if !defined(FIO___RECURSIVE_INCLUDE) && defined(FIO___INCLUDE_AGAIN)
/* recursive include statement */
#undef FIO___INCLUDE_AGAIN
#include FIO_INCLUDE_FILE
#else
#ifdef FIO_EVERYTHING___REMOVE_EXTERN
#undef FIO_EXTERN
#undef FIO_EVERYTHING___REMOVE_EXTERN
#endif
#ifdef FIO_EVERYTHING___REMOVE_EXTERN_COMPLETE
#undef FIO_EXTERN_COMPLETE
#undef FIO_EVERYTHING___REMOVE_EXTERN_COMPLETE
#endif

#endif /* !defined(FIO___RECURSIVE_INCLUDE) && defined(FIO___INCLUDE_AGAIN) */
/* *****************************************************************************

***************************************************************************** */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H)
/* *****************************************************************************
            Including facil.io modules for multi-file header option
***************************************************************************** */
#ifndef FIO_INCLUDE_FILE
#define FIO_INCLUDE_FILE "fio-stl/include.h"
#include "000 core.h"
#include "001 patches.h"
#endif

#include "000 dependencies.h"

#include "001 header.h"
#ifdef FIO_LOG
#include "001 logging.h"
#endif
#ifdef FIO_MEMALT
#include "001 memalt.h"
#endif

#ifdef FIO_ATOL
#include "002 atol.h"
#endif
#ifdef FIO_GLOB_MATCH
#include "002 glob matching.h"
#endif
#ifdef FIO_IMAP_CORE
#include "002 imap.h"
#endif
#ifdef FIO_MATH
#include "002 math.h"
#endif
#ifdef FIO_RAND
#include "002 random.h"
#endif
#ifdef FIO_SIGNAL
#include "002 signals.h"
#endif
#ifdef FIO_SORT_NAME
#include "002 sort.h"
#endif
#ifdef FIO_THREADS
#include "002 threads.h"
#endif
#if defined(FIO_URL) || defined(FIO_URI)
#include "002 url.h"
#endif

#ifdef FIO_FILES
#include "004 files.h"
#endif
#ifdef FIO_JSON
#include "004 json.h"
#endif
#ifdef FIO_SOCK
#include "004 sock.h"
#endif
#if defined(FIO_STATE) && !defined(FIO___RECURSIVE_INCLUDE)
#include "004 state callbacks.h"
#endif
#ifdef FIO_TIME
#include "004 time.h"
#endif
#ifdef FIO_RESP3
#include "004 resp3.h"
#endif
#ifdef FIO_URL_ENCODED
#include "004 urlencoded.h"
#endif
#ifdef FIO_MULTIPART
#include "004 multipart.h"
#endif

#if defined(FIO_CLI) && !defined(FIO___RECURSIVE_INCLUDE)
#include "005 cli.h"
#endif

#if defined(FIO_MEMORY_NAME) || defined(FIO_MALLOC) || defined(FIOBJ_MALLOC)
#include "010 mem.h"
#endif

#if defined(FIO_POLL) && !defined(FIO___RECURSIVE_INCLUDE)
#include "102 poll api.h"
#include "102 poll epoll.h"
#include "102 poll kqueue.h"
#include "102 poll poll.h"
#endif
#ifdef FIO_STR
#include "102 string core.h"
#endif
#ifdef FIO_STREAM
#include "102 stream.h"
#endif
#ifdef FIO_QUEUE
#include "102 queue.h"
#endif

#ifdef FIO_MUSTACHE
#include "104 mustache.h"
#endif

#ifdef FIO_CRYPTO_CORE
#include "150 crypto core.h"
#endif

#ifdef FIO_SHA1
#include "152 sha1.h"
#endif
#ifdef FIO_SHA2
#include "152 sha2.h"
#endif
#ifdef FIO_HKDF
#include "152 sha2z hkdf.h"
#endif
#ifdef FIO_BLAKE2
#include "152 blake2.h"
#endif
#ifdef FIO_SHA3
#include "152 sha3.h"
#endif
#ifdef FIO_CHACHA
#include "152 chacha20poly1305.h"
#endif
#ifdef FIO_AES
#include "153 aes.h"
#endif

#ifdef FIO_ED25519
#include "154 ed25519.h"
#endif

#ifdef FIO_P256
#include "154 p256.h"
#endif

#ifdef FIO_P384
#include "154 p384.h"
#endif

#ifdef FIO_ASN1
#include "155 asn1.h"
#endif

#ifdef FIO_RSA
#include "155 rsa.h"
#endif

#ifdef FIO_X509
#include "155 x509.h"
#endif

#ifdef FIO_OTP
#include "160 otp.h"
#endif
#ifdef FIO_SECRET
#include "160 secret.h"
#endif

#ifdef FIO_TLS13
#include "190 tls13.h"
#endif

#ifdef FIO_PEM
#include "301 pem.h"
#endif

#if defined(FIO_STR_SMALL) || defined(FIO_STR_NAME)
#include "200 string.h"
#endif
#ifdef FIO_ARRAY_NAME
#include "201 array.h"
#endif
#if defined(FIO_UMAP_NAME) || defined(FIO_OMAP_NAME) || defined(FIO_MAP_NAME)
#include "210 map.h"
#endif

#if defined(FIO_MAP2_NAME)
#include "210 map2.h"
#endif

#include "249 reference counter.h" /* required: pointer tagging cleanup is here */

#if defined(FIO_FIOBJ) && !defined(FIO___RECURSIVE_INCLUDE)
#include "250 fiobj.h"
#endif

#if defined(FIO_IO) && !defined(FIO___RECURSIVE_INCLUDE)
#include "400 io api.h"
#include "401 io types.h"
#include "402 io reactor.h"
#if defined(HAVE_OPENSSL)
#include "411 openssl.h"
#endif
#include "412 tls13.h"
#endif /* FIO_IO */

#if defined(FIO_PUBSUB) && !defined(FIO___RECURSIVE_INCLUDE)
#include "420 pubsub.h"
#endif

#if defined(FIO_REDIS) && !defined(FIO___RECURSIVE_INCLUDE)
#include "422 redis.h"
#endif

#ifdef FIO_HTTP1_PARSER
#include "431 http1 parser.h"
#endif
#ifdef FIO_WEBSOCKET_PARSER
#include "431 websocket parser.h"
#endif

#if defined(FIO_HTTP_HANDLE) && !defined(FIO___RECURSIVE_INCLUDE)
#include "431 http handle.h"
#endif

#if defined(FIO_HTTP) && !defined(FIO___RECURSIVE_INCLUDE)
#include "439 http.h"
#endif

#ifndef FIO___DEV___
#include "700 cleanup.h"
#endif

#if 0 && defined(FIO_TEST_ALL) && !defined(H___FIO_TESTS_START___H)
#include "900 tests start.h"
#include "902 atol.h"
#include "902 atomics.h"
#include "902 cli.h"
#include "902 core.h"
#include "902 files.h"
#include "902 fiobj.h"
#include "902 glob matching.h"
#include "902 http handle.h"
#include "902 imap.h"
#include "902 io.h"
#include "902 math.h"
#include "902 memalt.h"
#include "902 mustache.h"
#include "902 poll.h"
#include "902 pubsub.h"
#include "902 queue.h"
#include "902 random.h"
#include "902 sock.h"
#include "902 sort.h"
#include "902 state callbacks.h"
#include "902 stream.h"
#include "902 string core.h"
#include "902 time.h"
#include "902 url.h"
#include "903 chacha.h"
#include "903 sha.h"
#include "998 tests finish.h"
#endif

#endif /* !H___FIO_CSTL_COMBINED___H */
/* ************************************************************************* */
