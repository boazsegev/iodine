#!/usr/bin/env ruby
# frozen_string_literal: true
require 'iodine'

module Iodine
  class Base
    class NeoRackUp
      module NOOPHandler
      end
      module MiddleWare_Pre
        def initialize(*args, &blk);                @app = args[0]; super; end
      private
        def method_missing(method_name, *arguments)
            m = self.define_singleton_method(method_name) {|*args| @app.send(method_name, *args) }
            m.call(*arguments)
        end
      end
      module MiddleWare_Def
        def on_http(e);                     @app.on_http(e); end
        def on_finish(e);                   @app.on_finish(e); end
        def call(env);                      @app.call(env); end
        def on_authenticate(e);             @app.on_authenticate(e); end
        def on_authenticate_sse(e);         @app.on_authenticate_sse(e); end
        def on_authenticate_websocket(e);   @app.on_authenticate_websocket(e); end
        def on_open(e);                     @app.on_open(e); end
        def on_message(e, data);            @app.on_message(e, data); end
        def on_drained(e);                  @app.on_drained(e); end
        def on_timeout(e);                  @app.on_timeout(e); end
        def on_shutdown(e);                 @app.on_shutdown(e); end
        def on_close(e);                    @app.on_close(e); end
        def on_eventsource(e, message);     @app.on_eventsource(e, message); end
        def on_eventsource_reconnect(e,id); @app.on_eventsource_reconnect(e,id); end
      end
      UTF_8_BOM = '\xef\xbb\xbf'
      def use(mw, *args, &block)
        @middleware ||= []
        mw.prepend ::Iodine::Base::NeoRackUp::MiddleWare_Pre
        mw.include ::Iodine::Base::NeoRackUp::MiddleWare_Def
        @middleware <<[mw, args, block]
      end
      def run(a, &block)
        a = block if(!a)
        raise "Missing either an application handler or a block for the `run` instruction." unless a
        raise "Missing both `on_http(e)` and `call(env)` in provided App." unless (a.respond_to?(:on_http) || a.respond_to?(:call))
        Iodine::Base.add_missing_handlar_methods(a)
        while(@middleware && !@middleware.empty?)
          m = @middleware.pop
          a = m[0].new(a, *m[1], &m[2])
        end
        @app = a
      end
      def app
        @app
      end
      # validate name of Web Application configuration file.
      def self.iodine___detect_filename
        file_name = Iodine::Base::CLI.parse(true)[0];
        if(!file_name || File.directory?(file_name))
          file_name ||= './'
          file_name += '/' unless file_name.end_with?('/')
          defaults = ["#{file_name}config.ru", "#{file_name}config.nru"]
          defaults.pop if Iodine::Base::CLI['-R']
          file_name = nil;
          defaults.each {|n| file_name = n if(File.exist?(n))}
          file_name ||= defaults[-1]
        end
        file_name = nil if(!File.exist?(file_name))
        raise("Web App not found: missing config.#{Iodine::Base::CLI['-R'] ? '' : 'n'}ru?") unless file_name || Iodine::Base::CLI['-www']
        file_name
      end
      def self.iodine___load_rack fn
        return nil unless (File.extname(fn) == '.ru')
        begin
          require 'rack'
          Iodine::Utils.monkey_patch ::Rack::Utils
        rescue LoadError => e
          return nil unless Iodine::Base::CLI['-R']
          puts "ERROR: rack not installed."
          puts "       iodine -R requires the rack gem to be installed.\n"
          raise e
        end
        build = ::Rack::Builder.parse_file(fn)
        build
      end
      def self.iodine___load_neorack fn
        return nil unless fn
        cfgfile = ::File.read(fn)
        cfgfile.slice!(/\A#{UTF_8_BOM}/) if cfgfile.encoding == Encoding::UTF_8
        cfgfile.sub!(/^__END__\n.*\Z/m, '')
        builder = self.new
        builder.instance_eval(cfgfile, fn, 0)
        builder.app
      end
      def self.iodine___load_config(listener, fn, root_pid)
        err = "Web App not found (no `run`?) in #{fn}"
        begin
          app = ::Iodine::Base::NeoRackUp.iodine___load_rack(fn)
          app ||= ::Iodine::Base::NeoRackUp.iodine___load_neorack(fn) unless Iodine::Base::CLI['-R']
        rescue Exception => e
          err = e
          app = nil
        end
        unless !fn || app
          Iodine.stop
          Process.kill("TERM", root_pid)
          raise(err)
        end
        listener.handler = app
      end
      def self.iodine___start
        fn = ::Iodine::Base::NeoRackUp.iodine___detect_filename
        listener = Iodine.listen(nil, Iodine::Base::NeoRackUp::NOOPHandler)
        root_pid = Process.pid
        ### hot code reloading?
        if Iodine::Base::CLI['-preload']
          iodine___load_config(listener, fn, root_pid)
        else
          Iodine.on_state(:on_start) do
            iodine___load_config(listener, fn, root_pid)
          end
        end
        Iodine.start
      end
    end
  end
end

### .pid file
if Iodine::Base::CLI['-pid']
  pid_filename = Iodine::Base::CLI['-pid']
  pid_filename << "iodine.pid" if(pid_filename[-1] == '/')
  if File.exist?(pid_filename)
    raise "pid filename shold point to a valid file name (not a folder)!" if(!File.file?(pid_filename))
    raise "pid filename error! (doesn't end with .pid)" if(File.extname(pid_filename) != '.pid')
    File.delete(pid_filename)
  end
  Iodine.on_state(:pre_start) do
    IO.binwrite(pid_filename, "#{Process.pid}\r\n")
  end
  Iodine.on_state(:on_finish) do
    File.delete(pid_filename)
  end
end
### hot restarts 
if Iodine::Base::CLI['-hr'] && Iodine::Base::CLI['-w'].to_i != 0
  Iodine.run_after(Iodine::Base::CLI['-hr'] * 1000, -1) do
    Iodine.master? ? Process.kill("USR1", Process.pid) : false
  end
end
### Load configuration file
if Iodine::Base::CLI['--config']
  require Iodine::Base::CLI['--config']
end
### Start
Iodine::Base::NeoRackUp.iodine___start


